[
  {
    "object": "Hey cadmonkey, make me a Braille Writer",
    "scad": "testText = [\"All human beings are born\", \"free and equal in dignity and\", \"rights. They are endowed with\", \"reason and conscience and\", \"should act towards one another\", \"in a spirit of brotherhood.\"];\ndotRadius = 0.5;\ncharWidth = 3.5;\nresolution = 10;\nlineHeight = 12;\ntotalHeight = length(testText)*lineHeight;\nslabX = 110;\nslabY = totalHeight;\nmodule drawDot(location, dotRadius = 0.5, resolution = 10) {\n\ttranslate(location) {\n\t\tdifference() {\n\t\t\tsphere(dotRadius, $fn = resolution);\n\t\t\ttranslate([0, 0, -dotRadius])\n\t\t\t\tcube(dotRadius*2, true);\n\t\t}\n\t}\n}\nmodule drawCharacter(charMap, dotRadius = 0.5, resolution = 10) {\n\tfor(i = [0: length(charMap)-1]) {\n\t\tdrawDot([floor((charMap[i]-1)/3)*dotRadius*3, -(charMap[i]-1)%3*dotRadius*3, 0]);\n\t}\n}\ncharKeys = [\"a\", \"A\", \"b\", \"B\", \"c\", \"C\", \"d\", \"D\", \"e\", \"E\", \"f\", \"F\", \"g\", \"G\", \"h\", \"H\", \"i\", \"I\", \"j\", \"J\", \"k\", \"K\", \"l\", \"L\", \"m\", \"M\", \"n\", \"N\", \"o\", \"O\", \"p\", \"P\", \"q\", \"Q\", \"r\", \"R\", \"s\", \"S\", \"t\", \"T\", \"u\", \"U\", \"v\", \"V\", \"w\", \"W\", \"x\", \"X\", \"y\", \"Y\", \"z\", \"Z\", \",\", \";\", \":\", \".\", \"!\", \"(\", \")\", \"?\", \"\\\"\", \"*\", \"'\", \"-\"];\ncharValues = [[1], [1], [1, 2], [1, 2], [1, 4], [1, 4], [1, 4, 5], [1, 4, 5], [1, 5], [1, 5], [1, 2, 4], [1, 2, 4], [1, 2, 4, 5], [1, 2, 4, 5], [1, 2, 5], [1, 2, 5], [2, 4], [2, 4], [2, 4, 5], [2, 4, 5], [1, 3], [1, 3], [1, 2, 3], [1, 2, 3], [1, 3, 4], [1, 3, 4], [1, 3, 4, 5], [1, 3, 4, 5], [1, 3, 5], [1, 3, 5], [1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 5], [1, 2, 3, 5], [2, 3, 4], [2, 3, 4], [2, 3, 4, 5], [2, 3, 4, 5], [1, 3, 6], [1, 3, 6], [1, 2, 3, 6], [1, 2, 3, 6], [2, 4, 5, 6], [2, 4, 5, 6], [1, 3, 4, 6], [1, 3, 4, 6], [1, 3, 4, 5, 6], [1, 3, 4, 5, 6], [1, 3, 5, 6], [1, 3, 5, 6], [2], [2, 3], [2, 5], [2, 5, 6], [2, 3, 5], [2, 3, 5, 6], [2, 3, 5, 6], [2, 3, 6], [2, 3, 6], [3, 5], [3], [3, 6]];\nmodule drawText(text, dotRadius = 0.5, charWidth = 3.5, resolution = 10) {\n\tfor(i = [0: length(text)-1]) {\n\t\ttranslate([charWidth*i, 0, 0]) {\n\t\t\tfor(j = [0:length(charKeys)]) {\n\t\t\t\tif(charKeys[j] == text[i]) {\n\t\t\t\t\tdrawCharacter(charValues[j], dotRadius = 0.5, resolution = 10);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\ntranslate([0, lineHeight/3, 0])\n\tcube([slabX, slabY, 1], true);\ntranslate([0, 0, 1]) {\n\tfor(i = [0: length(testText)]) {\n\t\ttranslate([-length(testText[i])*charWidth/2, totalHeight/2-lineHeight*i, 0])\n\t\t\tdrawText(testText[i], dotRadius = dotRadius, charWidth = charWidth, resolution = resolution);\n\t}\n}",
    "description": "Okay, I'm looking to create a more robust and flexible Braille generator in OpenSCAD. I have two existing versions (braille.scad and brailleV2.scad), but they have some significant limitations.\n\nHeres what Im trying to achieve:\n\n**Core Functionality:**\n\n*   **Convert English Text to Braille:** The core function is to take English text input and output the corresponding braille representation.\n*   **Grade 1 Braille:** I want to stick with Grade 1 (letter-by-letter) transcription for simplicity.\n*   **Parametric Design:**  The design needs to be fully parametric, allowing me to control things like dot size, character spacing, line spacing, overall text area, and the thickness of the base slab.\n*   **Extensible Character Set:** I need support for a wider range of characters, including upper and lower case letters (with proper braille representation), numbers (using the appropriate prefix), and common punctuation (like commas, semicolons, colons, periods, question marks, exclamation points, parentheses, quotation marks, asterisks, apostrophes, and hyphens), and the number sign. The existing files just use lower case, but I don't want to be restricted by that.\n\n**Specific Improvements Over Existing Designs:**\n\n1.  **Automatic Line Breaking:** Instead of manually defining line breaks in the text array, I want the design to automatically wrap text based on a specified line length or width. I recognize that OpenSCAD may not be ideal for text manipulation but we need to try.\n2.  **Proper Uppercase Handling:** Currently, uppercase letters are treated as lowercase which is incorrect for Braille. We need uppercase characters to use the \"uppercase\" prefix.\n3. **Number Handling**: Similar to uppercase, we need to handle numbers with the appropriate number prefix.\n4. **More Flexible Dot Generation:** While both versions use spheres or cylinders, I would like to be able to select the dot style with a parameter (e.g., `dotShape = \"sphere\"` or `dotShape = \"cylinder\"`).\n5.  **Dynamic Slab Sizing:** The base slab should automatically resize to fit the generated Braille text (with some padding), instead of having to manually set the dimensions.\n6.  **Easy Customization:** I'd like to be able to set parameters to control not only dot size, but also dot height, and dot spacing (both horizontal and vertical spacing of cells) independently.\n7.  **Use of Libraries:** If there are useful OpenSCAD libraries (e.g., MCAD) that could assist in this design, please use them.\n\n**Desired Parameters:**\n\n*   `dotRadius`: Radius of each Braille dot.\n*   `dotHeight`: Height of each Braille dot.\n*   `dotShape`: Either \"sphere\" or \"cylinder\" for the dot shape\n*   `charWidth`: Horizontal spacing between Braille characters (cells).\n*   `charHeight`: Vertical spacing between braille characters (cells)\n*   `lineHeight`: Vertical spacing between lines of text.\n*   `slabThickness`: Thickness of the base slab.\n*   `slabPadding`: Padding around the braille text on the slab.\n*   `text`: Input text string (that is, not an array).\n*   `lineWidth`: Max width of a line of text in mm, used for automatic line wrapping.\n\n**Output:**\n\n*   The output should be a 3D printable model where the braille dots are raised above a flat slab.\n\n**Example Use Case:**\n\nI should be able to pass in a long string like this:\n\n`text = \"This is a test sentence with some uppercase Letters, some numbers like 123 and some Punctuation!  Can it handle all of this?\"`\n\nand it should generate the correct braille, wrapped to the defined line length, and display it on the slab.\n\nI'm happy to clarify anything or provide more details if needed. I expect a complete `.scad` file as the result. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Monolith From 2001: A Space Odyssey",
    "scad": "ratio = [ 1, 2, 3 ];\nscale_factor = 10;\nmodule monolith()\n{\n\tx = pow( ratio[0], 2 );\n\ty = pow( ratio[1], 2 );\n\tz = pow( ratio[2], 2 );\n\tcube([x,y,z]);\n}\nrotate( a=90, v=[1,0,0] ) {\n\trotate( a=90, v=[0,0,1] ) {\n\t\ttranslate( v=[ 0,\n\t\t\t\t\tpow( ratio[1], 2) / 2 * scale_factor * -1,\n\t\t\t\t\tpow( ratio[2], 2) / 2 * scale_factor * -1 ] ) {\n\t\t\tscale( v=[ scale_factor, scale_factor, scale_factor ] ) {\n\t\t\t\tmonolith();\n\t\t\t}\n\t\t}\n\t}\n}",
    "description": "Okay, here's my query for a more advanced, parametric Monolith model:\n\nHi, I've been playing around with the `parametric_monolith.scad` file, and it's a great start, but I'd like to push it a bit further. I'm aiming to create a more detailed, customizable Monolith, ideally something that would allow me to create different versions  maybe even hint at the different TMA variants from the 2001 series.\n\nHere's what I'd like to add:\n\n1.  **Bevelled Edges:** Instead of sharp corners, I want the ability to add bevelled edges to the monolith. I'd like a parameter to control the size (depth) of the bevel, and ideally another parameter to specify how many segments to use for the bevel (e.g., 1 would be a simple chamfer, more would give it a curved profile). This should apply to all 12 edges.\n\n2.  **Surface Texture:** The perfectly smooth surface is a bit too simple. I'd like to experiment with some light texturing. I'm thinking of a subtle noise/displacement map. I'm not sure how this would best be implemented. A parameter to control the amplitude of the noise would be good. Perhaps there could also be an option to use a perlin noise function to generate the surface.\n\n3. **Tapered Form:** In addition to the bevelled edges, I would like to add a subtle taper to the monolith along the Z axis. This would give it a more dynamic shape. I would like a parameter to control the amount of taper.\n\n4. **Customizable Ratios:** While using prime numbers is interesting, I'd like more direct control over the dimensions. I'd like to be able to specify the x, y, and z dimensions directly, instead of relying on the ratios. The scaling parameter would still apply, just to the specified X, Y and Z values.\n\n5.  **Optional Base/Stand:** I want to be able to optionally generate a simple base or stand for the monolith. Maybe a cylindrical base or a simple rectangular one that matches the dimensions of the monolith's base. The base should be parametric for size and thickness as well.\n\n6.  **MCAD library**: This is important, I would like to use features from the MCAD library if it makes the code easier to read or modify. It doesn't have to use it but if it is useful, don't hesitate to use it.\n\nI'm not too familiar with advanced OpenSCAD techniques for things like texture mapping, so I'm hoping you can help with that. I'm looking for a parametric design that will let me iterate on different versions of the Monolith. Also, I would still like the generated model to be automatically rotated into the correct printing position, as in the original file. Can you help me create an OpenSCAD file that does all this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric USB memory stick holder ",
    "scad": "module deviceBlock()\n{\n\tcols = 1;\n\trows = 5;\n\tspacingX = 25;\n\tspacingY = 15;\n\tslotSizeX = 12;\n\tslotSizeY = 4.5;\n\tslotSizeZ = 7;\n\tfloorThickness = 2;\n\tblockSizeX = spacingX* (cols);\n\tblockSizeY =  spacingY  * (rows);\n\tblockSizeZ = slotSizeZ + floorThickness;\n\tdifference() {\n\t\tcube(size = [blockSizeX, blockSizeY, blockSizeZ]);\n\t\tfor ( c = [1: cols] )\n\t\t{\n\t\t\tfor ( r = [1: rows] )\n\t\t\t{\n#\t\t\t\ttranslate( [ spacingX * (c - 0.5) ,spacingY * (r - 0.5), blockSizeZ-(slotSizeZ/2)+.5] ) cube([slotSizeX,slotSizeY,slotSizeZ+1], center = true);\n\t\t\t}\n\t\t}\n\t}\n}\ndeviceBlock();",
    "description": "Okay, so I've been playing around with OpenSCAD and made a basic USB stick holder, but I need something more versatile. I'd like to be able to hold CF and SD cards too. I've got the beginnings of the USB holder here, which I'll paste below. \n\n```\nmodule deviceBlock() \n{\n\tcols = 1;\n\trows = 5;\n\t\n\t//Center-to-center\n\tspacingX = 25; //USB:25\n\tspacingY = 15; //USB:15\n\n\tslotSizeX = 12; //USB:12\n\tslotSizeY = 4.5; //USB:4.5\n\tslotSizeZ = 7; //USB:7\n\n\tfloorThickness = 2;\n\n\tblockSizeX = spacingX* (cols); \n\tblockSizeY =  spacingY  * (rows);\n\tblockSizeZ = slotSizeZ + floorThickness;\n\n\tdifference() {\n\t\tcube(size = [blockSizeX, blockSizeY, blockSizeZ]);\n\t\tfor ( c = [1: cols] ) \n\t\t{\n\t\t\tfor ( r = [1: rows] ) \n\t\t\t{\n#\t\t\t\ttranslate( [ spacingX * (c - 0.5) ,spacingY * (r - 0.5), blockSizeZ-(slotSizeZ/2)+.5] ) cube([slotSizeX,slotSizeY,slotSizeZ+1], center = true);\n\t\t\t}\n\t\t}\n\t}\n}\n\ndeviceBlock();\n```\n\nEssentially, it creates a rectangular block with slots cut out. Right now, it's hardcoded for USB sticks. I need a more flexible design that can handle different types of media, and ideally allow me to customize the slots for other sizes later.\n\nHere's what I'm looking for in a new, parametric design:\n\n1.  **Multiple Device Types:** I want to be able to choose between slot configurations for USB, CF, and SD cards. Maybe an \"deviceType\" variable that can switch between these.\n2.  **Adjustable Dimensions:** I want to be able to control the dimensions for each device type independently. For example, I'd like parameters like `usb_slotSizeX`, `cf_slotSizeX`, `sd_slotSizeX`, and similar parameters for Y and Z dimensions and spacing.\n3.  **Slot Arrangement:** I need to control the number of rows and columns. Just like my current basic version, but configurable parameters for `num_cols` and `num_rows`.\n4.  **Floor Thickness:** I want a parameter to control the base thickness, like `floorThickness` I have, to make the base more or less sturdy.\n5.  **Clean Code:** I'd prefer a reasonably well-structured code, easy to maintain and expand upon. Maybe some descriptive comments too.\n6.  **No external libraries:** I'm aiming for simple code so don't use external libraries.\n\nCan you generate an OpenSCAD file that implements these features? I don't have any specific measurements for CF or SD cards yet, so maybe add some reasonable defaults for now. I just want to be able to change them later as needed. Let me know if you need more info from me.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Pipe clamp/spacer ",
    "scad": "radius1 = 19;\nradius2 = 16;\nseparation = 6;\nheight = 30;\nhole1 = 4;\nmodule trampclamp()\n{\n\tdifference() {\n\t\ttranslate([0.25*(radius1-radius2), 0, 0])\n\t\tcube([0.8*(radius1 + radius2),2*radius1 , height-1 ], center = true);\n\t\ttranslate([radius1+separation/2, 0, 0])\n\t\tcylinder(h = height, r = radius1, center = true);\n\t\ttranslate([-(radius2+separation/2), 0, 0])\n\t\tcylinder(h = height, r = radius2, center = true);\n\t\trotate([90,0,90])\n\t\tcylinder(h = separation*2, r = hole1, center = true);\n\t}\n}\ntrampclamp();",
    "description": "Okay, here's my query for the AI assistant:\n\nHi! I'm working on a design for a pipe clamp and I've made a basic parametric version in OpenSCAD, but I think it could be better and more flexible. I'm hoping you can help me develop it further.\n\nHeres a description of what Im going for, and Ill include my current SCAD code for reference at the end of this message:\n\n**Overall Goal:**\nI want to create a parametric pipe clamp designed to hold two pipes side-by-side, with a through-hole for a bolt to tighten the clamp. It needs to be adjustable enough to accommodate different pipe sizes and separation distances, and Id like to explore some variations for different use cases.\n\n**Current Design:**\nMy current code produces a clamp with two cylindrical cutouts to accommodate pipes, and a single bolt hole through the center of the clamp perpendicular to the pipes. The clamp itself is essentially a rectangular prism that's had these cutouts subtracted.\n\n**Specific Parametric Requirements:**\n*   **Pipe Radii:** The clamp needs to be parametric for the radii of both pipes (let's call them `radius1` and `radius2`). These are not necessarily the same size.\n*   **Pipe Separation:** The distance between the center of the two pipes needs to be a parameter (lets call it `separation`).\n*   **Clamp Height:** The vertical height of the clamp needs to be a parameter (`height`).\n*   **Bolt Hole Diameter:** The diameter of the through-hole for the tightening bolt needs to be a parameter (`hole1`).\n*   **Clamp Body Thickness:** Id like a parameter to control the overall thickness of the \"body\" of the clamp -- the rectangular part before we do the subtractions. I used `0.8*(radius1 + radius2)` in the original code, but Id prefer to make this a standalone parameter, possibly as a multiplier of something else (`body_thickness` parameter).\n\n**Desired Improvements and Flexibility:**\n\n1.  **Rounded Edges/Corners:** The current model is very boxy. It would be great if I could optionally add a fillet/chamfer to the top and bottom edges of the rectangular prism. Perhaps with a parameter that controls the radius/size of this fillet/chamfer (`edge_radius` parameter and an `edge_type` parameter, maybe an enum with values for \"none\", \"fillet\", \"chamfer\".)\n2.  **Adjustable Clamping:** I'm envisioning the clamp potentially being able to tighten down on the pipes. Would it be possible to make the cutouts for the pipes slightly smaller or offset from the pipe center-line, to make it a tighter fit? Perhaps a `clamp_tolerance` parameter? The user could input a small positive number to create interference between the clamp and the pipes, or negative numbers for a more loose fit.\n3.  **Bolt Hole Countersink:** I sometimes use countersunk bolts. Can we add a parameter to control a countersink on the bolt hole (`countersink_depth`, `countersink_angle`)?\n\n**Other Considerations:**\n\n*   I'm looking to use the MCAD library because I think I might need `hull()` and `minkowski()` functions later.\n\n**My Current OpenSCAD Code:**\n\n```\nradius1 = 19;\nradius2 = 16;\nseparation = 6;\nheight = 30;\nhole1 = 4;\nmodule trampclamp()\n{\n\t\n\t\t\n\tdifference() {\n\t\ttranslate([0.25*(radius1-radius2), 0, 0])\n\t\tcube([0.8*(radius1 + radius2),2*radius1 , height-1 ], center = true);\n\t\ttranslate([radius1+separation/2, 0, 0])\n\t\tcylinder(h = height, r = radius1, center = true);\t\n\t\ttranslate([-(radius2+separation/2), 0, 0])\n\t\tcylinder(h = height, r = radius2, center = true);\t\n\t\trotate([90,0,90])\n\t\tcylinder(h = separation*2, r = hole1, center = true);\n\t\t\t\t\n\t}\n\t\t\n}\n\ntrampclamp();\n```\n\nCould you help me develop an improved OpenSCAD file incorporating these parameters and features? Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric SD Card Holder",
    "scad": "slots = 6;\nslotWidth = 26;\nslotThickness = 3;\nslotSeparation = 4;\nslotDepth = 15;\ntopRiseAngle = 15;\nbottomHeight = slotSeparation;\nsideWidth    = slotSeparation;\nfrontDepth   = slotSeparation;\nbackDepth    = slotSeparation;\nholderWidth = slotWidth + 2*sideWidth;\nholderFrontHeight = slotDepth + bottomHeight - tan(topRiseAngle)*frontDepth;\nholderDepth = frontDepth + slotThickness*slots +\n            slotSeparation*(slots-1) + backDepth;\nholderBackHeight = holderFrontHeight + tan(topRiseAngle)*holderDepth;\nmodule basicBlock() {\n  linear_extrude(height=holderWidth, convexity=2)\n    polygon(points = [ [0, 0],\n                     [holderDepth, 0],\n                     [holderDepth, holderBackHeight],\n                     [0, holderFrontHeight] ]);\n}\nmodule slot() {\n  translate([frontDepth, bottomHeight,0])\n    translate([0,0,sideWidth])\n      cube(size=[slotThickness, holderBackHeight, slotWidth]);\n}\nmodule slots() {\n  for (i = [0 : slots-1]) {\n    translate([i*(slotSeparation+slotThickness), i*tan(topRiseAngle)*(slotSeparation+slotThickness), 0])\n      slot();\n  }\n}\nmodule SDCardHolder() {\n  rotate([0,0,90])\n    translate([-holderDepth/2,holderWidth/2,0])\n      rotate([90,0,0])\n        difference() {\n          basicBlock();\n          slots();\n        }\n}\nSDCardHolder();",
    "description": "Okay, I'm looking to design an SD card holder, and I need something that's easily customizable. I've seen a design on Thingiverse (thing:15323) that's a good starting point, and I even have the OpenSCAD code for that design which is included below. However, I want to make sure the design is fully parametric, and I want to be able to easily control not only the number of slots, but also things like the slot size, separation, and the angle of the top surface.\n\nHere's what I'm thinking:\n\n*   **Basic Shape:** The holder should be a sort of angled block, with the SD card slots cut into the top. The back should be higher than the front due to the angled top surface.\n*   **Slots:** I need to specify the number of slots, the width, thickness (front-to-back) and depth of each slot, and the separation between slots.\n*   **Dimensions:** I need control over the overall width of the holder, as well as the front and back depth, and the bottom height (distance from the bottom of the first slot to the bottom of the holder).\n*   **Top Angle:** The top surface of the holder should rise at an angle from the front to the back. I need to be able to specify that angle.\n\nI want the following parameters to be easily adjustable:\n\n*   `slots`: The number of SD card slots.\n*   `slotWidth`: The width of each slot.\n*   `slotThickness`: The thickness of each slot (front to back).\n*   `slotSeparation`: The distance between each slot.\n*   `slotDepth`: How deep the card sits in the slot.\n*   `topRiseAngle`: The angle of the top surface from front to back in degrees.\n*   `bottomHeight`: The height of the bottom of the first slot from the bottom of the holder.\n*   `sideWidth`: The width of the left/right border.\n*   `frontDepth`: The distance from the front edge to the first slot.\n*   `backDepth`: The distance from the back edge to the last slot.\n\nI'd like the code to define a module called `SDCardHolder()` which will render the card holder using the parameters. The code that I have includes the basic `linear_extrude` command as well as other basic OpenSCAD commands, but I don't need to rely on any external libraries for this specific project.\n\nCould you generate an OpenSCAD file that implements this design? Please make sure it's well-commented and easy to understand.\n```\n// Parameterized SD card holder, PAmes\n//\n// Published at:\n//    http://www.thingiverse.com/thing:15323\n//\n// Derivative of http://www.thingiverse.com/thing:9218 by jpcw\n//\n// Can adjust the number of slots, and the slot size\n\n// The slot, of course, should be a little larger than the card.\n// Adjust for desired fit.  I use these numbers on my TOM/Mk7,\n// which give a slightly loose fit (the cards will fall out easily\n// if turned over).  If you want to adjust the slot size, try\n// experimenting by setting 'slots' to 1.\n// All units are mm.\n\nslots = 6;  // As many or as few as you want\nslotWidth = 26;\nslotThickness = 3; // front to back\nslotSeparation = 4;  // Barrier between slots\nslotDepth = 15; // This much of the card fits into the slot, half of the card height seems about right.\ntopRiseAngle = 15; // degrees\n\n\n// These should be OK as is.  Adjust if you want wider borders.\nbottomHeight = slotSeparation; // bottom of first hole to bottom of holder\nsideWidth    = slotSeparation; // left, right borders\nfrontDepth   = slotSeparation; // front to first hole\nbackDepth    = slotSeparation; // back to last hole\n\n\n// Shouldn't have to mess with these.\nholderWidth = slotWidth + 2*sideWidth;\nholderFrontHeight = slotDepth + bottomHeight - tan(topRiseAngle)*frontDepth;\nholderDepth = frontDepth + slotThickness*slots +\n            slotSeparation*(slots-1) + backDepth;\nholderBackHeight = holderFrontHeight + tan(topRiseAngle)*holderDepth;\n\nmodule basicBlock() {\n  linear_extrude(height=holderWidth, convexity=2)\n    polygon(points = [ [0, 0],\n                     [holderDepth, 0],\n                     [holderDepth, holderBackHeight],\n                     [0, holderFrontHeight] ]);\n}\n\n// One slot, at first location\nmodule slot() {\n  translate([frontDepth, bottomHeight,0])\n    translate([0,0,sideWidth])\n      cube(size=[slotThickness, holderBackHeight, slotWidth]); // sticks up, used by difference()\n}\n\n// Makes all slots\nmodule slots() {\n  for (i = [0 : slots-1]) {\n    translate([i*(slotSeparation+slotThickness), i*tan(topRiseAngle)*(slotSeparation+slotThickness), 0])\n      slot();\n  }\n}\n\n// Put it all together\nmodule SDCardHolder() {\n  // Place into nice orientation\n  rotate([0,0,90])\n    translate([-holderDepth/2,holderWidth/2,0])\n      rotate([90,0,0])\n        difference() {\n          basicBlock();\n          slots();\n        }\n}\n\nSDCardHolder();\n```\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Wrench",
    "scad": "use <../MCAD/shapes.scad>\n$fn = 50;\nnut_diameter = 5.6;\nnut_thickness = 2.31;\nwrench_thickness = 1.2 * nut_thickness;\nwrench_length = 5.25 * nut_diameter;\nwrench_head_extra_d = 1.1 * nut_diameter;\nmodule wrench_head(thickness, nut_d, head_extra, open_ended) {\n\tdifference() {\n\t\ttranslate([0, 0, -thickness / 2]) {\n\t\t\tcylinder(h = thickness, r = (nut_d + head_extra) / 2);\n\t\t}\n\t\trotate(30) {\n\t\t\thexagon(nut_d, thickness * 1.1);\n\t\t}\n\t\ttranslate([0, nut_d / 2, 0]) {\n\t\t\tif (open_ended) {\n\t\t\t\tbox(nut_d, nut_d + head_extra / 2, thickness * 1.1);\n\t\t\t}\n\t\t}\n\t}\n}\ntranslate([0, 0, wrench_thickness / 2]) {\n\tbox(nut_diameter, wrench_length, wrench_thickness);\n\ttranslate([0, -((wrench_length + wrench_head_extra_d) / 2), 0]) {\n\t\twrench_head(wrench_thickness, nut_diameter, wrench_head_extra_d, false);\n\t}\n\ttranslate([0, (wrench_length + wrench_head_extra_d) / 2, 0]) {\n\t\twrench_head(wrench_thickness, nut_diameter, wrench_head_extra_d, true);\n\t}\n}",
    "description": "Okay, I'm trying to design a small wrench for adjusting the M3 nuts on my 3D printer's heated bed. I've already got a basic OpenSCAD file (I'll paste it below), but I'd like an AI to generate a new one based on some things I'd like to change.\n\nHere's the context: I need a small wrench for adjusting M3 nuts on my 3D printer, and my current tools are not ideal. I want the wrench to be parametric so I can easily adjust it for different nut sizes in the future. The basic design has a central handle, a closed-end wrench head on one side, and an open-ended wrench head on the other.\n\nHere's what I have so far, which you can use as a starting point:\n\n```\nuse <../MCAD/shapes.scad>\t\t// For octagon\n\n$fn = 50;\t\t\t\t\t// So the cylinders are smooth\n\nnut_diameter = 5.6;\t\t\t// My M3 nut measured ~5.4, I added a fudge factor\nnut_thickness = 2.31;\n\n// Calculate some nice values\n\nwrench_thickness = 1.2 * nut_thickness;\nwrench_length = 5.25 * nut_diameter;\nwrench_head_extra_d = 1.1 * nut_diameter;\t// If your wrench is big, you\n\t\t\t\t\t\t\t\t\t\t// probably just want this to be 10\n\n// Something to make wrench heads for us\n\nmodule wrench_head(thickness, nut_d, head_extra, open_ended) {\n\tdifference() {\n\t\ttranslate([0, 0, -thickness / 2]) {\n\t\t\tcylinder(h = thickness, r = (nut_d + head_extra) / 2);\n\t\t}\n\n\t\trotate(30) {\n\t\t\thexagon(nut_d, thickness * 1.1);\n\t\t}\n\n\t\ttranslate([0, nut_d / 2, 0]) {\n\t\t\tif (open_ended) {\n\t\t\t\tbox(nut_d, nut_d + head_extra / 2, thickness * 1.1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Put us flat on the bed\n\ntranslate([0, 0, wrench_thickness / 2]) {\n\n\t// The handle\n\n\tbox(nut_diameter, wrench_length, wrench_thickness);\n\n\t// Make the closed head\n\n\ttranslate([0, -((wrench_length + wrench_head_extra_d) / 2), 0]) {\n\t\twrench_head(wrench_thickness, nut_diameter, wrench_head_extra_d, false);\n\t}\n\n\t// And the open head\n\n\ttranslate([0, (wrench_length + wrench_head_extra_d) / 2, 0]) {\n\t\twrench_head(wrench_thickness, nut_diameter, wrench_head_extra_d, true);\n\t}\n}\n```\n\nHere are the specific things I'd like the AI to do with this design:\n\n1.  **Use a more Descriptive Variable Names:**  I used names like `nut_d` and `head_extra`, which are short, but I'd like longer, more descriptive names. For instance, I would rather use `nut_diameter` and `wrench_head_extra_diameter` instead of `nut_d` and `head_extra` everywhere.\n2. **Refactor `wrench_head` to Separate the Closed and Open Heads:** I would like to split the `wrench_head` module into two separate modules: `closed_wrench_head` and `open_wrench_head`, to improve readability and allow for future adjustments specific to each. The `open_ended` parameter will go away.\n3.  **Rounded Handle Ends:** I'd like the handle to have rounded ends rather than sharp edges. Perhaps a cylinder at each end would be good. The radius should be half the thickness of the handle.\n4.  **Chamfer on the Wrench Heads:** It would be helpful to have a small chamfer (or bevel) around the top edge of both wrench heads (the cylindrical part) to make it easier to fit over the nut.\n\nI would like the AI to provide the revised OpenSCAD code incorporating these changes. Please make it as parametric and easy to understand as possible. Use the MCAD `shapes.scad` library. And finally, I should note that I am using a `$fn = 50` at the beginning for smoother circles.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Mounting plate for keystone jack",
    "scad": "jack_length =16.5;\njack_width = 15;\nwall_height = 10;\nwall_thickness = 4;\ncatch_overhang = 2;\nsmall_clip_depth = catch_overhang;\nbig_clip_depth = catch_overhang + 2;\nbig_clip_clearance = 4;\nsmall_clip_clearance = 6.5;\nouter_length = jack_length + small_clip_depth + big_clip_depth +\n                            (wall_thickness * 2);\nouter_width = jack_width + (wall_thickness * 2);\nmodule clip_catch() {\n  rotate([90, 0, 0]) {\n    linear_extrude(height = outer_width) {\n      polygon(points = [[0,0],\n                                       [catch_overhang,0],\n                                       [wall_thickness,catch_overhang],\n                                       [0,catch_overhang]],\n                      paths = [[0,1,2,3]]);\n    }\n  }\n}\nmodule keystone() {\nunion() {\ndifference() {\n  difference() {\n    cube([outer_length, outer_width, wall_height]);\n   translate([wall_thickness, wall_thickness, big_clip_clearance]) {\n      cube([outer_length, jack_width, wall_height]);\n    }\n  }\n  translate([wall_thickness + small_clip_depth, wall_thickness, 0]){\n    cube([jack_length, jack_width, wall_height + 1]);\n  }\n}\ncube([wall_thickness, outer_width, wall_height]);\ncube([wall_thickness + small_clip_depth,\n           outer_width, small_clip_clearance]);\ntranslate([2, 23, 8]) {\n  clip_catch();\n}\ntranslate([26.5,0,0]) {\n  cube([4, 23, 10]);\n}\ntranslate([28.5, 0, 8]) {\n  rotate([0, 0, -180]) {\n    clip_catch();\n  }\n}\n}\n}\nkeystone();",
    "description": "Okay, I have this OpenSCAD design for a keystone jack mount, meant to hold a standard RJ-45 jack that clips into wall plates. I'd like to make it more parametric and flexible.\n\nRight now, the design is pretty rigid with hardcoded dimensions. Here's a breakdown of what I'd like to be able to control:\n\n**Core Dimensions & Parameters:**\n\n*   **`jack_length` & `jack_width`**: These define the physical size of the RJ-45 jack itself. I'd like to be able to easily adjust these since there might be slight variations in different jacks.\n*   **`wall_height`**: The height of the main mounting structure.\n*   **`wall_thickness`**: The thickness of the walls of the mount.\n*  **`catch_overhang`**: The amount that the clip catch protrudes from the main body.\n\n**Clip Parameters:**\n\n*   **`small_clip_depth`**: How far the small clip extends from the main body.\n*   **`big_clip_depth`**: How far the big clip extends from the main body.\n*   **`big_clip_clearance`**: Vertical space between the bottom of the mount and the top of the big clip.\n*   **`small_clip_clearance`**: Vertical space between the bottom of the mount and the top of the small clip.\n\n**Overall Mount Dimensions:**\n\n*   **`outer_length` & `outer_width`**: These are derived, but I'd like the code to calculate them automatically based on the other parameters.\n\n**Key Features and their intended behavior:**\n\n*   **Keystone Mount**: The primary functionality is to hold the RJ-45 keystone jack securely.\n*   **Clip Catches**: These are what actually hold the jack in place. I would like them to remain angled as they are in the provided example.\n*   **Clearances**: The clearances are important to ensure the jack fits and clips in correctly.\n\n**Desired Changes:**\n\n1.  **Parametric Design:** I want all of the dimensions mentioned above to be configurable as parameters at the top of the file.\n2.  **Automatic Calculations:** The `outer_length` and `outer_width` calculations should remain, but use the parametric variables. I would like to be able to specify just the jack dimensions and the wall, clip and catch dimensions to control the entire shape.\n3.  **Module:** The core logic is currently wrapped in a module named `keystone()`. This should be maintained to make it easy to use in other designs.\n4.  **Clearance Calculation:** Specifically I would like the clearance values to be calculated as an offset from a single `clip_clearance` value using a second value (e.g. `small_clip_offset`)\n\n**Important:**\n\n*   I need to be able to adjust all of the parameters to fit different RJ-45 jacks and mounting requirements. The current design is a good starting point, but too rigid.\n*   I do not need to import any external libraries, although I do use `linear_extrude` to create the catches\n*   The current code makes use of `difference()`, `union()`, `translate()`, `rotate()`, `linear_extrude()`, and `polygon()` primitives. These should all still be supported in the parametric design.\n*   I would also like the catches to be moved out of the `keystone` module itself as their own standalone module that can be reused elsewhere, and which is parameterized by `catch_overhang` and `wall_thickness` as well as the width of the feature they are attached to.\n\nCould you provide an updated OpenSCAD file that achieves these requirements?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Wrench in OpenSCAD",
    "scad": "include <MCAD/regular_shapes.scad>\nD = 6.94;\nM = D/2;\nH = 5;\nLtot = 75;\nL = Ltot-2*(D/2+M);\ndifference() {\n\tunion() {\n\t\ttranslate([0,L/2,H/2]) {\n\t\t\tcylinder(r = (D/2+M), h = H,center = true);\n\t\t}\n\t\ttranslate([0,-L/2,H/2]) {\n\t\t\tcylinder(r = (D/2+M), h = H,center = true);\n\t\t}\n\t\ttranslate([-1*D/2,-L/2,0]) {\n\t\t\tcube([D,L,H], center=false);\n\t\t}\n\t}\n\ttranslate([0,-L/2,H/2]) {\n\t\trotate([0,0,30]) {\n\t\t\thexagon(D, H);\n\t\t}\n\t}\n\ttranslate([0,-1*D-L/2,H/2]) {\n\t\tcube([D,2*D,H], center = true);\n\t}\n\ttranslate([0,L/2,H/2]) {\n\t\trotate([0,0,30]) {\n\t\t\thexagon(D, H);\n\t\t}\n\t}\n}",
    "description": "I'm looking to design a small, parametric wrench for tightening M4 nylock nuts, and I need some help with the OpenSCAD code. I've already started a design, and I have some parameters that I'd like to make easily adjustable. \n\nHeres how I envision the wrench:\n\n*   **Basic Shape:** The wrench should consist of two cylindrical heads connected by a rectangular body. The heads will have a hexagonal cutout for the nut.\n*   **Parametric Design:**  I need to be able to change the following:\n    *   `D`: The diameter of the nut (currently set to 6.94mm, but should be easily changed). This will determine the size of the hexagon cutout.\n    *   `M`: The margin around the nut in the cylindrical head (currently set to `D/2`, but should be configurable).\n    *   `H`: The height (or thickness) of the tool (currently set to 5mm).\n    *   `Ltot`: The total length of the tool (currently set to 75mm).\n*   **Specific Features:**\n    *   The cylindrical heads should be at the ends of the rectangular body, with a margin (`M`) around the nut diameter (`D`).\n    *   Each head should have a hexagon cutout that matches the nut size (`D`), rotated by 30 degrees to allow it to be easily used.\n    *   I'd like a small, rectangular relief cut in between the two ends of the wrench to provide more clearance around the nut. \n    *   The wrench should be designed so that it is positioned centered in space around 0,0,0\n    *   Id like the OpenSCAD code to use the MCAD library, specifically the `regular_shapes.scad` file in it, to easily create the hexagons and to make the code easier to read.\n*   **General Goal:**  The goal is to create a functional wrench for M4 nylock nuts that is easy to customize by changing the parameters mentioned above.\n\nId like the generated code to be as clear and well-commented as possible to make it easier for me to understand. Can you help me generate the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Gordian Knot 3D Puzzle",
    "scad": "basewidth = 8;\ntolerance = 4;\nwidth=basewidth*5;\nheight=basewidth*7;\ntolerance1 = tolerance/10;\ntolerance2 = tolerance1*2;\necho(\"Each piece is \",width,\" by \",height);\nmodule green2d() {\n    difference() {\n        square([width, height]);\n        translate([basewidth-tolerance1, basewidth-tolerance1]) square([basewidth+tolerance2, basewidth*5+tolerance2]);\n        translate([basewidth*3-tolerance1, basewidth-tolerance1]) square([basewidth+tolerance2, basewidth*5+tolerance2]);\n    }\n}\nmodule yellow2d() {\n    difference() {\n        square([width, height]);\n        translate([basewidth-tolerance1, basewidth-tolerance1]) square([basewidth+tolerance2, basewidth*5+tolerance2]);\n        translate([basewidth*3-tolerance1, basewidth-tolerance1]) square([basewidth+tolerance2, basewidth*5+tolerance2]);\n        translate([-0.1, basewidth*4-tolerance1]) square([basewidth*3+0.2, basewidth+tolerance2]);\n    }\n}\nmodule opiece2d() {\n    difference() {\n        square([width, height]);\n        translate([basewidth-tolerance1, basewidth-tolerance1]) square([basewidth+tolerance2, basewidth*5+tolerance2]);\n        translate([basewidth*3-tolerance1, basewidth-tolerance1]) square([basewidth+tolerance2, basewidth*5+tolerance2]);\n        translate([basewidth*2-0.1, basewidth*2-tolerance1]) square([basewidth+0.2, basewidth*3+tolerance2]);\n        translate([-0.1, basewidth*4-tolerance1]) square([basewidth*3+0.2, basewidth+tolerance2]);\n    }\n}\nmodule red2d() {\n    difference() {\n        square([width, height]);\n        translate([basewidth-tolerance1, basewidth-tolerance1]) square([basewidth+tolerance2, basewidth*2+tolerance2]);\n        translate([basewidth-tolerance1, basewidth*4-tolerance1]) square([basewidth+tolerance2, basewidth*2+tolerance2]);\n        translate([basewidth*3-tolerance1, basewidth-tolerance1]) square([basewidth+tolerance2, basewidth*5+tolerance2]);\n        translate([-0.1, basewidth*4-tolerance1]) square([basewidth+0.2, basewidth+tolerance2]);\n        translate([-0.1, basewidth*2-tolerance1]) square([basewidth+0.2, basewidth+tolerance2]);\n        translate([basewidth*3, basewidth*2-tolerance1]) square([basewidth*2+0.2, basewidth+tolerance2]);\n    }\n}\nmodule blue2d() {\n    difference() {\n        square([width, height]);\n        translate([basewidth-tolerance1, basewidth-tolerance1]) square([basewidth+tolerance2, basewidth+tolerance2]);\n        translate([basewidth-tolerance1, basewidth*3-tolerance1]) square([basewidth+tolerance2, basewidth*3+tolerance2]);\n        translate([basewidth*3-tolerance1, basewidth-tolerance1]) square([basewidth+tolerance2, basewidth*5+tolerance2]);\n        translate([basewidth*2-0.1, basewidth*2-tolerance1]) square([basewidth+0.2, basewidth*3+tolerance2]);\n        translate([-0.1, basewidth*4-tolerance1]) square([basewidth*3+0.2, basewidth+tolerance2]);\n    }\n}\nmodule green() {\n    color([0,1,0]) linear_extrude(height=basewidth) green2d();\n}\nmodule yellow() {\n    color([1,1,0]) linear_extrude(height=basewidth) yellow2d();\n}\nmodule orange() {\n    color([1,0.5,0]) linear_extrude(height=basewidth) opiece2d();\n}\nmodule purple() {\n    color([1,0,1]) linear_extrude(height=basewidth) opiece2d();\n}\nmodule red() {\n    color([1,0,0]) linear_extrude(height=basewidth) red2d();\n}\nmodule blue() {\n    color([0,0,1]) linear_extrude(height=basewidth) blue2d();\n}\nmodule printall() {\n    translate([-width*3/2-5, 5, 0]) green();\n    translate([-width*1/2, 5, 0]) yellow();\n    translate([width*1/2+5, 5, 0]) orange();\n    translate([-width*3/2-5, -height, 0]) red();\n    translate([-width*1/2, -height, 0]) purple();\n    translate([width*1/2+5, -height, 0]) blue();\n}\nmodule assembled() {\n    translate([0, 0, basewidth*2]) {\n        translate([0, 0, 0]) red();\n        translate([0, 0, basewidth*2]) yellow();\n    }\n    translate([basewidth*1,basewidth,0]) rotate([90,0,90]) {\n        translate([0, 0, 0]) purple();\n        translate([0, 0, basewidth*2]) green();\n    }\n    translate([-basewidth,basewidth*5,basewidth*6]) rotate([-90,90,180]) {\n        translate([0, 0, 0]) orange();\n        translate([0, 0, basewidth*2]) blue();\n    }\n}\nprintall();",
    "description": "Okay, I'm trying to create a parametric OpenSCAD model of a 3D puzzle called the \"Gordian Knot.\" I've seen it online, and it looks like a fun project. I've included the SCAD file I've already made, which is functional, but I want to make it more flexible and easy to customize with parameters.\n\nThe puzzle consists of six distinct pieces that interlock. Each piece has a 2D shape that is then linearly extruded to create a 3D form. The 2D shapes are all based on a rectangular outline with rectangular cutouts. Each piece is named by color (green, yellow, orange, purple, red, and blue).\n\nCurrently, the code uses a `basewidth` parameter to control the basic unit of size. I'd like to retain that, and also be able to control the overall dimensions of the main rectangular outline which is currently `width=basewidth*5` and `height=basewidth*7`.\n\nHere's a breakdown of what I want to achieve:\n\n*   **Parametric Dimensions:**\n    *   `basewidth`: (already present) The base unit of size, in mm.\n    *   `piece_width`: (new) The width of the main rectangular outline for each piece. Should default to `basewidth * 5`.\n    *   `piece_height`: (new) The height of the main rectangular outline for each piece. Should default to `basewidth * 7`.\n    *   `tolerance`: (already present, but should be in mm instead of tenths) The tolerance between parts, in mm. Currently, tolerance is divided by 10, but I would like a direct tolerance in mm rather than in tenths.\n\n*   **Piece Generation:**\n    *   Each piece should be generated using a module (as they are already).\n    *   The 2D shapes should be defined with mathematical logic (as they mostly already are), using the parameters above to determine the sizes and cutout locations.\n    *   The extrusions to make each piece 3D should be parameterized with a depth also using the `basewidth` parameter.\n\n*   **Assembly:**\n    *   I have some code that roughly positions the pieces as in the assembled version but I don't need this in the final parameterized version.\n\n*   **Coloring:**\n     * The color coding of the parts are useful and should be retained, but I am open to change the colors if they do not work well.\n\n*   **Output:**\n     * I would like to be able to print each of the pieces seperately as well as a printall model.\n\n*   **Libraries:**\n    *   I am not using any libraries currently and would like to not use any for the parameterized version.\n\nEssentially, I'm looking for a cleaner, more flexible version of my current code. I want to be able to easily adjust the size of the puzzle and the tolerance between parts.\n\nCould you please generate a parametric OpenSCAD file that achieves this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Stretchy Bracelet",
    "scad": "r2=30;\nh=8;\nw=15;\nt=0.4;\nn=20;\nm=27;\npi=3.14159;\nrr=pi*r2/n;\nr1=rr*1.5;\nro=r2+(r1+rr)*0.5;\nri=ro-h;\na=pi*2*ri/m-t;\necho(\"Inside Diameter = \",2*ri);\nsolid();\nmodule solid(){\ndifference(){\n\tcylinder(r=ro,h=w,$fn=m);\n\tfor(i=[1:m])rotate([0,0,i*360/m])\n\t\ttranslate([0,0,-0.03])linear_extrude(height=w+0.06)\n\t\t\tpolygon(points=[[ri+t,a/2-t],[ri+t,t-a/2],[ro+t*h/a,0]],paths=[[0,1,2]]);\n}}\nmodule hollow(){\ndifference(){\n\tbase(r1=r1,w=w);\n\tdifference(){\n\t\ttranslate([0,0,-0.01])base(r1=r1-t,w=w+0.02);\n\t\tfor(i=[1:m])rotate([0,0,i*360/m])\n\t\t\ttranslate([0,0,-0.02])linear_extrude(height=w+0.04)\n\t\t\t\tpolygon(points=[[ri,a/2],[ri,-a/2],[ro+3*t*h/a,0]],paths=[[0,1,2]]);\n\t}\n\tfor(i=[1:m])rotate([0,0,i*360/m])\n\t\ttranslate([0,0,-0.03])linear_extrude(height=w+0.06)\n\t\t\tpolygon(points=[[ri+t,a/2-t],[ri+t,t-a/2],[ro+t*h/a,0]],paths=[[0,1,2]]);\n}}\nmodule base(r1,w){\nrender()\nunion(){\n\tcylinder(r=r2+rr*0.5,h=w);\n\tfor(i=[1:n]){\n\t\trotate([0,0,i*360/n])translate([0,-r2,0])\n\t\tscale([1,0.5,1])linear_extrude(height=w,twist=180,slices=10)\n\t\t\ttranslate([rr,0,0])circle(r=r1,$fn=20);\n\t}\n}}\nmodule base1(r1,w){\nunion(){\n\tcylinder(r=ro-1.5,h=w,$fn=100);\n\tfor(i=[1:3]){\n\t\ttranslate([0,0,(i-1)*4.5+3])scale([1,1,2])rotate_extrude($fn=100)\n\t\t\ttranslate([ro-1.5,0,0])circle(r=1.5,$fn=20);\n\t}\n}}",
    "description": "Okay, I'm looking for an OpenSCAD design for a flexible, stretchy bracelet, and I have a few specific requirements and ideas based on designs I've seen.\n\nHere's what I want:\n\n**Core Structure:**\n\n*   **Circular Base:** The bracelet should be based around a circle, characterized by a major radius (let's call it `r2`).\n*   **Thickness:** The bracelet should have a defined thickness, which is the radial difference between the inner and outer radius (call it `h`).\n*   **Width:** It should also have a consistent width along its length (call it `w`).\n*   **Flexibility:** The key thing is that it should be flexible enough to stretch over a hand and then contract to fit snugly on a wrist. This is achieved by the geometry in the attached file.\n*   **No Clasp:** There's no clasp needed for this, it just relies on stretching.\n*   **Parametric Design:** Everything should be parametric, so I can adjust it easily for different sizes and looks.\n\n**Specific Design Elements:**\n\n*   **Twisty Shapes:** I want twisty, curved shapes around the circle to give it the flexibility and \"stretchy\" nature. These are similar to the \"spring\" pieces in the springamathing design. The provided code uses `n` to denote the number of these.\n    *   These should have a rounded shape, like in the existing code that uses circles and extrusion.\n\n*   **Connecting Ribs:** I want to have ribs or connectors that span around the circumference between the twisty shapes, giving the bracelet structure and stability and more flexibility. These are similar to the flat connectors from the link bracelet, and the code uses `m` to denote the number of these.\n    *   These connectors should have a flat edge on the outer surface of the bracelet.\n    *   The inner edges of these connectors should be inset from the edge of the bracelet and have a consistent thickness.\n    *   The number of these ribs is separate from the number of twisty shapes.\n\n**Parameters I need:**\n\n*   `r2`: Major radius of the bracelet (radius of the central circle).\n*   `h`: Thickness of the bracelet (radial difference between inner and outer radius).\n*   `w`: Width of the bracelet.\n*   `t`: Layer width and gap width between structural elements.\n*   `n`: Number of twisty shapes around the circle.\n*   `m`: Number of bendy parts (connectors) around the circle.\n\n**Additional Notes from the Provided Code:**\n\n*   There are alternative designs that use angled cording or horizontal cording. I am currently most interested in the flat design (using a cylinder for the base) along with the twisty elements and connecting ribs.\n* The existing code seems to handle the geometry well for generating the twisty shape and ribs, so I'd like to maintain that general approach.\n*   There are also commented-out hollow versions, so if the AI can suggest how these might be further explored that would be good.\n\n**Libraries:**\n\n*   No specific libraries beyond the standard OpenSCAD functions are needed, but please keep it all nicely organized so it's easy to understand and modify.\n\nSo, to summarize, I want an OpenSCAD file that generates a stretchy, flexible bracelet using a combination of twisty shapes and connecting ribs around a circular base. The design should be parametric and customizable using the parameters described. Please focus on generating the flat base version with twisty elements and ribs for now.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Field Notes Clip for Blackwing 602 Pencil",
    "scad": "include <MCAD/shapes.scad>\npencilRadius = 4.1;\nwallThickness = 3;\npencilWall = pencilRadius + wallThickness;\nheight = 38;\nlength = 35;\ndifference() {\nunion() {\ncylinder(height,pencilWall,pencilWall,true);\ntranslate([-3.75,-length/2,0])\ncube([wallThickness,length,height],true);\ntranslate([3.75,-length/2,0])\ncube([wallThickness,length,height],true);\n}\n#hexagon(pencilRadius*2, height+2);\n}\ntranslate([3.75,-(length+(wallThickness*0.5)),0])\ncylinder(height,wallThickness,wallThickness,true);\ntranslate([-3.75,-(length+(wallThickness*0.5)),0])\ncylinder(height,wallThickness,wallThickness,true);",
    "description": "Okay, I'm trying to design a pencil clip, kind of like the ones that come on Field Notes notebooks, but I want it to be specifically sized for different pencils, and I want it to be parametric so I can adjust things easily.\n\nI've already started messing around in OpenSCAD and I have a basic shape, but it's really inflexible. I'd like to get a more robust, parameterized version of this.\n\nHere's what I have so far and how it works. I'm trying to make a clip that slides onto a pencil. It essentially has two parts: a circular opening for the pencil to fit through, and two arms that press against the pencil to hold it in place. I'm using `difference()` to subtract the cylinder of the pencil hole from the main body.\n\nMy existing OpenSCAD code uses the `MCAD/shapes.scad` library. I have included a simple starting point:\n\n```openscad\ninclude <MCAD/shapes.scad>\npencilRadius = 4.1;\nwallThickness = 3;\npencilWall = pencilRadius + wallThickness;\nheight = 38;\nlength = 35;\n\ndifference() {\nunion() {\ncylinder(height,pencilWall,pencilWall,true);\ntranslate([-3.75,-length/2,0])\ncube([wallThickness,length,height],true);\ntranslate([3.75,-length/2,0])\ncube([wallThickness,length,height],true);\n}\n\n//#cylinder(height+2,pencilRadius,pencilRadius,true);\n#hexagon(pencilRadius*2, height+2);\n\n\n\n}\ntranslate([3.75,-(length+(wallThickness*0.5)),0])\ncylinder(height,wallThickness,wallThickness,true);\ntranslate([-3.75,-(length+(wallThickness*0.5)),0])\ncylinder(height,wallThickness,wallThickness,true);\n\n```\n\nThe `pencilRadius` variable defines the radius of the pencil itself. The `wallThickness` is the thickness of the clip material, and the `height` is the height of the clip. The `length` defines the length of the arms.\n\nCurrently, the values are hardcoded, and they are specifically sized for a Palomino Blackwing 602 pencil. I want to be able to adjust them easily, and Id like to add parameters for some of the spacing and arm shapes.\n\nHere are the things I want to parameterize:\n\n1.  **`pencil_radius`**: The radius of the pencil.\n2.  **`wall_thickness`**: The thickness of the clip material.\n3.  **`clip_height`**: The height of the clip.\n4.  **`arm_length`**: The length of the clip's arms.\n5.  **`arm_offset_x`**: The horizontal offset of the arm positions (the 3.75 in my code). I want to adjust the amount of pressure the arms put on the pencil.\n6.  **`arm_radius`**: the radius of the cylinder used for the arms, currently equal to `wallThickness`. It could be good to experiment with making the arms thicker or thinner than the main clip.\n\nI'd like to have the main body be a cylinder with the two arms attached on the sides. The hole in the cylinder should fit the pencil snugly when printed. The arms are currently rectangular, but maybe theres a better shape for flexibility and hold. Cylinders are easy, but if you have a better idea, let me know.\n\nSo, the ultimate goal is to have an OpenSCAD file with these parameters to easily generate clips for different pencils. I need the final object to have a clip for a pencil, and to be easily modified for different sizes.\n\nCould you help me create a fully parameterized OpenSCAD file that does this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric L-Bracket",
    "scad": "wall_thickness = 2;\ninternal_width = 12;\nslot_width = 4;\nside_length = 20;\nhead_annulus = (internal_width/2) - (slot_width/2);\nabit = 0.0001 * 1;\nmodule stadium3d(a, r, z, center = false){\n\toffset_x = center ? -(r + (a / 2)) : 0;\n\toffset_y = center ? -(r) : 0;\n\toffset_z = center ? -(z / 2) : 0;\n\ttranslate([offset_x, offset_y, offset_z])\n\tunion() {\n\t\ttranslate([r, 0, 0])\n\t\t\tcube([a, 2*r, z]);\n\t\ttranslate([r, r, 0])\n\t\t\tcylinder(h = z, r = r, center = false);\n\t\ttranslate([r + a, r, 0])\n\t\t\tcylinder(h = z, r = r);\n\t}\n}\nunion() {\n\tdifference() {\n\t\tcube([side_length + wall_thickness,\n\t\t      internal_width + 2*wall_thickness,\n\t\t      wall_thickness]);\n\t\ttranslate([wall_thickness + head_annulus,\n\t\t           wall_thickness + head_annulus,\n\t\t           -1])\n\t\t\tstadium3d(side_length - (2*head_annulus) - slot_width,\n \t\t\t          slot_width / 2,\n \t\t\t          wall_thickness + 2);\n\t}\n\ttranslate([wall_thickness, 0, 0])\n\trotate([0,-90,0])\n\tdifference() {\n\t\tcube([side_length + wall_thickness,\n\t\t      internal_width + 2*wall_thickness,\n\t\t      wall_thickness]);\n\t\ttranslate([wall_thickness + head_annulus,\n\t\t           wall_thickness + head_annulus,\n\t\t           -1])\n\t\t\tstadium3d(side_length - (2*head_annulus) - slot_width,\n \t\t\t          slot_width / 2,\n \t\t\t          wall_thickness + 2);\n\t}\n\ttranslate([wall_thickness - abit,\n\t           wall_thickness,\n\t           wall_thickness - abit])\n\trotate([90,0,0])\n\tlinear_extrude(height = wall_thickness) {\n\t\tpolygon([[0,0],\n\t\t        [side_length,0],\n\t\t        [0,side_length]]);\n\t}\n\ttranslate([wall_thickness - abit,\n\t           2*wall_thickness + internal_width,\n\t           wall_thickness - abit])\n\trotate([90,0,0])\n\tlinear_extrude(height = wall_thickness) {\n\t\tpolygon([[0,0],\n\t\t        [side_length,0],\n\t\t        [0,side_length]]);\n\t}\n}",
    "description": "Hi! I'm trying to create a parametric L-bracket for 3D printing. I've got a couple of OpenSCAD files that do what I want, but they are getting a little clunky, and I need a really flexible solution that I can use to create different sized brackets. I want to use it to fix some old furniture.\n\nI've attached the existing `l-bracket.scad` and `l-bracket.v1.1.scad` files to give you an idea of what I'm going for. The basic idea is an L-shape with two walls, and a couple of triangular gussets/braces for strength. The key feature is that each wall of the L-shape has a lengthwise slot for mounting. The `v1.1` version is closest to what I want, which allows for independent control of the lengths of each side.\n\nHere are the specific design requirements I have in mind:\n\n1.  **Parametric Dimensions:**\n    *   `wall_thickness`:  The thickness of the L-bracket walls.\n    *   `internal_width`:  The width of the slot/channel in each wall.\n    *   `slot_width`: The width of the slot in each wall\n    *   `side_length_h`: The length of the horizontal wall.\n    *   `side_length_v`: The length of the vertical wall.\n    *  It should also include a value to control the number of faces to use for the cylinders that form the end caps of the slots, named $fn (or a similar, logical name).\n2.  **Slot Feature:** Each wall should have a slot/channel running its entire length. It should be centered on the wall and be inset from the edges of the wall by at least the wall thickness. The slot needs to be created using a `stadium3d` type shape.\n3.  **Gussets/Braces:** Add triangular gussets/braces at the inner corner of the L-bracket. The gussets should extend the full length and height of their respective walls and overlap to make a solid model. They should be the same thickness as the wall.\n4.  **Overlap:** Use a technique like the `abit` variable to ensure that the various parts overlap slightly when they intersect to create a single, solid manifold STL file.\n\nI would prefer the design be as clean and efficient as possible while still being readable, so feel free to refactor or use helper functions/modules where needed. You do not need to import any libraries like MCAD.\n\nCan you create an OpenSCAD file that meets these requirements? I'm looking for a single `.scad` file that I can open and customize with those parameters.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Game card holder",
    "scad": "card_x = 54;\ncard_y = 80;\ncard_space = 2;\nwall_thickness = 2;\nplate_height = 2;\nwall_height = 12;\nshortwall_cut = card_x/(card_y/card_x);\nshortwall = (card_x-shortwall_cut)/2+wall_thickness+card_space/2;\nfemale_con_x = 10;\nfemale_con_y1 = 21;\nfemale_con_y2 = 12.5;\nmale_con_x = 11.4;\nmale_con_y1 = 19.8;\nmale_con_y2 = 10.46;\nangle = atan( ((female_con_y1-female_con_y2)/2) / female_con_x );\nunion() {\n\tdifference() {\n\t\tcube(size = [card_x+card_space+wall_thickness*2, card_y+card_space+wall_thickness*2,plate_height], center = true);\n\t\ttranslate([0,card_y/1.27,-card_x/4])\n\t\tcylinder(card_x/2, card_x/2, card_x/2, $fa=2);\n\t\ttranslate([0,-card_y/1.27,-card_x/4])\n\t\tcylinder(card_x/2, card_x/2, card_x/2, $fa=2);\n\t\ttranslate( [ (card_x/2) - female_con_x + card_space/2 + wall_thickness +0.01 , -female_con_y1/2, -plate_height ] )\n\t\tdifference() {\n\t\t\tcube(size = [female_con_x, female_con_y1, plate_height*2], center = false);\n\t\t\ttranslate( [ 0,female_con_y1,-1 ] )\n\t\t\trotate([0, 0, -angle])\n\t\t\tcube(female_con_x*2);\n\t\t\ttranslate( [ 0,0,-1 ] )\n\t\t\trotate([0, 0, angle-90])\n\t\t\tcube(female_con_x*2);\n\t\t}\n\t}\n\ttranslate( [ -(card_x/2) - card_space/2 - wall_thickness - male_con_x, -male_con_y1/2, -plate_height/2 ] )\n\tdifference() {\n\t\tcube(size = [male_con_x, male_con_y1, plate_height], center = false);\n\t\ttranslate( [ 0,male_con_y1,-1 ] )\n\t\trotate([0, 0, -angle])\n\t\tcube(male_con_x*2);\n\t\ttranslate( [ 0,0,-1 ] )\n\t\trotate([0, 0, angle-90])\n\t\tcube(male_con_x*2);\n\t}\n\ttranslate([  (card_x+card_space+wall_thickness*2)/2 , (card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\trotate([0,0,180])\n\tcube(size = [wall_thickness,(card_y-card_x)/2+wall_thickness+card_space/2,wall_height] ,center = false);\n\ttranslate([  -(card_x+card_space+wall_thickness*2)/2 +wall_thickness , (card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\trotate([0,0,180])\n\tcube(size = [wall_thickness,(card_y-card_x)/2+wall_thickness+card_space/2,wall_height] ,center = false);\n\ttranslate([  (card_x+card_space+wall_thickness*2)/2 -wall_thickness, -(card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\trotate([0,0,0])\n\tcube(size = [wall_thickness,(card_y-card_x)/2+wall_thickness+card_space/2,wall_height] ,center = false);\n\ttranslate([  -(card_x+card_space+wall_thickness*2)/2 , -(card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\trotate([0,0,0])\n\tcube(size = [wall_thickness,(card_y-card_x)/2+wall_thickness+card_space/2,wall_height] ,center = false);\n\ttranslate([  -(card_x+card_space+wall_thickness*2)/2  , (card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\trotate([0,0,270])\n\tcube(size = [wall_thickness, shortwall , wall_height] ,center = false);\n\ttranslate([  (card_x+card_space+wall_thickness*2)/2 , -(card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\trotate([0,0,90])\n\tcube(size = [wall_thickness, shortwall , wall_height] ,center = false);\n\ttranslate([  -(card_x+card_space+wall_thickness*2)/2 , -(card_y+card_space+wall_thickness*2)/2 +wall_thickness ,plate_height/2])\n\trotate([0,0,270])\n\tcube(size = [wall_thickness, shortwall , wall_height] ,center = false);\n\ttranslate([  (card_x+card_space+wall_thickness*2)/2 , (card_y+card_space+wall_thickness*2)/2 -wall_thickness ,plate_height/2])\n\trotate([0,0,90])\n\tcube(size = [wall_thickness, shortwall , wall_height] ,center = false);\n}",
    "description": "Okay, I'm looking to have an improved and more flexible version of my Settlers of Catan card holder. I've already got a basic design in OpenSCAD (attached as `cardholder.scad`), but it's a bit clunky and hard to adjust for different card sizes.\n\nEssentially, I need a card holder with a base plate and walls that will hold standard Catan game cards (or cards of a specified size). The current one is designed for 54mm x 80mm cards, with a small gap between the cards and the walls, and has connecting pieces for modularity. Id like to expand on that.\n\nHere are the key aspects of my current design that I'd like to see improved upon, and some new features I want:\n\n**Current Design:**\n\n*   **Base Plate:** A flat rectangular base with rounded cutouts at the front and back.\n*   **Walls:** Four long and four short walls creating a rectangular enclosure for the cards, with a small gap between the card edges and the walls.\n*   **Card Size:** Currently hardcoded for 54mm x 80mm cards with a small `card_space` variable between the card and the walls.\n*   **Connecting Pieces:** Male and female connectors on the sides to allow multiple card holders to be joined. These are currently based on some arbitrary measurements taken from a hand-modified box, and could use a rework.\n*   **\"I Just Take That Last Card\" Cut:** The short walls are slightly cut in a way to make it easier to take a single card from the end, currently calculated based on the card dimensions.\n\n**Desired Improvements and New Features:**\n\n*   **Parametric Card Size:** I need the card holder to be fully parametric. I want to be able to specify the card width and height, and have all other relevant dimensions (base plate size, wall positions, \"last card cut\", etc.) scale accordingly.\n*   **Customizable Wall Thickness and Height:** Allow independent control over wall thickness and wall height.\n*   **Improved Connector Design:** The connectors need to be more precisely defined and easily modifiable by variables. I'd also like them to be compatible between the X and Y sides. Ideally, they could use a simple tongue and groove design with a specified tongue width and groove depth/width, maybe with a slight taper for a snug fit.\n*   **Adjustable Card Space:** The gap between the cards and the walls should be a variable, so we can control the tightness of the fit.\n*   **Rounded Corners:** The corners of the base plate and walls should have an optional variable to control rounding.\n*    **Optional Logo:** Include an optional logo in the base plate. I would want the logo to be a simple extrusion, and it'd be great if I could specify the logo dimensions and position, or have it auto-center.\n*   **Use of Libraries (if applicable):** If there are any useful OpenSCAD libraries that would help to build some aspects of this design, feel free to use them and let me know which ones.  I am familiar with the MCAD library, for example, but I'm open to other recommendations.\n*   **Clear Variable Names:** Please use descriptive and clear variable names.\n\n**Specific Variables I'd like to have:**\n\n*   `card_width`: Width of the game card.\n*   `card_height`: Height of the game card.\n*   `card_space`: Space between card and walls.\n*   `wall_thickness`: Thickness of the walls.\n*   `wall_height`: Height of the walls.\n*   `base_plate_height`: Height of the base plate.\n*   `connector_tongue_width`: Width of the connector tongue.\n*    `connector_groove_width`: Width of the connector groove.\n*   `connector_groove_depth`: Depth of the connector groove.\n*   `corner_radius`: Radius of the rounded corners (0 for no rounding).\n*    `logo_width`: Width of the optional logo\n*    `logo_height`: Height of the optional logo\n*    `logo_depth`: Depth of the optional logo\n*    `logo_x_offset`: X offset of the logo from the center of the card holder.\n*    `logo_y_offset`: Y offset of the logo from the center of the card holder.\n\nI'm not particularly concerned about specific material thicknesses etc., I mainly want to be able to easily adjust these parameters and quickly re-render the design. Please do your best to generate an OpenSCAD file that meets these criteria.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Measuring Cup",
    "scad": "cups = 1;\ntbsp = 0;\ntsp = 0;\nmL = 0;\nwall = 1.6;\nsq = 1.2;\nsh = 0.16;\npi = 3.14159;\nvolume = cups*236588+tbsp*14787+tsp*4929+1000*mL;\ndifference(){\n\tminkowski(){\n\t\tcylinder(r1=0,r2=wall,h=wall,$fn=6);\n\t\tcupBase(volume);\n\t}\n\ttranslate([0,0,wall])cupBase(volume);\n}\nmodule cupBase(volume){\n\tx = pow(volume/(570*pi),1/3);\n\tmultmatrix(m=[\n\t\t[sq, 0, sh, 0],\n\t\t[0, 1/sq, 0, 0],\n\t\t[0, 0, 1, 0],\n\t\t[0, 0, 0,  1]])\n\tcylinder(h=10*x,r1=6*x,r2=9*x,$fn=64);\n}",
    "description": "Okay, I need some help designing a more advanced measuring cup. Ive made a very basic one, but Id like to make it more customizable and robust, and a little nicer looking.\n\nHere's what I currently have (attached: `measuring_cup.scad`). It's functional but quite simple:\n\n*   **Functionality:** It calculates the dimensions of a cup based on a target volume, specified as a sum of cups, tablespoons, teaspoons, and milliliters. It uses a cylinder with a slight taper for the cup shape. It also uses a Minkowski sum to create the wall thickness, which is a fixed amount.\n*   **Limitations:** The cup shape is very basic and not user-friendly. There are no handles or spouts. The base is a bit thin, and the top edge is very sharp. And all the unit conversions are embedded in the code instead of using a standard library. I'd also like to be able to adjust the taper/shape more.\n\nHeres what Id like the new design to accomplish:\n\n1.  **Parametric Volume Input:** I want to be able to specify the target volume in a more user-friendly way. Specifically, I want to be able to enter a target volume in milliliters (mL) and have the cup scale accordingly. I'd like it to also optionally still support cups, tablespoons, and teaspoons in the future, but the calculation should be done using a library and/or well-defined standard conversions.\n2.  **Refined Cup Shape:**\n    *   **Taper Control:** Instead of just scaling a cylinder, I'd like to be able to control the amount of taper between the base and the top of the cup. I think this could be done by scaling radius values at different heights.\n    *   **Curved Base:** Instead of a sharp flat cylinder base, Id like a rounded interior base for easier cleaning.\n    *   **Rounded Top Lip:** I'd like the top edge of the cup to be rounded (perhaps using a torus or some similar technique), making it more comfortable to use.\n3.  **Handle:** Id like to add a simple handle that's also parametric in terms of size and position, and perhaps can even have an opening.\n4.  **Spout:** Id like an option to add a spout. This would be a simple triangular cutout at the top of the cup rim.\n5.  **Robust Base:** I would like the base to be thicker (but still be rounded as described above for the interior).\n6.  **Wall Thickness:** Id still like a parametric wall thickness, similar to the original design.\n7.  **Unit Testing:** Can you include a way to verify the generated volume of the cup is correct? Ideally this would be something like a `check_volume` function that uses an integration calculation to estimate the volume based on the solid definition, and then compares to the target volume.\n\nHere are my additional requests, in addition to the above features:\n\n*   **Use of Libraries:** Please use the MCAD library for standard conversions (specifically to use the `standard_measures` library for unit conversions) and common math functions. Don't use libraries if they're not required (so you don't need any libraries for drawing shapes).\n*   **Commented Code:** Please comment the code clearly to explain how all parts of the design work.\n*   **Customization:** The design should allow me to easily modify all the parameters such as wall thickness, handle size, taper, and spout dimensions.\n\nI hope this is enough information, let me know if you need any clarification. Thanks for your help!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Miter Box",
    "scad": "x=100;\ny=30;\nz=30;\ncut=2;\nmodule miter(){\ndifference(){\ncube([x,y+10,z+10],true);\nunion(){\ntranslate([0,0,5])cube([x+12,y+1.5,z+10],true);\ntranslate([0,0,5])cube([cut,y*2,z+10],true);\nrotate([0,0,45])translate([0,0,5])cube([cut,y*3,z+10],true);\nrotate([0,0,-45])translate([0,0,5])cube([cut,y*3,z+10],true);\nrotate([0,0,60])translate([0,0,5])cube([cut,y*3,z+10],true);\nrotate([0,0,-60])translate([0,0,5])cube([cut,y*3,z+10],true);\n}\n}\n}\nmiter();",
    "description": "Okay, I'm looking for a parametric miter box design in OpenSCAD, specifically for cutting t-slot extrusions. I want to be able to easily adjust the dimensions and angles.\n\nI've started something myself, but it's not parametric and I don't think I'm doing the boolean operations in the best way. Here's the basic idea:\n\nI want a box-like structure, essentially a rectangular prism with some cuts in it. The basic box should have adjustable dimensions for length (x), width (y), and height (z).  These define the overall size of the box and also the size of the material we'll be using as a guide.\n\nThen, I need to cut out guides for the saw, that create angled cuts. I need the following angles: 90 degrees (straight cut), 45 degrees, and 30 degrees (plus the negative versions of those angles).  I think I was getting them okay, but it was messy. The saw kerf I'm imagining is about 2mm or so, that should be adjustable, too. Also, I want the cut guides to extend well past the box, so there's plenty of guide for the blade. I think a parameter to control their extended length would also be useful.  Finally, the height of the cut guides should at least be as tall as the 'z' height of the box.\n\nIt would also be great if the design had a tolerance built into the cuts so the t-slot extrusion doesn't bind or get scratched up by the guide. It should be a small tolerance of maybe .2 or .3 mm on each side.\n\nTo clarify the basic dimensions, the main body will be a simple rectangular prism, and the cuts will essentially be thin rectangles cut through it at the required angles. I imagine they will be similar to a miter saw guide, but they should have a \"slot\" shape so the saw blade can pass.\n\nSo, to summarize, here are the parameters I'm looking for:\n\n*   `x`: Length of the miter box.\n*   `y`: Width of the miter box (where the t-slot sits).\n*   `z`: Height of the miter box.\n*   `kerf`: Width of the saw cut.\n*   `cut_length_extension`: Length the cut guide extends past the main box.\n*   `tolerance`: tolerance applied to the cuts to allow free movement of the t-slot.\n*  `cut_height`: the height of the cut guides.\n\nPlease design this using OpenSCAD so I can easily generate the 3D model. I'm hoping to avoid using any modules that require a 3rd party installation. I'm thinking using standard boolean operations would be best.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric MakerGear X-carriage 40mm Fan Mount",
    "scad": "fan_angle = 45;\nfan_clip();\ntranslate([0,40,0])\nmirror([1,0,0])\nfan_clip();\nmodule fan_clip()\n{\n\trotate([0,0,-fan_angle])\n\tdifference()\n\t{\n\t\tunion()\n\t\t{\n\t\t\ttranslate([-4,8.5,0])\n\t\t\tcube([8,8,4]);\n\t\t\ttranslate([-4,11.5,0])\n\t\t\tcube([8,5,12]);\n\t\t}\n\t\ttranslate([0,20,8])\n\t\trotate([90,0,0])\n\t\tcylinder(r=3.5/2, h=15);\n\t}\n\tdifference(){\n\t\ttranslate([0,-4.3,0])\n\t\tcylinder(r=14, h=4);\n\t\ttranslate([0,-4.3,-1])\n\t\tcylinder(r=10.9, h=6);\n\t\ttranslate([-7,-20,-1])\n\t\tcube([14,10,6]);\n\t}\n}",
    "description": "Okay, I've got a design for a fan clip that I really like, but I want to make it more flexible. I've attached the original SCAD file, \"fanpiece2.scad\", and described how I modified it to add an adjustable fan angle. The key is that the fan pivots around a point, not just rotating the entire part.\n\nHere's the problem: the current design uses a fixed pivot point that works for my new 45-degree angle, but if I change the `fan_angle` variable, the actual fan pivot point is not consistent. Also, the current design places the fan mounting holes in the middle of a thin support structure, which makes it weaker and harder to print. I need to be able to change the angle of the fan without moving the center of the circular base, and the fan mounting holes need to be on a thick base.\n\nHere's what I need in a new, parametric OpenSCAD file:\n\n1.  **Adjustable Fan Angle:** The fan should rotate around the center of the circular base (that cylinder with r=14) using a variable, `fan_angle`, that can be set anywhere from 0 to 90 degrees. \n2.  **Circular Base:** Keep the circular base as it is. It needs to have the same dimensions, especially the radius of 14 and the height of 4. Include the hole in the center and the cut out on the edge as they are in the original file.\n3.  **Fan Mounting Platform:** I want a thick rectangular base extending from the circular base that the fan can be mounted on to. This thick base needs to remain perpendicular to the fan even as the fan pivots. This base also needs to support the holes for fan mounting screws.\n4.  **Mounting Holes:** The mounting holes need to be located on the fan mounting platform, and should adjust their position based on the `fan_angle` variable. The holes should have the same diameter as in \"fanpiece2.scad\" (3.5 mm in diameter), and should be spaced for a typical 40mm fan. The typical spacing is 31.5mm.\n5. **Thickness:** Keep the thickness of the mounting platform at a reasonable value, e.g. 4mm.\n6. **Dimensions:** I need to have a variable for the fan mounting platform width. I'll call it `platform_width`.\n7. **Library:** I'm already using the BOSL library for some other projects, so if you can incorporate it to make the code clearer that would be great.\n\nBasically, I want the same basic design, but with a proper pivot point, a stable mounting platform, and parametric controls for the fan angle and platform width. I've attached the original file as \"fanpiece2.scad\" for reference.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Plant Tag",
    "scad": "use <write/Write.scad>\ntext = \"Thai Basil\";\nfont = \"Letters.dxf\";\ntext_size = 6;\ntext_thickness = 0.8;\ntext_offset_y = 0.4;\nemboss = 1;\ntag_height = 10;\ntag_width = 45;\nspike_height = 40;\nspike_width = 6;\nspike_thickness = 1;\nif (emboss)\ncreate_plant_tag(\n    name=text,\n    font=str(\"write/\",font),\n    text_size=text_size, text_thickness=text_thickness, text_offset_y=text_offset_y,\n    height=tag_height, width=tag_width,\n    spike_height=spike_height, spike_width=spike_width,\n    thickness=spike_thickness);\nelse\ncreate_plant_tag_inset(\n    name=text,\n    font=str(\"write/\",font),\n    text_size=text_size, text_thickness=text_thickness, text_offset_y=text_offset_y,\n    height=tag_height, width=tag_width,\n    spike_height=spike_height, spike_width=spike_width,\n    thickness=spike_thickness);\nmodule create_plant_tag(\n    name,\n    font,\n    text_size,\n    text_thickness,\n    text_offset_y,\n    height,\n    width,\n    spike_height,\n    spike_width,\n    thickness)\n{\n    smidge = 0.01;\n    union()\n    {\n        linear_extrude(height=thickness) union()\n        {\n            translate([0,height/2-smidge]) square([width,height+smidge], center=true);\n            polygon(points=[ [-spike_width/6,-spike_height], [+spike_width/6,-spike_height],\n                             [+spike_width/2,0], [-spike_width/2,0] ],\n                    paths=[ [0,1,2,3] ]);\n        }\n        translate([0,height/2+text_offset_y,thickness+text_thickness/2-smidge]) color(\"red\")\n            write(name, center=true, h=text_size, t=text_thickness, font=font, space=1);\n    }\n}\nmodule create_plant_tag_inset(\n    name,\n    font,\n    text_size,\n    text_thickness,\n    text_offset_y,\n    height,\n    width,\n    spike_height,\n    spike_width,\n    thickness)\n{\n    smidge = 0.01;\n    difference()\n    {\n        linear_extrude(height=thickness) union()\n        {\n            translate([0,height/2-smidge]) square([width,height+smidge], center=true);\n            polygon(points=[ [-spike_width/6,-spike_height], [+spike_width/6,-spike_height],\n                             [+spike_width/2,0], [-spike_width/2,0] ],\n                    paths=[ [0,1,2,3] ]);\n        }\n        translate([0,height/2+text_offset_y,thickness-text_thickness/2]) color(\"red\")\n            write(name, center=true, h=text_size, t=text_thickness, font=font, space=1);\n    }\n}",
    "description": "Okay, I need a parametric plant tag generator in OpenSCAD. I want to be able to customize the tag with text, font, size, and other parameters. I've found a good starting point, but I need some improvements and more flexibility.\n\nHere's what I'm looking for:\n\n**Core Functionality:**\n\n*   **Text:** The tag should display text, which I'll specify.\n*   **Font:** I want to be able to choose from different fonts (e.g., Letters.dxf, BlackRose.dxf, Orbitron.dxf). This should work with the \"write\" library.\n*   **Text Size:** The size of the text should be adjustable.\n*   **Text Thickness:** The thickness of the text should also be adjustable.\n*   **Text Offset (Y):** I need to control how high or low the text appears on the tag using a Y-offset.\n*   **Emboss/Deboss:** I need an option to make the text either embossed (sticking out) or debossed (recessed).\n*   **Tag Dimensions:** The height and width of the tag itself should be adjustable.\n*   **Spike Dimensions:** The height and width of the stake (spike) part of the tag that goes into the soil needs to be adjustable, as does its thickness.\n*   **Libraries:** The design should work with the `write/Write.scad` library.\n*   **Units:** all units should be assumed to be mm.\n\n**Enhancements I'd Like:**\n\n1.  **Rounded Corners:** I'd like to be able to add an optional radius to the tag's corners. I want to be able to control the radius as a parameter, and be able to set it to 0 for no rounded corners.\n2.  **Spike Shape:** Instead of the trapezoidal spike, I'd like to have options for a rectangular spike and a triangular spike (a single point at the bottom). And ideally a parameter to choose between these options.\n3.  **Overall Thickness:** I'd like a parameter that controls the overall thickness of the tag *and* the spike, instead of the spike thickness being a separate parameter.\n4.  **Simplified Module Structure:** I think the code could be simplified to be less redundant. Instead of two modules for embossed and debossed text, perhaps a single module could handle both cases using a boolean parameter.\n5.  **Parameter defaults:** When parameters have reasonable defaults I would like them to be set.\n6.  **Commented Parameters:** All parameters should have in-code comments specifying their purpose and their default values.\n7.  **Render Preview:** I'd like the rendered preview to have a reasonable orientation and camera angle.\n\n**Example Usage:**\n\nIdeally, I'd like to set parameters like this:\n\n```openscad\ntext = \"My Plant\";\nfont = \"Letters.dxf\";\ntext_size = 8;\ntext_thickness = 1;\ntext_offset_y = 1;\nemboss = true; // or false for deboss\ntag_height = 15;\ntag_width = 60;\nspike_height = 50;\nspike_width = 8;\ncorner_radius = 2;\nspike_type = \"trapezoid\"; // \"rectangle\", \"triangle\",\noverall_thickness = 2;\n```\n\nAnd have the code generate a plant tag accordingly.\n\nCan you provide an OpenSCAD file that incorporates these features and improvements? I'm looking for a clean, well-commented, and easy-to-use parametric design. I'm ready to start designing my plant tags!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Wrench",
    "scad": "include <MCAD/shapes.scad>\nsize = 5.5;\nheight = 4;\nbar_length = 10*size;\nwall_size = max(4, size/4);\ndifference () {\n union () {\n  rotate(a=30, v=[0, 0, 1])\n   hexagon(height=height, size=size+wall_size*2);\n  translate([0, size, 0])\n   rotate(a=90, v=[0, 0, 1])\n    cube([wall_size, size+wall_size*2, height], center=true);\n  translate([0, -bar_length/2, 0])\n   cube([wall_size, bar_length, height], center=true);\n }\n union() {\n  translate([-size/2, 0, -height/2-0.05])\n   cube([size, size+wall_size, height+0.1]);\n  rotate(a=30, v=[0, 0, 1])\n   hexagon(height=height+0.1, size=size);\n }\n}",
    "description": "Okay, I'd like a parametric OpenSCAD file for a wrench, similar to the one I've designed before but with a few more options. The goal is to make it easily adjustable for different nut sizes and handle lengths.\n\nMy previous attempt is below:\n\n```\ninclude <MCAD/shapes.scad>\n\n// http://www.engineersedge.com/iso_hex_head_screw.htm\n\nsize = 5.5;\nheight = 4;\n\nbar_length = 10*size;\n\nwall_size = max(4, size/4);\n\n\n\ndifference () {\n union () {\n  // The outisde of the bit that actually holds the nut.\n  rotate(a=30, v=[0, 0, 1])\n   hexagon(height=height, size=size+wall_size*2);\n  \n  translate([0, size, 0])\n   rotate(a=90, v=[0, 0, 1])\n    cube([wall_size, size+wall_size*2, height], center=true);\n  \n\n  // The bar / handle\n  translate([0, -bar_length/2, 0])\n   cube([wall_size, bar_length, height], center=true);\n }\n \n union() {\n  translate([-size/2, 0, -height/2-0.05])\n   cube([size, size+wall_size, height+0.1]);\n\n  rotate(a=30, v=[0, 0, 1])\n   hexagon(height=height+0.1, size=size);\n }\n\n}\n```\n\nI want to be able to control the following:\n\n*   `nut_size`: The size of the nut the wrench is intended for (i.e., the flat-to-flat measurement of a hex nut).  I think this should drive most of the other dimensions.\n*   `wrench_height`: The overall thickness of the wrench.\n*   `handle_length`: The length of the wrench handle.  Ideally, there would be a default length, maybe a multiple of `nut_size`, but I want to be able to override that.\n*   `wall_thickness`: The thickness of the material surrounding the nut opening. I want to calculate a default value based on `nut_size`, but I'd like an override. Maybe something that defaults to `max(4, nut_size/4)`?\n*   `bar_width`: The width of the wrench handle. I'd also like this to have a default based on `wall_thickness`. I'd be happy with something like `wall_thickness`.\n\nI'd like the wrench to be based on a difference of unions, like my example. The main body should consist of a hexagon with an added rectangular piece for the second jaw around the nut, and a bar for the handle. Then, the cut-out for the nut should be made from a second hexagon and a rectangular cut, similar to how my example works.\n\nPlease use the MCAD library, specifically `shapes.scad` for the hexagon shape.\n\nI want to make sure that the nut hole is created with a slight tolerance; in the provided example the nut-hole hexagon is slightly taller by 0.1 than the main hexagon body (and extends below as well).\n\nCan you provide an OpenSCAD file implementing this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Day 9: Funnel, Parametric",
    "scad": "bottom_diameter = 70;\ncone_height = 45;\ntop_diameter = 5;\ntop_height = 20;\nwidth = 2.5;\nunion()\n{\ndifference()\n{\ncylinder(h=cone_height, r1=bottom_diameter/2 + width, r2 = top_diameter/2 + width);\ncylinder(h=cone_height, r1=bottom_diameter/2, r2 = top_diameter/2);\n}\ntranslate([0, 0, cone_height])\n{\ndifference()\n{\ncylinder(h=top_height, r=top_diameter/2 + width);\ncylinder(h=top_height, r=top_diameter/2);\n}\n}\n}",
    "description": "Okay, I'm looking for an OpenSCAD design for a parametric funnel. I've already got a basic design I've been playing around with (attached: funnel.scad), but I think there are some improvements that could be made and I'd like to make it more robust.\n\nMy current design creates a funnel using a cone section connected to a cylindrical neck. The parameters I'm currently using are: `bottom_diameter`, `cone_height`, `top_diameter`, `top_height`, and `width`, where `width` is the thickness of the funnel walls. I'm using `difference()` operations to create the hollow funnel by subtracting a smaller cylinder from a larger one.\n\nHeres what Id like improved and new parameters I'd like to introduce:\n\n1.  **Smooth Transitions:** Instead of a hard transition from the cone to the cylindrical neck, can we round that corner? I'm envisioning a fillet or a similar rounded transition there.\n2.  **Base:** I'd like to have an optional base that adds stability. It should be a flat cylinder connected to the bottom of the cone.\n    *   I need a new parameter, `base_diameter`, for the diameter of this base, and `base_height` for the height.\n    *   I'd like a boolean parameter called `has_base` that lets the user easily turn the base on or off.\n3.  **Hole in Base:** If theres a base, it should probably have a hole centered on the funnel's central axis, for easier mounting. The size of that hole could be an additional parameter, called `base_hole_diameter`.\n4.  **Top Rim:** I think a rounded or beveled rim at the top of the cylindrical section would be nice. I'd like a boolean parameter called `has_rim`, and if set to true, apply a small chamfer or bevel to the top of the cylinder. A `rim_width` parameter would control the width of that bevel or chamfer.\n5. **Wall Thickness Parameter:** Could we adjust the `width` parameter to more explicitly control the overall wall thickness of the entire funnel?\n6. **Units:** Could you also ensure that the generated OpenSCAD file uses the built-in `$fn` variable to control the resolution of all circular objects? Make it easily modifiable for different levels of resolution for printing versus display.\n\nSo, in summary, I'd like you to generate an OpenSCAD file for a parametric funnel using the following parameters:\n\n*   `bottom_diameter`\n*   `cone_height`\n*   `top_diameter`\n*   `top_height`\n*   `wall_thickness` (formerly `width`)\n*   `has_base` (boolean)\n*   `base_diameter`\n*   `base_height`\n*   `base_hole_diameter`\n*   `has_rim` (boolean)\n*   `rim_width`\n*   `$fn` (to control resolution of circles)\n\nPlease include comments to make the code easy to understand, particularly around how the rounded transition from the cone to the cylinder is created, along with the base and rim feature implementation.\n\nI *do not* need any MCAD libraries or any other external libraries for this design. I would like it to be stand-alone as much as possible.\n\nThanks in advance for your help!\n"
  },
  {
    "object": "Hey cadmonkey, make me a The Original Bitbeam",
    "scad": "beam_width     = 8;\nhole_diameter  = 5.1;\nhole_radius    = hole_diameter / 2;\nmodule beam(number_of_holes) {\n    beam_length = number_of_holes * beam_width;\n    difference() {\n        cube([beam_length,beam_width,beam_width]);\n        for (x=[beam_width/2 : beam_width : beam_length]) {\n            translate([x,beam_width/2,-2])\n            cylinder(r=hole_radius, h=12, $fn=30);\n        }\n        for (x=[beam_width/2 : beam_width : beam_length]) {\n            rotate([90,0,0])\n            translate([x,beam_width/2,-10])\n            cylinder(r=hole_radius, h=12, $fn=30);\n        }\n        }\n}\nbeam(3);",
    "description": "Okay, I'm looking to build some custom structural elements for my robot, and I really like the idea of using Bitbeam. I've got a basic bitbeam.scad file here that makes a standard length of beam, but I need something that can handle a wider variety of configurations.\n\nHere's what I want my custom OpenSCAD file to do:\n\n1.  **Parametric Beam Length:** I need to be able to specify the length of the beam not just by the *number* of holes but also by the physical length, so I can make specific lengths and not just increments of hole spacing. I need to be able to define beam length in millimeters (mm).  So, if I want a 50mm beam or a 100mm beam, I can just enter that and the code will handle hole placement.\n2. **Hole Spacing Control:** The standard spacing is 8mm, but it would be good to adjust this and the hole size. I also need the option to specify if the holes should be present (true) or not (false). I want control over both the horizontal and vertical spacing (if there are multiple rows of holes).\n3.  **Multiple Rows of Holes:** I want to be able to specify if there should be one row of holes on one face of the beam (like the original file) or if I should have multiple rows of holes on multiple faces of the beam. I'd like to control the vertical offset of each row of holes as well. I should be able to specify this on a face-by-face basis.\n4.  **Beam Dimensions:** I should be able to control the beam's width, height, and thickness. The current file is for a square beam, but I'll probably want to use rectangular beams sometimes.\n5.  **Hole Depth:** Ideally, I would like to specify the depth of the holes. In the original file they're designed to pass all the way through but I want the option to create shallow holes if needed. I also would like to add threads into these holes using a library function from MCAD.\n6. **End Features:** I need the option to add connection features to the ends of the beam. These could be simple tabs, dowel pins, or other features.\n7.  **Unit System:** The default unit should be mm.\n\nI would like the OpenSCAD file to use the MCAD library for the threading and perhaps other related functions, but I won't need you to include those files; just ensure that the necessary `use` statements are included.\n\nTo summarize, I want a parametric Bitbeam generator with the following features:\n\n*   **Parametric length** in mm\n*   **Hole control** (spacing, size, presence) horizontal and vertical.\n*   **Multiple hole rows** on multiple faces.\n*   **Beam dimensions** (width, height, thickness)\n*   **Hole depth** control\n*   **End feature** options.\n*   **Uses MCAD** for threading, etc.\n\nCould you generate an OpenSCAD file for this? Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Radioactive Trefoil (OpenSCAD)",
    "scad": "OuterRadius = 50;\nTrefoilHeight = 1;\nInnerRatio = 1.5;\nOuterRatio = 5;\nResolutionMultiplier = 10;\nTrefoil(OuterRadius,TrefoilHeight,InnerRatio,OuterRatio,ResolutionMultiplier);\nmodule Trefoil(outradius,height,inRatio,outRatio,rez){\n\tinradius = outradius/outRatio;\n\tunion(){\n\t\tcylinder(r=inradius,height,center=true, $fn=inradius*rez);\n\t\tdifference(){\n\t\t\tcylinder(r=outradius,height,center=true, $fn=inradius*rez);\n\t\t\tcylinder(r=inradius*inRatio,height*2,center=true, $fn=inradius*rez);\n\t\t\tfor(i=[0:3]){\n\t\t\t\trotate(a = i*120) {\n\t\t\t\tlinear_extrude(height=height+1, center=true)\n\t\t\t\tpolygon(points=[[0,0],[2*outradius,0],[(2*outradius)*cos(60),(2*outradius)*sin(60)]], paths=[[0,1,2]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "description": "Okay, I need an OpenSCAD design for a radiation trefoil symbol, and I want it to be parametric so I can easily adjust its size and proportions. I've found a simple example online but I'd like it to be more customizable, and I'd also like a specific base shape.\n\nHere's what I'm thinking:\n\n**Core Trefoil Shape:**\n\n*   The basic design is the standard trefoil: a central circle with three \"blades\" radiating outwards.\n*   **Key Parameters:**\n    *   `outerRadius`: The overall radius of the trefoil, determining its size.\n    *   `trefoilHeight`: The thickness/height of the trefoil.\n    *   `innerRatio`: This controls how far from the center the \"blades\" start relative to the *inner* circle radius. The example used 1.5, and I think that is fine as the default.\n    *   `outerRatio`: This controls how far the \"blades\" extend relative to the *inner* circle radius. The example used 5, and I think that's also a good default, but I'd still like to be able to adjust this.\n    *   `resolutionMultiplier`: This affects the number of facets for the circles in the trefoil.\n*   The center of the trefoil will be a cylinder of radius `outerRadius / outerRatio`.\n* The blades start at a radius of `(outerRadius/outerRatio) * innerRatio`\n*   The outer edges of the blades terminate at a radius of `outerRadius`.\n* The inner triangle that creates the gaps between blades should be subtracted from the disk.\n* I would like to keep the default ratios the same, because those are part of the standards. \n* I would like a parameter to control whether the blades are extruded linearly or if they are rotated to create a rounded effect.\n\n**Base Shape:**\n\n*   I would like a backing shape for the trefoil. By default, I want this to be a triangle, but I want to be able to choose between: triangle, circle or square.\n*   **New Parameters:**\n    * `baseShape`: A parameter that can be set to \"triangle\", \"circle\", or \"square\" (string parameter).\n        * if `baseShape` is \"triangle\", it should be an equilateral triangle which fully encompasses the trefoil. I would like it to be centered on the trefoil. The thickness of this should also be controlled by `trefoilHeight`.\n        * if `baseShape` is \"circle\", it should be a cylinder centered on the trefoil, which fully encompasses it. The height should also be controlled by `trefoilHeight`.\n        * if `baseShape` is \"square\", it should be a cube with a square base. I would like it to be aligned so that the faces of the square are parallel with the triangles that the trefoil blades are cut out of. The height should be controlled by `trefoilHeight`.\n    * `baseOffset`: This parameter should control the z-offset of the base, relative to the base of the trefoil. It's useful for making a flat base, where `baseOffset = -trefoilHeight/2`.\n   \n\n**Other Considerations:**\n\n*   I'd like all shapes to be centered around the origin.\n*   It would be nice if I could control the resolution of the cylinders with the `resolutionMultiplier` variable that was in the example I shared.\n\n**In summary:** I need a parametric OpenSCAD file to generate a radiation trefoil symbol with a customizable base shape.  The code needs to be adaptable and easy to tweak.  I do not have any custom libraries that I would like to include.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Collets for Tap Holder",
    "scad": "typ=\"H\";\ndbd=3.2;\nf2f=6.25;\nffn=6;\nfop=\"V\";\nfvs=0.5;\ngap=0.25;\nono=3;\nomn=0.5;\n collet(typ);\nmodule collet(typ)\n{\n\tdifference()\n\t{\n\t\tbody();\n\t\tif( typ == \"C\" )\n\t\t{\n\t\t\tdrill_bit();\n\t\t\topenings();\n\t\t}\n\t\telse if( typ == \"H\" )\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\taccessoire_bit();\n\t\t\t\tif( fop == \"V\" )\n\t\t\t\t{\n\t\t\t\t\topenings();\n\t\t\t\t}\n\t\t\t\telse if ( fop == \"F\" )\n\t\t\t\t{\n\t\t\t\t\trotate([0,0,360/ffn/2]) openings();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule body()\n{\n\tunion()\n\t{\n\t\tcylinder(h=31.25, r=13.75/2, $fn=13.75*PI, center=false);\n\t\ttranslate([0,0,10])\n\t\tcylinder(h=31.25-10, r1=13.75/2, r2=15/2, $fn=13.75*PI, center=false);\n\t\ttranslate([0,0,10])\n\t\tcylinder(h=31.25-10-4, r1=13.75/2, r2=20/2, $fn=13.75*PI, center=false);\n\t}\n}\nmodule drill_bit()\n{\n   cfn=ono*round(dbd*PI/ono);\n\tunion()\n\t{\n\t\ttranslate([0,0,-0.1])\n\t\tcylinder(h=10+0.2, r=(dbd-gap)/2, $fn=cfn, center=false);\n\t\ttranslate([0,0,7])\n\t\tcylinder(h=31.25-7+0.2, r=(dbd+gap)/2, $fn=cfn, center=false);\n\t\ttranslate([0,0,8.5])\n\t\tcylinder(h=8, r=(dbd+gap+1)/2, $fn=cfn, center=false);\n\t\ttranslate([0,0,8.5+8])\n\t\tcylinder(h=0.75, r1=(dbd+gap+1)/2, r2=(dbd+gap)/2, $fn=cfn, center=false);\n\t}\n}\nmodule openings()\n{\n\toy=dbd/ono > omn ? dbd/ono : omn;\n\ttranslate([0,0,9.5])\n\tfor(i=[0:ono-1])\n\t{\n\t\trotate([0,0,i*360/ono])\n\t\ttranslate([6,0,31.25/2])\n\t\tcube(size=[12,oy,31.25], center=true);\n\t}\n}\nmodule accessoire_bit()\n{\n\tlf=360/ffn;\n\tfod=f2f/sin(lf);\n\tunion()\n\t{\n\t\ttranslate([0,0,-0.1])\n\t\tcylinder(h=31.25+0.2, r=(fod+gap)/2, $fn=ffn, center=false);\n\t\ttranslate([0,0,8.5])\n\t\tcylinder(h=8, r=(fod+gap+1)/2, $fn=ffn, center=false);\n\t\ttranslate([0,0,8.5+8])\n\t\tcylinder(h=0.75, r1=(fod+gap+1)/2, r2=(fod+gap)/2, $fn=ffn, center=false);\n\t\tif( fvs != 0 )\n\t\tassign(xd=(fod+gap+fvs)/2-(fvs*cos(lf)/2/sin(lf))-0.05)\n\t\t{\n\t\t\tfor(i=[0:ffn-1])\n\t\t\tassign(x=xd*cos(i*lf), y=xd*sin(i*lf))\n\t\t\t{\n\t\t\t\ttranslate([x,y,31.25/2+0.75])\n\t\t\t\trotate([0,0,i*lf])\n\t\t\t\tcube([fvs,fvs,31.25], center=true);\n\t\t\t}\n\t\t}\n\t}\n}",
    "description": "Okay, I'm looking to create some collets for a tap holder, similar to what's described in the Thingiverse project 16956 (and its derivatives). I need a parametric OpenSCAD file that allows me to generate collets for both cylindrical (drill bits) and hexagonal (accessories) shanks.\n\nHere's what I need the design to be able to handle:\n\n**Overall Collet Structure:**\n\n*   The collet will have a basic cylindrical body with three sections:\n    *   A main cylindrical section.\n    *   A tapered transition from the main cylinder to a smaller cylinder.\n    *   A second taper to a smaller cylinder, which is intended to be clamped.\n*   The collet should have multiple openings (slits) along its length to allow it to compress and grip the shank. I need to control the number of these openings.\n\n**Parameters I want to control:**\n\n1.  **`typ` (Type):**  This parameter should switch between \"C\" for cylindrical and \"H\" for hexagonal.\n\n    *   **Cylindrical (`typ = \"C\"`):**\n        *   **`dbd` (Drill Bit Diameter):** The diameter of the drill bit the collet is intended for.\n    *   **Hexagonal (`typ = \"H\"`):**\n        *   **`f2f` (Face to Face):** The distance between opposite faces of the hexagon.\n        *   **`ffn` (Faces Number):**  Always 6 for a hexagon, but the parameter needs to be there in the script.\n        *   **`fop` (Face Opening):**  Defines where the openings are cut. Should be either \"V\" for vertex or \"F\" for face, to change which side of the hexagon the openings are cut at.\n        *    **`fvs` (Vertex Side length):** The side length of a cube used to exaggerate the cuts, where `fop` is set to \"V\".\n\n2.  **Common Parameters (used in both `typ` options):**\n    *   **`gap`:** Tolerance between the bit diameter (or hex size) and the collet bore, which can be used to control fit, i.e. make the bore slightly larger.\n    *   **`ono`:** The number of openings/slits/clamps.\n    *   **`omn`:** Minimum size to keep the openings, used to avoid the walls from fusing together when printing.\n\n**Specific Functionality:**\n\n*   **Cylindrical Collet (`typ = \"C\"`):**\n    *   The bore for the drill bit should be slightly smaller than the `dbd` plus `gap` at the start, expanding to `dbd` plus `gap` through the main body of the collet, then expanding again further out.\n    *   The `cfn` (number of facets of the cylinder) should be calculated, with `cfn=ono*round(dbd*PI/ono)`.\n    *   The openings should be rectangular, and cut out of the main body of the collet.\n*   **Hexagonal Collet (`typ = \"H\"`):**\n    *   The bore for the hex shank should be slightly smaller than `f2f` converted to diameter `fod` with the sine function, and an added `gap`, at the start, expanding to `fod` plus `gap` through the main body of the collet, then expanding again further out.\n    *  The openings should be rectangular, and cut out of the main body of the collet.\n        *   If `fop` is \"V\", the openings should be at the vertices of the hexagon, exaggerated with a cube as in the original code.\n        *   If `fop` is \"F\", the openings should be at the center of the faces of the hexagon.\n\n**General Notes:**\n\n*   I'd like the code to be well-commented, following general Openscad coding practices.\n*   I do not need any MCAD libraries.\n\nBasically, I need a parametric version of what is in `collets4tapHolder.scad`. I'm mainly going to be printing these on my 3D printer so I am not concerned about any manufacturing specific concerns other than the tolerance with the `gap`.\n\nCan you create an OpenSCAD file for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Tooth-paste/Paint Tube Key",
    "scad": "barrel_diameter = 9.0;\nbarrel_flats = 8.0;\nslot_width = 2.5;\nslot_length = 50.0;\nkey_width = 35.0;\nkey_height = 15.0;\nhole_diameter = 8;\noverlap = 1;\n$fn = 50;\ntranslate([0, 0, barrel_flats/2])\n\trotate(-90, [0, 0, 1]) rotate(-90, [1, 0, 0])\n\t\ttube_key(barrel_diameter, barrel_flats, slot_width, slot_length, key_width, key_height, hole_diameter);\nmodule tube_key(bd, bf, sw, sl, kw, kh, hd) {\n\tunion() {\n\t\ttranslate([0, 0, kh/2])\n\t\t\trotate(90, [1, 0, 0]) {\n\t\t\t\tdifference() {\n\t\t\t\t\thull() {\n\t\t\t\t\t\ttranslate([kw/2 - kh/2, 0, 0])\n\t\t\t\t\t\t\tcylinder(r = kh/2, h = bf, center = true);\n\t\t\t\t\t\ttranslate([- kw/2 + kh/2, 0, 0])\n\t\t\t\t\t\t\tcylinder(r = kh/2, h = bf, center = true);\n\t\t\t\t\t}\n#\t\t\t\t\ttranslate([-kh/2, 0, -bf/2-overlap])\n\t\t\t\t\t\tcylinder(r = hd/2, h = bf + 2*overlap);\n#\t\t\t\t\ttranslate([kh/2, 0, -bf/2-overlap])\n\t\t\t\t\t\tcylinder(r = hd/2, h = bf + 2*overlap);\n#\t\t\t\t\ttranslate([0, -4*kh/5, -bf/2-overlap])\n\t\t\t\t\t\tcylinder(r = kh/2, h = bf + 2*overlap);\n\t\t\t\t}\n\t\t\t}\n\t\ttranslate([0, 0, kh - overlap])\n\t\t\tdifference() {\n\t\t\t\tcylinder(r = bd/2, h = sl + bd);\n#\t\t\t\ttranslate([-sw/2, -bd/2 - overlap, bd/2])\n\t\t\t\t\tcube([sw, bd + 2*overlap, sl]);\n#\t\t\t\ttranslate([-bd/2 - overlap, bf/2, -overlap])\n\t\t\t\t\tcube([bd + 2*overlap, bd/2, sl + bd + 2*overlap]);\n#\t\t\t\ttranslate([-bd/2 - overlap, -bf/2 - bd/2, -overlap])\n\t\t\t\t\tcube([bd + 2*overlap, bd/2, sl + bd + 2*overlap]);\n\t\t\t}\n\t}\n}",
    "description": "Okay, I'm looking for an OpenSCAD design for a toothpaste tube key, and I'd like it to be fully parametric so I can easily adjust it for different tube sizes. I have a basic design in mind, but I want to make it a little more robust and flexible.\n\nHere's what I'm thinking:\n\n**Core Functionality:**\nThe key should have two main parts: a handle section for grip and a barrel section that clamps onto the tube. The barrel section will have a slot to roll the tube.\n\n**Parameters I Need to Control:**\n*   **`barrel_diameter`**: The diameter of the barrel that clamps on the toothpaste tube.\n*   **`barrel_flats`**: The thickness/height of the flat section of the barrel where the handle attaches, as well as how wide the key will effectively be when you're done winding up the tube. This also helps determine the handle cross-section.\n*  **`slot_width`**: The width of the slot in the barrel for the rolled-up toothpaste tube.\n*   **`slot_length`**: The length of the slot in the barrel. This influences how much tube can be rolled up at once.\n*   **`key_width`**: The overall width of the handle.\n*   **`key_height`**: The overall height of the handle.\n*   **`hole_diameter`**: The diameter of the hole that will be in the handle. This will usually be a hole on either side of the handle, for strength.\n*   **`overlap`**: A small tolerance value to ensure parts fit correctly.\n\n**Design Details I'd Like Included:**\n*   The handle should have a solid, comfortable feel. Id like a rounded, sort of oval, cross-section for the handle which is flat on the bottom where it connects to the barrel.\n*   I'd like two holes going through the handle, from top to bottom, as shown in the example code. I guess this is for strength but it is also what the handle feels like in my hand from using one like this before. I guess we need to cut the holes out of the handle.\n*   The barrel should be able to grip the tube effectively. I'd like a slot cut into the circular barrel, so that the user can slide the tube in.\n*   I want the design to be printable without supports, which means avoiding overhangs greater than 45 degrees.\n*   I'd also like to be able to adjust the number of `fn` in the OpenSCAD design.\n\n**Libraries:**\nI don't need any specialized libraries, I think this should be able to be constructed from the basic primitives.\n\n**What I Expect:**\nI'm looking for a single OpenSCAD file that defines a module for the toothpaste tube key, with all the parameters I've mentioned. I'd expect the main part of the script to instantiate the module with some default values, so it generates a default example design. I should be able to recompile the design after changing the parameters.\n\nHere is my design which is close to what I want:\n```\n//////\n// Tooth-paste/Paint Tube Key\n//\n// http://www.thingiverse.com/thing:21410\n// By: Alan Yates <thingiverse@alanyates.com>\n//////\n\n// geometry\nbarrel_diameter = 9.0;\nbarrel_flats = 8.0;\nslot_width = 2.5;\nslot_length = 50.0;\nkey_width = 35.0;\nkey_height = 15.0;\nhole_diameter = 8;\n\n// tolerances\noverlap = 1;\n$fn = 50;\n\ntranslate([0, 0, barrel_flats/2])\n\trotate(-90, [0, 0, 1]) rotate(-90, [1, 0, 0])\n\t\ttube_key(barrel_diameter, barrel_flats, slot_width, slot_length, key_width, key_height, hole_diameter);\n\nmodule tube_key(bd, bf, sw, sl, kw, kh, hd) {\n\tunion() {\n\t\ttranslate([0, 0, kh/2])\n\t\t\trotate(90, [1, 0, 0]) {\n\t\t\t\tdifference() {\n\t\t\t\t\thull() {\n\t\t\t\t\t\ttranslate([kw/2 - kh/2, 0, 0])\n\t\t\t\t\t\t\tcylinder(r = kh/2, h = bf, center = true);\n\t\t\t\t\t\ttranslate([- kw/2 + kh/2, 0, 0])\n\t\t\t\t\t\t\tcylinder(r = kh/2, h = bf, center = true);\n\t\t\t\t\t}\n#\t\t\t\t\ttranslate([-kh/2, 0, -bf/2-overlap])\n\t\t\t\t\t\tcylinder(r = hd/2, h = bf + 2*overlap);\n#\t\t\t\t\ttranslate([kh/2, 0, -bf/2-overlap])\n\t\t\t\t\t\tcylinder(r = hd/2, h = bf + 2*overlap);\n#\t\t\t\t\ttranslate([0, -4*kh/5, -bf/2-overlap])\n\t\t\t\t\t\tcylinder(r = kh/2, h = bf + 2*overlap);\n\t\t\t\t}\n\t\t\t}\n\t\ttranslate([0, 0, kh - overlap])\n\t\t\tdifference() {\n\t\t\t\tcylinder(r = bd/2, h = sl + bd);\n\t\t\n#\t\t\t\ttranslate([-sw/2, -bd/2 - overlap, bd/2])\n\t\t\t\t\tcube([sw, bd + 2*overlap, sl]);\n#\t\t\t\ttranslate([-bd/2 - overlap, bf/2, -overlap])\n\t\t\t\t\tcube([bd + 2*overlap, bd/2, sl + bd + 2*overlap]);\n#\t\t\t\ttranslate([-bd/2 - overlap, -bf/2 - bd/2, -overlap])\n\t\t\t\t\tcube([bd + 2*overlap, bd/2, sl + bd + 2*overlap]);\n\t\t\t}\n\t}\n}\n```\nIm looking forward to seeing your solution!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Owen's Bowden clamp: tightening cone improvement (parametric + inner rings)",
    "scad": "ir=6;\nch=16;\nor1=9.2;\nor2=7.8;\ngap=2;\nrippler=0.3;\nrippleh=1;\nripples=2;\ntol=0+0.01;\n$fn=0+40;\ndifference()\n{\n\tcylinder(r1=or1/2, r2=or2/2, h=ch);\n\ttranslate([0,0,-tol])\n\t{\n\t\tcylinder(r=ir/2,h=ch+2*tol);\n\t\ttranslate([-gap/2,0,0]) cube([gap,or1+tol,ch+2*tol]);\n\t}\n\tfor(i=[-tol:(ripples+rippleh):ch-rippleh-2*tol])\n\t\ttranslate([0,0,i])\n\t\t\tcylinder(r=ir/2+rippler * (ch-i)/ch, h=rippleh);\n}",
    "description": "Okay, I need an OpenSCAD design for a parametric feeder cone, specifically for a Bowden tube setup on a 3D printer. I'm having trouble getting a good, secure grip on the tube with the standard cone designs, so I need something with some extra features to improve the clamping force.\n\nHere are the key requirements and parameters I need to control:\n\n*   **Core Function:** The cone needs to have a tapered shape, with a smaller inner diameter at the top that fits my bowden tube, and a larger outer diameter at the base that fits into the clamp on my extruder.\n\n*   **Internal Diameter (Tube):** I need a parameter to control the internal radius at the small end of the cone, where the bowden tube inserts. Let's call this `ir`, and it defaults to 6mm (which is for a 6mm OD tube, so the inner dimension would be 4mm approximately).\n\n*   **Cone Height:** I need a parameter to control the overall height of the cone. Let's call this `ch` and default it to 16mm.\n\n*   **Outer Radius 1 (Large End):** I need a parameter to control the outer radius of the cone at the large end. Let's call this `or1` and default it to 9.2mm.\n\n*   **Outer Radius 2 (Small End):** I need a parameter to control the outer radius of the cone at the small end. Let's call this `or2` and default it to 7.8mm.\n\n*   **Vertical Opening:** I need a parameter to create a small vertical opening or slot down one side of the cone, to allow it to flex a bit. Let's call this `gap`, and it should default to 2mm. The opening should be centered on the X axis.\n\n*   **Internal Ripples:** Crucially, I need to include internal ripples or rings inside the cone, near the base (the larger end). These will grip the bowden tube better. I need these to be parametric too:\n    *   **Ripple Width (at base):**  `rippler` (default 0.3mm). This is how wide the ripples stick out (radially), starting at the base of the cone. It should taper to zero at the top of the cone.\n    *   **Ripple Height:** `rippleh` (default 1mm). This is the height of each ripple (on the Z axis).\n    *   **Ripple Spacing:** `ripples` (default 2mm). This is the distance between each ripple, measured from the start of one ripple to the start of the next, so `ripples+rippleh` is the distance between two ripples on the Z axis, so if it's not equal to the height then gaps will appear between the ridges.\n\n*   **Tolerance:** I want a small tolerance parameter (say, `tol` defaulting to 0.01mm), mainly for small adjustments and making sure the OpenSCAD preview handles subtractions without issues.\n\n*   **$fn:** For smoothness, I need to ensure the cylinder function uses a sufficiently high $fn value. I'd like to set $fn=40 or something like that.\n\nThe final design should use `difference()` to subtract the inner shape, the opening and the ripples from the outer shape of the cone. It should be fully parametric, meaning all the above values can be changed to suit different tube and printer dimensions. Please make sure the internal ripple diameter increases smoothly towards the base of the cone as per the existing file and that the ripples form a ring shape inside the cone.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Printable Spool Roller",
    "scad": "spool_wall = 5;\nspool_width = 90 - spool_wall;\nspool_diameter = 162.5;\nhole_diameter = 37.5;\nbearing_diameter = 19;\nbearing_thickness = 7;\nbolt_diameter = 4.5;\nholder_wall = 5;\nholder_base_height = 5;\nholder_base_width = spool_width + holder_wall;\nholder_base_length = 100;\nholder_bearing_width = bearing_diameter;\nbearing_radius = spool_diameter / 2 + bearing_diameter / 2;\nbearing_degree = acos((holder_base_length / 2) / (bearing_radius));\nholder_bearing_height = bearing_radius * sin(-bearing_degree)  + spool_diameter/2;\nmodule spool()\n{\n\trotate([0, 90, 0])\n\tdifference()\n\t{\n\tunion()\n\t{\n\t\tcolor([0.1,0.1,0.1])\n\t\ttranslate([0, 0, spool_width / 2])\n\t\tcylinder(r = spool_diameter / 2, h = spool_wall, center = true, $fn = 64);\n\t\tcolor([0.1,0.1,0.1])\n\t\ttranslate([0, 0, -(spool_width / 2)])\n\t\tcylinder(r = spool_diameter / 2, h = spool_wall, center = true, $fn = 64);\n\t\tcolor([0.5, 0, 0.7])\n\t\ttranslate([0, 0, 0])\n\t\tcylinder(r = spool_diameter / 2 - spool_wall, h = spool_width - spool_wall, center = true);\n\t}\n\tunion()\n\t{\n\t\tcolor([0.6, 0.6, 0.6])\n\t\tcylinder(r = hole_diameter / 2, h = spool_width + spool_wall + 0.1, center = true);\n\t}\n\t}\n}\nmodule holder()\n{\n\tcolor([1, 0, 0])\n\ttranslate([0, 0, -spool_diameter / 2])\n\tdifference()\n\t{\n\tunion()\n\t{\n\t\ttranslate([0, 0, -holder_base_height / 2])\n\t\tcube([spool_width + bearing_thickness + holder_wall * 2,\n\t\t\tholder_base_length,\n\t\t\tholder_base_height], center = true);\n\t\ttranslate([spool_width / 2,\n\t\t\t\tholder_base_length / 2 - bearing_diameter / 2,\n\t\t\t\tholder_bearing_height])\n\t\tunion()\n\t\t{\n\t\t\trotate([0, 90, 0])\n\t\t\tcylinder(r = bearing_diameter / 2, h = bearing_thickness + holder_wall * 2, center = true);\n\t\t\ttranslate([0, 0, -holder_bearing_height / 2])\n\t\t\tcube([bearing_thickness + holder_wall * 2, bearing_diameter, holder_bearing_height], center = true);\n\t\t}\n\t\ttranslate([-spool_width / 2,\n\t\t\t\tholder_base_length / 2 - bearing_diameter / 2,\n\t\t\t\tholder_bearing_height])\n\t\tunion()\n\t\t{\n\t\t\trotate([0, 90, 0])\n\t\t\tcylinder(r = bearing_diameter / 2, h = bearing_thickness + holder_wall * 2, center = true);\n\t\t\ttranslate([0, 0, -holder_bearing_height / 2])\n\t\t\tcube([bearing_thickness + holder_wall * 2, bearing_diameter, holder_bearing_height], center = true);\n\t\t}\n\t\ttranslate([spool_width / 2,\n\t\t\t\t-(holder_base_length / 2 - bearing_diameter / 2),\n\t\t\t\tholder_bearing_height])\n\t\tunion()\n\t\t{\n\t\t\trotate([0, 90, 0])\n\t\t\tcylinder(r = bearing_diameter / 2, h = bearing_thickness + holder_wall * 2, center = true);\n\t\t\ttranslate([0, 0, -holder_bearing_height / 2])\n\t\t\tcube([bearing_thickness + holder_wall * 2, bearing_diameter, holder_bearing_height], center = true);\n\t\t}\n\t\ttranslate([-spool_width / 2,\n\t\t\t\t-(holder_base_length / 2 - bearing_diameter / 2),\n\t\t\t\tholder_bearing_height])\n\t\tunion()\n\t\t{\n\t\t\trotate([0, 90, 0])\n\t\t\tcylinder(r = bearing_diameter / 2, h = bearing_thickness + holder_wall * 2, center = true);\n\t\t\ttranslate([0, 0, -holder_bearing_height / 2])\n\t\t\tcube([bearing_thickness + holder_wall * 2, bearing_diameter, holder_bearing_height], center = true);\n\t\t}\n\t}\n\tunion()\n\t{\n\t\ttranslate([0, 0, -holder_base_height / 2])\n\t\tcylinder(r = holder_base_length / 6, h = holder_base_height + 0.05, center = true);\n\t\tfor(i = [0 : 3])\n\t\t{\n\t\t\trotate([0, 0, i * 90])\n\t\t\ttranslate([holder_base_length / 2, 0, -holder_base_height / 2])\n\t\t\tcylinder(r = holder_base_length / 3.5, h = holder_base_height + 0.05, center = true);\n\t\t}\n\t\ttranslate([spool_width / 2,\n\t\t\t\tholder_base_length / 2 - bearing_diameter / 2,\n\t\t\t\tholder_bearing_height])\n\t\tunion()\n\t\t{\n\t\t\trotate([0, 90, 0])\n\t\t\tcylinder(r = bolt_diameter / 2, h = spool_wall + bearing_thickness * 2 + 0.1, center = true);\n\t\t\trotate([0, 90, 0])\n\t\t\tcylinder(r = bearing_diameter / 2 + 1, h = bearing_thickness, center = true);\n\t\t}\n\t\ttranslate([-spool_width / 2,\n\t\t\t\tholder_base_length / 2 - bearing_diameter / 2,\n\t\t\t\tholder_bearing_height])\n\t\tunion()\n\t\t{\n\t\t\trotate([0, 90, 0])\n\t\t\tcylinder(r = bolt_diameter / 2, h = spool_wall + bearing_thickness * 2 + 0.1, center = true);\n\t\t\trotate([0, 90, 0])\n\t\t\tcylinder(r = bearing_diameter / 2 + 1, h = bearing_thickness, center = true);\n\t\t}\n\t\ttranslate([spool_width / 2,\n\t\t\t\t-(holder_base_length / 2 - bearing_diameter / 2),\n\t\t\t\tholder_bearing_height])\n\t\tunion()\n\t\t{\n\t\t\trotate([0, 90, 0])\n\t\t\tcylinder(r = bolt_diameter / 2, h = spool_wall + bearing_thickness * 2 + 0.1, center = true);\n\t\t\trotate([0, 90, 0])\n\t\t\tcylinder(r = bearing_diameter / 2 + 1, h = bearing_thickness, center = true);\n\t\t}\n\t\ttranslate([-spool_width / 2,\n\t\t\t\t-(holder_base_length / 2 - bearing_diameter / 2),\n\t\t\t\tholder_bearing_height])\n\t\tunion()\n\t\t{\n\t\t\trotate([0, 90, 0])\n\t\t\tcylinder(r = bolt_diameter / 2, h = spool_wall + bearing_thickness * 2 + 0.1, center = true);\n\t\t\trotate([0, 90, 0])\n\t\t\tcylinder(r = bearing_diameter / 2 + 1, h = bearing_thickness, center = true);\n\t\t}\n\t}\n\t}\n}\nholder();",
    "description": "Okay, I'm looking to design a parametric spool holder for my 3D printer, and I've seen some designs that use bearings. I'd like to be able to customize it for different spool sizes and bearing/hardware options. I've got an existing OpenSCAD file I've been working with as a starting point, called \"PrintableSpool_Holder.scad\", but I'm struggling to make it truly parametric and robust. I'd like your help in designing a better version.\n\nHere's what I'm looking for in the design:\n\n**Core Functionality:**\n\n*   A spool holder that sits on a flat surface (like a desk or shelf).\n*   The design should use bearings on which the spool will rotate.\n*   It should be parametric, allowing me to easily adjust for different spools and hardware.\n\n**Key Parameters I want to control:**\n\n*   **Spool Dimensions:**\n    *   `spool_wall`: Thickness of the spool's side walls.\n    *   `spool_width`: Total width of the spool (outer edge to outer edge).\n    *   `spool_diameter`: Outer diameter of the spool (where the filament is wrapped).\n    *   `hole_diameter`: Diameter of the hole in the center of the spool. (Although it's currently unused in my SCAD, I would like this as an option for future use).\n*   **Hardware Dimensions:**\n    *   `bearing_diameter`: Outer diameter of the bearing.\n    *   `bearing_thickness`: Thickness of the bearing.\n    *   `bolt_diameter`: Diameter of the bolt to secure the bearing.\n*   **Holder Dimensions:**\n    *   `holder_base_length`: Length of the base of the holder. This determines stability.\n    *   `holder_base_height`: Thickness/height of the base.\n    *   `holder_wall`: Thickness of plastic around the bearing capture.\n\n**Design Considerations:**\n\n*   **Stability:** I want the base to be sufficiently wide and long to keep the spool from toppling over, even when the spool isn't perfectly balanced or it's nearly empty.\n*   **Bearing Support:** I'd like the bearing to be held securely on each side. The existing code uses a combination of cylinders and cubes to achieve this, which could be improved upon.\n*   **Bolt Holes:** The design needs clearance for the bolt securing the bearing.\n*   **Customizability:** I want to easily adjust the dimensions without breaking the design or ending up with impossible geometry.\n*   **Ease of Use:** I need a code structure that is easy to understand and modify.\n*   **Printability:** Should be easily printable with FDM 3D printing with minimal supports, if any. The holder should be printed in a way that the base is flat on the print bed.\n\n**Libraries:**\n\n* I'd like to use the `BOSL2` library to handle some of the more complex design elements, if possible.\n\nEssentially, I need a flexible OpenSCAD model where I can adjust the dimensions, and the design adapts automatically, providing good stability and proper bearing support.\n\nCan you help me build an improved parametric OpenSCAD file from my starting point, considering the above request?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Locking key for Ultimaker filament feeder (aka \"extruder\")",
    "scad": "handleWidth=20;\narmWidth=6;\narmLength=20;\narmHeight1=5.0;\narmHeight2=7.5;\nhandleDiameter= armHeight2;\ntol=0.02+0;\narmGap=16-armWidth*2;\n$fa=1;\n$fs=1;\nmodule arm()\n{\n\ttranslate([-(armWidth+armGap+armWidth)/2,0,0])\n\tdifference()\n\t{\n\t\thull()\n\t\t{\n\t\t\tcube([armWidth+armGap+armWidth,tol,armHeight1]);\n\t\t\ttranslate([0,armLength-tol,0])\n\t\t\t\tcube([armWidth+armGap+armWidth,tol,armHeight2]);\n\t\t}\n\t\ttranslate([armWidth,-tol,-tol])\n\t\t\tcube([armGap,armLength,armHeight2+0.01]);\n\t}\n\thull()\n\t{\n\t\tfor(s=[-1,+1]) scale([s,1,1])\n\t\ttranslate([-handleWidth/2, armLength, handleDiameter/2]) sphere(r=handleDiameter/2);\n\t}\n}\narm();",
    "description": "Okay, I'm having trouble with my Ultimaker's extruder feeder. It keeps popping off when I'm manually pushing filament through, and it's annoying. I found this little locking key design online, `um_extruder_lock2.scad`, that wedges in above the feeder arms and holds it in place. It works, but it's not quite perfect, and I'd like something more flexible and parametric.\n\nHere's what I'm looking for:\n\nI need a parametric OpenSCAD design for a locking key, similar to the one described above, that will fit in the space above the extruder arms of an Ultimaker.  I need to be able to adjust several dimensions so I can tweak it for different fits if I need to.\n\nSpecifically, I'd like the following parameters exposed:\n\n*   **`handleWidth`**:  The total width of the handle part that sticks out, basically how far the key extends to each side of the feeder arms.\n*   **`armWidth`**: The width of each individual arm that wedges into the space.\n*   **`armLength`**: The total length of the arms (from the handle to the tip that wedges in).\n*   **`armHeight1`**:  The height of the arm where it fits down near the frame (lower height).\n*   **`armHeight2`**:  The height of the arm near the handle (taller height).\n*   **`handleDiameter`**: The diameter of the sphere handle at the end of each arm, this should default to `armHeight2`.\n*   **`armGap`**: the distance between the arms.  This should probably be calculated as part of the design based on `armWidth` and a total distance which the user should not have to specify.\n\nThe design should feature:\n\n*   Two arms that are mirrored on either side of a central axis.\n*   Each arm should have a rectangular cross-section, with a transition in height along its length, from `armHeight1` near the frame to `armHeight2` near the handle.  This should be a smooth transition using `hull()` to create the shape.\n*   A small gap (parameter `armGap`, computed from other parameters) should exist between the arms.\n*   A half-sphere (radius `handleDiameter / 2`) should be at the end of each arm, where they meet at the handle section and should be connected to the arm smoothly using `hull()`.\n*   The design should be based off of the existing one, but I'd like the parameters listed above so it can be made a little more versatile.\n\nId prefer it if you made use of existing libraries, but I dont think anything fancy is necessary.  I guess if you wanted to be fancy, maybe use the `linear_extrude` function from [MCAD](https://github.com/openscad/MCAD) to make the change in arm height. That's just a thought though. Let me know what you think.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Washer/Spacer",
    "scad": "height = 5;\ninner_diameter = 5;\nouter_diameter = 10;\nchamfer_inner = 0.4;\nchamfer_outer = 0.4;\ninner_radius = inner_diameter/2;\nouter_radius = outer_diameter/2;\neps = 0.001;\n$fn = 50;\ndifference()\n{\n\tcylinder(h=height, r=outer_radius);\n\ttranslate([0,0,-eps]) cylinder(h=height+1, r=inner_radius);\n\ttranslate([0,0,-eps]) cylinder(h=chamfer_inner, r1=inner_radius+chamfer_inner, r2=inner_radius);\n    translate([0,0,-eps]) difference()\n    {\n        cylinder(h=chamfer_outer, r=outer_radius);\n        translate([0,0,-eps]) cylinder(h=chamfer_outer, r1=outer_radius-chamfer_outer, r2=outer_radius+eps);\n    }\n}",
    "description": "Okay, I need a simple, but flexible OpenSCAD design for a washer or spacer. I need to be able to control the height, the inner diameter, and the outer diameter of the washer. I'd also like to include a small chamfer on the bottom edges of the washer  both inner and outer - to help with 3D printing and reduce the \"elephant foot\" effect. I'd like to be able to specify the size of those chamfers, too. It's important that the chamfer is on the bottom of the washer only.\n\nCould you generate an OpenSCAD file that does this?\n\nI want these parameters to be easily adjustable:\n\n*   `height`: The overall height/thickness of the washer in millimeters.\n*   `inner_diameter`: The diameter of the hole in the center of the washer, in millimeters.\n*   `outer_diameter`: The outer diameter of the washer, in millimeters.\n*   `chamfer_inner`: The size of the inner chamfer at the bottom, in millimeters.\n*   `chamfer_outer`: The size of the outer chamfer at the bottom, in millimeters.\n\nMake sure the chamfer is applied to the bottom edge and that it's a proper chamfer, not just a flat cut.\nI'm also hoping to keep the code relatively clean and easy to read.\nI don't need any external libraries or complex features, just basic cylinders and `difference()` operations. Thank you!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Cake Guide",
    "scad": "radius = 50;\nwall_t = 2;\nwall_h = 10;\nslices = 10;\nslice_angle = 360 / slices;\nfor (slice = [1 : slices]) {\n  rotate([0, 0, slice_angle * (slice - 1)])\n    translate([-wall_t / 2, 0, 0])\n    cube(size = [wall_t, radius, wall_h], center=false);\n}",
    "description": "Okay, I need a design for a cake cutting guide. We had a major argument over slice sizes the other day, so we need something objective.\n\nI want to be able to make a guide for a circular cake. The guide should have vertical \"walls\" that go from the center of the cake to the outer edge, marking where to cut. I'd like to be able to adjust the following:\n\n*   **The radius of the cake:** I'd like to be able to specify how big the circle is that will be the diameter of the cake, probably using radius.\n*   **The thickness of the cutting walls:** I need to adjust how wide the vertical walls are so the cuts can be done, they can't be too thin to be practical.\n*   **The height of the walls:** These should be able to extend above the cake to be useful, so we need a height parameter.\n*   **The number of slices:** I need to be able to specify the number of slices I want for the cake.\n\nSo, basically, the code should generate a circular cake cutting guide with vertical walls, where I can specify the radius of the cake, the wall thickness, the wall height, and the number of slices. Please ensure the walls are positioned correctly so they radiate out from the center of the cake.\n\nI'm looking for a parametric OpenSCAD file, so that I can adjust all the options above. I would prefer that this design be done in base OpenSCAD primitives only (no libraries). The code I provided is a partially implemented example of what I'm looking for.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable: ultimaker foot (hence, feet also)",
    "scad": "bottomHeight=14;\ninternalHeight=12;\nroundness=1;\ncubeSide= 25;\noutSide= 4;\nplyWidth= 6;\nscrewDiameter=2.9+0;\nscrewDistToWalls=0.8+0;\nscrewHeadDiameter=6+0;\nscrewHeadDepth=2.2+0;\ntol=0.01+0;\ntranslate([-plyWidth-outSide,-plyWidth-outSide,0])\n{\n\tdifference()\n\t{\n\t\tminkowski()\n\t\t{\n\t\t\tsphere(r=1);\n\t\t\tdifference()\n\t\t\t{\n\t\t\t\ttranslate([roundness,roundness,-bottomHeight+roundness])\n\t\t\t\t\tcube([cubeSide + plyWidth + outSide -roundness*2, cubeSide + plyWidth + outSide -roundness*2, internalHeight+bottomHeight -roundness*2]);\n\t\t\t\ttranslate([cubeSide + plyWidth + outSide, cubeSide + plyWidth + outSide,-bottomHeight+roundness-tol])\n\t\t\t\t\tcylinder(r=cubeSide-outSide, h=internalHeight+bottomHeight-roundness*2+tol*2);\n\t\t\t}\n\t\t}\n\t\ttranslate([outSide,-tol,0]) cube([plyWidth, cubeSide+plyWidth+outSide+tol*2, internalHeight+tol]);\n\t\ttranslate([-tol+outSide,outSide,0]) cube([cubeSide+plyWidth+tol*2, plyWidth, internalHeight+tol]);\n\t\ttranslate([cubeSide/2+screwDistToWalls, cubeSide/2+screwDistToWalls,-bottomHeight-tol])\n\t\t{\n\t\t\tcylinder(r=screwDiameter/2, h=internalHeight+bottomHeight+tol*2, $fn=6);\n\t\t\tcylinder(r=screwDiameter/2, h=screwHeadDepth+2, $fn=20);\n\t\t\tcylinder(r=screwHeadDiameter/2, h=screwHeadDepth, $fn=20);\n\t\t}\n\t}\n}",
    "description": "Okay, I need to design a set of feet for my Ultimaker 3D printer, similar to the ones I found on Thingiverse, but I want more control over the parameters. Ive seen a few designs, and one I like the idea behind is the file \"um_feet.scad,\" but I want to adapt it and perhaps make it a little cleaner and more robust.\n\nHere's what I'm looking for:\n\n**Core Functionality:**\n\n*   **Feet for Ultimaker:** The primary purpose is to provide stable feet to lift the Ultimaker printer, specifically accommodating a larger power supply.\n*   **Parametric Design:** Everything needs to be adjustable through parameters. I want to be able to change the height, dimensions, screw hole size, and so on.\n*   **Snug Fit:**  The design should include an internal cavity that fits snugly around the Ultimaker's base.\n*   **Screw Hole:** There should be a countersunk screw hole designed for the standard Ultimaker screws, allowing for a pad to be attached or just to tighten it against the UM chassis.\n\n**Specific Parameters I Need Control Over:**\n\n*   **`bottomHeight`:** The height added by the foot to the bottom of the printer.\n*   **`internalHeight`:** The internal height of the cavity that fits around the printer's frame, making it a snug fit.\n*  **`roundness`**: A radius for rounding corners, for a nicer look.\n*   **`cubeSide`:** The main size of the horizontal plane of the foot.\n*   **`outSide`:** The wall thickness around the outer edge of the foot\n*   **`plyWidth`:** The thickness of the internal \"ply\" that sits against the Ultimaker chassis.\n*   **`screwDiameter`:** The diameter of the screw hole (not the countersink).\n*   **`screwDistToWalls`:**  The distance from the screw hole to the walls of the foot.\n*   **`screwHeadDiameter`:** The diameter of the countersink portion of the screw hole.\n*   **`screwHeadDepth`:** The depth of the countersink portion of the screw hole.\n*   **`tol`**: A tolerance value to prevent Z-fighting between faces, I guess.\n\n**Design Considerations (Based on the `um_feet.scad` file, but with a few requests):**\n\n*   **Main Shape:**  The core structure should be generated by subtracting a cylinder from a rounded cube.\n*   **Grooves:** Two grooves need to be cut out of the base to allow the foot to snugly fit around the edge of the Ultimaker.\n*  **Rounding**: The rounding is done using Minkowski sum, which is fine but I'd like to see if there might be a simpler way, perhaps using `hull()`, since the rounded corners will always be the same.\n*   **Screw Hole:** The screw hole must have a clear countersink. I'd prefer to see this built using the `polygon` library, so that the countersink can be properly controlled.\n* **Parametric Counterbore:** The screw head needs to be counterbored and also a small relief to facilitate the screwing.\n\n**Library Requirements:**\n\nI don't think any special libraries are needed for this design. I want this built from basic OpenSCAD primitives and the `polygon` library.\n\n**Additional Requests:**\n\n*   I'd like the code to be well-commented, making it easy to understand and modify.\n*   Please make sure the code is clear, readable, and easy to adjust.\n\nCould you help me design this parametric OpenSCAD file?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric motor case maker",
    "scad": "dm = 24.5;\nth = 2;\nhc = 13;\nhe =  dm/2;\nde = 2;\ndbe = 15.75;\nle = 2.5;\ndte = le/2;\nif (le-dte >0)\n{\ndifference() {\ncylinder(r = (dm/2+th), h = (hc+th));\ncylinder(r = (dm/2), h = hc);\ntranslate([dm/2-he,dbe/2,hc-dte/2])\ncylinder(r = (de/2)+th, h = le+2 * th, center = true);\ntranslate([dm/2-he,-dbe/2,hc-dte/2])\ncylinder(r = (de/2)+th, h = le+2 * th, center = true);\n}\n}\nelse\n{\ndifference() {\ncylinder(r = (dm/2+th), h = (hc+th));\ncylinder(r = (dm/2), h = hc);\ntranslate([dm/2-he,dbe/2,hc-dte/2])\ncylinder(r = (de/2)+th, h = le, center = true);\ntranslate([dm/2-he,-dbe/2,hc-dte/2])\ncylinder(r = (de/2)+th, h = le, center = true);\n}\n}",
    "description": "Okay, I need help creating a more robust and flexible parametric motor case generator in OpenSCAD. I've already got a basic version working, but it has a few limitations, and I think it could benefit from being more comprehensive and user-friendly.\n\nHere's what my current script does:\n\n*   It takes parameters for the motor diameter (`dm`), case thickness (`th`), motor height (`hc`), height to the ends of the motor (`he`), diameter of those ends (`de`), the distance between those ends (`dbe`), the length of those ends (`le`), and the distance to the ends (`dte`).\n*   It generates a basic cylindrical case with an internal void for the motor, and two cylindrical protrusions for the motor's end features.\n*   It uses a simple conditional to determine if the end cylinders should be cut shorter if they would protrude into the case.\n*   It is based on difference between cylinders.\n\nHere's what I'd like this new script to do:\n\n1.  **More Flexible End Features:** My current design only handles cylindrical end features on the motor. I need to be able to handle different shapes such as rectangular prongs or even mounting tabs on the sides. Ideally, the user should be able to define the shape (cube, cylinder), size, and position of these features through parameters. Perhaps using `linear_extrude` on a user specified polygon or circle, and translation parameters? I should be able to define multiple end features on a motor.\n\n2.  **Hole & Screw Placement:** The most important addition I need is the ability to add mounting screw holes at specified locations on the case. These should also be parametric, allowing the user to specify the number of holes, their diameter, and their position (perhaps using polar coordinates or relative positioning from a specified origin). I'd like to be able to specify the screw head clearance too. I think being able to define them as a vector of tuples (or whatever) might be best.\n\n3.  **Alignment Features:** It would be good to be able to add alignment features, like small pegs or notches on the case so that it could be attached to something precisely. These would also need to be configurable with parameters. The user should be able to choose the shape, size, and position of any number of these alignment features.\n\n4.  **Optional Internal Supports:** For very long or narrow motor cases, internal support structures might be needed to increase rigidity. Being able to add internal ribs or other supporting structures that are parametric and automatically generated would be fantastic. A simple radial structure would probably suffice.\n\n5.  **Clearance and Tolerances:** I need a way to specify some general clearance parameters so that the parts fit nicely without being too tight or too loose. Also, the screw hole should have a clearance as well.\n\n6.  **User-Friendly Parameter Input:** Perhaps a way to use comments to create more self-explanatory parameter inputs?\n\n7.  **Library Use:** I'd also like the code to be well-organized. It might be beneficial to use a library for some of these tasks, such as the `BOSL2` library, if there are helper functions that can streamline the process.\n\nEssentially, I want a robust motor case generator that can handle a wide variety of motors and mounting scenarios. I'd love it if the new code is well-commented and easy to understand for future modifications. Could you generate the OpenSCAD code for this?\n\nI'm not too familiar with all of the functions in BOSL2, so be sure to explain the usage of any included functions.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Clamp Mount for NEMA 17 Stepper",
    "scad": "type = \"90 degree\";\nthick = 1.6;\nshaft_height = 21;\nwidth=42;\nmount_flush=\"yes\";\nbase_1 = 50;\nbase_2 = 30;\nbase_3 = 30;\n$fa=1;\n$fs=0.5;\nNema_square = 42;\nNema_hole_offset = 31;\nNema_mount_hole_diameter = 3.6;\nNema_center_hole_diameter = 23;\nNema_mount_hole_radius = Nema_mount_hole_diameter/2;\nNema_center_hole_radius = Nema_center_hole_diameter/2;\nmodule NEMA17_plate() {\n\tdifference() {\n\t\tcube(size=[Nema_square, Nema_square, thick], center=true);\n\t\tcylinder(r=Nema_center_hole_radius, h=thick+2, center=true);\n\t\ttranslate([Nema_hole_offset/2, Nema_hole_offset/2, 0]) {\n\t\t\tcylinder(r=Nema_mount_hole_radius, h=thick+1, center=true);\n\t\t}\n\t\ttranslate([-Nema_hole_offset/2, Nema_hole_offset/2, 0]) {\n\t\t\tcylinder(r=Nema_mount_hole_radius, h=thick+1, center=true);\n\t\t}\n\t\ttranslate([-Nema_hole_offset/2, -Nema_hole_offset/2, 0]) {\n\t\t\tcylinder(r=Nema_mount_hole_radius, h=thick+1, center=true);\n\t\t}\n\t\ttranslate([Nema_hole_offset/2, -Nema_hole_offset/2, 0]) {\n\t\t\tcylinder(r=Nema_mount_hole_radius, h=thick+1, center=true);\n\t\t}\n\t}\n}\nmodule 90deg_clamp() {\n\tdelta = (shaft_height >= 21 ? abs(shaft_height-Nema_square/2) : 0);\n\tbase_width = (width - Nema_square > 0 ? width : Nema_square);\n\ttest_width = (mount_flush == \"yes\" ? (abs(width-Nema_square)/2) : 0);\n\tex_width = (width-Nema_square > 0 ? test_width : 0);\n\tunion() {\n\t\ttranslate([-21-delta, 0, thick/2]) {\n\t\t\tNEMA17_plate();\n\t\t}\n\t\ttranslate([-delta/2, 0, thick/2]) {\n\t\t\tcube(size=[delta, 42, thick], center=true);\n\t\t}\n\t\ttranslate([-(42+delta)/2, 21+ex_width/2, thick/2]) {\n\t\t\tcube(size=[42+delta, ex_width, thick], center=true);\n\t\t}\n\t\ttranslate([-(42+delta)/2, -21-ex_width/2, thick/2]) {\n\t\t\tcube(size=[42+delta, ex_width, thick], center=true);\n\t\t}\n\t\ttranslate([0, 0, base_1/2]) {\n\t\t\tcube(size=[thick, base_width, base_1], center=true);\n\t\t}\n\t}\n}\nmodule 180deg_clamp() {\n\tunion() {\n\t\ttranslate([-base_1-thick/2, 0, thick/2]) {\n\t\t\trotate([0, 90, 0]) {\n\t\t\t\t90deg_clamp();\n\t\t\t}\n\t\t}\n\t\ttranslate([0, 0, base_2/2]) {\n\t\t\tcube(size=[thick, width, base_2], center=true);\n\t\t}\n\t}\n}\nmodule 45deg_clamp() {\n\ttranslate([0, 0, width/2]) rotate([-90, 0, 0]) {\n\t\tunion() {\n\t\t\ttranslate([-base_1, 0, thick/2]) {\n\t\t\t\trotate([0, 90, 0]) {\n\t\t\t\t\t90deg_clamp();\n\t\t\t\t}\n\t\t\t}\n\t\t\trotate([0, -45, 0]) {\n\t\t\t\ttranslate([base_2/2, 0, thick/2]) {\n\t\t\t\t\tcube(size=[base_2, width, thick], center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule Multi_clamp() {\n\tbeta = base_2*sin(45);\n\tunion() {\n\t\t45deg_clamp();\n\t\ttranslate([beta-thick, beta, 0]) {\n\t\t\tcube(size=[thick, base_3, width], center=false);\n\t\t}\n\t}\n}\nif (type == \"90 degree\") {\n\t90deg_clamp();\n}\nif (type == \"45 degree\") {\n\t45deg_clamp();\n}\nif (type == \"180 degree\") {\n\t180deg_clamp();\n}\nif (type == \"Multi\") {\n\tMulti_clamp();\n}",
    "description": "Okay, I'm looking to create a mount for a NEMA 17 stepper motor that can be clamped onto a flat surface, like an optical breadboard. The idea is that the motor will be connected to something via a flexible drive shaft, so its exact placement isn't super critical. I want the design to be flexible enough that I can orient the motor at different angles relative to the surface it's clamped to: either 0, 45, or 90 degrees.\n\nI've got a basic version in mind, but I want to make it parametric so I can easily adjust it for different scenarios. Heres what Im thinking:\n\n**Core Features:**\n\n*   **NEMA 17 Mount:** The mount needs to accommodate a standard NEMA 17 stepper motor. This includes the square mounting face, the central hole, and the four mounting screw holes. The screw holes should be clearance for M3 screws.\n*   **Clamping Surfaces:** I want to have three distinct clamping surfaces that allow the motor to be oriented at 0, 45, and 90 degrees relative to the breadboard (or other mounting surface).\n*   **Parametric Design:** The design needs to be easily configurable through parameters.\n\n**Specific Parameters I'd like to control:**\n\n*   `clamp_thickness`: The thickness of the clamp material (e.g., 1.6mm).\n*   `shaft_height`: The height of the motor shaft above the base of the clamp. This will need to be a minimum value, which I believe should be half the width of the NEMA17 square, for stability, but I'd like it to be adjustable.\n*   `clamp_width`: The total width of the clamp, I want to control how far the clamp extends to the sides, specifically for the 90 degree surface.\n*   `mount_flush`: A boolean or string option to specify whether the motor mounting plate should be flush with the sides of the clamp.\n*   `base_length_90`: The length of the 90-degree base of the clamp.\n*   `base_length_180/45`: The length of the base portion for the 180 or 45 degree bases of the clamp\n*   `base_length_180_multi`: The length of the 180-degree base on the multi-clamp configuration.\n\n**Desired output:**\n\n* A single OpenSCAD file that will generate this configurable clamp mount.\n\n**Notes:**\n\n*   I do not need specific code to import libraries. The code should be easily copied/pasted to openscad.\n\nCan you generate an OpenSCAD file that will let me do all this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Cuvette/Vial Rack",
    "scad": "hole_shape=1;\nhole_size=10;\nhole_depth=12;\nrows=4;\ncolumns=3;\nspacing=1.6;\nbottom_thick=1.75;\n$fa=1;\n$fs=1;\ndifference() {\n\tcube(size=[rows*(hole_size+spacing)+spacing, columns*(hole_size+spacing)+spacing, bottom_thick+hole_depth], center=false);\n\tholes(hole_shape,hole_size,hole_depth,rows,columns,spacing,bottom_thick);\n}\nmodule holes(hole_shape,hole_size,hole_depth,rows,columns,spacing,bottom_thick) {\n\ttranslate([hole_size/2+spacing, hole_size/2+spacing, hole_depth/2+bottom_thick+0.5]) {\n\t\tfor (b=[0:columns-1]) {\n\t\t\tfor (i=[0:rows-1]) {\n\t\t\t\ttranslate([i*(hole_size+spacing), b*(hole_size+spacing), 0]) {\n\t\t\t\t\tif (hole_shape==1) {\n\t\t\t\t\t\tcylinder(r=hole_size/2, h=hole_depth+1, center=true);\n\t\t\t\t\t}\n\t\t\t\t\telse {cube(size=[hole_size, hole_size, hole_depth+1], center=true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "description": "Okay, I need help designing a customizable rack for cuvettes and vials, or really anything that needs to stand upright. I've found a pretty good starting point with this .scad file but it has a few limitations and I'd like to improve upon it.\n\nThe existing file, `custom_cuvette_vial_v2.scad`, is great because it lets me specify the hole shape (round or square), hole size, hole depth, number of rows and columns, spacing between holes, and thickness of the bottom layer. It uses a basic difference operation with a main cube and then removes an array of holes defined in a separate module. The `holes` module handles the placement and shape generation (circles or squares) for the individual cutouts. It uses standard OpenSCAD primitives like `cube`, `cylinder`, `translate`, and `for` loops to achieve this. \n\nHere's what I'd like to improve and incorporate into a new design:\n\n1.  **Rounded Edges:** I'd like to add the option for rounded edges along the perimeter of the main block, not just sharp corners. I think this would look cleaner and possibly make it more durable. The rounding should be a customizable parameter, specified with a radius.\n\n2.  **Customizable Side Wall Height:** Currently, the rack only has a base with the holes going straight through it. I want the option to add side walls, essentially like a tray, with a customizable wall height. Id like to be able to specify the side wall thickness as well.\n\n3.  **Support Structures:** For larger racks with deep holes, I'd like to add internal support structures between the base and the top of the holes. These supports would help reinforce the structure and prevent flexing or breakage. It would be great if I could control whether or not to generate these, and set their width. A simple grid pattern would be ideal to start, but if it's not too complicated, diagonal supports would also be a great option.\n\n4.  **Customizable Top Lip:** I'd like the option to add a slight top lip along the perimeter of the tray. This lip should have an adjustable thickness and height above the side walls.\n\n5. **Staggered Holes:** I'd like an option to stagger the holes in a grid, such that they are slightly offset in alternating rows and columns. I think it might help with better spacing for some items.\n\nSo, I'm looking for a new parametric OpenSCAD file that incorporates all of these new features and the original functionality of the `custom_cuvette_vial_v2.scad` file. The code should remain clean and well commented and make good use of modules to ensure modularity. I'm not using any special libraries for this, so I don't need to include any external library files.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Round cocktail stick",
    "scad": "total_length = 100;\ncone_length = 5;\nstick_diameter = 3.2;\nornament_size = 20;\nornament_thickness = 2;\nstick_fs = 1*0.1;\nornament_fs = 1*0.5;\nstick_radius = stick_diameter / 2;\nstick_length = total_length - cone_length;\nview();\nmodule cone()\n{\n    rotate([0, 90, 0]) cylinder(r1 = 0, r2 = stick_radius, h = cone_length, $fs = stick_fs);\n}\nmodule stick()\n{\n    translate([cone_length, 0, 0]) rotate([0, 90, 0]) cylinder(r = stick_radius, h = stick_length, $fs =stick_fs);\n}\nmodule ornament()\n{\n    difference() {\n        cylinder(r = ornament_size/2, h = stick_diameter);\n        translate([0, 0, -stick_diameter/2]) cylinder(r = ornament_size/2 - ornament_thickness, h = stick_diameter*2);\n    }\n}\nmodule view()\n{\n     translate([-total_length/2, 0, stick_radius]) {\n         cone();\n         stick();\n    }\n    translate([total_length/2 + ornament_size/2 - 0.2, 0, 0]) {\n        ornament();\n    }\n}",
    "description": "Okay, I need a parametric OpenSCAD design for a cocktail stick, but I want it to be a bit more sophisticated than the simple one I have.  My current design is okay, but it's not very customizable and the ornament is really just a simple ring.\n\nHere's what I'm looking for:\n\n**General Structure:**\n*   The basic stick should be a round cylinder with a pointed end (a cone).\n*   I need to be able to control the overall length of the stick, the length of the cone section, and the diameter of the cylindrical part.\n*   The ornament needs to be more interesting than just a ring. I'd like it to be a separate, customizable element at the end of the stick.\n\n**Specific Features:**\n1.  **Parametric Cone:**\n    *   I need parameters for the *length* of the cone.\n    *   The cone base should match the diameter of the cylindrical section.\n    *  The cone should terminate at a point.\n2.  **Parametric Cylinder:**\n    *   Parameter for the diameter.\n    *   The length should be automatically calculated based on total stick length and the cone length.\n3.  **Enhanced Ornament:**\n    *   Instead of a simple ring, I'd like the ornament to be a sphere, a torus, or a more complex shape like a star, heart, or a simple stylized animal shape.\n    *   I need parameters for the *size* (e.g., radius or overall bounding box size) and *thickness* of the ornament, as well as a *selection* for ornament type from a small set of options (sphere, torus, star, heart).\n    *   The ornament should be attached to the end of the stick.\n4. **Fine Control Over Facet Settings:**\n  *   I need to be able to separately control the `$fs` value for the stick and the ornament so that I can have high quality ornaments without generating an excessive amount of facets for the long cylindrical part.\n5. **Library Use:**\n    *   I think the BOSL2 library could be helpful here, particularly for creating the more complex ornament shapes, if it makes sense.  If a more appropriate library exists for complex shapes, please use that instead.\n\n**Parameters Needed:**\n\n*   `total_length`: Total length of the cocktail stick.\n*   `cone_length`: Length of the cone section at the pointy end.\n*   `stick_diameter`: Diameter of the cylindrical part of the stick.\n*   `ornament_type`: Selection between \"sphere\", \"torus\", \"star\", \"heart\".\n*   `ornament_size`: Overall size of the ornament.\n*   `ornament_thickness`: Thickness of the ornament.\n*   `stick_fs`:  $fs for the stick.\n*   `ornament_fs`: $fs for the ornament.\n\n**Output:**\nI'd like a single `.scad` file with all the code included.  It should be well commented and easy to understand. The design should be centered at the origin, so I don't have to worry about relative positioning.  \n\nPlease let me know if you have any questions, or if this isn't clear enough.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Boltless Hook for keyhole shelving units",
    "scad": "key_big = 11;\nkey_small = 6;\nkey_spacing = 39;\nkey_thickness = 1.25;\npoke = 30;\nhook = 20;\nsupport_thickness = 4;\nhookStart = support_thickness*2+key_thickness;\nangle = atan ( hook / poke);\nhype = poke + hook;\nKBR = key_big/2;\nKSR = key_small/2;\nmodule wedge()  {\n\ttranslate([0,-key_small,0]) difference() {\n\t\tcube([poke,key_small,hook]);\n\t\trotate(a=[0,-angle,0])translate([0,-1,0])cube([hype,key_small+2,hook]);\n\t}\t}\nmodule betterjoints() {\n\tintersection(){\n\t\ttranslate([0,-KSR,0])cube([key_spacing,key_small,support_thickness*2+key_thickness]);\n\t\tcylinder(h= support_thickness*2+key_thickness ,r1 = KBR , r2 = KBR,$fn=36);\n\t}\n}\ntranslate([-KBR- key_spacing/2,-KBR,0]) {\ntranslate([KBR,KBR - KSR,hookStart]) {\n\tcube([hook/2,key_small,poke]);\n\trotate(a=[0,270,180]) wedge();\n\ttranslate([poke,0,0])rotate(a=[0,0,180]) wedge();\n\ttranslate([0,0,-support_thickness]) cube([key_spacing,key_small,support_thickness]);\n\t}\ntranslate([KBR,KBR,0]) {\n\tcylinder(h= hookStart + poke, r1 = KSR ,r2 = KSR,$fn=36);\n\tcylinder(h= support_thickness ,r1 = KBR , r2 = KBR,$fn=36);\n\tbetterjoints();\n\ttranslate([key_spacing,0,0]){\n\t\tcylinder(h= hookStart, r1 = KSR ,r2 = KSR,$fn=36);\n\t\tcylinder(h= support_thickness ,r1 = KBR , r2 = KBR,$fn=36);\n\t\tbetterjoints();\n\t\t}\n\t}\n}",
    "description": "Okay, I've got this idea for a 3D printable hook that uses the keyholes in my boltless shelving units. I'd like to create a parametric OpenSCAD model so I can adjust it to fit different shelves.\n\nBasically, the design needs to have two posts that slot into the keyholes, and these posts need to be connected by a support bar. Then, extending from the support bar, I need a hook shape, a wedge-like design that extends out a bit and curves upwards to form a hook. I'd like to hang things like scissors, headphones, and maybe even small pots from these.\n\nHere are the important parameters I think we need to control:\n\n*   **`key_big`**:  The diameter of the larger round part of the keyhole. I'd need to make this a bit smaller than the actual measurement for clearance.\n*   **`key_small`**: The diameter of the smaller, offshoot part of the keyhole.  Also needs to be slightly smaller than the actual.\n*   **`key_spacing`**: The distance between the centers of the two keyholes. Make this slightly bigger than the actual for clearances.\n*   **`key_thickness`**: The thickness of the shelf material where the keyholes are cut out. This also should be a bit bigger than reality for the model.\n*   **`poke`**:  The distance the hook extends out from the support bar - a minimum distance.\n*   **`hook`**:  The total height of the hook's tip and is twice the width of the hook. The hook itself will be smaller than `poke`.\n*   **`support_thickness`**: The thickness of the support bar connecting the two posts and the lugs that go into the keyholes.\n\nI'd like the posts that fit in the keyholes to be cylindrical. The support bar connecting the two posts should also be rectangular with rounded edges for a good fit, and the connection between the support bar and the posts should be robust. I have a good start on the project and have included the initial code as a reference. It includes a `wedge()` module for the hook and a `betterjoints()` module.  It appears the module `betterjoints()` needs a little more consideration.\n\nI'd like to see some improvement on the structure around the keyhole connection as the model could break at those points, maybe some more overlap with the cylindrical post.\n\nIt would be really helpful if the model could be centered on the build platform, I have included a starting point for centering in the current code, but would like to see it improved. \n\nI'm hoping this can be a fully parametric design that I can customize for any boltless shelving.\n\nIs it possible for you to help me generate a parametric OpenSCAD file based on this? I don't need specific libraries mentioned.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Catch for Cabinet Latch",
    "scad": "length = 40;\nwidth = 11;\nheight = 11;\nbase_thick = 2;\ntop_width = 2;\ncurve_length = 19;\nsag = 1.5;\nhole_spacing = 32;\nhole_length = 9;\nhole_width = 3.75;\nwiggle = 0.1;\n$fn=10;\ncurve_height = height - base_thick;\ncurve_width = width - top_width;\ncurve_chord_length = sqrt(pow(curve_height,2) + pow(curve_width,2));\nR = (pow(curve_chord_length/2,2)+pow(sag,2))/(2*sag);\nratio = curve_height/curve_width;\nA = 1 + pow(ratio,2);\nB = curve_height;\nC = pow(curve_width,2)*A/4-pow(R,2)/A;\ny = (-B + sqrt(pow(B,2) - 4*C))/2;\nx = curve_width*(pow(ratio,2) - 1)/2 + ratio*y;\necho (str(\"R = \",R));\necho (str(\"x = \",x));\necho (str(\"y = \",y));\necho (str(\"ratio = \",ratio));\necho (str(\"discriminant = \",pow(B,2) - 4*A*C));\nunion(){\n\tdifference(){\n\t\tcube([length,width,base_thick]);\n\t\tfor (i=[-1,1]){\n\t\t\ttranslate([length/2 + i*hole_spacing/2,(width - hole_length + hole_width)/2,-wiggle]) #screwhole();\n\t\t}\n\t}\n\tdifference(){\n\t\ttranslate([(length-curve_length)/2,0,base_thick]) cube([curve_length,width,curve_height]);\n\t\t#translate([(length-curve_length)/2-wiggle,width + x,height + y]) rotate([0,90,0]) cylinder(h=curve_length+2*wiggle,r=R,center=false,$fn=50);\n\t}\n}\nmodule screwhole()\n{\n\thull(){\n\t\tcylinder(h=base_thick+2*wiggle,r=hole_width/2,center=false);\n\t\ttranslate([0,5.25,0]) cylinder(h=base_thick+2*wiggle,r=hole_width/2,center=false);\n\t}\n}",
    "description": "Okay, I'm looking to design a replacement part for a magnetic child safety cabinet latch. I broke a few of the plastic catches and want to print my own. I need a parametric OpenSCAD file so I can easily adjust the dimensions if needed.\n\nHere's a breakdown of the design I need:\n\n**General Shape:**\n\n*   The catch has a base that mounts to the cabinet frame and a curved protrusion that the latch mechanism engages with.\n*   The base is essentially a rectangular prism.\n*   The curved protrusion is formed by extruding a curved shape upwards from a portion of the base. The curve has a flat top.\n\n**Specific Dimensions and Features (and these need to be parameters):**\n\n*   **`length`:** The overall length of the base.\n*   **`width`:** The overall width of the base.\n*   **`height`:** The overall maximum height of the catch, including the base.\n*   **`base_thick`:** The thickness of the base itself.\n*   **`top_width`:** The width of the flat portion at the top of the curved protrusion.\n*   **`curve_length`:** The length of the curved portion of the catch (along the long axis of the base).\n*   **`sag`:** The maximum deviation of the curve from a straight line (imagine a straight edge against the curve; this is the gap).\n*   **`hole_spacing`:** The center-to-center distance between the mounting holes. There should be two holes.\n*   **`hole_length`:** The length of the mounting holes (along the long axis of the base). These holes are actually an elongated hole rather than a circle.\n*   **`hole_width`:** The width of the mounting holes.\n*    **`wiggle`**: A small positive value used as a fudge factor to ensure overlaps.\n\n**Design Details/Requirements:**\n\n*   The curved protrusion starts at the base and rises to the specified height. It needs to be a smooth, curve (not a series of lines or facets). I think the code I sent uses the arc of a circle.\n*   The mounting holes are elongated and need to be on the base, and should be centered along the width. \n*   The mounting holes should be evenly spaced from the center of the catch base, with one on either side.\n*   I've tried my best to define these well, but the parameters interact in a slightly complicated way in order to create the desired curve. If there's any questions I'll try my best to clarify.\n\n**OpenSCAD Specifics:**\n\n*   The design should be fully parametric so I can easily change the dimensions.\n*   I'd prefer a clean and well-commented code.\n\nI'm not sure if I have included enough detail to get a working solution. I did, however, use descriptive parameter names, hopefully this makes it easy to understand.\n"
  },
  {
    "object": "Hey cadmonkey, make me a OpenBeam Optical Rail Simple Rod Holder",
    "scad": "w=15;\nd=9;\nx =6.5;\ng =2;\nz =4;\ni=2;\na=20;\nmodule base(){\n\t\t\t\tdifference(){\n\t\t\tdifference(){\n\t\tdifference (){\n\t\tcylinder(a, w/2,w/2);\n\t\tcylinder(a-g*2,d/2,d/2);\n\t\t\t\t}\n\t\t\tcylinder(a,z/2,z/2);\n\t\t\t\t\t}\n\t\t\t\ttranslate ([0,0,a-g-2])\n\t\t\t\tcylinder(g,x/2,x/2);\n\t\t\t\t\t\t}\n\t\t}\nbase();",
    "description": "Okay, I'm working on a project to build a low-cost optical rail system using OpenBeam, and I need a part that will hold a smooth 13mm rod onto the OpenBeam. I'm calling this part the \"base_rod.\"\n\nI have a basic SCAD file that creates a cylindrical chuck with holes for the 13mm rod and a countersunk screw, but I need help making it more flexible and usable. Here's the breakdown of what I need:\n\n**Functionality:**\n\n*   **Rod Holding:** The primary function is to securely hold a smooth rod, specifically a 13mm diameter rod, for optical components.\n*   **OpenBeam Attachment:** It needs to attach to the standard OpenBeam profile (which is 15mm wide). I'm currently assuming the attachment will be a screw through the face of the base_rod and into the Openbeam, but I'm open to suggestions here.\n*   **Parametric Design:** I need the design to be parametric, so I can easily adjust parameters like the rod diameter, OpenBeam width, screw size, and overall height and width of the base.\n*   **Countersunk Screw:**  The current design uses a countersunk screw, which is good, but the parameters need to be configurable, like the screw head diameter, head height, and thread diameter.\n\n**Specific Needs and Questions:**\n\n1.  **Parametric Variables:**  I'd like the following to be parameters:\n    *   `rod_diameter`: Diameter of the smooth rod (currently 13mm).\n    *   `openbeam_width`: Width of the OpenBeam (currently 15mm).\n    *   `base_height`: Overall height of the base.\n    *   `screw_head_diameter`: Diameter of the screw head.\n    *   `screw_head_height`: Height of the screw head.\n    *   `screw_thread_diameter`: Diameter of the screw threads.\n    *   `screw_depth`: How deep the screw sits into the base_rod.\n\t * `screw_clearance`: The amout of extra space around the screw thread.\n    *  `base_width`: The width of the rod base.\n\t * `rod_clearance`: The ammount of clearance around the rod.\n2.  **Screw Position:** The current design has the screw hole in the center of the flat face of the base_rod. I am happy with this for now.\n\n3.  **Libraries:** I'm not using any libraries right now, but if you think some would be helpful, let me know and specify why you suggest them.\n4.  **Improved design** I am open to any design changes that may improve the function of this part.\n\nCan you help me create a fully parametric OpenSCAD file for this \"base\\_rod\" part? I'm happy to provide more details as needed. My current basic SCAD file is included as reference, though you don't need to use it specifically.\n\n```\n// The base for  the open optics rail made from Open Beam\n// holds a 13mm smooth rod\n\n\n//Variables\nw=15; //Width of Open Beam\nd=9; // rod diameter\nx =6.5; //width of screw head\ng =2; //heigth of screw head with some margin\nz =4; //width of screw thread with margin\ni=2; //screw heigth\na=20; //total heigth\n\nmodule base(){\n\t\t\t\tdifference(){\n\t\t\tdifference(){\n\t\tdifference (){\n\t\tcylinder(a, w/2,w/2);//whole chuck\n\t\tcylinder(a-g*2,d/2,d/2); //magnet hole\n\t\t\t\t}\n\t\t\tcylinder(a,z/2,z/2); //screw hole\t\n\t\t\t\t\t}\n\t\t\t\ttranslate ([0,0,a-g-2])\n\t\t\t\tcylinder(g,x/2,x/2); //head of screw hole\n\t\t\t\t\t\t}\n\t\t}\n\nbase();\n```\n"
  },
  {
    "object": "Hey cadmonkey, make me a Button cell / battery adapter - use a small one for a big one",
    "scad": "dBig=11.5;\nhBig=5.2;\ndSmall=7.8;\nhSmall=5.2;\nhTol=1;\ndTol=0.8;\nholeShift= 0.4;\n$fn=0+40;\ntol=0+0.1;\ndBigR= dBig - dTol;\ndSmallR= dSmall - dTol;\nhBigR= hBig - hTol;\ndifference()\n{\n  cylinder(r=dBigR/2, h=hBigR);\n  translate([(dBigR-dSmallR)/2+holeShift,0,hBigR-hSmall-tol])\n  hull()\n  {\n    cylinder(r=dSmallR/2, h=hSmall+2*tol);\n    translate([10,0,0]) cylinder(r=dSmallR/2-2, h=hSmall+2*tol);\n  }\n}",
    "description": "Okay, I need a custom battery adapter, and I'm hoping you can help me generate the OpenSCAD code for it. I'm trying to adapt a smaller button cell battery to fit a device designed for a larger one.\n\nBasically, I need a cylinder with a hole in it. The outer cylinder represents the size of the original, larger battery, and the hole will fit my smaller battery. Here are the key dimensions:\n\n*   **Original (Larger) Battery:**\n    *   Diameter: 11.5 mm (I'll call this `dBig`)\n    *   Height: 5.2 mm (I'll call this `hBig`)\n\n*   **Smaller Battery:**\n    *   Diameter: 7.8 mm (I'll call this `dSmall`)\n    *   Height: 5.2 mm (I'll call this `hSmall`)\n\nI need some tolerance in the design because of printer accuracy and slight variations in the batteries themselves. Let's use these values and let me adjust as needed:\n    *   Diameter Tolerance: 0.8 mm (I'll call this `dTol`) - This will reduce the diameters in the model for a slightly looser fit.\n    *   Height Tolerance: 1 mm (I'll call this `hTol`) - This will reduce the height of the larger battery cylinder in the model.\n\nAlso, the hole for the smaller battery needs to be slightly offset within the larger cylinder, by 0.4mm horizontally. I'll call that `holeShift`.\n\nThe idea is to create a solid cylinder that matches the bigger battery, and then cut out a space that allows the smaller battery to sit inside with the proper shift. I also need to adjust the hole a bit so the edges of the smaller battery don't rub too tight on the walls. It appears that the existing design already does this.\n\nThe code should be parametric, meaning that it should use variables for all these dimensions so they can be easily adjusted. Also, please include a reasonable `$fn` value for smooth curves.\n\nI'd like it if the final code didn't include any comments other than variable descriptions, since they make it harder for me to read the code.\n\nI think I have all the information, let me know if I missed anything.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Aperture Fan Grill",
    "scad": "size=80;\nborderthickness=5;\ncornerradius=4;\nthickness=2;\nscrewradius=2.3;\nscrewinset=4;\nspines=10;\nspinesize=2;\nspineoffset=10;\nspinerotation=0;\ndxf=false;\nholeradius=size/2-borderthickness;\nif (dxf)\n\tprojection(cut=false) fan_grill();\nelse\n\tfan_grill();\nmodule fan_grill()\n{\n\tunion()\n\t{\n\t\tdifference()\n\t\t{\n\t\t\tbody();\n\t\t\ttranslate([size/2,size/2,-thickness/4]) cylinder(r=holeradius,h=thickness*2);\n\t\t\ttranslate([screwinset,screwinset,0]) cylinder(r=screwradius,h=thickness);\n\t\t\ttranslate([screwinset,size-screwinset,0]) cylinder(r=screwradius,h=thickness);\n\t\t\ttranslate([size-screwinset,screwinset,0]) cylinder(r=screwradius,h=thickness);\n\t\t\ttranslate([size-screwinset,size-screwinset,0]) cylinder(r=screwradius,h=thickness);\n\t\t}\n\t\ttranslate([size/2,size/2,0])\n\t\tinterrior();\n\t}\n}\nmodule body()\n{\n\tunion()\n\t{\n\t\ttranslate([0,cornerradius,0]) cube(size=[size,size-(cornerradius*2),thickness]);\n\t\ttranslate([cornerradius,0,0]) cube(size=[size-(cornerradius*2),size,thickness]);\n\t\ttranslate([cornerradius,cornerradius,0]) cylinder(r=cornerradius,h=thickness);\n\t\ttranslate([cornerradius,size-cornerradius,0]) cylinder(r=cornerradius,h=thickness);\n\t\ttranslate([size-cornerradius,cornerradius,0]) cylinder(r=cornerradius,h=thickness);\n\t\ttranslate([size-cornerradius,size-cornerradius,0]) cylinder(r=cornerradius,h=thickness);\n\t}\n}\nmodule interrior()\n{\n\tfor(i=[0:spines-1])\n\t{\n\t\t  rotate(a=[0,0,i*(360.0/spines)+spinerotation])\n\t\t  translate([spineoffset,-spineoffset/3.141,0])\n\t\t  cube([spinesize,holeradius+(spineoffset/3.141),spinesize]);\n\t}\n}",
    "description": "Okay, I'm looking to create a parametric fan grill for an 80mm fan, and I'd like to be able to customize it for different fan sizes. I've seen a design on Thingiverse ([thing:15785](https://www.thingiverse.com/thing:15785)) which is close to what I want, and have a slightly modified version that I've attached called `fan_grill.scad`. However, I'd like to generate a similar OpenSCAD design that is a little more robust and also a little easier to understand and modify.\n\nHere's what I'm looking for:\n\n**Overall Design:** I want a square fan grill with rounded corners. It should have a main square body with a circular hole in the center. There should be screw holes for mounting the fan. The grill itself should be made of a series of radiating spines.\n\n**Parametric Controls:** I'd like to be able to control the following:\n\n*   **Fan Size:** This would be the overall size of the grill (currently `size`). It should determine the outer dimensions of the square and the diameter of the central hole.\n*   **Border Thickness:** The width of the solid border around the edge of the grill (currently `borderthickness`).\n*   **Corner Radius:** How rounded the corners of the grill are (currently `cornerradius`).\n*   **Sheet Thickness:**  The overall thickness of the grill (currently `thickness`).\n*   **Screw Radius:** The radius of the screw holes (currently `screwradius`).\n*   **Screw Inset:**  The distance the screw holes are set in from the corners of the grill (currently `screwinset`).\n*   **Number of Spines:** The number of radiating spines within the circular hole (currently `spines`).\n*   **Spine Thickness:**  The thickness of each spine (currently `spinesize`).\n*   **Spine Offset:** How far away from the center circle the spine starts (currently `spineoffset`). This is a difficult one to visualize. Perhaps there's a better way to describe how the spines are positioned, but right now this parameter works.\n*  **Spine Rotation:**  An extra rotation of all the spines (currently `spinerotation`).\n\n**Specific Design Requirements:**\n\n*   The central hole should be calculated based on the fan size and border thickness.\n*   Screw holes should be placed at the four corners, and the centers should be inset from the corners.\n*   The radiating spines should extend from their offset to the central hole. They should all be the same size, thickness, and symmetrically placed around the circle.\n\n**OpenSCAD Specific Requirements**\n* The code should be well commented to explain the purpose of each section and parameter.\n* I would prefer to avoid `translate()` operations where possible. Please use `rotate()` and `linear_extrude` or `polygon` type objects where possible to generate the spines.\n* Please use descriptive variable names.\n*   I'd like to use the `MCAD` library if possible to generate the rounded edges, so I would not need the `cube` + `cylinder` hacks for the corner.\n\n**Output:**\n* The output should be a single `.scad` file. It should generate a solid model of the fan grill suitable for 3D printing.\n\nI think that covers it. Let me know if you need any further clarification. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Nub Hook",
    "scad": "$fn    = 40*1;\nFUESSE = 3;\nHOEHE  = 6;\ndifference() {\n   cube([6,6,1], true);\n\tfor(j = [1:4]) {\n\t\trotate(j*360/4, [0, 0, 1]) {\n    \t\t\ttranslate([2.3, 2.3, -1]) cylinder(h=2, r=0.2);\n\t\t}\n\t}\n}\ntranslate([0,0,HOEHE/2]) {\n    cylinder(h=HOEHE, r=0.8, center = true);\n    translate([0,0,HOEHE/2]) {\n        sphere(1.5);\n    }\n}\nfor (i = [1:FUESSE]) {\n\trotate(270, [0,1,0]) {\n\t    translate([0.5,0,0]) {\n\t\t\trotate((i*360 / FUESSE) + 21, [1,0,0]) {\n\t\t\t\tlinear_extrude(height = 1, center = true) polygon(points=[[0,0],[3,0],[0,1.9]], paths=[[1,2,0]]);\n\t\t\t}\n\t\t}\n\t}\n}",
    "description": "Okay, I need a parametric OpenSCAD design for a hook that I can screw into a wall, and I have a pretty specific starting point in mind, based on another file I've been working with.\n\nBasically, I want to take the nub-like object described in the \"Nub_Hook.scad\" file I provided, which has a cylindrical body and a spherical top, and add a screw hole and some kind of flange or base that will allow it to be screwed into a wall. \n\nHere are the parameters I'd like to be able to control:\n\n*   **`HOEHE` (Height):** This controls the height of the central cylindrical section of the nub, and the position of the spherical top. I'd like to retain the same behaviour where the sphere is centered on top.\n*   **`FUESSE` (Number of feet/supports):** I'd like to keep the option of adding those decorative feet around the base that are in my original file.\n*   **Central Nub Dimensions:** The nub itself should retain the same basic dimensions from the \"Nub_Hook.scad\" file, particularly the cylinder radius (0.8) and sphere radius (1.5), as well as the 6x6x1 base.\n*   **Mounting Base:** I need a flat base to attach the nub to the wall. This should extend beyond the 6x6x1 base of the nub and should have countersunk screw holes.\n*   **Countersunk Screw Holes:** I need to be able to specify how many screw holes, their diameter, their position and the countersunk angle. I'd like to be able to specify if it should be centered and/or how far from center. I'd like it if there was a way to easily change them between even or odd amounts of screws (if they are centered), or to manually place them on a circle. I'd like to be able to define screw hole diameter and countersink diameter separately.\n*   **Base Thickness:** The thickness of the mounting base should also be a parameter.\n*   **Nub Base Connection:** I want the nub to be firmly attached to this mounting base.  The cylinder and cube from the original file should be connected to it as a single unit, not as just objects on the same plane.\n\nI'd like to be able to use the `MCAD` library for the screw hole functionality, specifically `screw_hole()`. I think it might be helpful to have a parameter that allows me to specify the screw type, and that would then update the countersink and screw hole diameter. If I specify no screw type, I'd like to be able to manually specify diameters and a countersink angle.\n\nI am attaching my original \"Nub_Hook.scad\" for reference. The critical part is the initial base and the nub:\n\n```\n$fn    = 40*1; // For Customizer\n\n// Nr of foots\nFUESSE = 3; // [0:8] \n\n// Height \nHOEHE  = 6; // [3:15]\n  \n\ndifference() {\n   cube([6,6,1], true);\n\tfor(j = [1:4]) {\n\t\trotate(j*360/4, [0, 0, 1]) {\n    \t\t\ttranslate([2.3, 2.3, -1]) cylinder(h=2, r=0.2);\n\t\t}\n\t}\n}\n\n\ntranslate([0,0,HOEHE/2]) {\n    cylinder(h=HOEHE, r=0.8, center = true);\n    translate([0,0,HOEHE/2]) {\n        sphere(1.5); \n    }\n} \n\nfor (i = [1:FUESSE]) {\n\trotate(270, [0,1,0]) {\n\t    translate([0.5,0,0]) {\n\t\t\trotate((i*360 / FUESSE) + 21, [1,0,0]) {\n\t\t\t\tlinear_extrude(height = 1, center = true) polygon(points=[[0,0],[3,0],[0,1.9]], paths=[[1,2,0]]);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\nLet me know if you have any questions, thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a PRotos Heatbed Powersupply Holder/Strap",
    "scad": "LENGTH        = 53.6;\nWIDTH         = 22;\nHEIGHT        = 37.4;\nBUTTON_LENGTH = 21.0;\nBUTTON_WIDTH  = 15.1;\nSCREWHOLE     = 2;\nWALL          = 2;\nSPAN          = WIDTH / 4;\nrotate([0,-90,0]) {\n\tdifference() {\n\t\tunion() {\n\t      color(\"yellow\") translate([0,-WALL/2,0])  cube([WIDTH, LENGTH+(2*WALL), HEIGHT+WALL]);\n\t\t\tcolor(\"pink\") translate([0,-SPAN-WALL/2,0]) cube([WIDTH, LENGTH+(2*(WALL+SPAN)), WALL]);\n\t\t\tcolor(\"green\") translate([WIDTH/2,-WALL/2-SPAN,0]) cylinder(r=WIDTH/2, h=WALL);\n\t\t\tcolor(\"gray\") translate([WIDTH/2,LENGTH+SPAN+WALL+WALL/2,0]) cylinder(r=WIDTH/2, h=WALL);\n\t\t}\n\t\tunion() {\n\t\t\tcolor(\"red\")  translate([-1,WALL/2,-1]) cube([WIDTH+2, LENGTH, HEIGHT+1]);\n\t\t\tcolor(\"blue\") translate([(WIDTH / 2) - (BUTTON_WIDTH / 2), (LENGTH / 2) - (BUTTON_LENGTH / 2)+WALL/2, HEIGHT -1]) cube([BUTTON_WIDTH, BUTTON_LENGTH, WALL+2]);\n\t\t\ttranslate([WIDTH/2,-WALL/2-SPAN,-1]) cylinder(r=SCREWHOLE/2+0.2, h=WALL+2);\ttranslate([WIDTH/2,LENGTH+SPAN+(1*WALL)+WALL/2,-1]) cylinder(r=SCREWHOLE/2+0.2, h=WALL+2);\n\t\t}\n\t}\n}\n$fn=100;",
    "description": "Okay, so I'm trying to design a mount for a power supply  specifically for a heated bed for a 3D printer, but really it could be for any boxy thing  that uses a strap that screws down. I've started with a basic design that I've attached called \"Heizbett_Netzteil_Halter.scad\", but I need a lot of flexibility and its currently pretty clunky.\n\nThe key features are:\n\n*   **Enclosure:** It needs to cradle the power supply box. This is essentially a rectangular frame with a base, but the sides don't need to fully enclose the box. Currently the design has three layers, a yellow frame, pink and gray cylinders for the strap, and green cylinder for mounting. \n*   **Strap:** The strap goes over the top of the box and screws down on either side of the frame. The strap needs to have a cutout for a button, and screw holes. Its currently represented by pink and gray cylinders. \n*   **Button Cutout:** I need to have a configurable rectangular cutout for a button on the top strap. This needs to be adjustable in size and position.\n*   **Screw Holes:** The screw holes need to be adjustable in size and position, and need to be on the ends of the strap.\n*   **Parametric Design:** Everything needs to be easily adjustable with variables at the top of the code. \n\nHere's what I want to be able to easily control using variables:\n\n*   **Inner dimensions:** The length, width, and height of the space where the power supply sits.\n*   **Wall thickness:** The thickness of the frame walls.\n*   **Strap thickness:** The thickness of the top strap.\n*   **Strap width:** The width of the top strap.\n*   **Button hole dimensions and position:** The width, length, and x/y position of the rectangular button hole.\n*   **Screw hole diameter and position:** The diameter of the screw holes, and the position of the holes relative to the mount, likely on the edges of the strap. \n*  **Rounding:** It would be nice if I can set the rounded-ness of the corners of the enclosure with a fillet or chamfer.\n*  **Rotation:** The design will need to rotate the initial part for better printing. I did this in the included file with a `rotate([0,-90,0])` call but it would be nice to incorporate this properly.\n\nI'm using OpenSCAD. I'm hoping you can provide a much cleaner, more parametric OpenSCAD file. I'm not specifically requesting any particular libraries or functions, but anything that makes the code easier to read and maintain would be great. I'm not sure which library, if any, is appropriate.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizeable RC Plane Wheel Hangers",
    "scad": "part=\"both\";\ndiameter = 50;\nwidth=30;\nnail_diameter=2.7;\nnail_orientation=\"angled\";\ntolerance=5;\naxle_clearance=10;\nwall_thickness=5;\nprint_part();\nmodule print_part() {\n\tif (part == \"left\") {\n\t\tleft();\n\t} else if (part == \"right\") {\n\t\tright();\n\t} else if (part == \"both\") {\n\t\tboth();\n\t} else {\n\t\tboth();\n\t}\n}\nmodule both(){\n\ttranslate([(width+2*wall_thickness+tolerance+10)/2,0,0])right();\n\ttranslate([-(width+2*wall_thickness+tolerance+10)/2,0,0])left();\n}\nmodule right(){\ndifference(){\nunion(){\n\t\tcube([width+2*wall_thickness+tolerance,diameter+2*wall_thickness+tolerance,diameter+2*wall_thickness+tolerance]);\n\t\ttranslate([0,diameter+2*wall_thickness+tolerance,0])\n\t\tcube([width+2*wall_thickness+tolerance,5,diameter+2*wall_thickness+tolerance+25]);\n}\ntranslate([width/2+wall_thickness+tolerance/2,diameter/2+wall_thickness+tolerance/2,diameter/2+wall_thickness+tolerance/2])\nrotate([90, 0, 90])\ncylinder(h = width+tolerance, r=diameter/2+tolerance/2,$fn=100,center=true);\ntranslate([wall_thickness,wall_thickness,diameter/2+wall_thickness+tolerance/2])\ncube([width+tolerance,diameter+tolerance,diameter+tolerance*5]);\ntranslate([wall_thickness,-1,diameter/2+wall_thickness+tolerance/2])\ncube([axle_clearance,diameter/2,diameter]);\nif(nail_orientation==\"angled\"){\n\ttranslate([width/2+wall_thickness+tolerance/2,diameter+2*wall_thickness+tolerance,diameter+2*wall_thickness+tolerance+25/2])\n\trotate([45, 0, 0])\n\tcylinder(h = 500, r=nail_diam/2,$fn=100,center=true);\n}\nelse{\n\ttranslate([width/2+wall_thickness+tolerance/2,diameter+2*wall_thickness+tolerance,diameter+2*wall_thickness+tolerance+25/2])\n\trotate([90, 0, 0])\n\tcylinder(h = 500, r=nail_diam/2,$fn=100,center=true);\n}\n}\n}\nmodule left(){\ndifference(){\nunion(){\n\t\tcube([width+2*wall_thickness+tolerance,diameter+2*wall_thickness+tolerance,diameter+2*wall_thickness+tolerance]);\n\t\ttranslate([0,diameter+2*wall_thickness+tolerance,0])\n\t\tcube([width+2*wall_thickness+tolerance,5,diameter+2*wall_thickness+tolerance+25]);\n}\ntranslate([width/2+wall_thickness+tolerance/2,diameter/2+wall_thickness+tolerance/2,diameter/2+wall_thickness+tolerance/2])\nrotate([90, 0, 90])\ncylinder(h = width+tolerance, r=diameter/2+tolerance/2,$fn=100,center=true);\ntranslate([wall_thickness,wall_thickness,diameter/2+wall_thickness+tolerance/2])\ncube([width+tolerance,diameter+tolerance,diameter+tolerance*5]);\ntranslate([width-wall_thickness+tolerance,-1,diameter/2+wall_thickness+tolerance/2])\ncube([axle_clearance,diameter/2,diameter]);\nif(nail_orientation==\"angled\"){\n\ttranslate([width/2+wall_thickness+tolerance/2,diameter+2*wall_thickness+tolerance,diameter+2*wall_thickness+tolerance+25/2])\n\trotate([45, 0, 0])\n\tcylinder(h = 500, r=nail_diam/2,$fn=100,center=true);\n}\nelse{\n\ttranslate([width/2+wall_thickness+tolerance/2,diameter+2*wall_thickness+tolerance,diameter+2*wall_thickness+tolerance+25/2])\n\trotate([90, 0, 0])\n\tcylinder(h = 500, r=nail_diam/2,$fn=100,center=true);\n}\n}\n}",
    "description": "Okay, I'm looking to design a customizable RC plane hanger, something that can be 3D printed and mounted on a wall. I've got a basic OpenSCAD file that I've started to play with, but I'd like to get a more polished parametric design.\n\nThe hanger needs to hold the plane by its landing gear wheels. The typical RC plane wheel setup is where the wheel is attached to an L-shaped rod (the axle), so the hanger design needs to accommodate that.  I want to be able to create either a left hanger, right hanger, or a set of two (both).\n\nHere are the main things I'd like to be able to customize:\n\n*   **Wheel Diameter:** The diameter of the wheel itself, in millimeters. This will determine the size of the slot that the wheel sits in.\n*   **Total Wheel Width:** The total width of the wheel plus the horizontal portion of the axle, in millimeters. This will determine the width of the hanger arm.\n*   **Nail/Screw Diameter:** The diameter of the nail or screw I'll be using to mount the hanger to the wall, in millimeters.\n*   **Nail/Screw Orientation:** Whether the mounting nail/screw hole should be horizontal or angled.\n*   **Clearance Tolerance:** A bit of extra space around the wheel slot, to make it fit more easily, in millimeters.\n*   **Axle Clearance:** The width of the slot the axle will slide into, in millimeters.\n*   **Part Selection:** A choice to generate only a \"left\" side hanger, a \"right\" side hanger, or \"both\" hangers.\n*   **Wall Thickness:** This should be a parameter, though I'm not sure if I want to be able to customize this one at the moment.\n*   The parts should have a small \"lip\" that goes over the wheel so that it is securely held.\n\nI'd prefer to be able to change these parameters at the top of the file so that I can easily modify them. I'd like for the design to be relatively simple and easy to print.\n\nCould you generate an OpenSCAD file for this? I don't have a preference for any particular libraries, but I'm also not using any at the moment. Let me know if you have any questions!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Mobile Phone Stand",
    "scad": "base_width = 70;\nbase_length = 86;\nbase_height = 3;\ncube([base_width,base_length,base_height]);\nback_length = 110;\nback_thickness = 3;\nback_angle = 23;\ntranslate([0,base_length,0])\nrotate(back_angle,[1,0,0])\ncube([base_width,back_thickness,back_length]);\nfront_length = 62;\nfront_thickness = 3;\nfront_transY = sin(back_angle) * back_length;\nfront_transZ = cos(back_angle) * back_length;\nfront_angle = 240;\ntranslate([0,front_transY, front_transZ])\nrotate(front_angle, [1,0,0])\ncube([base_width,front_length,front_thickness]);\nh_length = 22;\ntranslate([0,16,49])\nrotate(150,[1,0,0])\ncube([base_width,h_length,base_height]);\ns_length  = 10;\ntranslate([0,-2,56])\nrotate(60,[1,0,0])\ncube([base_width,s_length,base_height]);",
    "description": "Okay, I'd like to design a parametric phone stand using OpenSCAD. I've been playing around with some basic shapes, and I have a rough idea of what I want, but I'd like something more flexible. \n\nRight now, I have a design that's built with a base, a back support, a front lip to hold the phone, and two small support pieces. The dimensions and angles are all hardcoded, though. I'd like to make this easily adjustable so I can customize it for different phones and viewing angles.\n\nHere's what I envision:\n\n*   **Base:** The base should be a rectangular prism. I want to control the width, length, and height of the base.\n*   **Back Support:** This will be angled backward from the back of the base. I need parameters for the length, thickness, and angle of this support.\n*   **Front Lip:** This will extend forward from the back support to hold the phone. I need parameters for the length and thickness of this lip, plus the angle it makes with the back support. This angle likely needs to be calculated or derived, rather than set directly, as the angle is relative to the back.\n*   **Phone Support Pieces:** These will be small, angled pieces that provide additional support or a more defined cradle for the phone on the front and back. I need to be able to control the length and relative angles of these pieces, plus the height where they attach to the back.\n*   **Parametric Approach:** I want to be able to adjust all of these dimensions and angles as parameters. It would be great if there were some comments in the code that explained what each parameter does.\n*   **No Libraries**: I do not need any external libraries.\n\nBasically, I'm looking for a fully parametric OpenSCAD file that lets me define the overall dimensions and angles of a fairly standard phone stand. It should be relatively simple and based on the structure I've already got, but the parameters should be easy to understand and modify.\n\nI think that's it for now. Let me know if you need any more information!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Snowflake Ornament",
    "scad": "arm_num = 6;\nbranch_length =40;\nbranch_angle = 15;\nbranch_thickness = 3;\nthickness = 6;\nspike_num = 6;\nseed =1;\nmodule tree(branch_length,branch_angle, branch_thickness, thickness,spike_num,seed){\n\tmodule half_tree(){\n\t\tcube([branch_thickness/2,branch_length,thickness]);\n\t\tfor ( i = [1:spike_num]){\n\t\t\ttranslate([0, (branch_length-1.3)*cos(i*13), 0])\n\t\t\trotate(branch_angle*(seed+sin(i*15)))\n\t\t\tcube([branch_length*sin(i*(2+seed))+0.5, branch_thickness, thickness]);\n\t\t}\n\t}\n\thalf_tree(branch_length, branch_angle,branch_thickness, thickness,spike_num, seed);\n\tmirror()half_tree(branch_length, branch_angle, thickness, spike_num, seed);\n}\nmodule snowflake(arm_num, branch_length, branch_angle, branch_thickness, thickness, spike_num, seed){\n\thole_dist = branch_length;\n\ttranslate([0,branch_length,0])cylinder(h=thickness, r=branch_length*sin(1*(2+seed))+branch_thickness, $fn=10);\n\t\tfor ( i = [0:arm_num-1]){\n\t\t\trotate( i*360/arm_num, [0,0,1])\n\t\t\ttree(branch_length,branch_angle, branch_thickness, thickness,spike_num,seed);\n\t\t}\n}\ntranslate([branch_length,branch_length,0]){\ndifference(){\nsnowflake(\n\tarm_num,\n\tbranch_length,\n\tbranch_angle,\n\tbranch_thickness,\n\tthickness,\n\tspike_num,\n\tseed\n);\ntranslate([0,branch_length,-2])cylinder(h=thickness*2, r=branch_length*sin(3), $fn=10);\n}\n}",
    "description": "Okay, I'm trying to design a parametric snowflake-like ornament for 3D printing, and I've made a decent start in OpenSCAD, but I want something a little more robust and customizable. I've based my work on this design I found online: http://www.thingiverse.com/thing:1388, but I've noticed that the design I have doesn't print as sturdy as I'd like, and some of the original design's complexity is missing.\n\nHere's what I'm aiming for, and what I've got so far.\n\nMy current OpenSCAD code looks like this (I'll paste it in here so you can see what I'm working with):\n\n```\n//Parametric Snowflake... and star\n//common snowflake variables\n//make seed 100 for a star\narm_num = 6;\nbranch_length =40;\nbranch_angle = 15;\nbranch_thickness = 3;\nthickness = 6;\nspike_num = 6; //suggest under 40\nseed =1; //any number 1 -7\n\n//snowflake starts\nmodule tree(branch_length,branch_angle, branch_thickness, thickness,spike_num,seed){\n\tmodule half_tree(){\n\t\tcube([branch_thickness/2,branch_length,thickness]);\n\n\t\tfor ( i = [1:spike_num]){\n\t\t\ttranslate([0, (branch_length-1.3)*cos(i*13), 0]) \n\t\t\trotate(branch_angle*(seed+sin(i*15))) \n\t\t\tcube([branch_length*sin(i*(2+seed))+0.5, branch_thickness, thickness]);\n\t\t}\n\t}\n\n\thalf_tree(branch_length, branch_angle,branch_thickness, thickness,spike_num, seed);\n\tmirror()half_tree(branch_length, branch_angle, thickness, spike_num, seed);\n}\n\nmodule snowflake(arm_num, branch_length, branch_angle, branch_thickness, thickness, spike_num, seed){\n\thole_dist = branch_length;\n\ttranslate([0,branch_length,0])cylinder(h=thickness, r=branch_length*sin(1*(2+seed))+branch_thickness, $fn=10);\n\t\tfor ( i = [0:arm_num-1]){\n\t\t\trotate( i*360/arm_num, [0,0,1])\n\t\t\ttree(branch_length,branch_angle, branch_thickness, thickness,spike_num,seed);\n\t\t}\n}\n\ntranslate([branch_length,branch_length,0]){\ndifference(){\n\nsnowflake(\n\tarm_num, \n\tbranch_length, \n\tbranch_angle,\n\tbranch_thickness,\n\tthickness,\n\tspike_num,\n\tseed\n);\ntranslate([0,branch_length,-2])cylinder(h=thickness*2, r=branch_length*sin(3), $fn=10);\n}\n}\n```\n\nThe main design is based on a central hub with a specified number of \"arms\" radiating outwards. Each arm is like a small \"tree\" with smaller branch-like features coming off of it. The number of arms, the length of the main branch, and a couple of \"seed\" values all affect the overall shape.\n\nHeres what I want the final design to have, specifically, with regard to robustness:\n*   **Thicker Base:** I think the center of the snowflake, where all the arms join, needs to be thicker and more robust to prevent breakage. My current design has a simple cylinder, which isn't that strong. I want a way to create a thicker, more solid hub at the center.\n*   **Thicker Arms:** I'd like to be able to control how thick the arms are individually, with a parameter; the \"branch_thickness\" setting affects the whole tree. The inner portion of the arms is most fragile.\n*   **More Complex Branches:** The little branch-like features coming off the arms are all generated with simple cubes. This is functional but fairly basic. If possible I'd like to make them slightly less simple looking, maybe some small rounded features.\n*   **Configurable Joint Style:** where the branches meet the arms, a basic connection is made, I'd like to be able to configure this.\n\nHere's what I want the parameters to be (using my current variable names where possible):\n\n*   `arm_num`: The number of main arms of the snowflake.\n*   `branch_length`: The length of the main branch/arm.\n*   `branch_angle`: The angle at which the \"branches\" sprout off the main arms, with respect to the main arm axis.\n*   `branch_thickness`: The initial thickness of the main branch.\n*   `arm_thickness`: The thickness of the main arm near the base.\n*   `thickness`: Overall thickness of the snowflake (z-dimension).\n*   `spike_num`: The number of \"spikes\" or branches on each arm.\n*   `seed`: A seed value to create variation in the branches.\n*   `center_hub_radius`: Radius of the main, robust center hub.\n*    `center_hub_height`: Height of the main, robust center hub.\n*   `branch_curve`: A value controlling curvature of the branches.\n*    `joint_type`: An integer selecting between several joint styles (0, 1, 2 for example).\n\nI want to be able to control these parameters to create a variety of snowflake/star-like ornaments and, if possible, to use some of the other functions in openscad, but I don't want it to be recursive.\n\nI am okay with using the `MCAD` library if that would help simplify things, or if there are other libraries that would help, I can try to install those. I am also okay with using helper modules for things like making the joints.\n\nCould you help me create an OpenSCAD file with these parameters? Thank you.\n"
  },
  {
    "object": "Hey cadmonkey, make me a any-angle rod clamp, for diagonal reprap support",
    "scad": "rod_dia=8;\nwall=3;\nscrew_dia=3;\ngap=2;\nscrew_separation=1;\nbevel=1;\nsmooth=1;\nrender_movable_parts = false;\nmodule rod() {\n  color([0.7, 0.7, 0.7]) {\n    rotate([0,0,180/8])\n      cylinder(r=rod_dia/2/cos(180/8), h=80, $fn=smooth ? 23 : 8, center=true);\n  }\n}\nmodule clamp() {\n  dia = rod_dia + screw_dia/2 + screw_separation+ wall;\n  difference() {\n    rotate([0,90,0])  {\n      rotate([0,0,45/2]) {\n\ttranslate([0,0,gap / 2]) {\n\t  cylinder(r=dia/cos(180/8),\n\t\t   h=rod_dia+wall-gap / 2, $fn=8);\n\t}\n      }\n    }\n    if (bevel) {\n      for (rot=[0:45:360]) {\n        rotate([rot,0,0]) {\n  \t  translate([rod_dia+wall,dia,0]) {\n\t    rotate([0,0,45]) {\n\t      cube([wall*2 * cos(180/4) - 0.2, 100, 100], center=true);\n            }\n\t  }\n        }\n      }\n    }\n    translate([rod_dia/2,\n\t       (rod_dia+screw_dia+screw_separation)/2,0]) {\n      rod();\n      translate([-rod_dia/2, 0,0]) {\n      cube([rod_dia, rod_dia, 100], center=true);\n      }\n    }\n    rotate([0,90,0])  {\n      cylinder(r=screw_dia/2, $fn=10, h = 100, center=true);\n    }\n  }\n  if (render_movable_parts) {\n    translate([rod_dia/2, (rod_dia+screw_dia+screw_separation)/2,0]) rod();\n  }\n}\nrotate([0,90,0]) {\n  translate([gap / 2,0,0]) {\n    if (render_movable_parts) {\n      clamp();\n    }\n    rotate([45,180,0]) clamp();\n  }\n}",
    "description": "Okay, I'm looking for an OpenSCAD design for a rod clamp, but I want it to be more flexible and configurable than the one I'm currently using. The basic idea is still a clamp that connects two rods at an adjustable angle, but I need more parameters to control the design.\n\nHere's what I'm envisioning:\n\n*   **Rod Diameter:** This needs to be a variable, not just fixed at 8mm. I want to be able to specify the rod diameter as a parameter, `rod_dia`.\n*   **Clamp Wall Thickness:** The thickness of the clamp material, `wall`, needs to be adjustable.\n*   **Screw Diameter:** The diameter of the screw used to tighten the clamp, `screw_dia`, also needs to be a parameter.\n*   **Gap Between Clamps:** The space or `gap` between the two halves of the clamp (where the rod is inserted) should be configurable.\n*   **Screw Separation:** The distance between the screw hole and the rod, `screw_separation`, should also be a parameter.\n*  **Clamp Angle:**  The angle between the two rods needs to be adjustable.  I want to set this as an angle parameter, `clamp_angle`. I'd like it to be adjustable within a practical range (e.g. maybe 30 to 150 degrees), but perhaps the program can throw an error if I input an out-of-range value.\n*   **Beveled Edges:**  I'd like an optional bevel on the edges of the clamp. This could be toggled with a `bevel` parameter (1 for on, 0 for off), and I'd also like to be able to control how big the bevel is, maybe using a `bevel_size` parameter.\n*   **Smooth Channel:**  An option to smooth the edges of the channel, similar to the existing code, should be controlled by a `smooth` parameter (1 for on, 0 for off).\n*  **Number of Clamp Sections:** Right now the clamp is a two-part clamp with a 45 degree angle between those parts. I'd like to have a variable `clamp_sections` which would enable the design to have more than two clamping sections, for example 3 sections with a 30 degree angle between sections. The default should be two sections. When using multiple sections the angle between each section should be the value of `clamp_angle` divided by `clamp_sections-1`.\n* **Screw Countersink:** I would like to have a countersink feature for the screw holes. The depth and countersink diameters should be configurable with `countersink_depth` and `countersink_dia` parameters.\n*   **Render Movable Parts:** A debug option, `render_movable_parts`, would be useful to optionally show the rod during debugging but otherwise to omit it.\n\nI'd like to avoid using any external libraries if possible, but if it's truly needed, I'd prefer something like BOSL2 since I've had some experience with that library, but please tell me which parts of the library are used in your response.\n\nThe current code I'm using can be found below, if that's helpful.\n\n```\n// Rod diameter\nrod_dia=8;\n// Wall thickness\nwall=3;\n// Screw diameter\nscrew_dia=3;\n// Gap between clamps.\ngap=2;\n// Space between screw and rod.\nscrew_separation=1;\n// Bevel\nbevel=1;  //  [1, 0]\n// Smooth channel\nsmooth=1;  //  [1, 0]\n\n\n/* [Hidden] */\nrender_movable_parts = false;\n\nmodule rod() {\n  color([0.7, 0.7, 0.7]) {\n    rotate([0,0,180/8])\n      cylinder(r=rod_dia/2/cos(180/8), h=80, $fn=smooth ? 23 : 8, center=true);\n  }\n}\n\nmodule clamp() {\n  dia = rod_dia + screw_dia/2 + screw_separation+ wall;\n  difference() {\n    rotate([0,90,0])  {\n      rotate([0,0,45/2]) {\n\ttranslate([0,0,gap / 2]) {\n\t  cylinder(r=dia/cos(180/8),\n\t\t   h=rod_dia+wall-gap / 2, $fn=8);\n\t}\n      }\n    }\n    if (bevel) {\n      for (rot=[0:45:360]) {\n        rotate([rot,0,0]) {\n  \t  translate([rod_dia+wall,dia,0]) {\n\t    rotate([0,0,45]) {\n\t      cube([wall*2 * cos(180/4) - 0.2, 100, 100], center=true);\n            }\n\t  }\n        }\n      }\n    }\n    translate([rod_dia/2,\n\t       (rod_dia+screw_dia+screw_separation)/2,0]) {\n      rod();\n      translate([-rod_dia/2, 0,0]) {\n      cube([rod_dia, rod_dia, 100], center=true);\n      }\n    }\n    rotate([0,90,0])  {\n      cylinder(r=screw_dia/2, $fn=10, h = 100, center=true);\n    }\n  }\n  if (render_movable_parts) {\n    translate([rod_dia/2, (rod_dia+screw_dia+screw_separation)/2,0]) rod();\n  }\n}\n\nrotate([0,90,0]) {\n  translate([gap / 2,0,0]) {\n    if (render_movable_parts) {\n      clamp();\n    }\n    \n    rotate([45,180,0]) clamp();\n  }\n}\n```\n"
  },
  {
    "object": "Hey cadmonkey, make me a Moustache for Movember",
    "scad": "a1 = 12;\nw1 = 15;\nl1 = 25;\na2 = -12;\nw2 = 12;\nl2 = 20;\na3 = -22;\nw3 = 8;\nl3 = 10;\na4 = -18;\nw4 = 5;\nl4 = 10;\na5 = -20;\nw5 = 3;\nl5 = 15;\n\tunion(){\n\t\tmirror()\n\t\t\tHalfMo();\n\t\tHalfMo();\n\t}\nmodule HalfMo(){\n\tintersection(){\n\t\ttranslate([12,18,0])\n\t\tunion(){\n\t\t\tsphere(15);\n\t\t\trotate([0,90,0])\n\t\t\tunion(){\n\t\t\t\trotate([a1,0,0]){\n\t\t\t\t\tcylinder(r1 = w1, r2=w2,h=l1);\n\t\t\t\t\ttranslate([0,0,l1+sin(a2)*w2]){\n\t\t\t\t\t\trotate([a2,0,0]){\n\t\t\t\t\t\t\tcylinder(r1 = w2/cos(a2), r2=w3,h=l2);\n\t\t\t\t\t\t\ttranslate([0,0,l2+sin(a3)*w3]){\n\t\t\t\t\t\t\t\trotate([a3,0,0]){\n\t\t\t\t\t\t\t\t\tcylinder(r1 = w3/cos(a3), r2=w4,h=l3);\n\t\t\t\t\t\t\t\t\ttranslate([0,0,l3+sin(a4)*w4]){\n\t\t\t\t\t\t\t\t\t\trotate([a4,0,0]){\n\t\t\t\t\t\t\t\t\t\t\tcylinder(r1 = w4/cos(a4), r2=w5,h=l4);\n\t\t\t\t\t\t\t\t\t\t\ttranslate([0,0,l4+sin(a5)*w5])\n\t\t\t\t\t\t\t\t\t\t\t\trotate([a5,0,0])\n\t\t\t\t\t\t\t\t\t\t\t\t\tcylinder(r1 = w5/cos(a4), r2=0,h=l5);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcube(75);\n\t}\n}",
    "description": "Okay, I'd like to get a parametric version of this mustache design I found on Thingiverse (it's for Movember!). I'm not a big OpenSCAD expert, and I want to be able to tweak the shape and size of the mustache more easily.\n\nRight now, it's hardcoded with these specific segment angles, widths, and lengths, defined by these variables: `a1`, `w1`, `l1`, `a2`, `w2`, `l2`, `a3`, `w3`, `l3`, `a4`, `w4`, `l4`, `a5`, `w5`, and `l5`. I'd like to be able to control each of these more directly, and maybe even add more \"segments\" to make longer or curlier mustaches.\n\nHere's what I'm thinking:\n\n1.  **Segment Parameters:** Instead of individual variables, I want to use a list (or an array of lists) that defines each segment. The parameters for each segment should include:\n    *   `angle`:  The angle of the segment (like `a1`, `a2`, etc.).\n    *   `start_width`: The width at the beginning of the segment (like `w1`, `w2`, etc.)\n    *   `end_width`: The width at the end of the segment (like `w2`, `w3`, etc.) - this needs to be separate from `start_width` since the cylinders have differing radii.\n    *   `length`: The length of the segment (like `l1`, `l2`, etc.).\n\n2.  **Number of Segments:** I'd like to be able to specify the number of segments in the mustache, allowing me to add or remove segments easily.\n\n3.  **Symmetry:** The current design uses `mirror()` to create the full mustache. That's good! I need to make sure that's preserved.\n\n4.  **Center:** I like the way the center is currently made by the `sphere(15)` at `translate([12,18,0])`. That looks like it works well as a base.\n\n5. **Scaling:** The comments in the code hint at scaling via `scale([0.8,0.8,0.4])`. I want to be able to scale the entire design with a parameter.\n\n6.  **Base Shape:** I think the base shape created by `intersection(){ translate([12,18,0]) union(){sphere(15); ...} cube(75);}` is pretty close to what I want, so lets not change the method of producing that.\n\n7. **Libraries:** I don't think I'll need anything beyond the core OpenSCAD features for this.\n\nSo basically, I want a parametric function that takes this list of segment parameters, generates the mustache segments, and combines them with a spherical base and mirrored structure.  I'd like to have the code be as clean and readable as possible, so it's easy to modify in the future. I would also like it to be easy to add more segments.\n\nCan you help me create this parametric OpenSCAD file?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Universal hose adapter & coupler & funnel, and a web service",
    "scad": "cone1_min=28;\ncone1_max=32;\ncone1_height=20;\ncone1_wall=2;\ncone1_barb_width=0;\ncone2_max=18;\ncone2_min=15;\ncone2_height=30;\ncone2_wall=2;\ncone2_barb_width=0.8;\njoin_height=3;\nbarb_flatness_ratio=2;\nbarb_spacing_ratio=2;\nbarb_skew_ratio=0.15;\ncheck_guts=0;\ntol=0.05;\nfunction xpos(rmin, rmax, height, hpos) = ( rmin+(rmax-rmin)*hpos/height )/2;\nmodule hollow_cone(rmin, rmax, height, wall, barb_width)\n{\n\tif(rmin>0 && rmax>0 && height>0)\n\t{\n\t\tdifference()\n\t\t{\n\t\t\tcylinder(r1=rmin/2, r2=rmax/2, h=height);\n\t\t\tif(wall>0)\n\t\t\t\ttranslate([0,0,-tol])\n\t\t\t\t\tcylinder(r1= rmin/2-wall, r2= rmax/2-wall, h=height+2*tol);\n\t\t}\n\t\tif(barb_width>0 && barb_flatness_ratio!=0)\n\t\t{\n\t\t\tfor(bs=[barb_width*barb_flatness_ratio : 1 : barb_width*barb_flatness_ratio])\n\t\t\t{\n\t\t\t\tfor(hpos=[\n\t\t\t\t\tbs/2\n\t\t\t\t\t: barb_width * barb_flatness_ratio * (1 + barb_spacing_ratio)\n\t\t\t\t\t: height - bs/2]\n\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\ttranslate([0,0,hpos])\n\t\t\t\t\trotate_extrude()\n\t\t\t\t\t\tpolygon( points=[\n\t\t\t\t\t\t\t[xpos(rmin,rmax,height,hpos)-tol, 0],\n\t\t\t\t\t\t\t[xpos(rmin,rmax,height,hpos + bs*(1-barb_skew_ratio)) + barb_width, bs * (1-barb_skew_ratio)],\n\t\t\t\t\t\t\t[xpos(rmin,rmax,height,hpos + bs)-tol, bs],\n\t\t\t\t\t\t] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\tdifference()\n\t{\n\t\tunion()\n\t\t{\n\t\t\tcolor([1,0,0])\n\t\t\thollow_cone(cone1_min, cone1_max, cone1_height, cone1_wall, cone1_barb_width);\n\t\t\tcolor([0,0,1])\n\t\t\t\ttranslate([0,0,cone1_height+join_height+cone2_height])\n\t\t\t\t\trotate([180,0,0])\n\t\t\t\t\t\thollow_cone(cone2_min, cone2_max, cone2_height, cone2_wall, cone2_barb_width);\n\t\t\tif(join_height>0)\n\t\t\t{\n\t\t\t\tcolor([0,1,0])\n\t\t\t\ttranslate([0,0,cone1_height])\n\t\t\t\trotate_extrude()\n\t\t\t\t\tpolygon( points=[\n\t\t\t\t\t\t[ cone1_max/2-cone1_wall, 0],\n\t\t\t\t\t\t[ cone1_max/2, 0],\n\t\t\t\t\t\t[ max(cone1_max,cone2_max)/2, join_height/2],\n\t\t\t\t\t\t[ cone2_max/2, join_height],\n\t\t\t\t\t\t[ cone2_max/2-cone2_wall, join_height],\n\t\t\t\t\t\t[ min(cone1_max/2-cone1_wall,cone2_max/2-cone2_wall), join_height/2],\n\t\t\t\t\t] );\n\t\t\t}\n\t\t}\n\t\tif(check_guts!=0)\n\t\t\ttranslate([0,0,-tol]) cube([100,100,100]);\n\t}",
    "description": "Okay, I need an OpenSCAD design for a hose adapter, but I want it to be really flexible and customizable. I've seen some designs that are good, but I want to be able to control a lot of the details.\n\nBasically, it should be like two cones joined together, with different sizes and options for each cone. So, I want to be able to specify the base and top radius for both cones, as well as their individual heights and wall thicknesses. And most importantly, I want to be able to add barbs (those little ridges) to the *outside* of each cone to help the hoses grip better. Crucially, I need to control the *size* of those barbs on each cone independently, as well as their spacing and how flat or pointy they are, and even how much the barb is angled/skewed. The skew should be able to be negative to create concave barbs, although I understand that only makes sense for the lower cone.\n\nSpecifically, I need the following parameters:\n\n*   **Lower Cone:**\n    *   `cone1_min`: Base radius (mm)\n    *   `cone1_max`: Top radius (mm)\n    *   `cone1_height`: Height (mm)\n    *   `cone1_wall`: Wall thickness (mm)\n    *   `cone1_barb_width`: Barb width (mm)\n\n*   **Top Cone:**\n    *   `cone2_max`: Base radius (mm)\n    *   `cone2_min`: Top radius (mm)\n    *   `cone2_height`: Height (mm)\n    *   `cone2_wall`: Wall thickness (mm)\n    *   `cone2_barb_width`: Barb width (mm)\n\n*   **Joining Section:**\n    *   `join_height`: Height of the cylindrical section connecting the two cones (mm)\n\n*   **Barb Properties (for both cones):**\n    *   `barb_flatness_ratio`: Ratio of barb height to width (e.g., 1 = 45-degree angle, 2= flatter)\n    *   `barb_spacing_ratio`: Ratio of space between barbs to barb height (e.g., 0 = adjacent, 1 = equal space)\n    *   `barb_skew_ratio`: How much the barb leans/is skewed (0.5 is symmetrical, negative values can create concave barbs, which should be allowed only for the lower cone).\n\n*   **Debugging:**\n    *   `check_guts`: A flag to cut away part of the object to expose the interior and verify thicknesses.\n\nI'd also like a small tolerance parameter (e.g. `tol`) that can be used in internal calculations.\n\nIdeally, the code should generate a single object combining the two cones and the joiner, and that object should be ready to print directly, with properly defined thicknesses for the wall.\n\nI don't need any special libraries, just the standard OpenSCAD functions.\n\nCould you generate the OpenSCAD code for this? Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Rolling Pin Spacer",
    "scad": "pin = 46;\npinr=pin/2;\nDough = 5;\ndifference () {\n   cylinder (h=7,r=pinr+Dough, $fn = 200);\n   translate ([0,0,-2]) cylinder (h=14,r=pinr, $fn = 200);\n   rotate([30,0,0]) translate ([0,0,-5]) cube([pinr+Dough+2,2,20]);;\n}",
    "description": "Okay, I'm looking for a way to make rolling pin spacers, but I'd like them to be fully parametric so I can easily adjust them to different rolling pins and dough thicknesses. I've seen a design before that does this, and I'm hoping you can help me create a better version.\n\nThe basic idea is to create a spacer that fits over the ends of a rolling pin. This spacer should be a cylinder with a hole in the center to fit over the rolling pin, and a small gap on one side to allow the dough to pass. The important parameters should be:\n\n1.  **Rolling Pin Diameter:** This is the diameter of the rolling pin itself. I need to be able to specify this in millimeters. The spacer hole will be slightly larger than this to allow it to slide on easily.\n2.  **Dough Thickness:** This is the desired thickness of the rolled dough, also in millimeters. This determines the height of the cylinder section around the pin.\n3. **Spacer Height**: This is how thick the spacers themselves are. \n4. **Slant Angle:** I'd like the gap for the dough to be slanted, rather than just a flat cutout. This is for easier rolling action. The angle should be adjustable in degrees.\n5. **Gap Width:** This is the width of the gap on the outside of the spacer where the dough passes.\n6. **Cylinder Resolution**: I want to be able to control the resolution of the cylinder so it doesn't look too faceted.\n7. **Clearance:** I'd like a small, parametric, clearance to be added to the internal diameter of the cylinder to make it easy to slide onto the rolling pin, and allow for slight printer inaccuracies.\n\nI'd like the OpenSCAD file to be fully parameterized, with clear and descriptive comments for each variable. I don't need any fancy text or support structures, and it would be nice if it could be a single object (no groups). I would prefer to avoid libraries if possible, or stick to standard OpenSCAD functions.\n\nBasically, I need something I can easily modify to fit different rolling pin diameters and dough thickness requirements. Please generate the OpenSCAD file for this design.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric twisted star box",
    "scad": "part = \"both\";\n$fn = 100;\niRadius    =   20;\nwThickness =    3;\nsbHeight   =   93;\nsbLip      =   10;\ntFactor    = -100;\ntGap       =    0.3;\ntTwist = (sbHeight * tFactor)/100;\noRadius = iRadius + wThickness;\nlSide = 2 * oRadius;\nmodule lip() {\n\trotate_extrude($fn=200)\n\t\tpolygon(points=[[oRadius,0],[oRadius,wThickness],[iRadius,wThickness]]);\n}\nmodule box() {\n\tdifference() {\n\t\tunion() {\n\t\t\tlinear_extrude(height = sbHeight, center = false, convexity = 10, twist = tTwist)\n\t\t\t\tunion() {\n\t\t\t\t\trotate([0,0,45])\n\t\t\t\t\t\tsquare([lSide,lSide], true);\n\t\t\t\t\tsquare([lSide,lSide], true);\n\t\t\t\t}\n\t\t\ttranslate([0,0,wThickness])\n\t\t\t\tcylinder(r=oRadius,h=sbHeight+sbLip);\n\t\t}\n\t\ttranslate([0,0,sbHeight+sbLip])\n\t\t\tlip();\n\t\ttranslate([0,0,wThickness])\n\t\t\tcylinder(r=iRadius,h=sbHeight+sbLip+1);\n\t}\n}\nmodule top() {\n\tdifference() {\n\t\tunion() {\n\t\t\tlinear_extrude(height = sbLip+wThickness+wThickness, center = false, convexity = 10, twist = tTwist*(sbLip+wThickness)/sbHeight)\n\t\t\t\tunion() {\n\t\t\t\t\trotate([0,0,45])\n\t\t\t\t\t\tsquare([lSide,lSide], true);\n\t\t\t\t\tsquare([lSide,lSide], true);\n\t\t\t\t}\n\t\t\ttranslate([0,0,wThickness])\n\t\t\t\tcylinder(r=oRadius,h=sbLip);\n\t\t}\n\t\ttranslate([0,0,wThickness])\n\t\t\tcylinder(r=oRadius+tGap,h=sbLip+wThickness+1);\n\t}\n}\nif (part == \"bottom\")\n{\n    box();\n}\nelse if (part == \"top\")\n{\n    translate([3*lSide/2,0,0])\n        top();\n}\nelse if (part == \"both\")\n{\n    box();\n    translate([3*lSide/2,0,0])\n        top();\n}",
    "description": "Okay, I'm looking for help creating a parametric, twisted star box in OpenSCAD. I've previously found a design for this box that uses Art of Illusion and a special plugin, but I want to do this directly in OpenSCAD.\n\nI've already created a basic version in OpenSCAD (see below), but I'd like to improve on it, adding a few key features.\n\nMy current design uses these parameters:\n\n*   `part`:  A string parameter to specify if we are creating \"both\" the top and bottom parts, just the \"top\", or just the \"bottom\".\n*   `$fn`:  A value that controls the smoothness of curves.\n*   `iRadius`: The inner radius of the box.\n*   `wThickness`:  The wall thickness for the box, lid, and lip.\n*   `sbHeight`: The height of the main box body, excluding the lip/top.\n*   `sbLip`: The height of the lip on the bottom of the box and the top of the lid.\n*   `tFactor`:  A value to control the amount of twist applied to the box and lid.\n*   `tGap`: The gap between the lid and the bottom lip for a snug fit.\n\nMy current code generates a star-shaped base with an optional lip and a matching star-shaped top/lid.  It uses `linear_extrude` with a twist parameter to create the twisted shape. I've also included a gap to ensure the top fits into the bottom.\n\nI am hoping you can help create a more polished design by taking into account the following considerations:\n\n1.  **Robustness:**  I've used simple differences between cylinders and linear extrudes.  I would like the code to use better methods of generating the star shape and to minimize the use of boolean operations, in particular the difference operation, since it can be slow and is often error-prone. If possible, I'd prefer to avoid boolean operations altogether. Is this possible while still generating a hollow box and lid?\n\n2.  **Precise fit:** The gap ( `tGap`) is currently a simple offset applied to the radius of the lid. I would prefer to have the gap applied directly to the internal profile of the top so that the lid fits the bottom exactly on the non-twisted profile. The twisting can deform the internal fit so it isn't perfectly consistent with a straight sided box. Is it possible to more accurately account for how twisting changes the internal profile?\n\n3.  **Ease of Customization:**  The current method of specifying the star shape as squares is difficult to understand.  I'd like to make it easier to modify the shape to use a different regular polygon for the side of the box and lid. I'd like to add an additional parameter that specifies the number of sides on the box. (e.g. `nSides`) which defaults to 8 (as in the current design), but will allow me to create boxes with a variable number of sides (e.g. a hexagon box, etc.)\n\n4.  **Code Clarity:** I'd like the code to be well organized and commented. Variable names should be descriptive and the code should be easy to read and understand.\n\n5. **Library Use**: I am comfortable with using libraries to achieve my goals, such as BOSL2 for its polygon manipulation tools or other libraries, if necessary. I think that the `linear_extrude` is not working perfectly as it is difficult to see the star profile in the solid. If a library can help me better construct my object I would prefer to use it.\n\nSo, I need a fully parametric OpenSCAD design for a twisted box with a matching top/lid, based on a regular polygon, and taking into account the issues noted above, but I'd prefer not to use the `difference` operation if possible. Can you help with this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Camera Lens Cap Holder",
    "scad": "lens_diameter = 58;\nmount_height = 2;\nmount_width = 4;\nmount_base = 3;\nmount_lip_height = 0.1;\nmount_lip_width = 0.2;\nbuckle_gap = 5;\nbuckle_width = 42;\nbuckle_thickness = 4;\nfilled_buckle = false;\ncircle_sides = 70;\nunion()\n{\n    buckle();\n    capmount();\n}\nmodule buckle()\n{\n    buckle_inner = lens_diameter/2 + mount_width + buckle_gap;\n    buckle_outer = buckle_inner + buckle_thickness;\n    squared_inner = buckle_width;\n    squared_outer = buckle_width + 2*buckle_thickness;\n    squared_offset = sqrt(pow(buckle_outer,2) - pow(squared_outer/2,2));\n    linear_extrude(height=mount_base) union()\n    {\n        intersection()\n        {\n            square([buckle_outer*4, squared_outer], center=true);\n            difference()\n            {\n                circle(buckle_outer, $fn=circle_sides);\n                circle(buckle_inner, $fn=circle_sides);\n            }\n        }\n        difference()\n        {\n            square([squared_offset*2, squared_outer], center=true);\n            square([squared_offset*2, squared_inner], center=true);\n        }\n    }\n}\nmodule capmount()\n{\n    lip_height = mount_base + mount_height;\n    cap_outer = lens_diameter/2 + mount_width;\n    cap_inner = lens_diameter/2 - mount_width;\n    union()\n    {\n        linear_extrude(height=mount_base) difference()\n        {\n            circle(cap_outer, $fn=circle_sides);\n            if (!filled_buckle) circle(cap_inner, $fn=circle_sides);\n        }\n        if (!filled_buckle) for(i=[-45,45])\n            linear_extrude(height=mount_base) rotate(i)\n                square([lens_diameter, mount_width], center=true);\n        difference()\n        {\n            linear_extrude(height=lip_height)\n                circle(cap_outer, $fn=circle_sides);\n            linear_extrude(height=lip_height)\n                circle(lens_diameter/2 - mount_lip_width, $fn=circle_sides);\n            linear_extrude(height=lip_height - mount_lip_height)\n                circle(lens_diameter/2, $fn=circle_sides);\n        }\n    }\n}",
    "description": "Okay, so I'm trying to design a lens cap holder that attaches to my camera strap, and I've got a couple of existing OpenSCAD files that kind of do what I want, but they're not quite flexible enough. I'd like to combine some of their features, and make it easier to customize for different lens cap sizes and straps.\n\nI have a \"lens_cap_buckle.scad\" file that creates the basic buckle and a mount for a specific lens cap size, and \"lens_cap_buckle_mk2.scad\" that allows for multiple cap mounts, and also adds an option to split the buckle to make it easier to attach. But I think the \"mk2\" version makes the design overly complex. I also notice that in `lens_cap_buckle.scad` that the two square supports have been coded in explicitly instead of parametrically.\n\nHeres what I'm looking for:\n\n**Overall Design:**\n\nI need a design that creates two main parts: a buckle that attaches to a camera strap, and a mount that holds a lens cap. The buckle should be curved with a flat section for the strap. The mount should have a lip that helps secure the lens cap by friction fit.\n\n**Parametric Features:**\n\nI want to be able to easily customize:\n\n*   **`lens_diameter`:** The outer diameter of the lens cap that the mount is designed for.\n*   **`mount_height`:** The height of the cylindrical part of the lens cap mount that grips the cap.\n*   **`mount_width`:** The thickness of the material of the cylindrical part that mounts the cap.\n*   **`mount_base`:** The height of the base of both the buckle and the cap mount.\n*   **`mount_lip_height`:** The height of the lip on the mount that provides the friction grip.\n*  **`mount_lip_width`:** The width of the lip that provides the friction grip.\n*   **`buckle_gap`:** The gap between the buckle and the lens cap mount  where the strap goes through.\n*   **`buckle_width`:** The width of the camera strap.\n*   **`buckle_thickness`:** The thickness of the material of the buckle.\n*   **`buckle_split`:**  A parameter to control whether the buckle has a split or not, and if so, the size of the split. Setting this to 0 will prevent the split.\n*   **`filled_buckle`:** A boolean parameter (true/false) to determine if the center of the mount should be filled with material, or left hollow.\n*   **`circle_sides`**: The number of sides used to create smooth circles.\n\n**Specific Design Requests:**\n\n1.  **Separate Buckle and Mount:** The design should consist of a single `buckle()` module and a single `capmount()` module.\n2. **Parametric Support:** The two square supports seen in `lens_cap_buckle.scad` should be calculated based on the `lens_diameter` and `mount_width` instead of explicitly coded in.\n3. **Single `capmount()` Module:** Unlike `lens_cap_buckle_mk2.scad` I only want a single `capmount()` module, which takes `lens_diameter` and `mount_height` as arguments.\n4. **Buckle Split:** The buckle split should be implemented as in `lens_cap_buckle_mk2.scad`, such that, if `buckle_split` is non-zero, a thin rectangle is cut out of the buckle arc.\n5. **Combined Structure:**  Both the buckle and the cap mount should be combined into a single overall structure.\n6. **No Magic Numbers:** As much as possible, no values should be hard coded. Use the parameters to define dimensions, where appropriate.\n\nId like this to be a single file, using basic OpenSCAD modules (like `linear_extrude`, `circle`, `square`, `union`, `difference`, etc), and I am _not_ using any specific libraries.\n\nCan you generate the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Square and Circle ",
    "scad": "$fa = 0.01;\nsize = 100;\nheight= 5;\nthick = 5;\nunion() {\ndifference()\n{\n    cube([size,size,height]);\n    translate([thick / 2.0,thick/2.0,-10])cube([size-thick,size-thick,height+50]);\n}\ndifference() {\ntranslate([size/2.0,size/2.0,0])cylinder(height,size/2.0,size/2.0);\ntranslate([size/2.0,size/2.0,-10])cylinder(height+20,size/2.0 - thick/2.0,size/2.0 - thick/2.0);\n}\n};",
    "description": "Okay, I need a parametric OpenSCAD file for a calibration object. I want a square base with a circular hole in the center. Think of it as a flat, square puck with a circular cutout.\n\nHere's the specifics:\n\n1.  **Overall Shape:** The base should be a square.\n2.  **Hole:** There should be a circular hole cut through the center of the square.\n3.  **Parameters:** I need to be able to easily adjust the following:\n    *   `size`: The side length of the square.\n    *   `height`: The thickness (height) of the square base.\n    *   `thick`: The thickness of the wall around the cutout (essentially, the difference between the outer circle and the hole). This should also be used for the border of the square.\n4. **Easy-to-Read Code:** I'd like the code to be as easy to understand as possible. I don't need complicated math or tricks, just straightforward constructions that clearly show what's happening.\n5. **No External Dependencies:** I'd prefer if you could do this using the standard OpenSCAD primitives and not rely on any external libraries. I would like to keep it as simple as possible.\n\nThis object will be used to dial in my printer's settings, so accuracy and precision is important. The circle is particularly useful to see if it comes out round. I've attached the `.scad` code I've tried already, just in case it gives you some more info about what I'm thinking of, but I'd like to see a fresh approach.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Reci CO2 Laser Head Direct Mount",
    "scad": "fn_value = 50;\nlensMountDiameter = 14;\nexteriorTubeDiameter = 27.64;\ntubeHeight = 15;\ntubeWallThickNess = 3;\ncollarHeight = 3;\nrotate(a=[0,180,0]) {\nunion() {\nhex_nut(lensMountDiameter);\n\t\t\tdifference()\n\t\t\t{\n\t\t\t\ttranslate( [0,0,(collarHeight/2)+collarHeight] )\n\t\t\t\t\tcylinder( h = collarHeight, r = (exteriorTubeDiameter * 0.5) +tubeWallThickNess, center = true );\n\t\t\t\ttranslate( [0,0,collarHeight+0.1] )\ncylinder( h = collarHeight*2, r = (lensMountDiameter * 0.5), center = true );\n\t\t\t}\n\t\t\tdifference()\n\t\t\t{\n\t\t\t\ttranslate( [0,0,(tubeHeight/2)+collarHeight] )\n\t\t\t\t\tcylinder( h = tubeHeight, r = (exteriorTubeDiameter * 0.5) + tubeWallThickNess, center = true );\n\t\t\t\ttranslate( [0,0,tubeHeight+collarHeight] )\n\t\t\t\tcylinder( h = 100, r = (exteriorTubeDiameter * 0.5), center = true );\n\t\t\t}\n}\n}\ndefQ = 32;\nfunction get_thr_qual(dia) = lookup(dia, [\n[5,10],[6,12],[7,14],[8,16],[10,20],[12,12],[14,28],[16,32],[18,36],[20,40],[22,44],[24,48],[27,54],[30,60],[33,66],[36,72],[39,78],[42,84],[45,90],[48,96],[52,104],[56,112],[60,120],[64,128],[78,156]]);\nfunction get_sh_qual(dia) = lookup(dia, [\n[5,10],[6,12],[7,14],[8,16],[10,20],[12,24],[14,28],[16,32],[18,36],[20,40],[22,44],[24,48],[27,54],[30,60],[33,66],[36,72],[39,78],[42,84],[45,90],[48,96],[52,104],[56,112],[60,120],[64,128],[78,156]]);\nmodule hex_nut(dia)\n{\n\t$fn = get_sh_qual(dia);\n\tthr = get_thr_qual(dia);\n\thi = hex_nut_hi(dia);\n\tdifference()\n\t{\n\t\tcylinder(r = hex_nut_dia(dia)/2,h = hi, $fn=6);\n\t\ttranslate([0,0,-0.1])\tcylinder(r = dia/2, h =hi + 0.2);\n\t}\n\ttranslate([0,0,0.1])\tthread_in(dia,hi-0.2,thr);\n}\nmodule hex_bolt(dia,hi)\n{\n\t$fn = get_sh_qual(dia);\n\tthr = get_thr_qual(dia);\n\thhi = hex_bolt_hi(dia);\n\tcylinder(r = hex_bolt_dia(dia)/2,h = hhi, $fn=6);\n\ttranslate([0,0,hhi-0.1])\tthread_out(dia,hi+0.1,thr);\n}\nfunction get_coarse_pitch(dia) = lookup(dia, [\n[1,0.25],[1.2,0.25],[1.4,0.3],[1.6,0.35],[1.8,0.35],[2,0.4],[2.5,0.45],[3,0.5],[3.5,0.6],[4,0.7],[5,0.8],[6,1],[7,1],[8,1.25],[10,1.5],[12,1.75],[14,1],[16,2],[18,2.5],[20,2.5],[22,2.5],[24,3],[27,3],[30,3.5],[33,3.5],[36,4],[39,4],[42,4.5],[45,4.5],[48,5],[52,5],[56,5.5],[60,5.5],[64,6],[78,5]]);\nfunction hex_nut_dia(dia) = lookup(dia, [\n[3,6.4],[4,8.1],[5,9.2],[6,11.5],[8,16.0],[10,19.6],[12,22.1],[16,27.7],[20,34.6],[24,41.6],[30,53.1],[36,63.5]]);\nfunction hex_nut_hi(dia) = lookup(dia, [\n[3,2.4],[4,3.2],[5,4],[6,3],[8,5],[10,5],[12,10],[14,5],[16,13],[20,16],[24,19],[30,24],[36,29]]);\nfunction hex_bolt_dia(dia) = lookup(dia, [\n[3,6.4],[4,8.1],[5,9.2],[6,11.5],[8,14.0],[10,16],[12,22.1],[16,27.7],[20,34.6],[24,41.6],[30,53.1],[36,63.5]]);\nfunction hex_bolt_hi(dia) = lookup(dia, [\n[3,2.4],[4,3.2],[5,4],[6,3.5],[8,4.5],[10,5],[12,10],[16,13],[20,16],[24,19],[30,24],[36,29]]);\nmodule thread_out(dia,hi,thr=defQ)\n{\n\tp = get_coarse_pitch(dia);\n\th = (cos(30)*p)/8;\n\tRmin = (dia/2) - (5*h);\n\ts = 360/thr;\n\tt = (hi-p)/p;\n\tn = t*thr;\n\tcylinder(r = Rmin, h = hi);\n\tfor(sg=[0:n])\n\t\tth_out_pt(Rmin-0.1,p,s,sg,thr,h,(hi-p)/n);\n}\nmodule th_out_pt(rt,p,s,sg,thr,h,sh)\n{\n\tas = (sg % thr) * s;\n\tae = as + s  - (s/100);\n\tz = sh*sg;\n\tcas=cos(as);\n\tsas=sin(as);\n\tcae=cos(ae);\n\tsae=sin(ae);\n\trtp=rt+(5*h);\n\tcasrt=cas*rt;\n\tsasrt=sas*rt;\n\tcaert=cae*rt;\n\tsaert=sae*rt;\n\tpolyhedron(\n\t\tpoints = [\n\t\t\t[casrt,sasrt,z],\n\t\t\t[casrt,sasrt,z+(3/4*p)],\n\t\t\t[cas*rtp,sas*rtp,z+(3/8*p)],\n\t\t\t[caert,saert,z+sh],\n\t\t\t[caert,saert,z+(3/4*p)+sh],\n\t\t\t[cae*rtp,sae*rtp,z+sh+(3/8*p)]],\n\t\ttriangles = [\n\t\t\t[0,1,2],\n\t\t\t[3,5,4],\n\t\t\t[0,3,4],[0,4,1],\n\t\t\t[0,5,3],[0,2,5],\n\t\t\t[1,4,5],[1,5,2]]);\n}\nmodule thread_in(dia,hi,thr=defQ)\n{\n\tp = get_coarse_pitch(dia);\n\th = (cos(30)*p)/8;\n\tRmin = (dia/2) - (5*h);\n\ts = 360/thr;\n\tt = (hi-p)/p;\n\tn = t*thr;\n\tdifference()\n\t{\n\t\tcylinder(r = (dia/2)+0.5,h = hi);\n\t\ttranslate([0,0,-1]) cylinder(r = (dia/2)+0.1, h = hi+2);\n\t}\n\tfor(sg=[0:n])\n\t\tth_in_pt(Rmin+0.2,p,s,sg,thr,h,(hi-p)/n);\n}\nmodule th_in_pt(rt,p,s,sg,thr,h,sh)\n{\n\tas = ((sg % thr) * s - 180);\n\tae = as + s -(s/100);\n\tz = sh*sg;\n\tcas=cos(as);\n\tsas=sin(as);\n\tcae=cos(ae);\n\tsae=sin(ae);\n\trtp=rt+(5*h);\n\tcasrt=cas*rt;\n\tcasrtp=cas*rtp;\n\tsasrt=sas*rt;\n\tsasrtp=sas*rtp;\n\tcaert=cae*rt;\n\tcaertp=cae*rtp;\n\tsaert=sae*rt;\n\tsaertp=sae*rtp;\n\tpolyhedron(\n\t\tpoints = [\n\t\t\t[casrtp,sasrtp,z],\n\t\t\t[casrt,sasrt,z+(3/8*p)],\n\t\t\t[casrtp,sasrtp,z+(3/4*p)],\n\t\t\t[caertp,saertp,z+sh],\n\t\t\t[caert,saert,z+(3/8*p)+sh],\n\t\t\t[caertp,saertp,z+(3/4*p)+sh]],\n\t\ttriangles = [\n\t\t\t[0,1,2],\n\t\t\t[3,5,4],\n\t\t\t[0,3,4],[0,4,1],\n\t\t\t[0,5,3],[0,2,5],\n\t\t\t[1,4,5],[1,5,2]]);\n}",
    "description": "Okay, I'm looking to design a mount that attaches a specific type of laser lens directly to a Reci CO2 laser tube. I've got some existing code that does this, but it's a bit monolithic and I'd really like to make it more parametric and easier to adapt for different lens and tube sizes.\n\nHere's the basic idea: I need a cylindrical piece that slides over the end of a Reci laser tube. This cylinder has to be fairly thick to be stable, so I need to be able to adjust its wall thickness and height. On the other end of this cylinder, I need a threaded mount for the laser lens.\n\nHere are the key parameters I'm looking to control:\n\n*   **`lensMountDiameter`**: The diameter of the threads on the laser lens mount. This needs to be adjustable. For my current setup, this is 14mm, but I might have other sizes in the future. The current code defaults to a fine (1mm pitch) thread if the diameter is 14mm, and course threads for other sizes, this is important.\n*   **`exteriorTubeDiameter`**: The outer diameter of the Reci laser tube. Currently set for the Reci W6 tube at 27.64mm. I need to be able to adjust this for other tubes.\n*   **`tubeHeight`**: The length of the cylindrical tube section that slides over the laser tube. This is currently 15mm, but I'd like to be able to adjust it.\n*   **`tubeWallThickNess`**: The thickness of the walls of the cylindrical tube section. This is currently 3mm, but I need it to be a parameter.\n*   **`collarHeight`**: A small collar area near the lens mount, I need it to be a parameter. This is currently 3mm.\n\nThe code I have also uses a thread library, which is really nice. I'd like the AI to reuse it. Here are the key details of the library usage:\n\n*   The library uses functions called `get_thr_qual` and `get_sh_qual` to determine the number of segments used in the thread. These functions use lookup tables. I will not attach the libraries but I expect you to understand the functionality I described.\n*   The library uses a function `get_coarse_pitch` to lookup the thread pitch based on diameter, using a lookup table. I need to make sure that if the `lensMountDiameter` is 14mm, the pitch is forced to 1mm for a fine thread, if I set a different value it should default to the correct course pitch.\n*   The library also has modules `hex_nut`, `hex_bolt`, `thread_out`, `thread_in`, `th_out_pt`, and `th_in_pt`.\n*   The library uses lookup tables `hex_nut_dia`, `hex_nut_hi`, `hex_bolt_dia`, `hex_bolt_hi`.\n\nI need a version that utilizes the existing thread library. The existing code also rotates the part 180 degrees on the Y-axis, please retain this functionality.\n\nCan you write a parametric OpenSCAD file based on the above using this thread library? I expect the file to be self contained, so there's no need to import any .scad files, the functions/modules should be inside this file. The library code is fine but will need to be made a bit more robust, as it only covers a portion of thread sizes.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Printrbot LC Z Stop Dial",
    "scad": "$fn=5*10;\nLength=65;\nDial=3;\nadd =\"pointer\";\ncylinder(h=Dial,r=10);\nif (add==\"knurled\")\n{\n  for ( i = [0 : 10] )\n  {\n      translate([sin(i*36)*9,cos(i*36)*9, 0]) cylinder(h=Dial,r=3);\n  }\n}\nif (add==\"pointer\")\n{\n    translate([-9,-9,0]) linear_extrude(height=Dial) polygon(points=[[0,0],[7,0],[0,7]], paths=[[0,1,2]]);\n}\ndifference () {\ncylinder(h=Length,r=4);\ntranslate([0,0,Length-15]) cylinder(h=20,r=1.5);\n}",
    "description": "Okay, I'm looking to design a knob for my 3D printer's Z-axis adjustment, and I'd like it to be parametric so I can easily adjust its size and features. I already have an idea of what I want, based on a simple .scad file I've been using, but it's not as flexible as I need.\n\nHere's what I'm aiming for:\n\n**Core Functionality:**\n\n*   **Knob for Z-axis:** It's primary purpose is to easily turn the Z-stop screw on my 3D printer. This means it should have a central hole that slides onto the existing screw.\n*   **Parametric Design:** I want to control the knob's dimensions using variables, and it would be great if these variables are easy to understand and use.\n\n**Specific Design Elements & Parameters:**\n\n*   **Total Length (Length):**  I need to be able to specify the total length of the knob (how far it sticks out).\n*   **Dial Thickness (Dial):** I need to be able to control the thickness of the dial part of the knob (the top part).\n*   **Center Hole Diameter (Hole_Diameter):** I need to control the diameter of the central hole that goes on the adjustment screw. Currently, I'm using a diameter of 4mm for the cylinder that slides onto the adjustment screw but I need to change it to a parameter called `Hole_Diameter`.\n*   **Hole Depth (Hole_Depth):** I need a parameter that controls the depth of the hole that will slide onto the adjustment screw. Currently, this is equal to the total length of the knob, but I would like to independently control this.\n*   **Optional Top Feature (add):** I would like this to be a choice of either 'none' (just a basic dial), 'pointer' (with a pointer feature on the top), or 'knurled' (with a knurled edge). \n    *   **Pointer Feature:** The pointer should be a small triangular extrusion on the top of the dial that makes it easy to visually track how much the knob has been turned. The location of the pointer should also be parametric.\n    *   **Knurled Edge:** The knurls should be small cylindrical extrusions around the edge of the dial to increase grip. I need control over the knurl diameter and the number of knurls, as well as the radius at which these knurls are placed.\n*   **Fillet Option** I would like an option to add fillets to the top edges of the knob. I would like to be able to control the radius of this fillet.\n\n**Parametric Variables:**\n\nI'd like to be able to specify all the following variables:\n*   `Length`: Total length of the knob.\n*   `Dial`: Thickness of the dial head.\n*   `Hole_Diameter`: Diameter of the center hole.\n*   `Hole_Depth`: Depth of the center hole.\n*   `add`: Specifies the top feature (none, pointer, or knurled)\n*   `Knurl_Diameter`: Diameter of the cylindrical extrusions on the knurled edge.\n*  `Knurl_Radius`: Radius from the knob center of the cylindrical extrusions on the knurled edge.\n*  `Knurl_Number`: Number of cylindrical extrusions on the knurled edge.\n*  `Pointer_Length`: The length of the two sides of the triangular pointer.\n*  `Pointer_Offset`: Distance from the knob center of the triangular pointer (both x and y).\n*   `Fillet_Radius`: Radius of the fillet on the top of the knob.\n\n**OpenSCAD Libraries:**\n\nI would prefer you not to use any external libraries.\n\nEssentially, I want a fully parametric version of this simple knob that can be easily customized to different printer setups. Please let me know if you need any more information, and thank you for your help!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Toilet Lower Seat Hinge Bracket",
    "scad": "BracketWidth = 13;\nBracketLength = 54;\nBracketHeight = 7.5;\nHingeWidth = BracketWidth;\nHingeLength = 9;\nHingeHeight = 15;\nHingeHoleRadius = 5;\nHingeHoleWallThickness = 3;\nHingeHoleRoundness = 0.01;\nMountingHoleSize = 4.5;\nMountingHoleScrewHeadSize = 9.5;\nMountingHoleScrewHeadthickness = 2.5;\nFirstMountingHole = 12.75;\nDistanceBetweenMountingHole =  18.8;\nScrewHeadRoundness = 5;\nScrewRoundness = 2;\nrotate(a=[0,-90,0]){\ndifference(){\n\tcube(size = [BracketWidth,BracketLength,BracketHeight], center = false);\n\ttranslate(v = [BracketWidth * .5, BracketLength - FirstMountingHole, 0]) cylinder(h=BracketHeight, r=MountingHoleSize/2, $fs=ScrewRoundness);\n\ttranslate(v = [BracketWidth * .5, BracketLength - FirstMountingHole, 0]) cylinder(h=MountingHoleScrewHeadthickness, r = MountingHoleScrewHeadSize/2, $fs=ScrewHeadRoundness);\n\ttranslate(v = [BracketWidth * .5, BracketLength - FirstMountingHole - DistanceBetweenMountingHole, 0]) cylinder(h=BracketHeight, r=MountingHoleSize/2, $fs=ScrewRoundness);\n\ttranslate(v = [BracketWidth * .5, BracketLength - FirstMountingHole - DistanceBetweenMountingHole, 0]) cylinder(h=MountingHoleScrewHeadthickness, r = MountingHoleScrewHeadSize/2, $fs=ScrewHeadRoundness);\n\ttranslate(v = [BracketWidth * .25, BracketLength * .5, BracketHeight * .5]) cube(size = [.1,BracketLength,.1], center = false);\n\ttranslate(v = [BracketWidth * .5, BracketLength * .5, BracketHeight * .5]) cube(size = [.1,BracketLength,.1], center = false);\n\ttranslate(v = [BracketWidth * .75, BracketLength * .5, BracketHeight * .5]) cube(size = [.1,BracketLength,.1], center = false);\n}\ndifference() {\n\thull(){\n\t\ttranslate(v = [0, BracketLength, 0]) cube(size = [HingeWidth,HingeLength,HingeHeight], center = false);\n\t\ttranslate(v = [0, BracketLength +HingeHoleRadius + HingeHoleWallThickness, HingeHeight +BracketHeight]) rotate(a=[0,90,0]) cylinder(h = BracketWidth, r=HingeHoleRadius + HingeHoleWallThickness, center = false, $fa=HingeHoleRoundness);\n\t}\n\ttranslate(v = [-1, BracketLength +HingeHoleRadius + HingeHoleWallThickness, HingeHeight  + BracketHeight]) rotate(a=[0,90,0]) cylinder(h = BracketWidth*2, r=HingeHoleRadius, center = false, $fa=HingeHoleRoundness);\n\ttranslate(v = [BracketWidth * .25, BracketLength * .5, BracketHeight * .5]) cube(size = [.1,BracketLength,.1], center = false);\n\ttranslate(v = [BracketWidth * .5, BracketLength * .5, BracketHeight * .5]) cube(size = [.1,BracketLength,.1], center = false);\n\ttranslate(v = [BracketWidth * .75, BracketLength * .5, BracketHeight * .5]) cube(size = [.1,BracketLength,.1], center = false);\n}\n}",
    "description": "Okay, so I've been trying to fix a broken toilet seat hinge with 3D prints, and I'm having some issues. I found a design on Thingiverse (http://www.thingiverse.com/thing:6971) but it broke really quickly. I think part of the problem was that I also used these shims (http://www.thingiverse.com/thing:29107) which, while helpful, ended up putting too much stress on the hinge because the screw holes didn't quite line up perfectly.\n\nI've adjusted my shims, but I also need a more robust hinge. I've started playing with OpenSCAD and put together something that's kind of close but could use some improvement. I'm attaching my current .scad file, \"LowerToiletHinge.scad\".\n\nHere's what I'm looking for:\n\nI need a parametric OpenSCAD design for a lower toilet seat hinge bracket, something that's designed to be strong but flexible enough to fit different toilet setups. I'm trying to make the hinge itself a little more robust to avoid the breakage issue I was experiencing.\n\nHere's a breakdown of the features and parameters I need:\n\n**General Layout & Dimensions (Relative to the bottom back of the seat):**\n\n*   **Bracket:** This is the flat, mounting part of the hinge.\n    *   `BracketWidth`: Width of the bracket.\n    *   `BracketLength`: Length of the bracket.\n    *   `BracketHeight`: Height (thickness) of the bracket.\n*   **Hinge Upright:** This is the vertical section that connects to the seat itself.\n    *   `HingeWidth`: Width of the hinge upright.\n    *   `HingeLength`: Length of the hinge upright.\n    *   `HingeHeight`: Height of the hinge upright.\n*   **Hinge Hole:** This is the hole for the hinge pin.\n    *   `HingeHoleRadius`: Radius of the hinge hole.\n    *   `HingeHoleWallThickness`: Thickness of the material around the hinge hole.\n    *   `HingeHoleRoundness`:  A parameter controlling the smoothness of the circle for the hinge hole (smaller value means a smoother circle, but slower rendering). This should be controlled by `$fa`.\n\n*   **Mounting Holes:** These are the screw holes for attaching the hinge to the toilet.\n    *   `MountingHoleSize`: Diameter of the mounting holes.\n    *   `MountingHoleScrewHeadSize`: Diameter of the countersunk section for screw heads.\n    *   `MountingHoleScrewHeadthickness`: Thickness of the countersunk section for screw heads.\n    *   `FirstMountingHole`: Distance of the first mounting hole from the back of the bracket.\n    *   `DistanceBetweenMountingHole`: Distance between the two mounting holes.\n    *   `ScrewHeadRoundness`: This controls the roundness of the countersunk screw hole (lower values give a more circular result, and is controlled by `$fa`).\n     *  `ScrewRoundness`: This controls the roundness of the screw hole (lower values give a more circular result, and is controlled by `$fa`).\n*   **Reinforcement Pins:** I've added some small pins down the length of the neck to strengthen it.\n\n**Specific Modeling Requests:**\n\n1.  **Rotation for Printing:** The design should be initially modeled so that the bottom bracket is flat on the build plate, and then rotated 90 degrees on the Y-axis (a=[0, -90, 0]) *after* all the shapes are generated to make printing easier. This is very important!\n2.  **Countersunk Holes:** The mounting holes should have a countersunk section to allow for the screw heads to sit flush.\n3.  **Hinge Hole Placement:** The hinge hole should be centered on the hinge upright with a flat bottom.\n4. **Reinforcement:** Use the reinforcement pins on both the flat bracket and the hinge upright, as implemented in my attached file.\n5.  **Use `hull()` for the hinge upright.** As used in my attached file, I like the look, but I'm open to suggestions if this isn't the most efficient way to model this.\n6.  **Good Defaults:** Please give me reasonable default values for all the parameters in case I'm working from a new toilet design that I haven't measured.\n7.  **Modularity/Best Practices:** If you have any suggestions on how to better design the script for readability, maintainability, or potential future modifications I'm happy to hear them!\n\nCould you please generate a fully parametric OpenSCAD file for me? I'm not using any extra libraries beyond what's standard.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Remote Control Holder",
    "scad": "use <MCAD/boxes.scad>;\nAddTriangles=1;\nKT=20;\nST=5;\nT=2;\nBD=KT+ST+2*T;\nBW=45;\nBL=90;\nFW=25;\nmodule Triangle(h) {\n\tlinear_extrude(height=h, center=false, convexity=10, twist=0)\n\t\tpolygon(\n\t\t\tpoints=[[0,0],[0,5.5],[5.5,5.5]],\n\t\t\tpaths=[[0,1,2]]);\n}\nmodule BracketHoles() {\n\tfor (i=[-20, 0, 20])\n\t{\n\t\ttranslate([0,KT/2,i])\n\t\t\trotate([90,0,0])\n\t\t\t\tcylinder(h=KT, r=2.5, center=true);\n\t}\n}\nmodule RemoteControlBracket() {\n\tunion() {\n\t\tdifference() {\n\t\t\troundedBox([BW,BD,BL], 5, false);\n\t\t\ttranslate([0,-(ST-T)/2,T])\n\t\t\t\troundedBox([BW-2*T,KT,BL], 2, true);\n\t\t\ttranslate([0,ST/2,10])\n\t\t\t\troundedBox([BW/3,KT,BL], 2, true);\n\t\t\ttranslate([0,-(KT+ST+T)/2,30])\n\t\t\t\trotate([90,90,0])\n\t\t\t\t\troundedBox([BL,FW,ST], 2, true);\n\t\t\tBracketHoles();\n\t\t}\n\t\tif (AddTriangles)\n\t\t{\n\t\t\ttranslate([T+5.5-BW/2,T-BD/2,2*T-BL/2])\n\t\t\t\trotate([0,0,90])\n\t\t\t\t\tTriangle(BL-T*3);\n\t\t\ttranslate([BW/2-T+0.1,T+5.6-BD/2,2*T-BL/2])\n\t\t\t\trotate([0,0,180])\n\t\t\t\t\tTriangle(BL-T*3);\n\t\t\ttranslate([T/2-BW/2, 5.5+T-BD/2, 6-T-BL/2])\n\t\t\t\trotate([0,90,0])\n\t\t\t\t\trotate([0,0,180])\n\t\t\t\t\t\tTriangle(BW-T);\n\t\t}\n\t}\n}\nRemoteControlBracket();",
    "description": "Okay, I'm trying to design a holder for my power remote control, the kind that controls multiple outlets. I want something that can be mounted to the side of my bed, a wall, or even a bookshelf.\n\nI've already got a basic design started in OpenSCAD, and I'm hoping you can help me make it more flexible and parametric. I've included the code below, but let me walk you through what I've done so far. It uses the `boxes.scad` library from MCAD.\n\nThe code defines a `RemoteControlBracket` module that creates a sort of box-like holder. It's got a cutout for the remote itself, and smaller cutouts for what I was thinking would be screw heads. There's also a large rectangular cutout at the front, presumably for the remote's buttons to be accessible. It also has some screw holes.  I've also added some optional triangular bracing to make it a bit sturdier.\n\nHere are the specific parameters I'm using right now:\n\n*   **KT** (Remote Control Thickness):  Currently set to 20.\n*   **ST** (Screw Head Thickness): Set to 5\n*   **T** (Wall Thickness): Set to 2.\n*   **BD** (Box Depth): Calculated as KT + ST + 2*T.\n*   **BW** (Box Width): Set to 45.\n*   **BL** (Box Length): Set to 90.\n*   **FW** (Front Hole Width): Set to 25.\n*   **AddTriangles** (Option to add support triangles): 1 or 0 (true/false)\n\nWhat I'd like your help with is turning these parameters into variables that are easy to adjust so I can adapt this holder to different remote sizes. Also, the screw holes are just in a line at the back and are fixed, it would be nice if there were a configurable way to have these holes placed.\n\nSpecifically, I'd like the following:\n\n1.  **Make all dimensions parametric:**  I want to be able to easily change the remote control's dimensions (length, width, thickness) and have the holder adjust accordingly. The screw head thickness and wall thickness should also be adjustable.\n\n2.  **Configurable screw hole placement:**  Instead of the current fixed positions for screw holes, I'd like parameters that control:\n    *   The number of screw holes.\n    *   The vertical spacing between screw holes.\n    *   The distance of the screw holes from the left/right edges of the holder.\n    *   The diameter of the screw holes.\n\n3.  **Support for different mounting:**  While the current version is designed for flat mounting, I'd like to add options or parameters for other mounting methods (like slots for screws that allow the screw to slide, for example). This may be something I do on my own, but if you have suggestions I'm open to it.\n4. **Front cutout:** I would like to be able to change the shape of the front cutout (e.g. rectangular, rounded corners, circular).\n5. **Optional rounded corners**: I would like a parameter to control whether the holder has rounded corners, and the size of the rounding.\n\nBasically, I'm aiming for a generic remote control holder module that can adapt to most remote controls and various mounting configurations.  Could you help me rewrite the OpenSCAD code to achieve that? I'm happy to do some of the work myself but I need help figuring out how to parametrize everything and get the screw hole positioning system working.\n\nThanks in advance for your help!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Ring",
    "scad": "include <write/Write.scad>\nmessage = \"i <3 MakerBot\";\nFont = \"write/Letters.dxf\";\nfont_size = 10;\nfont_spacing = 0;\nring_thickness = 1.6;\nring_width = 6;\nring_size = 18.14;\ninner_diameter = ring_size;\ninner_radius = inner_diameter/2;\nfont_scale = font_size/10;\nspacing_factor = font_spacing/100;\ntranslate([0,0,ring_width/2])\nring();\nmodule ring() {\n\tif(ring_thickness == .8){\n\t\tdifference(){\n\t\t\tdifference(){\n\t\t\t\ttranslate([0,0,0])\n\t\t\t\t\tcylinder(r=inner_radius+ring_thickness,h=ring_width,$fn = 100,center = true);\n\t\t\t\tscale(font_scale)\n\t\t\t\twritecylinder(message,[0,0,0],((inner_radius+ring_thickness)/font_scale)+.1,ring_width,space=1.05+spacing_factor,rotate=0,up=.5,center = true,font = Font);\n\t\t\t}\n\t\t\tcylinder(r=inner_radius,h=ring_width+1,$fn = 100,center = true);\n\t\t}\n\t}\n\telse{\n\t\tdifference(){\n\t\t\tdifference(){\n\t\t\t\ttranslate([0,0,0])\n\t\t\t\t\tcylinder(r=inner_radius+ring_thickness,h=ring_width,$fn = 100,center = true);\n\t\t\t\tscale(font_scale)\n\t\t\t\twritecylinder(message,[0,0,0],(inner_radius+ring_thickness)/font_scale*1.01,ring_width,space=1.05+spacing_factor,rotate=0,up=.5,center = true,font = Font);\n\t\t\t}\n\t\t\tcylinder(r=inner_radius,h=ring_width+1,$fn = 100,center = true);\n\t\t}\n\t}\n}",
    "description": "Okay, I'm trying to create a custom ring with a message on it using OpenSCAD. I found a great example online that uses the `write/Write.scad` library, and I'd like to adapt it to make my own ring design more flexible. \n\nHere's what I'm looking for:\n\n**Core Functionality:**\n\n*   I need a ring with a circular cross-section.\n*   The ring should have a customizable message engraved (or rather, cut out) on its outer surface, using the `writecylinder` function from the `write/Write.scad` library.\n*   The design should allow me to choose from different fonts available within the library (like \"Letters.dxf\", \"orbitron.dxf\", and \"BlackRose.dxf\").\n\n**Customizable Parameters:**\n\n*   **Message:**  A text string (limited to 26 characters, like in the example I found) that will be engraved on the ring.\n*   **Font:**  A selection from the font options within the `write/Write.scad` library.  I should be able to easily switch between \"Letters.dxf\", \"orbitron.dxf\", and \"BlackRose.dxf\" (or add others if the library has them).\n*   **Font Size:**  The size of the text characters. I'd like a range, maybe something like 10 to 20, so I can adjust the message's size on the ring.\n*  **Font Spacing:** I would like to adjust the space between the letters (positive and negative values).\n*   **Ring Thickness:** The thickness of the ring's wall (the difference between the inner and outer radius). It would be cool to have some presets like \"Thin,\" \"Normal,\" and \"Thick\", which correspond to 0.8mm, 1.6mm, and 2.4mm, or that I could define manually as a numeric variable.\n*   **Ring Width:**  The height of the ring (the distance along the Z-axis). I was thinking of a range of 6-12 mm, or a numeric variable.\n*   **Ring Size:** The inner diameter of the ring, which will be based on US ring sizes. I need a comprehensive list of US ring sizes like the example I found, with associated inner diameter values. This will let me specify the size of the ring using standard US sizes, rather than diameter directly.\n\n**Specific Requests for the OpenSCAD code:**\n\n1.  **Parametric Design:**  All the above parameters should be easily adjustable at the beginning of the file using variables, like how the example `message_ring_customizer.scad` does.\n2.  **Use of `write/Write.scad`:**  The code needs to correctly use the `writecylinder` function from the `write/Write.scad` library to generate the text engraving.\n3.  **Ring Sizing:** It would be best if you could implement the ring sizes using a look-up table or some other easy-to-use method so that I don't have to manually look up each ring size diameter. If you use a module or a function, please explain how to add more sizes or adjust the default list.\n4.  **Clean Code:** Please make the code reasonably well-commented and readable.\n\nEssentially, I want a fully customizable ring generator that's easy to use. Can you help me create a parametric OpenSCAD file based on the example I provided, incorporating these enhancements?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Simple Cup or Vase",
    "scad": "1_res = 5;\nradius_1 = 30;\nheight_1 = 30;\nt_wall = 1;\nt_bottom = 2;\ndifference()\n{\ntranslate([0, 0, height_1/2])\ncylinder(r = radius_1, h = height_1, center = true, $fn = 1_res);\ntranslate([0, 0, t_bottom + 2*height_1/2])\ncylinder(r = radius_1-t_wall, h = 2*height_1, center = true, $fn = 1_res);\n}",
    "description": "Okay, I'm looking for an OpenSCAD design for a customizable cup or vase, similar to the one I saw on Thingiverse, but I'd like a few more options and flexibility. \n\nHere's what I'm envisioning:\n\n**Core Shape:**\n\n*   I want to start with a basic cylinder, but also have an option to use a regular polygon for the base and top cross-section.\n*   The user should be able to specify the number of sides for the polygon option, or just use a circle by setting the number of sides to something high, or maybe an explicit \"circle\" toggle.\n\n**Dimensions:**\n\n*   **Outer Radius (or Polygon Radius):** User-definable. This would be the radius of the cylinder, or the circumradius of the polygon.\n*   **Height:** User-definable.\n*   **Wall Thickness:** User-definable, allowing for both thin and thick walls. Should also allow for a negative wall thickness (as the example did).\n*   **Bottom Thickness:** User-definable, also allowing negative values to make it a hollow cylinder/polygon instead of a cup with a solid bottom.\n\n**Advanced Features:**\n\n*   **Tapering:** I'd like an option to taper the cup, so the radius (or polygon size) is different at the top than at the base. This should be controlled by a separate parameter for the top radius or top polygon size. If no top radius/polygon size is provided, the top and base should have the same cross-section.\n*   **Wall Texture:** I'm interested in having an option to add a simple texture to the outside wall. Perhaps an option to add a series of vertical grooves or ridges, or a simple repeating pattern. I think this can be a toggle with a height, width, and depth parameter for the texture.\n*   **Smoothing:** Allow an option to \"smooth\" the edges of the wall texture features by adding fillets to the vertical edges of the grooves or ridges.\n*   **Handles:** I'd like the option to add handles. I think a simple, rounded handle would be a good starting point. The handle should have adjustable parameters for size and placement, as well as a count parameter in case someone wants two handles.\n\n**Output:**\n\n*   The OpenSCAD code should be well-commented and easy to understand.\n*   The code should have sensible default values.\n*   It should make use of the BOSL2 library if that would make the code more concise and readable.\n\nI think that should cover all the things I'd like to be able to adjust. I'm looking forward to seeing what you can come up with.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Key Tray",
    "scad": "centreD=3.8;\ncentreH=10;\nsteamventD=1.6;\nsteamventT=54;\nsteamventH=15;\nbowlsupportH=10;\nbowlsupportT=40;\nlayerhight=0.2+1-1;\ncentreR=centreD/2;\nsteamventR=steamventD/2;\nsteamventE=steamventR*2;\nmikiears=layerhight*6;\nrotate([0,0,45]){\ncylinder(centreH,centreR,centreR);\ntranslate([steamventT,0,0]){\n\tcylinder(steamventH,steamventR,steamventR);\n\tcylinder(mikiears,steamventE,steamventE);}\n\ttranslate([0,-2,0])cube([54,4,3]);\nrotate([0,0,45]){\n\ttranslate([bowlsupportT,0,0]){\n\t\tcylinder(bowlsupportH,steamventD,steamventD);\n\t\tcylinder(mikiears,steamventD,steamventE);}\n\ttranslate([0,-2,0])cube([bowlsupportT,4,3]);}\nrotate([0,0,165]){\n\ttranslate([bowlsupportT,0,0]){\n\t\tcylinder(bowlsupportH,steamventD,steamventD);\n\t\tcylinder(mikiears,steamventD,steamventE);}\n\ttranslate([0,-2,0])cube([bowlsupportT,4,3]);}\nrotate([0,0,285]){\n\ttranslate([bowlsupportT,0,0]){\n\t\tcylinder(bowlsupportH,steamventD,steamventD);\n\t\tcylinder(mikiears,steamventD,steamventE);}\n\ttranslate([0,-2,0])cube([bowlsupportT,4,3]);}\n}",
    "description": "Okay, I have this basic key tray design in OpenSCAD, and I'd like to take it a step further. I want to create a design that can accommodate various sizes of glass pot lids and hold them securely, turning them into stylish key trays.\n\nCurrently, my design (attached, called Key_tray.scad) has a central spire, a steam vent, and three bowl supports that are rotated around the center. All these are built using cylinders and cubes. However, it is designed for one specific pot lid. I need to make it parametric so the diameter of the outer supports is linked to the pot lid used. I would also like to improve the overall aesthetic and functionality. \n\nHere are my specific needs and requests:\n\n1.  **Parametric Lid Support:** The most crucial part is making the bowl supports (the 3 supports rotated around the center) adjustable for different pot lid sizes. Instead of having a fixed `bowlsupportT` (radius from the center), I'd like to use a parameter that represents the *radius of the pot lid* being used. Then, the supports should be positioned so they are just *inside* the edge of the pot lid. I need a way to specify the pot lid diameter/radius and have the bowl supports reposition and expand to accommodate the chosen lid.\n    \n2.  **Variable Support Thickness:**  Instead of fixed cube supports, could you make those a bit more adjustable in how they attach to the center? The current design has a `bowlsupportT` that translates the cylinders and cubes directly outwards. Instead of a simple translation, could this use an `offset` parameter (or something similar) so they can support different thickness lids? Maybe a \"clamp\" function?\n    \n3.  **Adjustable Steam Vent:** The steam vent is currently just a cylinder. It needs to be adjustable in height. It would also be good to have it adjustable in the distance from the center.\n\n4.  **Slightly Different Bowl Support Design:**  Instead of just a cylinder with a flat cylinder, could we explore different support shapes? Something that provides a bit more contact with the underside of the pot lid, maybe a slightly curved or angled design?\n\n5.  **Base Plate:** Currently the design has no base. I want to add a base to provide some stability. This base should also have a parameter so that it can adjust to the diameter of the lid used.\n\n6. **Variable Material Thickness:** I need to be able to control the material thickness in mm. So, the thickness of the \"base plate\" as well as the thickness of the steam vents and support bars.\n\n7.  **Use of Libraries:** Please use the `BOSL` library where applicable for things like arcs and maybe some of the transformation functions, but I don't need anything fancy. Please specify which specific libraries are used (e.g. MCAD, BOSL, BOSL2, dotSCAD, NopSCADlib, BOLTS).\n\nEssentially, I want a fully parametric key tray generator that takes a pot lid size as a main input and automatically generates a design that securely holds it while looking good. The design should be easy to customize, and I'd like to have multiple parameters for all the key features. Let me know if you have any questions or need more information.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Catapult with Text",
    "scad": "include <smallsidefont.scad>;\nprojectile_diameter = 13;\ncatapult_length = 100;\ncatapult_thickness = 2;\nplay = 0.5;\nbuildBase = true;\nbuildArm = true;\nmargin = 2;\ncw = 2 * projectile_diameter/3;\nct = catapult_thickness;\nrs = projectile_diameter/3;\nbr = rs/3;\nfnrs = 32;\nhr = (projectile_diameter-1)/2;\ner = 1.4 * hr;\nhw = cw/2;\nxs = rs + cw/2;\nys = sqrt((er+rs)*(er+rs)-(hw+rs)*(hw+rs));\nlb = catapult_length-2*ys-br ;\nbase_w = max (15, cw*1.4);\nbase_h = catapult_length*0.6;\nbase_t = ct*1.5;\nbaseOffW = (buildArm ? base_w/2 + margin : 0);\ntranslate([-baseOffW-base_w/4,-20, base_t+base_t/10]) scale([2,2,1]) writeText(0.28,0.5,3,[\"P\",\"H\",\"I\",\"N\"],4,[0,4,8,11.5],14.5);\nif (buildBase) {\n\ttranslate ([baseOffW, 0, base_t/2])\n\tdifference() {\n\t\tunion () {\n\t\t\troundBox(base_w, base_h, base_t, 2);\n\t\t\ttranslate ([0, -base_h/8 +base_h*0.33 , base_t/2])\n\t\t\trotate (90, [0, -1, 0])\n\t\t\tlinear_extrude(height=base_w, center=true)\n\t\t\tpolygon(points=[[0,0],[0,base_h/4],[base_t*1.2,base_h/4-base_h/16],[base_t*1.2,base_h/16]], paths=[[0,1,2,3]]);\n\t\t}\n\t\ttranslate([0, -base_h*0.15, 0])\n\t\troundBox(cw, base_h*0.3, base_t*2, 2);\n\t\ttranslate ([0, base_h*0.3, 0])\n\t\trotate(-45, [1, 0, 0])\n\t\tcube([cw+play,catapult_length, ct+play], center=true );\n\t}\n}\noffW = (buildBase ? -er - margin: 0);\nif (buildArm) {\ntranslate([offW, catapult_length/2 -ys -br, ct/2])\ndifference() {\n\tunion () {\n\t\tcylinder (r=er, h = ct, center=true, $fn=fnrs);\n\t\troundedLink(xs, ys, rs, ct);\n\t\troundedLink(xs, -ys, rs, ct);\n\t\troundedLink(-xs, -ys, rs, ct);\n\t\troundedLink(-xs, ys, rs, ct);\n\t\ttranslate ([xs-rs-br, ys, 0])\n\t\tcylinder (r=br, h=ct, center=true, $fn=fnrs);\n\t\ttranslate ([-xs+rs+br, ys, 0])\n\t\tcylinder (r=br, h=ct, center=true, $fn=fnrs);\n\t\ttranslate([0, ys, 0])\n\t\tcube([2*(xs-rs-br), 2*br, ct], center=true);\n\t\ttranslate([0, -(ys+lb/2-br/2), 0])\n\t\tcube([cw, lb - br, ct], center=true);\n\t\ttranslate([cw/2-br, -(ys+lb-br), 0])\n\t\tcylinder (r=br, h=ct, center=true, $fn=fnrs);\n\t\ttranslate([-cw/2+br, -(ys+lb-br), 0])\n\t\tcylinder (r=br, h=ct, center=true, $fn=fnrs);\n\t\ttranslate([0, -(ys+lb-br), 0])\n\t\tcube([2*(xs-rs-br), 2*br, ct], center=true);\n\t}\n\tcylinder (r=hr, h = ct*1.2, center=true, $fn=fnrs);\n}\n}\nmodule roundedLink(xr, yr, rc, rt) {\n\tdifference () {\n\t\tlinear_extrude(height=rt, center=true)\n\t\tpolygon(points=[[0,0],[xr,yr],[0,yr]], paths=[[0,1,2]]);\n\t\ttranslate ([xr, yr, 0])\n\t\tcylinder (r=rc, h=rt*1.2, center=true, $fn=fnrs);\n\t}\n}\nmodule roundBox(bw, bh, bt, rb) {\n\tunion () {\n\t\tcube([(bw-2*rb)*1.05, (bh-2*rb)*1.05, bt], center=true);\n\t\ttranslate ([(bw-rb)/2, 0, 0])\n\t\tcube([rb, bh-2*rb, bt], center=true);\n\t\ttranslate ([-(bw-rb)/2, 0, 0])\n\t\tcube([rb, bh-2*rb, bt], center=true);\n\t\ttranslate ([0, -(bh-rb)/2, 0])\n\t\tcube([bw-2*rb, rb, bt], center=true);\n\t\ttranslate ([0, (bh-rb)/2, 0])\n\t\tcube([bw-2*rb, rb, bt], center=true);\n\t\ttranslate ([(-bw+2*rb)/2, (bh-2*rb)/2, 0])\n\t\tcylinder (r=rb, h = bt, center=true, $fn=fnrs);\n\t\ttranslate ([(bw-2*rb)/2, (bh-2*rb)/2, 0])\n\t\tcylinder (r=rb, h = bt, center=true, $fn=fnrs);\n\t\ttranslate ([(-bw+2*rb)/2, (-bh+2*rb)/2, 0])\n\t\tcylinder (r=rb, h = bt, center=true, $fn=fnrs);\n\t\ttranslate ([(bw-2*rb)/2, (-bh+2*rb)/2, 0])\n\t\tcylinder (r=rb, h = bt, center=true, $fn=fnrs);\n\t}\n}",
    "description": "Okay, I'd like to design a catapult, similar to the one I've been using, but I need it to be more customizable. I've got 5 boys, and anything I print for them needs to be labeled immediately, or chaos ensues! I've been using a derivative of a design that allows for text using the `smallsidefont.scad` library from thingiverse, and a 13mm diameter for the projectile is perfect for marbles, and 30 for a ping pong ball. \n\nHere's what I need this new design to do:\n\n1.  **Projectile Diameter:** I need a variable for the `projectile_diameter` so I can easily switch between marble (13mm) and ping pong (30mm), or anything else I might want to throw.\n\n2.  **Catapult Dimensions:** I want to be able to change the overall `catapult_length` and the `catapult_thickness`. I'd also like to control how much space is allowed for movement of the arm, a `play` variable.\n\n3.  **Base and Arm Options:** I need boolean variables to control whether to build the base (`buildBase`) and arm (`buildArm`).\n\n4.  **Text Customization:** I absolutely need to be able to customize the text that appears on the catapult, and specify its position. It would be great if I could use `smallsidefont.scad` for this since it works well. I'd need to be able to set:\n    *   The text string itself, which can be a list of individual characters.\n    *   The character spacing.\n    *   The font size.\n    *   The text position on the base, as well as the rotation angle of the text to match the side of the catapult.\n\n5.  **Overall Parametric Design:** I want the design to be fully parametric so that all the other dependent dimensions and positions (like the width and height of the base, the arm lengths and positions, the roundness of the corners) are calculated automatically based on the variables I set in #1-4 above. \n\nEssentially, I want to take the current design, but make it completely customizable based on the variables above. I've included the code for the current catapult and the `smallsidefont.scad` code I'm using if you need it. I'm not looking for you to recreate `smallsidefont.scad` though, just use it.\n\nI'm using OpenSCAD so if you can provide the code that would be great.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Sign",
    "scad": "use <write/Write.scad>\nsign_size = 0;\nmanual_length = 100;\nmanual_width = 100;\nmessage_one = \"Stand Back!\";\nfont_one_size = 60;\nmessage_two = \"I`m Going to Make a Thing!\";\nfont_two_size = 30;\nFont = \"write/orbitron.dxf\";\nicon = 0;\nicon_size = 12;\nicon_rotation = 0;\nhole_radius = 2.5;\nemboss_style = 0;\nbuild_plate_size = sign_size;\nmanual_build_plate_length = manual_length;\nmanual_build_plate_width = manual_width;\nholeR = hole_radius;\nfont_one_scale = font_one_size/10;\nfont_two_scale = font_two_size/10;\nREP2length = 285/1;\nREP2width = 153/1;\nREP1length = 225/1;\nREP1width = 145/1;\nToMlength = 120/1;\nToMwidth = 120/1;\nheight = 5/1;\ncornerR = 15/1;\nicon_rot = icon_rotation*-9;\nmain();\nicon_scale = icon_size/5;\nmodule main() {\n\tplateLength = 0;\n\tplateWidth = 0;\n\tif(build_plate_size == 0){\n\t\tassign(plateLength = REP2length - 20){\n\t\t\tassign(plateWidth = REP2width - 20){\n\t\t\t\techo(plateLength);\n\t\t\t\techo(plateWidth);\n\t\t\t\tsign(plateLength,plateWidth);\n\t\t\t}\n\t\t}\n\t}\n\tif(build_plate_size == 1){\n\t\tassign(plateLength = REP1length - 20){\n\t\t\tassign(plateWidth = REP1width - 20){\n\t\t\t\tsign(plateLength,plateWidth);\n\t\t\t}\n\t\t}\n\t}\n\tif(build_plate_size == 2){\n\t\tassign(plateLength = ToMlength - 20){\n\t\t\tassign(plateWidth = ToMwidth - 20){\n\t\t\t\tsign(plateLength,plateWidth);\n\t\t\t}\n\t\t}\n\t}\n\tif(build_plate_size == 3){\n\t\tassign(plateLength = manual_build_plate_length - 20){\n\t\t\tassign(plateWidth = manual_build_plate_width - 20){\n\t\t\t\tsign(plateLength,plateWidth);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule sign(pL,pW) {\n\tplateLength = pL;\n\tplateWidth = pW;\n\ttranslate([-plateLength/2,-plateWidth/2,0])\n\tdifference(){\n\t\tif(emboss_style == 0){\n\t\t\tunion(){\n\t\t\t\ttranslate([plateLength/2,plateWidth-20,5])\n\t\t\t\t\tcolor([1,1,1])\n\t\t\t\t\t\tscale([font_one_scale,font_one_scale,5])\n\t\t\t\t\t\t\twrite(message_one,space=1.05,center = true,font = Font);\n\t\t\t\ttranslate([plateLength/2,20,5])\n\t\t\t\t\tcolor([1,1,1])\n\t\t\t\t\t\tscale([font_two_scale,font_two_scale,5])\n\t\t\t\t\t\t\twrite(message_two,space=1.05,center = true,font = Font);\n\t\t\t\tcolor([1,1,1]){\n\t\t\t\t\ttranslate([plateLength/2,plateWidth/2,5])\n\t\t\t\t\t\tlinear_extrude(height = 5, center = true, convexity = 10, slices = 5)\n\t\t\t\t\t\t\tscale([icon_scale,icon_scale,0]){\n\t\t\t\t\t\t\t\trotate([0,0,icon_rot]){\n\t\t\t\t\t\t\t\t\tif(icon == 0)\n\t\t\t\t\t\t\t\t\t\ttranslate([4,0,0])\n\t\t\t\t\t\t\t\t\t\tscale(.25)\n\t\t\t\t\t\t\t\t\t\tmakerbot_replicator_2();\n\t\t\t\t\t\t\t\t\tif(icon == 1)\n\t\t\t\t\t\t\t\t\t\tradiation();\n\t\t\t\t\t\t\t\t\tif(icon == 2)\n\t\t\t\t\t\t\t\t\t\tradiation_sign();\n\t\t\t\t\t\t\t\t\tif(icon == 3)\n\t\t\t\t\t\t\t\t\t\tscale(.2)\n\t\t\t\t\t\t\t\t\t\tskull_crossbones();\n\t\t\t\t\t\t\t\t\tif(icon == 4)\n\t\t\t\t\t\t\t\t\t\ttranslate([0,2,0])\n\t\t\t\t\t\t\t\t\t\tscale(.18)\n\t\t\t\t\t\t\t\t\t\thang_loose();\n\t\t\t\t\t\t\t\t\tif(icon == 5)\n\t\t\t\t\t\t\t\t\t\ttranslate([0,-1,0])\n\t\t\t\t\t\t\t\t\t\tscale(.15)\n\t\t\t\t\t\t\t\t\t\tmoney();\n\t\t\t\t\t\t\t\t\tif(icon == 6)\n\t\t\t\t\t\t\t\t\t\tbomb();\n\t\t\t\t\t\t\t\t\tif(icon == 7)\n\t\t\t\t\t\t\t\t\t\ttranslate([0,-1,0])\n\t\t\t\t\t\t\t\t\t\tscale([.8,.8,1])\n\t\t\t\t\t\t\t\t\t\tmakerbot_logo();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tunion(){\n\t\t\t\t\ttranslate([cornerR,0,0])\n\t\t\t\t\t\tcube([plateLength-cornerR*2,plateWidth,5]);\n\t\t\t\t\ttranslate([0,cornerR,0])\n\t\t\t\t\t\tcube([plateLength,plateWidth-cornerR*2,5]);\n\t\t\t\t\ttranslate([cornerR,cornerR,0])\n\t\t\t\t\t\tcylinder(h = height, r = cornerR);\n\t\t\t\t\ttranslate([cornerR+(plateLength-cornerR*2),cornerR,0])\n\t\t\t\t\t\tcylinder(h = height, r = cornerR);\n\t\t\t\t\ttranslate([cornerR,cornerR+(plateWidth-cornerR*2),0])\n\t\t\t\t\t\tcylinder(h = height, r = cornerR);\n\t\t\t\t\ttranslate([cornerR+(plateLength-cornerR*2),cornerR+(plateWidth-cornerR*2),0])\n\t\t\t\t\t\tcylinder(h = height, r = cornerR);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdifference(){\n\t\t\t\tunion(){\n\t\t\t\t\ttranslate([cornerR,0,0])\n\t\t\t\t\t\tcube([plateLength-cornerR*2,plateWidth,5]);\n\t\t\t\t\ttranslate([0,cornerR,0])\n\t\t\t\t\t\tcube([plateLength,plateWidth-cornerR*2,5]);\n\t\t\t\t\ttranslate([cornerR,cornerR,0])\n\t\t\t\t\t\tcylinder(h = height, r = cornerR);\n\t\t\t\t\ttranslate([cornerR+(plateLength-cornerR*2),cornerR,0])\n\t\t\t\t\t\tcylinder(h = height, r = cornerR);\n\t\t\t\t\ttranslate([cornerR,cornerR+(plateWidth-cornerR*2),0])\n\t\t\t\t\t\tcylinder(h = height, r = cornerR);\n\t\t\t\t\ttranslate([cornerR+(plateLength-cornerR*2),cornerR+(plateWidth-cornerR*2),0])\n\t\t\t\t\t\tcylinder(h = height, r = cornerR);\n\t\t\t\t}\n\t\t\t\tunion(){\n\t\t\t\t\ttranslate([plateLength/2,plateWidth-20,5])\n\t\t\t\t\t\tcolor([1,1,1])\n\t\t\t\t\t\t\tscale([font_one_scale,font_one_scale,5])\n\t\t\t\t\t\t\t\twrite(message_one,space=1.05,center = true,font = Font);\n\t\t\t\t\ttranslate([plateLength/2,20,5])\n\t\t\t\t\t\tcolor([1,1,1])\n\t\t\t\t\t\t\tscale([font_two_scale,font_two_scale,5])\n\t\t\t\t\t\t\t\twrite(message_two,space=1.05,center = true,font = Font);\n\t\t\t\t\tcolor([1,1,1]){\n\t\t\t\t\t\ttranslate([plateLength/2,plateWidth/2,5])\n\t\t\t\t\t\t\tlinear_extrude(height = 5, center = true, convexity = 10, slices = 5)\n\t\t\t\t\t\t\t\tscale([icon_scale,icon_scale,0]){\n\t\t\t\t\t\t\t\t\trotate([0,0,icon_rot]){\n\t\t\t\t\t\t\t\t\t\tif(icon == 0)\n\t\t\t\t\t\t\t\t\t\t\ttranslate([4,0,0])\n\t\t\t\t\t\t\t\t\t\t\tscale(.25)\n\t\t\t\t\t\t\t\t\t\t\tmakerbot_replicator_2();\n\t\t\t\t\t\t\t\t\t\tif(icon == 1)\n\t\t\t\t\t\t\t\t\t\t\tradiation();\n\t\t\t\t\t\t\t\t\t\tif(icon == 2)\n\t\t\t\t\t\t\t\t\t\t\tradiation_sign();\n\t\t\t\t\t\t\t\t\t\tif(icon == 3)\n\t\t\t\t\t\t\t\t\t\t\tscale(.2)\n\t\t\t\t\t\t\t\t\t\t\tskull_crossbones();\n\t\t\t\t\t\t\t\t\t\tif(icon == 4)\n\t\t\t\t\t\t\t\t\t\t\ttranslate([0,2,0])\n\t\t\t\t\t\t\t\t\t\t\tscale(.18)\n\t\t\t\t\t\t\t\t\t\t\thang_loose();\n\t\t\t\t\t\t\t\t\t\tif(icon == 5)\n\t\t\t\t\t\t\t\t\t\t\ttranslate([0,-1,0])\n\t\t\t\t\t\t\t\t\t\t\tscale(.15)\n\t\t\t\t\t\t\t\t\t\t\tmoney();\n\t\t\t\t\t\t\t\t\t\tif(icon == 6)\n\t\t\t\t\t\t\t\t\t\t\tbomb();\n\t\t\t\t\t\t\t\t\t\tif(icon == 7)\n\t\t\t\t\t\t\t\t\t\t\ttranslate([0,-1,0])\n\t\t\t\t\t\t\t\t\t\t\tscale([.8,.8,1])\n\t\t\t\t\t\t\t\t\t\t\tmakerbot_logo();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate([cornerR,cornerR+(plateWidth-cornerR*2),0])\n\t\t\tcylinder(h = height*4, r = holeR,center = true);\n\t\ttranslate([cornerR+(plateLength-cornerR*2),cornerR+(plateWidth-cornerR*2),0])\n\t\t\tcylinder(h = height*4, r = holeR,center = true);\n\t}\n}\nmodule radiation_sign() {\n  polygon(points=\n    [[1.129, -3.788], [0.798, -4.587], [0.000, -4.917], [-0.798, -4.587], [-1.129, -3.788], [-0.798, -2.990], [0.000, -2.660], [0.798, -2.990], [0.000, -5.482], [-0.853, -5.252], [-2.545, -8.181], [-1.339, -8.688], [0.000, -8.868], [1.339, -8.688], [2.545, -8.180], [0.854, -5.252], [1.708, -3.773], [1.707, -3.788], [5.084, -3.788], [4.921, -2.491], [4.408, -1.241], [3.582, -0.172], [2.540, 0.618], [0.857, -2.297], [1.473, -2.910], [-0.850, -2.293], [-2.540, 0.633], [-3.582, -0.156], [-4.408, -1.226], [-4.921, -2.477], [-5.084, -3.773], [-1.708, -3.773], [-1.471, -2.906], [13.832, -10.684], [0.975, 11.585], [0.535, 12.020], [0.000, 12.128], [-0.534, 12.020], [-0.975, 11.585], [-13.832, -10.684], [-13.981, -11.262], [-13.827, -11.812], [-13.432, -12.222], [-12.857, -12.383], [12.857, -12.383], [13.432, -12.222], [13.827, -11.811], [13.981, -11.262], [0.000, 8.757], [10.902, -10.125], [-10.902, -10.125]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 0, 0], [8, 9, 10, 11, 12, 13, 14, 15, 8, 8], [16, 17, 18, 19, 20, 21, 22, 23, 24, 16, 16], [25, 26, 27, 28, 29, 30, 31, 32, 25, 25], [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 33, 33], [48, 49, 50, 48, 48]]\n    );}\nmodule radiation(){\n\trad1();\n\trad2();\n\trad3();\n\trad4();\n}\nmodule rad1() {\n  polygon(points=\n    [[7.018, -11.155], [2.353, -3.148], [0.796, -3.660], [-0.117, -3.749], [-1.040, -3.660], [-2.605, -3.148], [-7.285, -11.155], [-5.350, -12.218], [-3.075, -12.948], [-0.056, -13.280], [2.932, -12.948], [5.155, -12.218]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0, 0, 0]]\n    );}\nmodule rad2() {\n  polygon(points=\n    [[-0.034, -1.810], [1.041, -1.592], [1.915, -0.998], [2.502, -0.120], [2.717, 0.953], [2.502, 2.031], [1.915, 2.913], [1.041, 3.508], [-0.034, 3.727], [-1.110, 3.508], [-1.988, 2.913], [-2.580, 2.031], [-2.797, 0.953], [-2.580, -0.120], [-1.988, -0.998], [-1.110, -1.592]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0]]\n    );}\nmodule rad3() {\n  polygon(points=\n    [[6.925, 13.117], [2.329, 5.064], [3.541, 3.977], [4.068, 3.232], [4.458, 2.369], [4.795, 0.729], [14.070, 0.739], [14.026, 2.934], [13.524, 5.263], [12.307, 8.042], [10.519, 10.471], [8.774, 12.034]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0, 0, 0]]\n    );}\nmodule rad4() {\n  polygon(points=\n    [[-14.057, 0.906], [-4.773, 0.906], [-4.445, 2.527], [-4.065, 3.372], [-3.526, 4.129], [-2.289, 5.231], [-6.898, 13.280], [-8.784, 12.138], [-10.553, 10.535], [-12.351, 8.088], [-13.559, 5.334], [-14.041, 3.047]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0, 0, 0]]\n    );}\nmodule bomb() {\n  polygon(points=\n    [[4.524, 11.943], [5.827, 12.172], [5.573, 10.404], [4.512, 9.325], [2.751, 9.059], [1.363, 9.795], [0.651, 11.207], [0.278, 11.893], [-0.435, 12.244], [-1.294, 12.113], [-1.822, 11.557], [-1.786, 9.807], [-0.483, 9.940], [0.253, 5.765], [3.952, 4.922], [6.671, 3.087], [8.621, 0.481], [9.616, -3.054], [9.581, -5.170], [9.143, -7.028], [7.504, -9.955], [5.111, -12.105], [1.833, -13.370], [-0.260, -13.535], [-2.245, -13.285], [-5.406, -11.898], [-7.750, -9.678], [-9.255, -6.662], [-9.621, -4.704], [-9.580, -2.632], [-8.458, 0.783], [-6.439, 3.310], [-3.644, 5.054], [-4.368, 9.252], [-3.077, 9.566], [-3.282, 11.026], [-2.908, 12.317], [-2.050, 13.184], [-0.797, 13.584], [0.256, 13.429], [1.061, 12.956], [1.954, 11.364], [2.447, 10.581], [3.330, 10.326], [4.273, 10.808]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 0, 0]]\n    );}\nmodule skull_crossbones() {\n  polygon(points=\n    [[-0.141, 68.518], [-8.246, 68.036], [-16.875, 66.590], [-25.281, 63.980], [-32.720, 60.007], [-32.720, 59.998], [-32.729, 59.998], [-38.887, 54.306], [-43.567, 47.249], [-46.438, 39.248], [-47.166, 30.727], [-47.157, 30.727], [-47.157, 30.718], [-46.182, 23.390], [-44.135, 16.606], [-41.131, 10.630], [-37.288, 5.724], [-38.100, 1.499], [-38.109, 1.438], [-38.109, 1.376], [-37.539, -7.221], [-36.202, -10.576], [-34.254, -13.070], [-34.254, -13.079], [-34.246, -13.079], [-34.122, -13.185], [-48.198, -6.112], [-49.915, -4.158], [-51.047, -1.914], [-52.689, 0.846], [-55.774, 3.563], [-55.906, 3.634], [-59.152, 4.639], [-61.630, 3.836], [-63.517, 1.632], [-63.623, 1.420], [-64.652, -2.617], [-64.893, -6.376], [-67.544, -8.756], [-70.220, -11.959], [-70.229, -11.968], [-71.225, -15.258], [-70.008, -17.939], [-68.001, -19.269], [-66.172, -19.835], [-66.172, -19.844], [-66.154, -19.844], [-62.319, -20.282], [-59.337, -19.949], [-54.363, -19.755], [-27.164, -32.782], [-27.172, -35.216], [-36.520, -40.073], [-46.460, -44.458], [-49.311, -44.736], [-51.496, -44.212], [-54.685, -43.799], [-59.513, -44.705], [-60.051, -44.996], [-61.668, -46.894], [-62.309, -49.150], [-61.887, -51.403], [-60.589, -53.357], [-60.545, -53.401], [-55.897, -57.829], [-55.077, -64.540], [-54.998, -64.911], [-53.409, -67.599], [-51.011, -68.897], [-48.466, -68.653], [-46.249, -67.398], [-45.949, -67.115], [-42.862, -63.244], [-42.853, -63.226], [-39.687, -58.331], [-22.419, -49.186], [-22.401, -49.177], [-18.613, -53.085], [-14.164, -55.774], [-14.129, -55.783], [-14.093, -55.800], [-7.127, -57.696], [0.256, -58.190], [7.502, -57.650], [14.314, -55.597], [18.755, -52.959], [22.569, -49.133], [39.511, -57.926], [42.483, -61.983], [43.560, -64.077], [45.473, -66.234], [45.464, -66.242], [45.579, -66.339], [47.775, -68.072], [50.112, -68.932], [52.598, -68.388], [54.574, -66.533], [54.707, -66.295], [55.976, -61.778], [56.338, -57.591], [61.251, -53.084], [61.277, -53.049], [62.573, -51.036], [62.865, -48.718], [61.804, -46.531], [59.672, -44.935], [59.540, -44.873], [55.585, -43.814], [51.091, -44.220], [51.073, -44.229], [48.795, -44.685], [46.284, -44.167], [46.284, -44.176], [27.375, -35.410], [27.367, -32.623], [27.437, -32.588], [54.010, -20.064], [54.019, -20.064], [56.508, -19.430], [58.252, -19.694], [60.457, -20.195], [63.597, -20.188], [63.641, -20.188], [66.430, -19.859], [68.923, -18.785], [70.755, -16.660], [71.322, -13.705], [71.031, -12.850], [64.981, -6.156], [64.588, -1.800], [63.341, 2.434], [63.147, 2.787], [61.544, 4.322], [59.249, 5.018], [58.922, 5.018], [56.557, 4.345], [54.169, 2.611], [54.107, 2.549], [54.019, 2.478], [51.950, 0.092], [50.808, -2.284], [47.986, -6.385], [34.784, -12.876], [36.714, -10.376], [38.039, -7.024], [38.602, 1.543], [38.594, 1.605], [38.585, 1.658], [37.650, 6.562], [41.657, 11.312], [44.858, 17.166], [46.892, 24.061], [47.395, 31.935], [47.395, 31.961], [46.202, 40.275], [43.210, 47.941], [38.470, 54.785], [32.032, 60.633], [32.014, 60.642], [26.067, 63.728], [18.415, 66.136], [3.969, 68.430], [3.969, 68.438], [3.881, 68.438], [0.926, 64.981], [3.792, 64.911], [3.836, 64.911], [3.881, 64.911], [17.524, 62.715], [24.828, 60.374], [29.924, 57.802], [29.933, 57.793], [29.942, 57.785], [35.831, 52.465], [40.123, 46.296], [42.806, 39.382], [43.868, 31.829], [43.868, 31.811], [43.868, 31.803], [43.550, 25.454], [42.127, 19.843], [39.828, 14.986], [36.883, 10.901], [36.627, 18.873], [36.636, 18.944], [36.636, 19.023], [37.775, 23.065], [39.132, 28.372], [39.132, 28.381], [39.343, 34.157], [38.659, 36.744], [37.024, 38.955], [34.695, 36.301], [35.833, 33.796], [35.621, 28.707], [35.621, 28.698], [34.350, 24.406], [33.126, 19.297], [33.108, 19.147], [33.117, 19.147], [33.502, 9.454], [35.101, 1.094], [35.101, 1.067], [34.463, -6.160], [32.394, -10.275], [32.385, -10.283], [28.849, -12.186], [25.003, -13.582], [24.968, -13.591], [24.968, -13.599], [18.362, -17.436], [18.291, -17.489], [18.230, -17.542], [15.476, -21.639], [14.737, -26.052], [8.306, -27.363], [0.415, -27.728], [0.406, -27.728], [-7.331, -27.507], [-14.252, -26.229], [-14.947, -21.915], [-17.683, -17.656], [-17.789, -17.542], [-17.912, -17.445], [-20.863, -15.338], [-24.580, -13.732], [-24.580, -13.723], [-28.681, -12.345], [-31.900, -10.451], [-31.909, -10.442], [-33.982, -6.294], [-34.598, 0.988], [-34.598, 1.023], [-33.006, 9.349], [-32.632, 18.988], [-32.623, 18.988], [-32.641, 19.129], [-33.865, 24.244], [-35.136, 28.540], [-35.348, 33.628], [-34.210, 36.133], [-36.539, 38.788], [-38.174, 36.576], [-38.858, 33.990], [-38.647, 28.213], [-38.647, 28.204], [-37.290, 22.898], [-36.151, 18.856], [-36.151, 18.785], [-36.142, 18.706], [-36.477, 10.133], [-41.369, 19.368], [-42.889, 24.948], [-43.638, 30.912], [-42.972, 38.480], [-40.383, 45.658], [-36.182, 52.015], [-30.683, 57.123], [-30.674, 57.132], [-23.675, 60.767], [-15.466, 63.200], [-6.960, 64.561], [-11.527, 17.348], [-12.859, 17.171], [-24.139, 15.646], [-27.046, 14.212], [-28.805, 12.098], [-29.522, 9.703], [-29.307, 7.426], [-26.608, 0.723], [-23.735, -2.417], [-20.849, -3.854], [-17.154, -4.077], [-13.679, -1.861], [-9.816, 3.087], [-6.747, 8.475], [-6.396, 11.497], [-7.142, 14.371], [-8.885, 16.516], [11.818, 17.348], [9.176, 16.516], [7.433, 14.371], [6.687, 11.497], [7.038, 8.475], [10.107, 3.087], [13.970, -1.861], [17.445, -4.077], [21.140, -3.854], [24.026, -2.417], [26.899, 0.723], [29.598, 7.426], [29.813, 9.703], [29.096, 12.098], [27.337, 14.212], [24.430, 15.646], [13.150, 17.171], [59.099, 1.490], [59.178, 1.490], [60.139, 0.900], [61.226, -2.939], [61.462, -6.809], [62.027, -8.202], [67.803, -14.420], [66.957, -15.857], [63.561, -16.660], [63.261, -16.686], [59.125, -16.272], [56.410, -15.965], [52.705, -16.783], [52.608, -16.827], [28.804, -28.046], [30.383, -18.970], [49.794, -9.428], [50.138, -9.207], [52.705, -6.306], [54.054, -3.660], [56.303, -0.212], [56.453, -0.079], [-59.301, 1.111], [-59.204, 1.111], [-57.564, 0.512], [-55.422, -1.330], [-54.239, -3.422], [-52.861, -6.093], [-50.315, -8.952], [-50.068, -9.119], [-30.145, -19.015], [-28.557, -28.196], [-53.119, -16.448], [-53.507, -16.316], [-57.115, -16.077], [-59.954, -16.475], [-65.307, -16.422], [-65.325, -16.422], [-67.512, -15.452], [-67.706, -15.081], [-67.230, -13.829], [-67.230, -13.820], [-61.877, -8.361], [-61.400, -7.276], [-60.413, -0.062], [-59.566, 0.979], [-0.873, -0.203], [-5.733, -5.283], [-7.585, -9.640], [-8.070, -14.129], [-7.333, -18.429], [-5.653, -19.949], [-3.677, -18.917], [-0.917, -15.981], [1.094, -0.256], [1.138, -16.034], [3.894, -18.975], [5.865, -20.011], [7.549, -18.486], [8.290, -14.182], [7.796, -9.701], [5.953, -5.345], [26.538, -16.783], [24.411, -22.627], [23.336, -28.804], [23.327, -29.042], [23.380, -29.272], [23.777, -36.398], [23.036, -40.657], [23.036, -40.675], [22.569, -42.095], [22.472, -42.342], [22.463, -42.359], [18.452, -48.278], [12.982, -52.325], [6.869, -54.204], [0.256, -54.662], [-6.523, -54.243], [-12.823, -52.511], [-12.823, -52.502], [-15.892, -50.621], [-18.817, -47.760], [-22.728, -41.037], [-22.807, -40.710], [-22.807, -40.701], [-23.574, -36.283], [-23.169, -29.272], [-23.116, -29.042], [-23.124, -28.804], [-24.183, -22.687], [-26.282, -16.898], [-25.611, -17.101], [-25.576, -17.110], [-25.541, -17.118], [-24.959, -17.286], [-21.793, -25.991], [-21.784, -26.008], [-19.870, -36.283], [-19.897, -36.301], [-19.870, -36.336], [-19.861, -36.371], [-19.835, -36.371], [-15.632, -40.079], [-10.793, -42.287], [-5.450, -43.387], [0.265, -43.771], [0.273, -43.771], [6.603, -43.352], [12.356, -41.804], [16.991, -39.376], [19.932, -36.168], [19.949, -36.168], [21.881, -25.805], [21.881, -25.788], [24.897, -17.445], [26.167, -16.916], [26.185, -16.907], [26.202, -16.898], [-22.586, -18.415], [-20.179, -20.161], [-18.169, -23.144], [-17.780, -26.158], [-17.692, -26.158], [-17.718, -26.211], [-16.492, -26.873], [-16.669, -26.873], [-16.766, -37.024], [-18.186, -35.586], [-20.099, -25.514], [-20.099, -25.506], [-20.099, -25.488], [22.401, -18.865], [20.196, -25.285], [20.188, -25.294], [20.188, -25.303], [18.256, -35.551], [16.986, -37.068], [16.871, -26.705], [18.115, -26.044], [18.089, -26.000], [18.265, -26.000], [18.698, -22.935], [20.611, -20.152], [15.478, -27.296], [15.522, -31.697], [13.026, -33.081], [13.000, -28.037], [-15.266, -27.384], [-12.850, -28.116], [-12.876, -33.055], [-15.302, -31.785], [11.589, -28.337], [11.615, -33.646], [8.766, -34.422], [8.714, -28.751], [-11.439, -28.416], [-8.617, -28.831], [-8.669, -34.448], [-11.465, -33.628], [7.302, -28.892], [7.355, -34.660], [5.036, -34.934], [5.009, -29.025], [-7.205, -28.963], [-4.798, -29.104], [-4.824, -35.057], [-7.267, -34.740], [3.598, -29.086], [3.625, -35.039], [0.900, -35.163], [0.900, -29.130], [-3.387, -29.148], [-0.512, -29.157], [-0.512, -35.198], [-3.413, -35.163], [15.540, -33.355], [15.584, -38.170], [13.061, -39.590], [13.035, -34.607], [-15.319, -33.417], [-12.885, -34.590], [-12.903, -39.599], [-15.372, -38.144], [-11.474, -35.128], [-8.687, -35.895], [-8.731, -41.037], [-11.500, -40.199], [11.624, -35.128], [11.650, -40.181], [8.819, -41.072], [8.775, -35.851], [7.364, -36.089], [7.417, -41.398], [5.071, -41.795], [5.045, -36.353], [-7.276, -36.168], [-4.833, -36.468], [-4.859, -41.680], [-7.329, -41.328], [3.634, -36.459], [3.660, -41.927], [0.900, -42.016], [0.900, -36.574], [-3.422, -36.574], [-0.512, -36.609], [-0.512, -41.980], [-3.448, -41.813], [-26.784, -38.999], [-26.246, -41.522], [-26.238, -41.548], [-26.097, -42.086], [-24.438, -46.258], [-41.698, -55.394], [-42.227, -55.827], [-45.914, -61.480], [-45.931, -61.498], [-48.507, -64.672], [-50.420, -65.422], [-51.593, -63.940], [-52.537, -56.567], [-53.022, -55.694], [-58.031, -50.923], [-58.031, -50.914], [-58.781, -49.283], [-58.031, -47.951], [-54.609, -47.276], [-52.414, -47.616], [-49.642, -48.200], [-45.499, -47.863], [-45.287, -47.801], [-35.642, -43.578], [26.978, -39.105], [44.864, -47.395], [44.926, -47.431], [48.833, -48.175], [52.096, -47.607], [52.114, -47.598], [55.206, -47.279], [58.129, -48.101], [59.381, -49.247], [58.622, -50.720], [58.596, -50.755], [53.419, -55.456], [52.899, -56.479], [52.465, -60.921], [51.576, -64.646], [50.544, -65.431], [47.845, -63.649], [47.730, -63.552], [45.693, -60.510], [44.325, -58.057], [41.707, -55.156], [41.363, -54.927], [24.544, -46.196], [26.273, -42.183], [26.326, -41.989], [26.449, -41.566], [26.449, -41.548], [26.458, -41.522], [26.458, -41.513], [26.485, -41.398]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 0, 0], [164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 164, 164], [262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 262, 262], [279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 279, 279], [296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 296, 296], [318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 318, 318], [342, 343, 344, 345, 346, 347, 348, 349, 342, 342], [350, 351, 352, 353, 354, 355, 356, 357, 350, 350], [358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 358, 358], [414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 414, 414], [427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 427, 427], [439, 440, 441, 442, 439, 439], [443, 444, 445, 446, 443, 443], [447, 448, 449, 450, 447, 447], [451, 452, 453, 454, 451, 451], [455, 456, 457, 458, 455, 455], [459, 460, 461, 462, 459, 459], [463, 464, 465, 466, 463, 463], [467, 468, 469, 470, 467, 467], [471, 472, 473, 474, 471, 471], [475, 476, 477, 478, 475, 475], [479, 480, 481, 482, 479, 479], [483, 484, 485, 486, 483, 483], [487, 488, 489, 490, 487, 487], [491, 492, 493, 494, 491, 491], [495, 496, 497, 498, 495, 495], [499, 500, 501, 502, 499, 499], [503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 503, 503], [527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 527, 527]]\n    );}\nmodule hang_loose() {\n  polygon(points=\n    [[-5.059, -96.457], [-12.154, -95.479], [-17.838, -94.735], [-25.983, -91.532], [-34.127, -88.330], [-35.322, -83.425], [-37.398, -72.452], [-38.279, -66.384], [-45.718, -52.326], [-53.157, -38.269], [-59.972, -13.380], [-67.126, 12.496], [-80.782, 30.789], [-94.099, 48.169], [-96.191, 55.218], [-98.283, 62.190], [-96.996, 65.119], [-95.708, 68.047], [-92.434, 69.190], [-89.160, 70.332], [-87.068, 69.793], [-84.488, 68.745], [-75.180, 57.793], [-50.315, 30.493], [-48.720, 34.212], [-47.323, 37.724], [-43.689, 39.388], [-40.054, 41.053], [-34.822, 40.703], [-29.590, 40.353], [-28.029, 42.017], [-22.297, 48.261], [-10.001, 51.164], [-6.683, 49.986], [-3.696, 48.925], [-2.637, 50.325], [4.471, 57.047], [10.962, 58.091], [16.954, 58.718], [23.366, 52.187], [29.778, 45.657], [34.309, 38.274], [38.840, 30.891], [39.812, 26.656], [43.624, 15.941], [48.586, 21.669], [63.251, 39.025], [65.556, 41.706], [70.606, 44.089], [80.454, 48.770], [86.251, 51.542], [90.766, 51.301], [94.752, 50.439], [97.539, 46.044], [99.857, 41.796], [98.340, 40.247], [93.060, 35.969], [89.297, 33.240], [84.684, 26.577], [76.405, 12.889], [68.147, -5.989], [63.556, -17.842], [55.584, -28.425], [39.705, -47.292], [31.011, -57.593], [30.342, -64.973], [30.481, -74.212], [30.501, -78.088], [27.114, -81.506], [10.986, -94.803], [7.881, -95.724], [-5.059, -96.457], [-0.684, -92.830], [-2.501, -83.549], [-5.194, -67.051], [-6.155, -59.329], [-6.646, -67.436], [-5.469, -87.234], [-4.918, -92.667], [-2.801, -93.054], [-9.873, -91.008], [-11.119, -78.280], [-12.330, -66.639], [-17.781, -68.203], [-28.554, -70.798], [-33.974, -72.297], [-32.473, -79.771], [-30.984, -86.668], [-20.843, -89.405], [-10.215, -92.175], [7.243, -91.214], [11.817, -90.221], [15.514, -86.644], [19.293, -82.628], [18.782, -80.495], [17.667, -68.020], [16.407, -62.392], [11.856, -63.277], [7.887, -64.029], [5.385, -62.873], [8.008, -61.109], [14.694, -60.363], [16.948, -59.530], [14.835, -59.361], [6.936, -58.907], [-0.740, -58.466], [-3.052, -59.128], [-2.821, -67.539], [-0.283, -82.612], [2.415, -92.207], [22.185, -77.041], [22.519, -66.608], [21.818, -59.305], [21.082, -59.382], [19.988, -60.945], [19.071, -62.252], [19.067, -66.012], [20.266, -75.181], [21.589, -80.470], [22.185, -77.041], [-21.145, -63.228], [-13.017, -61.274], [-10.689, -60.599], [-10.538, -61.798], [-8.893, -59.624], [-7.273, -56.250], [-8.360, -52.798], [-11.369, -46.112], [-13.290, -42.878], [-12.392, -36.428], [-10.870, -28.756], [-8.585, -23.743], [-6.925, -19.951], [-8.395, -18.371], [-9.866, -16.791], [-12.542, -18.207], [-17.980, -20.108], [-21.225, -20.180], [-29.612, -13.015], [-40.065, -4.095], [-42.617, -1.927], [-47.056, -1.222], [-51.495, -0.517], [-54.664, -1.822], [-57.898, -3.164], [-58.243, -5.159], [-58.524, -7.118], [-51.846, -28.990], [-45.168, -50.862], [-41.838, -56.083], [-38.509, -61.304], [-34.343, -63.051], [18.648, -54.804], [25.862, -54.138], [34.328, -47.532], [42.072, -41.149], [51.081, -30.022], [60.089, -18.894], [62.945, -10.183], [68.967, 4.651], [72.134, 10.774], [70.825, 11.353], [69.227, 11.932], [69.447, 12.496], [71.043, 13.061], [72.128, 13.259], [71.241, 14.372], [70.354, 15.288], [71.030, 15.431], [75.648, 16.496], [81.548, 25.479], [87.365, 34.368], [92.040, 37.755], [96.716, 41.142], [96.596, 43.034], [95.366, 46.703], [94.256, 48.479], [90.883, 48.938], [87.509, 49.397], [77.588, 44.705], [67.668, 40.013], [63.131, 34.533], [58.594, 29.053], [59.111, 28.183], [60.675, 25.552], [63.686, 18.925], [64.212, 17.593], [62.662, 18.584], [57.245, 23.105], [55.410, 25.256], [53.449, 23.321], [43.624, 9.933], [45.469, 4.524], [49.951, -4.260], [52.496, -8.067], [49.495, -5.544], [46.588, -2.918], [44.517, 1.332], [41.752, 7.131], [41.056, 8.679], [39.730, 6.284], [38.262, 0.800], [38.121, -2.289], [36.428, 0.307], [34.452, 2.831], [29.475, 0.241], [24.780, -2.278], [23.734, -4.416], [20.950, -8.472], [19.212, -10.390], [14.254, -12.152], [-2.626, -22.018], [-6.120, -25.205], [-8.059, -30.808], [-9.998, -36.855], [-3.250, -50.156], [-0.543, -54.249], [4.678, -54.699], [-15.360, -15.505], [-13.394, -13.260], [-14.691, -11.318], [-17.075, -12.016], [-18.980, -14.525], [-19.593, -16.390], [-18.252, -16.564], [-22.123, -14.808], [-18.577, -8.846], [-16.529, -6.468], [-19.356, -3.308], [-22.466, -5.513], [-26.066, -6.718], [-29.896, -6.656], [-30.882, -5.981], [-29.400, -5.441], [-23.794, -2.952], [-19.670, -0.909], [-22.032, 6.288], [-27.646, 27.828], [-29.677, 36.787], [-33.594, 37.985], [-37.295, 38.986], [-40.765, 37.956], [-44.235, 36.926], [-45.986, 34.874], [-47.737, 32.822], [-48.175, 29.559], [-48.613, 26.296], [-44.108, 12.139], [-39.546, -2.058], [-31.057, -9.053], [-22.531, -16.008], [3.034, -14.145], [5.802, -12.564], [4.517, -11.060], [1.850, -9.260], [-1.790, -9.981], [-4.048, -10.998], [-4.765, -13.151], [-5.482, -15.515], [-2.608, -15.726], [0.267, -15.726], [-7.305, -9.429], [-1.572, -6.684], [1.053, -6.365], [3.887, -7.954], [6.844, -9.420], [0.650, 3.465], [-2.317, 2.011], [-7.855, 0.031], [-12.839, 0.397], [-12.995, 1.126], [-9.656, 2.180], [0.012, 6.106], [-1.494, 11.368], [-3.374, 23.221], [-3.752, 37.458], [-3.648, 44.780], [-7.093, 47.008], [-10.539, 49.236], [-15.470, 47.974], [-20.401, 46.712], [-23.525, 43.943], [-26.650, 40.876], [-23.803, 24.632], [-20.954, 8.686], [-14.739, -0.980], [-8.343, -10.628], [13.368, -6.107], [17.749, -4.451], [16.356, -2.287], [14.677, -0.260], [8.734, -1.312], [7.159, -1.735], [6.395, -1.902], [7.357, -4.150], [9.074, -7.541], [22.252, 9.886], [24.051, 33.733], [24.404, 43.810], [27.282, 39.621], [27.635, 35.921], [27.962, 32.957], [29.564, 35.610], [31.167, 38.262], [27.729, 43.371], [24.292, 48.479], [18.961, 52.501], [13.175, 56.512], [3.585, 54.075], [1.373, 51.141], [-0.662, 48.459], [0.051, 32.528], [0.876, 16.486], [5.443, 16.151], [12.580, 14.964], [6.936, 14.042], [1.613, 13.185], [4.424, 4.327], [5.637, 2.054], [8.364, 2.856], [10.746, 3.657], [13.696, 2.499], [16.647, 1.341], [18.494, -1.258], [20.488, -3.865], [-55.321, 0.202], [-48.098, 1.213], [-44.494, 1.612], [-47.261, 5.399], [-49.920, 9.110], [-48.190, 8.660], [-46.559, 8.308], [-50.310, 17.464], [-51.484, 19.644], [-50.760, 19.545], [-49.666, 19.764], [-50.078, 21.857], [-50.386, 23.457], [-53.358, 21.598], [-58.809, 17.010], [-61.723, 13.601], [-62.500, 10.380], [-62.842, 7.840], [-61.215, 3.677], [-59.303, -0.486], [29.846, 3.827], [34.311, 5.925], [28.032, 6.416], [26.832, 6.429], [26.366, 4.594], [25.965, 2.054], [29.846, 3.827], [36.259, 9.991], [39.551, 11.895], [38.143, 18.000], [35.334, 27.587], [33.559, 31.593], [30.725, 28.460], [28.127, 25.264], [27.538, 21.810], [27.031, 18.122], [29.649, 19.414], [32.184, 20.938], [32.824, 20.337], [32.179, 17.943], [29.098, 13.484], [27.208, 9.681], [29.513, 8.944], [32.370, 8.584], [-56.334, 23.692], [-53.318, 26.633], [-57.975, 32.892], [-65.963, 39.082], [-67.039, 36.701], [-70.745, 30.327], [-73.377, 26.514], [-72.238, 23.834], [-67.535, 18.613], [-64.132, 15.648], [-61.741, 18.290], [-72.844, 32.040], [-66.724, 42.443], [-68.315, 44.491], [-73.707, 47.588], [-74.623, 47.429], [-74.201, 48.625], [-73.779, 50.160], [-76.707, 55.057], [-84.116, 63.711], [-89.213, 67.668], [-92.491, 66.292], [-95.667, 61.320], [-94.035, 54.517], [-92.230, 49.548], [-88.587, 44.610], [-84.944, 39.671], [-82.396, 40.523], [-78.436, 42.449], [-76.930, 43.092], [-79.707, 40.153], [-82.192, 38.071], [-75.415, 28.589]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 0], [72, 73, 74, 75, 76, 77, 78, 79, 72], [80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 80], [90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 90], [110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 110], [120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 120], [152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 152], [218, 219, 220, 221, 222, 223, 224, 218], [225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 225], [251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 251], [261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 261], [287, 288, 289, 290, 291, 292, 293, 294, 295, 287], [296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 296], [325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 325], [345, 346, 347, 348, 349, 350, 351, 345], [352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 352], [369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 369], [380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 380]]\n    );}\nmodule money() {\n  polygon(points=\n    [[-54.142, -63.317], [-54.142, -33.436], [-39.938, -33.436], [-39.727, -35.435], [-39.517, -41.853], [-38.936, -45.731], [-37.564, -49.159], [-35.398, -52.136], [-32.441, -54.663], [-24.149, -58.365], [-12.687, -60.266], [-12.687, -2.923], [-21.735, 3.705], [-36.913, 15.595], [-45.198, 24.117], [-48.749, 32.403], [-49.933, 43.582], [-48.999, 53.400], [-46.198, 62.126], [-41.529, 69.761], [-34.992, 76.304], [-29.646, 79.783], [-23.603, 82.328], [-16.862, 83.939], [-9.425, 84.616], [-9.425, 101.556], [0.360, 101.556], [0.360, 84.616], [17.589, 82.380], [33.924, 77.567], [33.924, 48.317], [19.720, 48.317], [19.509, 50.316], [19.194, 57.576], [17.622, 64.717], [13.959, 70.044], [8.205, 73.556], [0.360, 75.252], [0.360, 21.171], [12.144, 13.175], [23.836, 3.765], [32.188, -6.369], [37.199, -17.226], [38.451, -22.926], [38.869, -28.806], [37.988, -38.407], [35.344, -46.903], [30.938, -54.295], [24.770, -60.581], [19.292, -64.277], [12.854, -67.263], [5.456, -69.538], [-2.902, -71.103], [-2.902, -87.937], [-12.687, -87.937], [-12.687, -71.103], [-34.677, -68.473], [-2.902, -59.634], [3.411, -57.451], [7.830, -53.637], [11.224, -46.561], [12.355, -37.118], [10.934, -26.965], [6.673, -18.179], [2.649, -13.524], [-2.902, -8.815], [-10.056, 27.274], [-10.056, 74.516], [-15.948, 71.668], [-20.157, 66.914], [-22.682, 60.252], [-23.524, 51.684], [-22.682, 44.753], [-20.157, 38.374], [-15.948, 32.548]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 0], [57, 58, 59, 60, 61, 62, 63, 64, 65, 57], [66, 67, 68, 69, 70, 71, 72, 73, 74, 66]]\n    );}\nmodule makerbot_replicator_2() {\n  polygon(points=\n    [[-81.295, 41.859], [-80.882, 42.857], [-76.064, 47.675], [-75.066, 48.088], [-31.115, 48.088], [42.455, 48.088], [43.453, 47.675], [48.271, 42.857], [48.684, 41.860], [48.684, -47.468], [48.271, -48.466], [43.453, -53.284], [42.455, -53.697], [-75.066, -53.697], [-76.064, -53.284], [-80.882, -48.466], [-81.295, -47.468], [-2.326, -18.073], [-24.840, -40.588], [-25.774, -41.212], [-26.875, -41.431], [-62.903, -41.431], [-64.004, -41.212], [-64.937, -40.588], [-68.344, -37.181], [-68.968, -36.248], [-69.187, -35.146], [-69.187, 30.571], [-68.968, 31.672], [-68.344, 32.606], [-64.937, 36.012], [-64.004, 36.636], [-62.903, 36.855], [30.292, 36.855], [31.393, 36.636], [32.326, 36.012], [35.733, 32.606], [36.357, 31.672], [36.576, 30.571], [36.576, -14.799], [36.350, -15.919], [35.733, -16.833], [34.818, -17.450], [33.698, -17.676], [-1.367, -17.676], [33.781, -35.058], [31.846, -35.860], [0.123, -35.860], [-0.942, -35.645], [-1.812, -35.058], [-2.399, -34.188], [-2.614, -33.123], [-2.614, -22.399], [-2.399, -21.334], [-1.812, -20.464], [-0.942, -19.877], [0.123, -19.662], [22.731, -19.662], [31.846, -19.662], [33.781, -20.464], [35.379, -22.062], [36.181, -23.997], [36.181, -31.525], [35.379, -33.460]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 0], [17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 17, 17], [45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 45]]\n    );}\nmodule makerbot_logo() {\n  polygon(points=\n    [[0.001, 17.388], [-1.745, 17.300], [-3.456, 17.044], [-5.132, 16.621], [-6.764, 16.021], [-9.709, 14.425], [-12.293, 12.300], [-14.419, 9.716], [-16.015, 6.770], [-16.615, 5.138], [-17.038, 3.463], [-17.294, 1.752], [-17.382, 0.005], [-17.294, -1.741], [-17.038, -3.461], [-16.615, -5.136], [-16.015, -6.768], [-14.419, -9.713], [-12.293, -12.298], [-9.709, -14.432], [-6.764, -16.019], [-5.132, -16.619], [-3.456, -17.042], [-1.745, -17.298], [0.001, -17.386], [1.747, -17.298], [3.458, -17.042], [5.134, -16.619], [6.765, -16.019], [9.711, -14.432], [12.295, -12.298], [14.421, -9.713], [16.017, -6.768], [16.608, -5.136], [17.040, -3.461], [17.296, -1.741], [17.384, 0.005], [17.296, 1.752], [17.040, 3.463], [16.608, 5.138], [16.017, 6.770], [14.421, 9.716], [12.295, 12.300], [9.711, 14.425], [6.765, 16.021], [5.134, 16.621], [3.458, 17.044], [1.747, 17.300], [0.001, 14.972], [3.017, 14.672], [5.830, 13.799], [8.370, 12.414], [10.584, 10.589], [12.410, 8.375], [13.794, 5.835], [14.668, 3.022], [14.967, 0.005], [14.668, -3.020], [13.794, -5.824], [12.410, -8.373], [10.584, -10.587], [8.370, -12.412], [5.830, -13.797], [3.017, -14.670], [0.001, -14.970], [-3.015, -14.670], [-5.829, -13.797], [-8.369, -12.412], [-10.582, -10.587], [-12.408, -8.373], [-13.793, -5.824], [-14.666, -3.020], [-14.966, 0.005], [-14.666, 3.022], [-13.793, 5.835], [-12.408, 8.375], [-10.582, 10.589], [-8.369, 12.414], [-5.829, 13.799], [-3.015, 14.672], [-4.700, 11.418], [-5.661, 11.330], [-6.543, 11.065], [-7.354, 10.624], [-8.078, 10.007], [-8.686, 9.266], [-9.110, 8.463], [-9.374, 7.581], [-9.453, 6.629], [-9.453, -8.126], [-9.312, -9.008], [-8.880, -9.696], [-8.210, -10.146], [-7.363, -10.296], [-6.481, -10.146], [-5.793, -9.696], [-5.344, -9.008], [-5.203, -8.126], [-5.203, 7.132], [-2.098, 7.132], [-2.098, -8.126], [-1.957, -9.008], [-1.534, -9.696], [-0.872, -10.146], [0.001, -10.296], [0.865, -10.146], [1.535, -9.696], [1.959, -9.008], [2.100, -8.126], [2.100, 7.132], [5.196, 7.132], [5.196, -8.126], [5.345, -9.008], [5.795, -9.696], [6.483, -10.146], [7.356, -10.296], [8.212, -10.137], [8.882, -9.678], [9.314, -8.990], [9.455, -8.126], [9.455, 6.629], [9.367, 7.581], [9.111, 8.463], [8.679, 9.266], [8.079, 10.007], [7.347, 10.624], [6.545, 11.065], [5.663, 11.330], [4.702, 11.418]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 0, 0], [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 48, 48], [80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 80, 80]]\n    );}",
    "description": "Okay, I want to design a customizable sign that I can 3D print. I'd like it to be parametric so I can easily change things like the size, text, and icon.\n\nHere are the specific features I'm looking for:\n\n1.  **Sign Size Presets:** I want to have a few pre-defined size options based on common Makerbot printers, specifically:\n    *   \"Makerbot Replicator 2\"\n    *   \"Makerbot Replicator\"\n    *   \"Makerbot Thingomatic\"\n    *   And a \"Manual\" option where I can specify the length and width directly.\n\n2.  **Manual Size Control:** If I choose the \"Manual\" size, I need separate parameters to control the length and width of the sign. I'd like to be able to set these within a range, say 100 to 300 units.\n\n3.  **Two Lines of Text:** The sign should have two lines of customizable text.\n    *   I need a parameter for each line to specify the text message.\n    *   I need separate parameters for the font size of each line, with a range of, say, 20 to 60 units.\n\n4.  **Font Selection:** I'd like to be able to choose from a few different fonts. Specifically I need to have \"Letters.dxf,\" \"orbitron.dxf\" and \"BlackRose.dxf.\" I expect to use the `write` module within the `Write.scad` file (included).\n\n5.  **Icon Selection:** I want to be able to add an icon to the sign from a list of presets. I would like to see:\n    *   \"Makerbot Replicator 2\"\n    *   \"Radiation\"\n    *   \"Radiation Sign\"\n    *   \"Skull and Crossbones\"\n    *   \"Hang Loose\"\n    *   \"Money\"\n    *   \"Bomb\"\n    *   \"Makerbot Logo\"\n    * I expect to use the code for each of these in the base file I am giving to the AI assistant, which will include the Write.scad library.\n\n6.  **Icon Size and Rotation:** I need to be able to control the size of the selected icon (within a range of, say, 5 to 20 units) and rotate the icon (within a range of -20 to 20 degrees) as well.\n\n7.  **Mounting Holes:** I'd like the option to add mounting holes to the sign. I want a parameter that lets me choose from \"None\", \"Small\", or \"Big\" with corresponding radii of 0, 2.5, or 5.\n\n8.  **Embossing Style:** Finally, I need a parameter to select if the text and icon are either \"Raised\" (embossed) or \"Cut Out\" (engraved).\n\nI've included all the necessary code to create the shapes, including the font definitions, the icon definitions, and the write library (`Write.scad`). I just need you to convert the structure to utilize the `customizer` library so that I can alter the variables directly in the customizer app in Thingiverse. I expect to utilize this code in the customizer, so there is no need for a preview.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Microphone Flag",
    "scad": "number_of_sides = 4;\nwidth_of_logo = 50;\nheight_of_logo = 50;\nhole_diameter = 40;\nuse_bottom = \"false\";\nresolution = 100*1;\nmodule flag(size, height, sides, hole, bottom)\n{\n\tdifference()\n\t{\n\t\tunion()\n\t\t{\n\t\t\tdifference()\n\t\t\t{\n\t\t\t\tunion()\n\t\t\t\t{\n\t\t\t\t\ttranslate([0, 0, height/2-3/2-5])\n\t\t\t\t\t\tcylinder(h = 3, r1 = sqrt((tan((90+((sides-3)*90))/sides)*size/2)*(tan((90+((sides-3)*90))/sides)*size/2)+(size/2)*(size/2))+4, r2 = sqrt((tan((90+((sides-3)*90))/sides)*size/2)*(tan((90+((sides-3)*90))/sides)*size/2)+(size/2)*(size/2))+4, center = true, $fn = resolution);\n\t\t\t\t\tif (bottom == \"true\")\n\t\t\t\t\t{\n\t\t\t\t\t\ttranslate([0, 0, -height/2+3/2])\n\t\t\t\t\t\t\tcylinder(h = 3, r1 = sqrt((tan((90+((sides-3)*90))/sides)*size/2)*(tan((90+((sides-3)*90))/sides)*size/2)+(size/2)*(size/2))+4, r2 = sqrt((tan((90+((sides-3)*90))/sides)*size/2)*(tan((90+((sides-3)*90))/sides)*size/2)+(size/2)*(size/2))+4, center = true, $fn = resolution);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tunion()\n\t\t\t\t{\n\t\t\t\t\tfor ( i = [0 : sides-1] )\n\t\t\t\t\t{\n\t\t\t\t\t\trotate(360/sides*i, [0, 0, 1])\n\t\t\t\t\t\ttranslate([0, -(tan((90+((sides-3)*90))/sides)*size/2)-2-30/2, 0])\n\t\t\t\t\t\t\tcube([size+10, 30, height], center = true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor ( i = [0 : sides-1] )\n\t\t\t{\n\t\t\t\trotate(360/sides*i, [0, 0, 1])\n\t\t\t\ttranslate([0, -(tan((90+((sides-3)*90))/sides)*size/2)-5+3/2, 0])\n\t\t\t\t\tcube([size, 3, height], center = true);\n\t\t\t\tdifference()\n\t\t\t\t{\n\t\t\t\t\tunion()\n\t\t\t\t\t{\n\t\t\t\t\t\trotate(360/sides*i, [0, 0, 1])\n\t\t\t\t\t\ttranslate([size/2, -(tan((90+((sides-3)*90))/sides)*size/2), 0])\n\t\t\t\t\t\t\tcylinder(h = height, r1 = 5, r2 = 5, center = true, $fn = resolution);\n\t\t\t\t\t}\n\t\t\t\t\tunion()\n\t\t\t\t\t{\n\t\t\t\t\t\trotate(360/sides*i, [0, 0, 1])\n\t\t\t\t\t\ttranslate([size/2, -(tan((90+((sides-3)*90))/sides)*size/2), 0])\n\t\t\t\t\t\t\tcylinder(h = height+1, r1 = 2, r2 = 2, center = true, $fn = resolution);\n\t\t\t\t\t\trotate(360/sides*i, [0, 0, 1])\n\t\t\t\t\t\ttranslate([size/2-10, -(tan((90+((sides-3)*90))/sides)*size/2), 0])\n\t\t\t\t\t\t\tcube([20, 20, height+1], center = true);\n\t\t\t\t\t\trotate(360/sides*i, [0, 0, 1])\n\t\t\t\t\t\ttranslate([size/2, -(tan((90+((sides-3)*90))/sides)*size/2), 0])\n\t\t\t\t\t\trotate(360/sides+180, [0, 0, 1])\n\t\t\t\t\t\ttranslate([-10, 0, 0])\n\t\t\t\t\t\t\tcube([20, 20, height+1], center = true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tunion()\n\t\t{\n\t\t\tcylinder(h = height+1, r = hole/2, center = true, $fn = resolution);\n\t\t}\n\t}\n}\nflag(width_of_logo, height_of_logo, number_of_sides, hole_diameter, use_bottom);",
    "description": "Okay, I'm looking to create a customizable microphone flag, like the kind you see on TV interviews. I've already got a decent idea in my head and even found an existing OpenSCAD file that does most of what I want, but it's not *quite* perfect and I'd like to be able to tweak some things.\n\nHere's what I need:\n\n**Overall Shape:** The flag should be based on a multi-sided shape, like a polygon. I want to be able to easily control the number of sides, from a triangle all the way up to something like a dodecagon.\n\n**Logo Area:** Each side of the polygon needs a flat, rectangular area where I can stick a logo or a label. I want to be able to set the width and height of this logo area independently. I also need these areas to be smoothly joined together; the existing model does that with rounded corners which is good.\n\n**Microphone Hole:**  There needs to be a circular hole through the center to slide the microphone through. I want to control the diameter of this hole.\n\n**Optional Bottom:** I want the option to have a bottom plate that mirrors the top. That way it could be more rigid and keep things aligned better. But I also want the ability to turn that off if I just want the top plate.\n\n**Key Parameters I need to control:**\n\n*   **Number of Sides:** An integer value that controls how many sides the main polygon shape has. (e.g. 3 for triangle, 4 for square, etc.). I need a reasonable range like 3-12, for now.\n*   **Logo Width:** The width of the rectangular space on each side for the logo, in millimeters.\n*   **Logo Height:** The height of the rectangular space on each side for the logo, in millimeters.\n*   **Hole Diameter:** The diameter of the microphone hole, in millimeters.\n*   **Use Bottom Plate:** A boolean or a string value (\"true\" or \"false\") that turns the bottom plate on or off.\n\n**Existing OpenSCAD File:** I'm attaching my current Openscad file. It already has most of the main construction. It uses basic OpenSCAD functions like `cylinder()`, `cube()`, `translate()`, `rotate()`, `difference()`, and `union()`.  \n\nI'm hoping you can help me clean it up a bit and make it more flexible. For example, the code to generate the rounded corners is kind of verbose, so I would love a more elegant solution if you know of one.\n\nI do not need external libraries. I just need it to use the functions provided by the OpenSCAD language itself. Thanks.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Whirly One (OpenSCAD)",
    "scad": "blade_radius = 70;\nblade_width = 10;\nblade_thickness = 0.9;\nblade_pitch = 30;\nhandle_length = 8;\nhandblock = 0;\nouter_ring = 1;\nrotors = 1;\n$fn=100;\ntranslate([0,0,-0.3]) if(rotors == 1) {\n\t\tunion() {\n\t\t\tcylinder(r=2, h=handle_length-4.75/2.1);\n\t\t\tcylinder(r1=blade_width, r2=2, h=blade_width*0.707);\n\t\t\ttranslate([0,0,handle_length]) cube([4.75,4.75,5.75], center=true);\n\t\t\tcylinder(r=blade_width/2, h=0.6);\n\t\t}\n\ttranslate([0,0,0]) rotate([0,0,45]) union() {\n\tfor(i=[0:3]){\n\t\trotate([0,0,90*i]) rotor();\n\t}\n}\nif(outer_ring == 1)\n\tdifference() {\n\t\tcylinder(r=blade_radius, h=(blade_width+blade_thickness)*sin(blade_pitch));\n\t\ttranslate([0,0,-0.035]) cylinder(r=blade_radius-blade_thickness, h=(blade_width+blade_thickness)*1.2*sin(blade_pitch));\n\t}\n}\nif(handblock == 1) {\n\ttranslate([blade_radius + 30,-25,-0.3]) union() {\n\trotate([0,0,0]) spinner_thingy();\n\ttranslate([0,35,14]) rotate([180,0,180]) difference() {\n\t\tminkowski() { minkowski() { minkowski() {\n\t\t\thull() {\n\t\t\t\tcube([30,30,15], center=true);\n\t\t\t\ttranslate([0,20,0]) cube([15,30,15], center=true);\n\t\t\t}\n\t\t\ttranslate([0,0,0]) cylinder(r=3, h=1, center=true);\n\t\t}\n\t\t\trotate([90,0,0]) cylinder(r=3, h=1, center=true);\n\t\t}\n\t\t\trotate([0,90,0]) cylinder(r=3, h=1, center=true);\n\t\t}\n\t\ttranslate([0,0,-14.01]) scale([1.15,1.15,1.15]) spinner_thingy(0);\n\t }\n\t}\n}\nif(handblock == 1) {\n\ttranslate([112.5,-20,0]) cube([10,80,0.6], center=true);\n\ttranslate([87,-20,0]) cube([10,80,0.6], center=true);\n\ttranslate([110,-35,0]) cube([80,10,0.6], center=true);\n\ttranslate([110,-17,0]) cube([80,5,0.6], center=true);\n\ttranslate([110,35,0]) cube([80,10,0.6], center=true);\n}\nmodule rotor()\n{\n\ttranslate([-blade_radius,-blade_width/2+blade_width*sin(blade_pitch)/2,0]) rotate([blade_pitch,0,0]) union() {\n\t\tcube([blade_radius,blade_width,blade_thickness]);\n\t\ttranslate([-blade_width/16, blade_width/2,0]) cylinder(r=blade_width/2,h=blade_thickness);\n\t}\n}\nmodule spinner_thingy(final = 1)\n{\n union() {\n\tdifference() {\n\t\tcylinder(r=7, h=15);\n\t\tif(final) union() {\n\t\t\tcube([6,6,6], center=true);\n\t\t\ttranslate([0,12,8]) rotate([90,0,0]) cylinder(r=2, h=25);\n\t\t}\n\t}\n\tdifference() {\n\t\ttranslate([0,0,15]) sphere(r=7);\n\t\tif(final) translate([0,12,8]) rotate([90,0,0]) cylinder(r=2, h=25);\n\t}\n }\n if(final == 0) {\n\ttranslate([0,0,4]) cylinder(r=14, h=11);\n\ttranslate([14-4,-12.5,9.5]) cube([8,25,11], center=true);\n }\n}",
    "description": "Okay, I'm looking for an OpenSCAD design for a whirly-bird toy, kind of like the old-fashioned ones made of wood, but designed for 3D printing. I've got a pretty specific idea in mind, so I'll try to lay it all out.\n\nThe core of the design is a central shaft, a rotor with multiple blades, and then options for either a simple handle or a string-pull mechanism.\n\nFirst, the rotor itself. It should have a number of blades, ideally four, arranged radially around a central point. Each blade should be rectangular, with an adjustable length (radius), width, and thickness. The key thing is that each blade should be angled upwards from the horizontal. I'd like to be able to control the angle of that pitch. Each blade also needs a small semi-circular endcap on the outward edge.\n\nNext, there needs to be a central shaft to support the rotor. One end should be flat and connect to the blades, and the other end needs a couple of configurations. In one case, there should be a simple round handle, maybe with a slightly larger radius end stop and a short section that connects to the rotor. In another case, the handle end should terminate in a small keyed block that can fit into a string pull spinner mechanism.\n\nFor the pull mechanism, the keyed block should be sized to fit snugly but freely into the spinner. The spinner itself should be cylindrical with a recessed area on one side with a slot for the key, and a hole through the cylinder for a string. I'd like the cylinder to terminate with a hemispherical end.\n\nIt would be great if the whole thing could also be surrounded by an outer ring, and to specify the offset between the main rotor blades and that ring.\n\nFinally, and very importantly, I'd like the whole thing to be fully parametric. All the dimensions, angles, and number of blades should be adjustable as parameters within the OpenSCAD code. I'd also like to have flags to toggle between the different configuration options. For example:\n- `handle_type` can be \"handle\", \"string_pull\" or \"none\" \n- `outer_ring_present` can be `true` or `false`\n- `blade_count` to specify the number of rotor blades.\n\nHere's a list of the parameters I can think of:\n* `blade_radius` (length of a blade)\n* `blade_width` (width of a blade)\n* `blade_thickness` (thickness of a blade)\n* `blade_pitch` (angle of blade)\n* `handle_length` (length of the handle)\n* `handle_radius` (radius of the handle)\n* `end_stop_radius` (radius of handle end stop)\n* `key_block_size` (size of the key block for the string pull mechanism)\n* `spinner_radius` (radius of the string spinner)\n* `spinner_height` (height of the spinner)\n* `string_hole_radius` (radius of the string hole)\n* `outer_ring_radius`\n* `outer_ring_offset` (offset from rotor)\n\nI think that should be enough information. Id like the code to use named modules to structure the different parts. Please do not use any libraries beyond what's built into OpenSCAD. I'm very interested in the quality of the code, so please try to make it clean and easy to follow.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Universal Phone Stand",
    "scad": "phone_height = 125.45;\nphone_width = 66.35;\nphone_thickness = 8.7;\nstand_height = 80;\nstand_width = 80;\nstand_thickness = 50;\nphone_stand_angle = 350;\nphone_stand_min_height = 10;\nphone_stand_to_back = 5;\nholdback = 0.9;\nholdback_multiplier = 10;\nphone_stand();\nmodule phone_stand(){\n  difference(){\n    cube([stand_width,stand_thickness,stand_height]);\n    translate([stand_width/2 - phone_width/2,phone_stand_to_back,phone_stand_min_height])\n    rotate(phone_stand_angle,[1,0,0])\n    cube([phone_width,phone_thickness,phone_height]);\n    translate([stand_width/2 - phone_width*holdback/2,phone_stand_to_back+(phone_thickness/2)-(phone_thickness*5*holdback),phone_stand_min_height + phone_height - (phone_height*holdback)])\n    rotate(phone_stand_angle,[1,0,0])\n    cube([phone_width*holdback,phone_thickness*5*holdback,phone_height*holdback]);\n  }\n}",
    "description": "Okay, I'm looking to design a customizable phone stand using OpenSCAD. I've already got a basic idea of how I want it to look and function, and I've even written some preliminary code, but it could definitely be better. I'd like to make it more robust and more easily customizable.\n\nHere's what I'm thinking:\n\nThe phone stand should be a solid block with a cutout for the phone to rest on. This cutout should be angled to allow the phone to lean back slightly. I'd also like a small lip or holdback at the bottom of the cutout to prevent the phone from sliding out. It is important that the cut-out and holdback are created as a subtraction from the base solid.\n\nHere's the code I've got so far. It seems to work but could be simplified and made more flexible:\n```\n//Customizable Phone Stand\n//Height of the phone //default 125.45\nphone_height = 125.45;\n//Width of the phone //default 66.35\nphone_width = 66.35; \n//Thickness of the phone //default 8.7\nphone_thickness = 8.7;  \n\n//Height of the stand //default 80\nstand_height = 80; //[30:120]\n//Width of the stand //default 80\nstand_width = 80; //[60:200]\n//Thickness of the stand //default 50\nstand_thickness = 50; //[35:100]\n\n//Angle at which the phone stands //default 350\nphone_stand_angle = 350; //[335:360]\n//The height from the bottom of the stand, to where the phone begins //default 10\nphone_stand_min_height = 10; //[2:60]\n//From the front of the stand to where the phone starts //default 5\nphone_stand_to_back = 5; //[2 : 20]\n//to hold back the phone //default 0.9\nholdback = 0.9;\n//not used at this time\nholdback_multiplier = 10; \n\n//Make!\nphone_stand();\n\nmodule phone_stand(){\n  difference(){\n    cube([stand_width,stand_thickness,stand_height]);\n    //The Phone\n    translate([stand_width/2 - phone_width/2,phone_stand_to_back,phone_stand_min_height]) \n    rotate(phone_stand_angle,[1,0,0]) \n    cube([phone_width,phone_thickness,phone_height]);\n    //The Holdback\n    translate([stand_width/2 - phone_width*holdback/2,phone_stand_to_back+(phone_thickness/2)-(phone_thickness*5*holdback),phone_stand_min_height + phone_height - (phone_height*holdback)]) \n    rotate(phone_stand_angle,[1,0,0]) \n    cube([phone_width*holdback,phone_thickness*5*holdback,phone_height*holdback]);\n  }\n}\n```\n\nHere's a breakdown of the parameters I'd like to be able to control:\n\n*   **Phone Dimensions:** `phone_height`, `phone_width`, `phone_thickness`. These should define the size of the phone that the stand is designed for.\n*   **Stand Dimensions:** `stand_height`, `stand_width`, `stand_thickness`. These should control the overall size of the stand.\n*   **Phone Angle:** `phone_stand_angle`. This determines the angle at which the phone leans back.\n*  **Phone Cutout Position**: `phone_stand_min_height` this is the height from the base of the stand to the bottom of the phone cutout, and `phone_stand_to_back` which is how far from the front of the stand the phone cutout begins.\n*   **Holdback:** `holdback`. This controls the size of the lip at the base of the cutout. Ideally, this is a fraction of the phone's dimensions.\n*  **Holdback_Multiplier** This is unused in the above file, but I'd like to experiment with controlling the depth of the holdback using this multiplier.\n\nI'd also like to make sure it can be easily adjusted for different phone sizes and stand preferences. It should be easy to modify the stand's dimensions, the phone angle, and the holdback. I want this to work with the Customizer, so I need to include the parameter ranges.\n\nI'm open to any suggestions you have on how to make this design better. I'm not using any libraries, but am familiar with BOSL if you think that could help. Could you help me get this design finalized into a single .scad file?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Limit Switch Mount",
    "scad": "switchHolesAboveSlotHoles = 71.0;\nthickness = 7.0;\nbaseWidth = 70.0;\nswitchHolesWidth = 21.5;\nswitchHolesHeight = 10.5;\ntSlotHoleDiameter = 7.0/2;\nswitchHoleDiameter = 3.7/2;\ntSlotHoleHeight = (tSlotHoleDiameter * 2);\nheight = switchHolesAboveSlotHoles - 1 + (tSlotHoleHeight * 2);\ntopWidth = switchHolesWidth + 10.0;\nholeResolution = 20;\ncolor(\"SeaGreen\")\nrotate([0,90,0]) {\ndifference() {\n  polyhedron(\n    points=[ [(thickness/2),(baseWidth/2),0],[(thickness/2),-(baseWidth/2),0],[-(thickness/2),-(baseWidth/2),0],[-(thickness/2),(baseWidth/2),0],\n           [(thickness/2),(topWidth/2),height], [-(thickness/2),(topWidth/2),height], [(thickness/2),-(topWidth/2),height], [-(thickness/2),-(topWidth/2),height]  ],\n    triangles=[ \t[0,1,4],[1,2,6],[2,3,5],[3,0,4],\n \t\t\t\t[3,4,5],[6,2,7], [4,1,6], [2,5,7],\n\t\t\t\t[5,6,7], [5,4,6],\n              \t[1,0,3], [2,1,3] ]\n   );\n  union() {\n     for (y = [-1, 1]) {\n        translate([0, (baseWidth/2 - (tSlotHoleHeight * 1.5)) * y, tSlotHoleHeight]) {\n           rotate([0,90,0]) {\n              cylinder (h = thickness + 1, r=tSlotHoleDiameter, center = true, $fn=holeResolution);\n           }\n        }\n     }\n  }\n  union() {\n     for (z = [0, switchHolesHeight]) {\n        for (y = [-1, 1]) {\n           for (slot = [-1, -0.5, 0, 0.5, 1]) {\n              translate([0, y * (switchHolesWidth/2), (tSlotHoleHeight + switchHolesAboveSlotHoles) + (slot * switchHoleDiameter) - z]) {\n                 rotate([0,90,0]) {\n                    cylinder (h = thickness + 1, r=switchHoleDiameter, center = true, $fn=holeResolution);\n                 }\n              }\n           }\n        }\n     }\n  }\n}\n}",
    "description": "Okay, I'm looking to create a mount for a limit switch that attaches to a T-slot extrusion. I want it to be fully customizable, similar to the provided `Y-Limit-Switch-Mount.scad` file, but I'd like to add some additional features and make the design a bit more robust.\n\nHere's what I need:\n\n**Core Functionality (Based on Provided File):**\n\n*   **T-Slot Mounting:** The mount should attach securely to a T-slot extrusion using two cylindrical holes for bolts.\n*   **Limit Switch Mounting:** It should have adjustable slots to mount a standard limit switch. I'd like 4 hole locations like the existing design, to allow mounting in either direction, with vertical slots instead of just small circle holes.\n\n**Customization Parameters:**\n\n*   `thickness`: The thickness of the mounting plate.\n*   `baseWidth`: The width of the base that attaches to the T-slot.\n*   `switchHolesWidth`: The horizontal center-to-center distance between the limit switch mounting holes.\n*   `switchHolesHeight`: The vertical center-to-center distance between the limit switch mounting holes.\n*   `switchHoleDiameter`: The diameter of the holes for the switch mounting screws.\n*  `switchSlotLength`: The length of the vertical slot in which the switch mounting holes are centered.\n*   `tSlotHoleDiameter`: The diameter of the T-slot mounting holes.\n*   `switchHolesAboveSlotHoles`: The vertical distance from the center of the T-slot mounting holes to the center of the lowest row of limit switch mounting holes.\n*   `holeResolution`: Resolution of the circles and slots, should default to 20.\n\n**New Features/Changes I'd Like:**\n\n1.  **Rounded Corners/Edges:** I'd like the mount to have rounded corners and edges for a more finished and less sharp look. This should be adjustable with a parameter named `edgeRadius`.\n2.  **Optional Gussets:** I'd like to add optional gussets on the sides to increase rigidity. There should be a boolean parameter called `gussetsEnabled` that turns them on or off, and then an additional parameter, `gussetThickness` to adjust the gusset thickness\n3.  **Countersunk Mounting Holes:** The T-slot mounting holes should be countersunk to accommodate flat-head screws.\n4.  **Adjustable Countersink Angle:** I would like to specify the countersink angle with a parameter called `countersinkAngle`.\n5.   **Horizontal Limit Switch Slots**: Rather than just a small hole, I'd like the switch mounting positions to be horizontal slots, similar to the vertical slots but oriented 90 degrees\n6.   **Horizontal Slot Length**: This slot length should also be configurable using a `horizontalSlotLength` parameter.\n7.  **Better code structure:** I want the design to be more modular and readable than the original file.\n\n**Libraries:**\nI am not sure if it's necessary, but I think I'd like to use the BOSL2 library for the countersinking and fillets, if that would make it easier.\n\n**Overall:**\n\nI'm looking for a parametric OpenSCAD file that allows for easy customization of all of these parameters. I'm not too attached to the use of polyhedron and I would prefer a more modular implementation using linear_extrude and other more standard primitives. The design should be robust, easily modified, and well-documented with comments.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Blizzard of Unique Snowflakes",
    "scad": "seed=1;\necho(str(\"Seed \",seed));\nseeds=rands(0,1000000,7,seed);\necho(str(\"Seeds \",seeds));\nhex = rands(0,1,6,seeds[0]);\necho(\"hex \",hex);\nhsolid = rands(0,1,6,seeds[1]);\necho(\"hex solid \",hsolid);\nhhex = rands(0,1,6,seeds[2]);\necho(\"hhex \",hhex);\nlength = rands(5,20,6,seeds[3]);\necho(\"length \",length);\nwidth = rands(0.2,2,6,seeds[4]);\necho(\"width \",width);\nangle = rands(60,120,6,seeds[5]);\necho(\"angle \",angle);\ndepth = rands(1,4,1,,seeds[6])[0];\necho(\"depth \",depth);\nscaleh=0.8 * 1;\nheight0=2 * 1;\nheight=[height0,height0*scaleh,height0*pow(scaleh,2), height0*pow(scaleh,3), height0*pow(scaleh,4), height0*pow(scaleh,5), height0*pow(scaleh,6)];\nif (hex[0]) drawhex(length[1], height[1], hsolid[1]);\nfor (angle1 = [0 : 60 : 359]) {\n\trotate(angle1)arm();\n\t}\nmodule arm() {\n\ttranslate ([0,-width[1]/2,0]) {\n\t\tcube([length[1],width[1],height[1]]);\n\t\ttranslate ([length[1],width[1]/2,0]) {\n\t\t\tif (hex[1]>.5) drawhex(length[2], height[2], hsolid[2]);\n\t\t\tif (hhex[1]>.5) drawhex(length[2]/2, height[2], hsolid[2]);\n\t\t\tif (depth>1) {\n\t\t\t\trotate(-angle[1]) arm2();\n\t\t\t\tarm2();\n\t\t\t\trotate(angle[1]) arm2();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nmodule arm2() {\n\ttranslate ([0,-width[2]/2,0]) {\n\t\tcube([length[2],width[2],height[2]]);\n\t\ttranslate ([length[2],width[2]/2,0]) {\n\t\t\tif (hex[2]>.5) drawhex(length[3], height[3], hsolid[3]);\n\t\t\tif (hhex[2]>.5) drawhex(length[3]/2, height[3], hsolid[3]);\n\t\t\tif (depth>2) {\n\t\t\t\trotate(-angle[2]) arm3();\n\t\t\t\tarm3();\n\t\t\t\trotate(angle[2]) arm3();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nmodule arm3() {\n\ttranslate ([0,-width[3]/2,0]) {\n\t\tcube([length[3],width[3],height[3]]);\n\t\ttranslate ([length[3],width[3]/2,0]) {\n\t\t\tif (hex[3]>.5) drawhex(length[4], height[4], hsolid[4]);\n\t\t\tif (hhex[3]>.5) drawhex(length[4]/2, height[4], hsolid[4]);\n\t\t\tif (depth>3) {\n\t\t\t\trotate(-angle[3]) arm4();\n\t\t\t\tarm4();\n\t\t\t\trotate(angle[3]) arm4();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nmodule arm4() {\n\ttranslate ([0,-width[4]/2,0]) {\n\t\tcube([length[4],width[4],height[4]]);\n\t\ttranslate ([length[4],width[4]/2,0]) {\n\t\t\tif (hex[4]>.5) drawhex(length[5], height[5]);\n\t\t\tif (hhex[4]>.5) drawhex(length[5]/2, height[5]);\n\t\t\t}\n\t\t}\n\t}\nmodule drawhex(size, height, s) {\n\ttranslate([0,0,height/2]) difference() {\n\t\thexagon(size, height);\n\t\tif (s>0.5) translate([0,0,-0.5]) hexagon(size-height, height+1);\n\t\t}\n\t}\nmodule hexagon(size, height) {\n\tboxWidth = size/1.75;\n\tfor (r = [-60, 0, 60]) rotate([0,0,r])\n\t\tcube([boxWidth, size, height], true);\n\t}",
    "description": "Okay, I'm looking to create a parametric OpenSCAD design for snowflakes, similar to the one I've seen. I really like the idea of generating a large number of unique snowflake designs based on a seed number, like the one I've described, but I'd like some additional options for controlling the snowflake's appearance, and I want it to be a bit more flexible in its structure.\n\nHere are the core requirements:\n\n1.  **Seed-Based Generation:** The design *must* use a seed number to generate all of the random parameters. This way, I can recreate the same snowflake by using the same seed. I don't want true random, I want repeatable pseudo-random.\n\n2.  **Hierarchical Structure:** The snowflake should have a hierarchical, branching structure.  It starts from a central point, extends outward with main arms, and then those arms can have their own branches, and so on. It should look like a real snowflake in how it branches.  I'd like to control the number of branching levels, similar to the depth parameter in the example, as well as the scaling of each level.\n\n3.  **Randomized Branch Parameters:** Each level of the branch should have a random set of parameters:\n    *   **Branch Length:** The length of each branch should be random, with a specified range for each level.\n    *   **Branch Width:** The width of each branch should also be random, with a specified range for each level.\n    *   **Branch Angle:** The angle of the secondary branches relative to the main arm should be random, with a specified range for each level, not just the first one. I would like control over the number of sub-branches per level.\n    *   **Branch Shape:** For the branch itself, I'd like more flexibility than just cubes. The branch should be a parametric shape; a rectangle, possibly an ellipse, or even a triangle/polygon.\n    *   **Branch Decoration:** I'd like to optionally add decorations at the end of each branch level. These could include hexagons, circles, or even small, randomized teeth. Think of the different shapes of snow crystal tips. Ideally these would also be parametric.\n    *   **Decoration Shape**: Ability to select a shape for the decorations. Options should include circle, hexagon, diamond, square and triangle.\n    *  **Decoration Size**: Ability to vary the size of the decorations on each level with a random range for each level.\n\n4.  **Hexagonal Base:** I like the hexagonal element in the example I provided, and would like this retained. Each branch can optionally have an inner and outer hexagon of random size at each end. The hexagons should also have a solid/hollow option, so I can create filled or outlined hexagons. \n\n5.  **Height Control:**  The height of each snowflake should be parametric and controlled by a global height and a scaling factor for each level as in the example I've provided, but should also allow for the height of the decorations to scale independently.\n\n6.  **No recursion:**  As in the example provided, the design should *not* use recursion (it doesn't work well in OpenSCAD). Instead, use a method to iterate through a fixed number of levels (depth).\n\n7.  **Easy Parameter Adjustment:** I need to be able to easily adjust the parameter ranges for each level of the snowflake (length, width, angle, branch/decoration size, etc.) so I can create a wide variety of snowflakes without having to modify too much code. Ideally, this would be done using simple parameter arrays.\n\n8. **Use of Libraries:**  I'd like to keep the code as simple as possible and don't want to use any complex libraries for this.\n\nCan you help me create an OpenSCAD design with these requirements?  I'm looking for something I can generate thousands of different snowflake designs with. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customize washer",
    "scad": "include <write/Write.scad>\nwasher_sides = 128;\nfreemode = \"no\";\nfree_id=6.6;\nfree_od=12;\nfree_height=1.2;\ntolerance=0.25;\nsizeM=6.0;\ni_id=sizeM*1.1;\ni_od=sizeM*2.0;\ni_height=sizeM*0.2;\nbuild_size_width = 1;\nbuild_size_depth = 1;\nbuild_space_between_washer = 1;\nif(freemode==\"yes\")\n{\n washer_array_gen(free_id+tolerance,free_od-tolerance,free_height);\n} else\n{\n washer_array_gen(i_id+tolerance,i_od-tolerance,i_height);\n}\nmodule washer_gen(id,od,height) {\n\t$fn = washer_sides;\n\t\tdifference () {\n\t\t\tcylinder(r = od/2, h = height);\n\t\t\ttranslate([0,0,-height*2]) cylinder(r = id/2, h = height*4);\n         writecylinder(str(sizeM),[0,0,0],(id-tolerance),height-0.5,h=sizeM/3,face=\"top\");\n\t}\n}\nmodule washer_array_gen(id,od,height) {\n\tmax_width_count = build_size_width;\n\tmax_depth_count = build_size_depth;\n\tfor (x = [0:max_width_count-1]) {\n\t\tfor (y = [0:max_depth_count-1]) {\n\t\t\t\ttranslate([x*(od+build_space_between_washer),y*(od+build_space_between_washer),0]) washer_gen(id,od,height);\n\t\t}\n\t}\n}",
    "description": "Okay, I'd like to request a parametric OpenSCAD file for generating washers. I need it to be flexible enough to create both standard \"M\" sized washers based on a table and also freeform washers where I specify the inner diameter, outer diameter, and height directly.\n\nHere's a breakdown of what I'm looking for:\n\n**Core Functionality:**\n\n*   **Washer Generation:** The core function should generate a washer (a cylinder with a concentric hole). It needs to be able to handle different inner diameters, outer diameters, and heights.\n*   **\"M\" Sized Washers:** I need a way to specify an \"M\" size (e.g., M6, M8, etc.). Based on this M size, the script should automatically calculate the inner diameter, outer diameter, and height of the washer according to something similar to the BS4320: 1968 standard using the dimensions found in the roymech.co.uk link I included (I don't need it to be exact but should follow the formula of a multiplier of sizeM). For example:\n    *   Inner Diameter (i_id) should be a bit bigger than the M size, something like `sizeM * 1.1`.\n    *   Outer Diameter (i_od) should be larger than the inner diameter, like `sizeM * 2.0`.\n    *   Height (i_height) should be relatively small, like `sizeM * 0.2`.\n*   **Freeform Washers:** I need the ability to bypass the \"M\" sizing and directly specify the inner diameter, outer diameter, and height.\n\n**Parameters:**\n\n*   **`freemode`:** A string variable that can be either `\"yes\"` or `\"no\"`. If `\"yes\"`, then the script uses the freeform parameters. If `\"no\"`, it uses the M sizing system.\n*   **`free_id`:** When `freemode` is `\"yes\"`, this float is the inner diameter of the washer. Should have a reasonable range, maybe `0:200`.\n*   **`free_od`:** When `freemode` is `\"yes\"`, this float is the outer diameter of the washer. Should have a reasonable range, maybe `0:200`.\n*   **`free_height`:** When `freemode` is `\"yes\"`, this float is the height of the washer. Should have a reasonable range, maybe `0:100`.\n*   **`sizeM`:** When `freemode` is `\"no\"`, this float defines the \"M\" size of the washer (e.g., 6 for M6). I'd like to have a list of preset M sizes to choose from via a drop down, something like `[2,3,4,5,6,8,10,12,16,20,24]`.\n*   **`tolerance`:** A float that adds to the inner diameter and subtracts from the outer diameter. Should have a reasonable range, maybe `0:1`.\n\n**Array Generation:**\n\n*   **Array Creation:** It should include a module that automatically arranges the washers in a grid.\n*   **`build_size_width`:** An integer determining how many washers to place in a row. Have a range of `[1,5,10]`.\n*   **`build_size_depth`:** An integer determining how many rows to create. Have a range of `[1,5,10]`.\n*   **`build_space_between_washer`:** A float for the space between washers in the grid.\n\n**Additional Considerations:**\n\n*   **Write Cylinder Text:** There should also be a text label written onto the top face of each washer, something that says what M-size it is, which is made using the `writecylinder()` module in the included library \"write/Write.scad\".\n*   **`washer_sides`:** A variable that controls the number of sides used for the cylinder.\n\n**Libraries Used:**\n\n*   `write/Write.scad`\n\nI think that covers everything! Let me know if you need any clarifications.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Ring - inside and out",
    "scad": "include <write/Write.scad>\nOutterMessage = \"I <3 MakerBot\";\nInnerMessage = \"I <3 OpenSCAD\";\nFont = \"write/Letters.dxf\";\nfont_size = 10;\nfont_spacing = 0;\nring_thickness = 1.6;\nring_width = 6;\nring_size = 18.14;\ninner_diameter = ring_size;\ninner_radius = inner_diameter/2;\nfont_scale = font_size/10;\nspacing_factor = font_spacing/100;\ntranslate([0,0,ring_width/2])\nring();\nmodule ring() {\n\tif(ring_thickness == .8){\n\t\tdifference(){\n\t\t\tdifference(){\n\t\t\t\ttranslate([0,0,0])\n\t\t\t\t\tcylinder(r=inner_radius+ring_thickness,h=ring_width,$fn = 100,center = true);\n\t\t\t\tscale(font_scale)\n\t\t\t\t\t{\n\t\t\t\t\twritecylinder(OutterMessage,[0,0,0],((inner_radius+ring_thickness)/font_scale)+.1,ring_width,space=1.05+spacing_factor,rotate=0,up=.5,center = true,font = Font);\n\t\t\t\t\tmirror([1,0,0]) writecylinder(InnerMessage,[0,0,0],((inner_radius)/font_scale)-0.3,ring_width,space=1.10+spacing_factor,rotate=0,up=.5,center = true,font = Font);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tcylinder(r=inner_radius,h=ring_width+1,$fn = 100,center = true);\n\t\t}\n\t}\n\telse{\n\t\tdifference(){\n\t\t\tdifference(){\n\t\t\t\ttranslate([0,0,0])\n\t\t\t\t\tcylinder(r=inner_radius+ring_thickness,h=ring_width,$fn = 100,center = true);\n\t\t\t\tscale(font_scale)\n\t\t\t\t\t{\n\t\t\t\t\twritecylinder(OutterMessage,[0,0,0],\n\t\t\t\t\t\t(inner_radius+ring_thickness)/font_scale*1.01,ring_width,space=1.05+spacing_factor,\n\t\t\t\t\t\trotate=0,up=.5,center = true,font = Font);\n\t\t\t\t\tmirror([1,0,0])\n\t\t\t\t\twritecylinder(InnerMessage,[0,0,0],\n\t\t\t\t\t\t(inner_radius)/font_scale-0.25,ring_width,space=1.10+spacing_factor,\n\t\t\t\t\t\trotate=0,up=.5,center = true,font = Font);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tcylinder(r=inner_radius,h=ring_width+1,$fn = 100,center = true);\n\t\t}\n\t}\n}",
    "description": "Okay, I'm looking for a customizable ring design in OpenSCAD. I want to be able to engrave text on both the outside and inside of the ring.\n\nHere are the parameters I'd like to be able to control:\n\n*   **Outer Message:**  A string of text that will be engraved on the outer surface of the ring. I'd like this to be limited to a maximum of 26 characters, just to make sure it fits nicely.\n*   **Inner Message:** A string of text for the inner surface of the ring, also with a 26 character limit.\n*   **Font:**  I'd like to be able to select the font from a predefined list of fonts using the `write/Write.scad` library. Specifically, I'd like to be able to choose between \"write/Letters.dxf\" for a basic font, \"write/orbitron.dxf\" for a futuristic font, and \"write/BlackRose.dxf\" for a fancy font.\n*   **Font Size:** An integer that allows me to control the text size. I want to be able to scale from 10-20.\n*   **Font Spacing:** An integer to adjust the spacing between characters. This can be both positive (increase spacing) or negative (decrease spacing) and range from -100 to 100.\n*   **Ring Thickness:** A float value to adjust the ring's wall thickness. I need options for \"Thin\" at 0.8, \"Normal\" at 1.6, and \"Thick\" at 2.4.\n*   **Ring Width:**  The width of the ring along the Z-axis, which should be between 6 and 12.\n*   **Ring Size:** The inner diameter of the ring using standard US ring sizes, specified in millimeters. I need to be able to select from the list provided: 11.63:0, 11.84:0.25, 12.04:0.5, 12.24:0.75, 12.45:1, 12.65:1.25, 12.85:1.5, 13.06:1.75, 13.26:2, 13.46:2.25, 13.67:2.5, 13.87:2.75, 14.07:3, 14.27:3.25, 14.48:3.5, 14.68:3.75, 14.88:4, 15.09:4.25, 15.29:4.5, 15.49:4.75, 2215.9:5.25, 16.1:5.5, 16.31:5.75, 16.51:6, 16.71:6.25, 16.92:6.5, 17.12:6.75, 17.32:7, 17.53:7.25, 17.73:7.5, 17.93:7.75, 18.14:8, 18.34:8.25, 18.54:8.5, 18.75:8.75, 18.95:9, 19.15:9.25, 19.35:9.5, 19.56:9.75, 19.76:10, 19.96:10.25, 20.17:10.5, 20.37:10.75, 20.57:11, 20.78:11.25, 20.98:11.5, 21.18:11.75, 21.39:12, 21.59:12.25, 21.79:12.5, 22:12.75, 22.2:13, 22.4:13.25, 22.61:13.5, 22.81:13.75, 23.01:14, 23.22:14.25, 23.42:14.5, 23.62:14.75, 23.83:15, 24.03:15.25, 24.23:15.5, 24.43:15.75, 24.64:16\n\nThe design should use the `writecylinder` function from the `write/Write.scad` library to engrave the text onto the cylinder. It's important that the inner message is mirrored so it reads correctly when viewed from inside the ring and also scaled to fit.\n\nCan you generate the OpenSCAD file that will accomplish this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Magnetic Driver Bit Handle",
    "scad": "MagDia = 8.4;\nBitDia = 7.6;\nBitDth = 12;\nHandDia = 23;\nHandLen = 80;\nVertDia = 14;\nVertOff = 4.7;\nGripDia = 6;\nGripDth = 2.5;\nGripRatioTop = 4;\nGripRatioBot = 1.5;\nGripOff = 6;\ndifference()\n{\n\tcylinder(HandLen,HandDia/2,HandDia/2,$fn=6);\n\ttranslate([0,0,HandLen-HandDia+6])\n\t\tdifference()\n\t\t{\n\t\t\tsphere(HandDia, $fn=36);\n\t\t\tsphere(HandDia-6, $fn=36);\n\t\t\ttranslate([0,0,-HandDia])\n\t\t\t\tcube([HandDia*2,HandDia*2,HandDia*2],true);\n\t\t}\n\ttranslate([0,0,-1])\n\t\tdifference()\n\t\t{\n\t\t\tcylinder(HandLen+2,HandDia,HandDia,$fn=72);\n\t\t\tcylinder(HandLen+2,HandDia/2-.5,HandDia/2-.5,$fn=36);\n\t\t}\n\tfor(x = [30 : 60 : 330])\n\t\trotate([0,0,x])\n\t\t\ttranslate([HandDia/2+VertOff,0,-1])\n\t\t\t\tcylinder(HandLen+2,VertDia/2,VertDia/2,$fn=36);\n\ttranslate([0,0,GripDia+GripOff])\n\t\tdifference()\n\t\t{\n\t\t\trotate_extrude(convexity=10,$fn=36)\n\t\t\t\ttranslate([HandDia/2+GripDia-GripDth, 0, 0])\n\t\t\t\t\tscale([1,GripRatioTop,1])\n\t\t\t\t\t\tcircle(GripDia);\n\t\t\ttranslate([0,0,-(GripDia*GripRatioTop+.01)])\n\t\t\t\tcylinder(GripDia*GripRatioTop,HandDia,HandDia);\n\t\t}\n\ttranslate([0,0,GripDia+GripOff])\n\t\tdifference()\n\t\t{\n\t\t\trotate_extrude(convexity=10,$fn=36)\n\t\t\t\ttranslate([HandDia/2+GripDia-GripDth, 0, 0])\n\t\t\t\t\tscale([1,GripRatioBot,1])\n\t\t\t\t\t\tcircle(GripDia);\n\t\t\tcylinder(GripDia*GripRatioBot,HandDia,HandDia);\n\t\t}\n\ttranslate([0,0,-1])\n\t\tcylinder(BitDth+1,BitDia/2,BitDia/2,$fn=6);\n\ttranslate([0,0,BitDth-.1])\n\t\tcylinder(HandLen,MagDia/2,MagDia/2,$fn=36);\n}",
    "description": "Okay, I'm looking for a fully parametric magnetic handle for 1/4\" driver bits. I've got an existing design that I like the basic shape of, but I want to make it more customizable.\n\nHere's what I'm thinking:\n\n**Core Functionality:**\n\n*   **Magnetic Bit Retention:** It needs to hold standard 1/4\" driver bits using a magnet.\n*   **Customizable Dimensions:** I want to easily change the overall handle size, grip features, and magnet/bit hole sizes.\n\n**Specific Features (Based on my Current Design):**\n\n*   **Handle Shape:** It should be a cylindrical handle with a slightly rounded top and bottom, like a pill.\n*   **Rounded Top:** I want the top to have a smooth, rounded profile, similar to a sphere cut off at the base with an inset.\n*   **Chamfered Edges:** I like that it has the rounded edges where the cylinder joins with the top, not sharp corners.\n*   **Vertical Grips:** There should be vertical grooves or slots around the main cylinder to improve grip, evenly spaced.\n*   **Finger Grips:** It should have oval-shaped depressions for the fingers that are shallower than the grip slots and wrap around the handle. These depressions should have a different ratio of height to width on the top and bottom.\n*   **Bit Hole:**  A hole for the 1/4\" driver bits. This should go deeper into the handle than the magnet hole.\n*   **Magnet Hole:**  A separate hole for the magnet, positioned slightly behind the bit hole.\n\n**Parametric Design Requests:**\n\nI want to control these parameters with variables:\n\n*   `magnet_diameter`:  Diameter of the magnet hole.\n*   `bit_diameter`: Diameter of the 1/4\" driver bit hole.\n*   `bit_depth`: Depth of the bit hole.\n*   `handle_diameter`: Diameter of the main handle cylinder.\n*   `handle_length`: Length of the main handle cylinder.\n*   `rounded_top_diameter`: Diameter of the sphere for the top cap. (should be tied to `handle_diameter` for good scaling)\n    *   `rounded_top_inset`: The amount of the inset on the sphere.\n*   `chamfer_size`: Radius of the rounded over corner on the main cylinder\n*   `vertical_grip_diameter`: Diameter of the vertical grip slots.\n*   `vertical_grip_offset`:  Distance from the outer edge of the handle to the center of the grip slots.\n*   `finger_grip_diameter`: Diameter of the finger grip depressions.\n*   `finger_grip_depth`: Depth of the finger grip depressions.\n*    `finger_grip_top_ratio`: Height/Width ratio of finger grip on the top half.\n*    `finger_grip_bottom_ratio`: Height/Width ratio of finger grip on the bottom half.\n*   `finger_grip_offset`: Offset of the grips from the bottom of the handle\n*   `vertical_grip_count`: Number of vertical grip slots, which will determine their angle spacing.\n\n**Additional Requests:**\n\n*   I would like to see the code be easy to understand, with clear comments explaining what each part does.\n*   I'd like to avoid any hardcoded values as much as possible.\n*   Please use the BOSL2 library for any shapes or transformations that are part of that library.\n\nEssentially, I need a parametric version of my current design. I'm not expecting you to handle every possible variation under the sun but, the parameters I've listed above need to be configurable.\n\nCan you generate an OpenSCAD file for this design, using the parameters above?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizer'ed denture holder",
    "scad": "1_part=\"both\";\n2_width=71;\n3_height=23.5;\n4_length=56;\n5_curve=30;\n6_wall_thickness=1.5;\n7_Top_Smudge_Factor=5;\nwidth=2_width+1-1;\nheight=3_height+1-1;\nlength=4_length+1-1;\ncurve=5_curve+1-1;\nwallthickness=6_wall_thickness+1-1;\nlc=length-curve;\ncyl=width/2;\ncurcyl=curve/cyl;\nfingz=height/2;\nfingw=fingz/2;\nfingh=width+2+wallthickness*4;\n$fn = 164 + 1;\nTopSmugeFactor=7_Top_Smudge_Factor/100;\nif( 1_part == \"top\" ){\n\ttop();\n}else {\nif( 1_part == \"bottom\" ){\n\tbottom();\n}else {\n\ttranslate([-(length+wallthickness*6)/2,0,0])top();\n\ttranslate([(length+wallthickness*6)/2,0,0])bottom();\n}}\nmodule top(){\n\ttranslate([-(length+wallthickness*4+TopSmugeFactor)/2,-(width+wallthickness*4+TopSmugeFactor)/2,0])difference(){\n\t\tbasic(0,4,TopSmugeFactor,fingz);\n\t\ttranslate([wallthickness,wallthickness,wallthickness])basic(2,2,TopSmugeFactor,fingz);\n\t\ttranslate([length/2,-1,fingz])rotate([-90,0,0])scale([1.5,1,1])cylinder(fingh,fingw,fingw);\n\t}\n}\nmodule bottom(){\n\ttranslate([-(length+wallthickness*2)/2,-(width+wallthickness*2)/2,0])difference(){\n\t\tbasic(0,2);\n\t\ttranslate([wallthickness,wallthickness,wallthickness])basic(2);\n\t}\n}\nmodule basic(plus=0,thick=0,fuge=0,th=height){\n\txw1=(length+wallthickness*thick+fuge)/length;\n\tyw1=(width+wallthickness*thick+fuge)/width;\n\tzw1=th+wallthickness+plus;\n\tscale([xw1,yw1,1]){\n\t\tcube([lc,width,zw1]);\n\t\tdifference(){\n\t\t\ttranslate([lc,cyl,0])scale([curcyl,1,1])cylinder(zw1,cyl,cyl);\n\t\t\ttranslate([-curve+10,-1,-1])cube([curve+10,width+2,zw1+2]);\n\t\t}\n\t}\n}",
    "description": "Okay, I need a custom container designed to hold and protect my dentures. I'd like it to be a two-part box, with a base and a lid, and I want to be able to adjust the dimensions easily based on my specific denture measurements.\n\nHere's what I'm envisioning:\n\n*   **Two-Part Design:** The design should consist of a base cup that the dentures sit in and a top cover that fits snugly over the base.\n*   **Parametric Design:** I need the design to be fully parametric, controlled by variables for things like the width, height, and length of the dentures, as well as wall thickness and a little bit of a gap between the top and bottom for a good fit.\n*   **Denture Measurements:** I've identified the key measurements I'll be taking, and the OpenSCAD script should have variables for each:\n    *   `width`: The width of the dentures including gums at the widest point (molar to molar).\n    *   `height`: The vertical height of the dentures, measured with them placed on a table, including the gums at the top.\n    *   `length`: The length of the dentures, including gums, measured in the direction food goes down.\n    *   `curve`: The distance from the very front of the dentures to the canine teeth along the length.\n    *   `wall_thickness`: The thickness of the box walls.\n    *   `Top_Smudge_Factor`: A small gap added between the top and bottom for a good fit (a small amount).\n\n*   **Finger Holes/Grips:** I'd like there to be some small holes or grips on the sides of the top cover to make it easier to remove. A small cylindrical finger hole on either side of the top should be fine.\n\n*   **Units:** All measurements should be in millimeters.\n*   **Output:** I would like to be able to select which part of the design to generate, i.e. just the top cover, just the base, or both. This should be controlled by a single variable.\n\nI'd prefer a fairly simple, clean design  no need for fancy curves or decorations. Functionality and parametric control are the most important things.  I'm comfortable with fairly low tolerances, and do not need any extra features such as threading or living hinges.\n\nPlease use OpenSCAD to create this parametric model. I don't need any other libraries to be included.\n"
  },
  {
    "object": "Hey cadmonkey, make me a OpenSCAD Helical Gears",
    "scad": "doubleHelical=1;\ngearHeight=7;\npitchDiam=45;\nshaftDiam=5;\nteethNum=30;\naddendum=2;\ndedendum=2;\ntoothWidth=2;\nangle=-30;\norientation=-1;\ncenterShape=3;\nstarNum=6;\nstarWidth=2;\ncircleNum=7;\ncircleDiam=7;\nextrudeOut=1;\nextrudeOutHeight=3;\nextrudeOutWidth=7;\nextrudeIn=1;\nextrudeInDiam=pitchDiam/2-dedendum*2;\nextrudeInHeight=3;\nrome=0;\nromeDiam=pitchDiam/2;\nromeHeight=gearHeight;\nromeTeeth=teethNum*2/3;\nromeAdd=2;\nromeDed=2;\nromeToothWidth=2;\nromeAngle=5;\ngear();\nmodule tooth(heightGear, diamPitch) {\n\ttoothHeight=addendum+dedendum*2;\n\tunion(){\n\t\ttranslate([0,toothHeight/2,0]) rotateTooth(1);\n\t\tif (doubleHelical==1){\n\t\t\ttranslate([0,toothHeight/2,-heightGear+0.1]) rotateTooth(-1);\n\t\t}\n\t}\n\tmodule rotateTooth(direction){\n\t\tdifference(){\n\t\t\trotate([0,direction*angle,0])\n\t\t\tbox(toothWidth,toothHeight,heightGear*1.5);\n\t\t\ttranslate([0,0,heightGear*0.75+dedendum/2])\n\t\t\tbox(heightGear,toothHeight+0.5,dedendum+heightGear/2);\n\t\t\ttranslate([0,0,-heightGear*0.75-dedendum/2])\n\t\t\tbox(heightGear,toothHeight+0.5,dedendum+heightGear/2);\n\t\t}\n\t}\n}\nmodule helical(numTeeth, diamPitch, heightGear) {\n\trootRad=diamPitch/2-dedendum;\n\tdifference(){\n\tfor (i = [1:numTeeth]) {\n\t\ttranslate([sin(360*i/numTeeth)*(rootRad-dedendum), cos(360*i/numTeeth)*(rootRad-dedendum), 0 ]){\n\t\t\trotate([0,0,-360*i/numTeeth]) tooth(heightGear, diamPitch);\n\t\t}\n\t}\n\ttranslate([0,0,-gearHeight/2-1]) cylinder(heightGear+2, diamPitch/2-dedendum, diamPitch/2-dedendum);\n\t}\n}\nmodule solid(heightGear, diamPitch) {\n\trootRad=diamPitch/2-dedendum;\n\ttranslate([0,0,-(heightGear*doubleHelical)+0.1*doubleHelical])\n\tcylinder(heightGear+(heightGear-0.1)*doubleHelical, rootRad, rootRad);\n}\nmodule star() {\n\tstarAngle=360/starNum;\n\trootRad=diamPitch/2-dedendum;\n\tunion(){\n\t\tfor (s=[1:starNum]){\n\t\t\ttranslate([0,0,gearHeight/2-(gearHeight/2*doubleHelical)]){\n\t\t\t\trotate([0, 0, s*starAngle]) dislocateBox(starWidth, (pitchDiam/2-dedendum*2)/2, gearHeight+(gearHeight*doubleHelical));\n\t\t\t}\n\t\t}\n\t\ttranslate ([0,0,-gearHeight*doubleHelical])\n\t\ttube(gearHeight+(gearHeight*doubleHelical), pitchDiam/2-dedendum, starWidth);\n\t\ttranslate ([0,0,-gearHeight*doubleHelical]){\n\t\t\ttube(gearHeight+(gearHeight*doubleHelical), pitchDiam/4+dedendum, starWidth);\n\t\t}\n\t\ttranslate([0,0,-gearHeight*doubleHelical])\n\t\tcylinder(gearHeight+(gearHeight*doubleHelical), shaftDiam/2+starWidth, shaftDiam/2+starWidth);\n\t}\n}\nmodule circle() {\n\trootRad=pitchDiam/2-dedendum;\n\tdifference(){\n\t\tsolid(gearHeight-0.1*doubleHelical, pitchDiam);\n\t\tfor (c=[1:circleNum]){\n\t\t\ttranslate([sin(360*c/circleNum)*(rootRad/2+shaftDiam/2), cos(360*c/circleNum)*(rootRad/2+shaftDiam/2), -gearHeight*doubleHelical]){\n\t\t\t\tcylinder(gearHeight+gearHeight*doubleHelical, circleDiam/2, circleDiam/2);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule romeGear(){\n\ttranslate([0,0,romeHeight/2+gearHeight]){\n\t\trotate([0,0,romeAngle]){\n\t\t\tunion(){\n\t\t\t\thelical(romeTeeth, romeDiam, romeHeight);\n\t\t\t\ttranslate ([0,0,-romeHeight/2]) solid(romeHeight, romeDiam);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule gear(){\n\tdifference () {\n\t\tunion() {\n\t\t\ttranslate([0,0,gearHeight/2]) helical(teethNum, pitchDiam, gearHeight);\n\t\t\tif (centerShape==1) solid(gearHeight, pitchDiam);\n\t\t\tif (centerShape==2) star();\n\t\t\tif (centerShape==3) circle();\n\t\t\tif (rome==1) romeGear();\n\t\t\tif (extrudeOut==1) {\ntranslate([0,0,-gearHeight*doubleHelical+0.1*doubleHelical])\tcylinder(gearHeight-(extrudeInHeight*extrudeIn)+extrudeOutHeight+romeHeight*rome+gearHeight*doubleHelical-0.1*doubleHelical, extrudeOutWidth/2+shaftDiam/2, extrudeOutWidth/2+shaftDiam/2);\n\t\t\t}\n\t\t}\n\t\tif (extrudeIn==1) {\n\t\t\tdifference(){\n\t\t\t\ttranslate([0,0,gearHeight-extrudeInHeight+0.1*doubleHelical]) cylinder(extrudeInHeight, extrudeInDiam, extrudeInDiam);\n\t\t\t\tcylinder(gearHeight+extrudeOutHeight, (extrudeOutWidth+shaftDiam)/2*extrudeOut, (extrudeOutWidth+shaftDiam)/2*extrudeOut);\n\t\t\t}\n\t\t}\n\ttranslate([0,0,-gearHeight*doubleHelical]) cylinder(gearHeight+extrudeOutHeight+romeHeight+(gearHeight*doubleHelical), shaftDiam/2, shaftDiam/2);\n\t}\n}\nmodule dislocateBox(xBox, yBox, zBox){\n\ttranslate([0,yBox,0]){\n\t\tdifference(){\n\t\t\tbox(xBox, yBox*2, zBox);\n\t\t\ttranslate([-xBox,0,0]) box(xBox, yBox*2, zBox);\n\t\t}\n\t}\n}\nmodule box(xBox, yBox, zBox) {\n\tscale ([xBox, yBox, zBox]) cube(1, true);\n}\nmodule cone(height, radius) {\n\t\tcylinder(height, radius, 0);\n}\nmodule oval(xOval, yOval, zOval) {\n\tscale ([xOval/100, yOval/100, 1]) cylinder(zOval, 50, 50);\n}\nmodule tube(height, radius, wall) {\n\tdifference(){\n\t\tcylinder(height, radius, radius);\n\t\tcylinder(height, radius-wall, radius-wall);\n\t}\n}\nmodule hexagon(height, depth) {\n\tboxWidth=height/1.75;\n\t\tunion(){\n\t\t\tbox(boxWidth, height, depth);\n\t\t\trotate([0,0,60]) box(boxWidth, height, depth);\n\t\t\trotate([0,0,-60]) box(boxWidth, height, depth);\n\t\t}\n}\nmodule octagon(height, depth) {\n\tintersection(){\n\t\tbox(height, height, depth);\n\t\trotate([0,0,45]) box(height, height, depth);\n\t}\n}\nmodule dodecagon(height, depth) {\n\tintersection(){\n\t\thexagon(height, depth);\n\t\trotate([0,0,90]) hexagon(height, depth);\n\t}\n}\nmodule hexagram(height, depth) {\n\tboxWidth=height/1.75;\n\tintersection(){\n\t\tbox(height, boxWidth, depth);\n\t\trotate([0,0,60]) box(height, boxWidth, depth);\n\t}\n\tintersection(){\n\t\tbox(height, boxWidth, depth);\n\t\trotate([0,0,-60]) box(height, boxWidth, depth);\n\t}\n\tintersection(){\n\t\trotate([0,0,60]) box(height, boxWidth, depth);\n\t\trotate([0,0,-60]) box(height, boxWidth, depth);\n\t}\n}\nmodule rightTriangle(adjacent, opposite, depth) {\n\tdifference(){\n\t\ttranslate([-adjacent/2,opposite/2,0]) box(adjacent, opposite, depth);\n\t\ttranslate([-adjacent,0,0]){\n\t\t\trotate([0,0,atan(opposite/adjacent)]) dislocateBox(adjacent*2, opposite, depth);\n\t\t}\n\t}\n}\nmodule equiTriangle(side, depth) {\n\tdifference(){\n\t\ttranslate([-side/2,side/2,0]) box(side, side, depth);\n\t\trotate([0,0,30]) dislocateBox(side*2, side, depth);\n\t\ttranslate([-side,0,0]){\n\t\t\trotate([0,0,60]) dislocateBox(side*2, side, depth);\n\t\t}\n\t}\n}\nmodule 12ptStar(height, depth) {\n\tstarNum=3;\n\tstarAngle=360/starNum;\n\tfor (s=[1:starNum]){\n\t\trotate([0, 0, s*starAngle]) box(height, height, depth);\n\t}\n}",
    "description": "Hi, I'm working on a project involving gears, and I'm looking for a parametric OpenSCAD script to generate helical gears. I've been experimenting with some existing scripts, and I like the general approach used in the 'gears_helical.scad' and 'gears_helical_v2.scad' files I've found, but I need a more flexible and robust solution.  I'm not fully happy with the hard-coded numbers and wish to create gears with more dynamic parameters.\n\nHeres what Im aiming for:\n\n**Gear Parameters (Must be fully parametric):**\n\n*   **Double Helical:** A boolean parameter (true/false or 1/0) to toggle whether the gear should be a double helical gear. If true, the gear needs to be twice the single height and have mirrored helixes.\n*   **Gear Height:**  The overall height/depth of the gear (single height in the case of single helical).\n*   **Pitch Diameter:** The pitch diameter of the gear.\n*   **Shaft Diameter:** The diameter of the hole in the center for the shaft.\n*   **Number of Teeth:** The number of teeth on the gear.\n\n**Tooth Parameters (Must be fully parametric):**\n\n*   **Addendum:** The addendum of the gear teeth.\n*   **Dedendum:** The dedendum of the gear teeth.\n*   **Tooth Width:** The width of a single tooth.\n*   **Helix Angle:** The angle of the helix. A positive value should generate right-handed gears, and a negative value should generate left-handed gears. I'm also concerned that both gear files offset the mirrored section of double-helical gears by 0.1mm.\n*   **Orientation:** An integer parameter to control the orientation of the helix. While not correctly implemented in 'gears_helical.scad', this should control the \"hand\" of the helix (1 for left, -1 for right). This might be unnecessary if Helix Angle works correctly.\n\n**Center Shape Parameters (Selectable Options):**\n\n*   **Center Shape Type:** An integer to determine the shape of the center of the gear:\n    *   1 = Solid core: no hole shapes.\n    *   2 = Star: A star shape in the center\n    *   3 = Circles: A pattern of circular holes.\n*   **Star Number:** If the center shape is a star, the number of points for the star.\n*   **Star Width:** If the center shape is a star, the width of the star arms.\n*   **Circle Number:** If the center shape is circles, the number of circles.\n*   **Circle Diameter:** If the center shape is circles, the diameter of the circles.\n\n**Center Extrusion Parameters (Optional):**\n\n*   **Extrude Out:** Boolean to enable/disable an extrusion around the shaft (like a hub).\n*   **Extrude Out Height:** If `extrudeOut` is enabled, the height of the extrusion.\n*   **Extrude Out Width:** If `extrudeOut` is enabled, the width of the extrusion (in relation to shaft diameter, maybe as a multiple?).\n*   **Extrude In:** Boolean to enable/disable an extrusion inwards from gear base diameter to the shaft bore.\n*   **Extrude In Diameter:** If `extrudeIn` is enabled, the diameter for the inward extrusion.\n*    **Extrude In Radius:** If `extrudeIn` is enabled, the radius for the inward extrusion.\n*   **Extrude In Height:** If `extrudeIn` is enabled, the height of the inward extrusion.\n\n**Rome Gear Parameter (Optional, needs to be mutually exclusive with 'extrudeIn'):**\n\n*   **Rome Gear:** Boolean to enable/disable a \"rome gear\" on top of the base gear.\n*   **Rome Diameter:** If rome gear is enabled, the pitch diameter of the rome gear.\n*   **Rome Height:** If rome gear is enabled, the height of the rome gear.\n*   **Rome Teeth:** If rome gear is enabled, the number of teeth of the rome gear.\n*   **Rome Addendum:** If rome gear is enabled, the addendum of the rome gear teeth.\n*   **Rome Dedendum:** If rome gear is enabled, the dedendum of the rome gear teeth.\n*  **Rome Tooth Width**: if rome gear is enabled, the tooth width of the rome gear.\n*   **Rome Angle:** If rome gear is enabled, the rotation angle of the rome gear.\n\n**Important Considerations:**\n\n*   The code should be well-commented and easy to understand.\n*   I'd like to avoid the 0.1mm offset for double-helical gears, so the mirrored teeth should be properly unioned.\n*   I want the `extrudeIn` to use a diameter (as is was intended) and a radius, as the original file mistakenly did.\n\n**Libraries:**\n\nI am happy for you to make use of standard OpenSCAD functions and don't need any custom libraries for basic shape generation, but please avoid the need for specific OpenSCAD files within the library\n\nCould you please generate an OpenSCAD file that fulfills these requirements? I'm aiming for a clean, well-structured, and flexible solution.\n\nThank you!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Bicycle Light Mount",
    "scad": "PART_GAP = 0.25;\nHANDLEBAR_TUBE_DIAMETER = 1.01 ;\nHANDLEBAR_CLAMP_WIDTH = .3 ;\nHANDLEBAR_CLAMP_THICKNESS = .2 ;\nHANDLEBAR_CLAMP_BOLT_DIAMETER = 0.12 ;\nHANDLEBAR_CLAMP_BOLT_CAP_DIAMETER = 0.22 ;\n\tHC_MAXX = HANDLEBAR_TUBE_DIAMETER/2 + HANDLEBAR_CLAMP_WIDTH;\n\tHC_MAXY = HANDLEBAR_TUBE_DIAMETER/2 + HANDLEBAR_CLAMP_THICKNESS;\n\tHC_BOLTX = HC_MAXX - HANDLEBAR_CLAMP_WIDTH/2;\nHANDLEBAR_CLAMP_DROP_LENGTH = 2;\nHANDLEBAR_CLAMP_DROP_BOLT_DIAMETER = 0.25;\nLIGHT_DIAMETER = 1.2;\nLIGHT_CLAMP_WIDTH = 2;\nLIGHT_CLAMP_FLANGE = 0.3;\nLIGHT_CLAMP_THICKNESS = .2;\nLIGHT_CLAMP_BOLT_DIAMETER = 0.25;\nLIGHT_CLAMP_BRACKETL_MIN = 1.5;\n\tLC_MAXX = LIGHT_DIAMETER/2 + LIGHT_CLAMP_FLANGE;\n\tLC_MAXY = LIGHT_DIAMETER/2 + LIGHT_CLAMP_THICKNESS;\n\tLC_BOLTX = LC_MAXX - LIGHT_CLAMP_FLANGE/2;\n\tSUPX = LC_MAXY-sqrt(pow(LC_MAXY,2)-pow(LIGHT_DIAMETER/2,2));\n\tSUPY = (LIGHT_CLAMP_WIDTH-(LIGHT_CLAMP_THICKNESS*2+LIGHT_CLAMP_BOLT_DIAMETER))/2;\n\tBRACKETL = LIGHT_DIAMETER+(LIGHT_CLAMP_FLANGE-HANDLEBAR_CLAMP_BOLT_CAP_DIAMETER);\n\tBRACKETR = LIGHT_CLAMP_THICKNESS+LIGHT_CLAMP_BOLT_DIAMETER/2;\nmodule BoltCut () {\n\tunion () {\n\t\tcylinder (h=HC_MAXY, r=HANDLEBAR_CLAMP_BOLT_CAP_DIAMETER/2, center=false);\n\t\tcylinder (h=HC_MAXY*2, r=HANDLEBAR_CLAMP_BOLT_DIAMETER/2, center=true);\n\t}\n}\nmodule ClampBoltCut () {\n\ttranslate ([HC_BOLTX,-(HANDLEBAR_CLAMP_WIDTH-HANDLEBAR_CLAMP_BOLT_CAP_DIAMETER/2),0]) rotate ([90,0,0]) BoltCut ();\n}\nmodule LightClampBoltCut () {\n\ttranslate ([LC_BOLTX,-(LIGHT_CLAMP_FLANGE-HANDLEBAR_CLAMP_BOLT_CAP_DIAMETER/2),0]) rotate ([90,0,0]) BoltCut ();\n}\nmodule HandlebarClamp () {\n\tdifference () {\n\t\tunion () {\n\t\tcylinder (h=HANDLEBAR_CLAMP_WIDTH, r=HC_MAXY, center = true);\n\t\tcube(size=[HC_MAXX*2, HANDLEBAR_CLAMP_WIDTH * 2, HANDLEBAR_CLAMP_WIDTH], center = true);\n\t\t}\n\t\tcylinder (h=HANDLEBAR_CLAMP_WIDTH+1, r=HANDLEBAR_TUBE_DIAMETER/2, center=true);\n\t\tClampBoltCut (); mirror ([1,0,0]) ClampBoltCut();\n\t\ttranslate ([-(HC_MAXX+.5),0,-(HANDLEBAR_CLAMP_WIDTH+1)/2]) cube(size=[HC_MAXX*2+1,HC_MAXY+1, HANDLEBAR_CLAMP_WIDTH+1]);\n\t}\n}\nmodule HandlebarClampDrop () {\n\tdifference () {\n\t\tunion (){\n\t\t\tHandlebarClamp ();\n\t\t\ttranslate ([0,0,-HANDLEBAR_CLAMP_WIDTH/2]) linear_extrude (height=HANDLEBAR_CLAMP_WIDTH) {\n\t\t\t\thull () {\n\t\t\t\t\ttranslate ([0, -(HANDLEBAR_CLAMP_DROP_LENGTH-((HANDLEBAR_CLAMP_DROP_BOLT_DIAMETER/2)+HANDLEBAR_CLAMP_WIDTH)), 0])  circle (r=(HANDLEBAR_CLAMP_DROP_BOLT_DIAMETER/2)+HANDLEBAR_CLAMP_WIDTH);\n\t\t\t\t\ttranslate ([0,-HC_MAXY/2,(HANDLEBAR_CLAMP_WIDTH/2)]) square ([(HANDLEBAR_CLAMP_WIDTH-HANDLEBAR_CLAMP_BOLT_CAP_DIAMETER)+HANDLEBAR_TUBE_DIAMETER, HC_MAXY], center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (LIGHT_CLAMP_BRACKETL_MIN>BRACKETL) {\n\t\t\t\ttranslate ([0,-(HANDLEBAR_CLAMP_DROP_LENGTH-((HANDLEBAR_CLAMP_DROP_BOLT_DIAMETER/2)+HANDLEBAR_CLAMP_WIDTH)),0]) cylinder (h=(LIGHT_CLAMP_BRACKETL_MIN - BRACKETL)/2 + HANDLEBAR_CLAMP_WIDTH/2, r=(HANDLEBAR_CLAMP_WIDTH + HANDLEBAR_CLAMP_DROP_BOLT_DIAMETER/2)*.9);\n\t\t\t}\n\t\t}\n\t\tcylinder (h=HANDLEBAR_CLAMP_WIDTH+1, r=HANDLEBAR_TUBE_DIAMETER/2, center=true);\n\t\t translate ([0, -(HANDLEBAR_CLAMP_DROP_LENGTH-((HANDLEBAR_CLAMP_DROP_BOLT_DIAMETER/2)+HANDLEBAR_CLAMP_WIDTH)), 0]) cylinder (h=LIGHT_CLAMP_BRACKETL_MIN/2 + HANDLEBAR_CLAMP_WIDTH/2+1, r=HANDLEBAR_CLAMP_DROP_BOLT_DIAMETER/2, center=true);\n\t}\n}\nmodule LightClampBase () {\n\t\tunion () {\n\t\tcylinder (h=LIGHT_CLAMP_WIDTH, r=LC_MAXY, center = true);\n\t\tcube(size=[LC_MAXX*2, LIGHT_CLAMP_FLANGE* 2, HANDLEBAR_CLAMP_WIDTH], center = true);\n\t\t}\n}\nmodule LightClampWithSupport () {\n\tdifference () {\n\t\tunion (){\n\t\t\tLightClampBase ();\n\t\t\trotate ([90,0,0]) linear_extrude (height=LIGHT_CLAMP_FLANGE) hull ()  projection (cut = false)  rotate ([-90,0,0]) LightClampBase();\n\t\t}\n\t\tcylinder (h=LIGHT_CLAMP_WIDTH+1, r=LIGHT_DIAMETER/2, center=true);\n\t\tLightClampBoltCut (); mirror ([1,0,0]) LightClampBoltCut();\n\t\ttranslate ([-(LC_MAXX+.5),0,-(LIGHT_CLAMP_WIDTH+1)/2]) cube(size=[LC_MAXX*2+1,LC_MAXY+1, LIGHT_CLAMP_WIDTH+1]);\n\t}\n}\nmodule LightClampWithBoltMount () {\n\tdifference () {\n\t\tunion () {\n\t\t\tLightClampWithSupport ();\n\t\t\ttranslate ([0,-(LIGHT_DIAMETER/2+LIGHT_CLAMP_BOLT_DIAMETER/2),0]) rotate ([0,90,0]) cylinder (h=BRACKETL, r=BRACKETR, center=true);\n\t\t\ttranslate ([0,-(LIGHT_DIAMETER/2+LIGHT_CLAMP_BOLT_DIAMETER/2)/2,0]) cube (size=[BRACKETL,LIGHT_DIAMETER/2+LIGHT_CLAMP_BOLT_DIAMETER/2,BRACKETR*2], center=true);\n\t\t\ttranslate ([BRACKETL/2,-(LC_MAXY)/2,BRACKETR]) rotate ([90,0,-90]) linear_extrude (height=BRACKETL) polygon(points=[ [0,0],[SUPX,0],[0,SUPY] ] );\n\t\t\tmirror ([0,0,1]) translate ([BRACKETL/2,-(LC_MAXY)/2,BRACKETR]) rotate ([90,0,-90]) linear_extrude (height=BRACKETL) polygon(points=[ [0,0],[SUPX,0],[0,SUPY] ] );\n\t\t}\n\t\ttranslate ([0,-(LIGHT_DIAMETER/2+LIGHT_CLAMP_BOLT_DIAMETER/2)-0.01,0]) rotate ([0,90,0]) cylinder (h=1+LIGHT_DIAMETER+(LIGHT_CLAMP_FLANGE-HANDLEBAR_CLAMP_BOLT_CAP_DIAMETER)/2, r=LIGHT_CLAMP_BOLT_DIAMETER/2, center=true);\n\t\tcylinder (h=LIGHT_CLAMP_WIDTH+1, r=LIGHT_DIAMETER/2, center=true);\n\t}\n}\n$fa=2; $fs=0.05;\ntranslate ([0,0,HANDLEBAR_CLAMP_WIDTH/2]) HandlebarClamp ();\ntranslate ([0,PART_GAP,HANDLEBAR_CLAMP_WIDTH/2]) mirror ([0,1,0]) HandlebarClampDrop ();\ntranslate ([-(PART_GAP+HC_MAXX*2),0,HANDLEBAR_CLAMP_WIDTH/2]) HandlebarClamp ();\ntranslate ([-(PART_GAP+HC_MAXX*2),PART_GAP,HANDLEBAR_CLAMP_WIDTH/2]) mirror ([0,1,0]) HandlebarClampDrop ();\ntranslate ([LC_MAXX + HC_MAXX + PART_GAP,0,LIGHT_CLAMP_WIDTH/2]) LightClampWithSupport ();\ntranslate ([LC_MAXX + HC_MAXX + PART_GAP, PART_GAP, LIGHT_CLAMP_WIDTH/2]) mirror ([0,1,0]) LightClampWithBoltMount ();",
    "description": "Okay, I'd like to get a parametric OpenSCAD design for a bicycle light mount. I've been using a version I found online, but it's a bit clunky and hard to adjust, and I think I can make it more flexible. I'd like to base the design off of what I currently have, but I'd like a lot more control over the dimensions.\n\nHeres what Im thinking the design needs to include, based on my current design, which is attached:\n\n*   **Handlebar Clamp:** The mount needs to clamp onto a cylindrical handlebar. I need to be able to specify the diameter of the handlebar, the width and thickness of the clamp, and the bolt diameter used to close the clamp. It should use two bolts to clamp to the handlebars. The bolts should also be able to be recessed.\n*   **Clamp Drop:** I need a downward drop from the handlebar clamp, essentially a thickened arm. This needs to be parametric in the length and include a bolt hole for attachment to the light clamp. I'll need to be able to set the diameter of this bolt. The width of this bolt hole should also be controlled parametrically, to allow the mount to fit onto the light clamp, while also providing sufficient thickness.\n*   **Light Clamp:** This part holds the flashlight. It needs to clamp around the flashlight, also using two bolts. I need to be able to define the diameter of the flashlight, the width, thickness, and flange of the clamp, and the diameter of the bolt. This clamp will attach to the bottom of the handlebar clamp drop using a bolt. The bolt for this clamp should also be able to be recessed.\n*   **Light Clamp Bracket:** I'll also need a small bracket that projects to the bottom of the light clamp from the drop bolt hole. This should be parametric in both length, width, and thickness to provide support for the light clamp.\n*   **General Parametrics:** I'd like to be able to control all of the relevant parameters easily through variables at the top of the file. This includes things like bolt sizes, clamp widths, and other dimensions like the distance that the bracket extends from the bolt.\n*   **Part Gap:** I'd like to be able to specify a small gap between the different parts when assembling it so that it prints with a little breathing room.\n*   **Modularity:** It would be ideal if the handlebar clamp, the drop arm, the light clamp, and the bracket were defined as separate modules so I can adjust them individually if necessary. \n\nI want the final design to be easily customizable for different handlebar and flashlight diameters, and different bolt sizes.  The original design was meant to hang underneath the handlebars, so Id like to retain that.\n\nI know some of these things can be achieved with using `hull()` and `linear_extrude()`. I think I may also need to do some math to get the brace triangles correct, similar to the original implementation. I would like the bolts to be cut out as cylinders with a bolt cap inset, similar to the existing `BoltCut()` module.\n\nFor libraries, I do not need any external .scad files, but would like to make sure everything is using OpenSCAD's standard library.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizer Multitone Whistle",
    "scad": "windway_width=12/1;\nwindway_height=3/1;\nwindway_length=16/1;\nsidewall=1/1;\nwall=2/1;\nextra=1/1;\nchamber_height=10/1;\nchamber_width=windway_width;\nramp_angle=12/1;\nopening_width=6/1;\nramp_length=(wall+extra)/tan(ramp_angle);\nlength_for_a4=176.4/1;\nnum_whistles=5;\nlength1=88;\nlength2=78;\nlength3=74;\nlength4=66;\nlength5=58;\nfunction note_to_freq(halfstep_from_a4) = 440 * pow(1.059463094359, halfstep_from_a4);\nfunction note_to_length(halfstep_from_a4) = 440/note_to_freq(halfstep_from_a4) * length_for_a4;\nwhistle(length1);\nif (num_whistles>1)\n\ttranslate([1*(windway_width+sidewall),0,0])\n\t\t\twhistle(length2);\nif (num_whistles>2)\n\ttranslate([2*(windway_width+sidewall),0,0])\n\t\t\twhistle(length3);\nif (num_whistles>3)\n\ttranslate([3*(windway_width+sidewall),0,0])\n\t\t\twhistle(length4);\nif (num_whistles>4)\n\ttranslate([4*(windway_width+sidewall),0,0])\n\t\t\twhistle(length5);\nmodule whistle(chamber_length=86) {\n\tdifference() {\n\t\tunion() {\n\t\t\ttranslate([0,wall/4,0]) difference() {\n\t\t\t\tcube([windway_width+sidewall*2,windway_length+wall/2,windway_height+wall*2], center=true);\n\t\t\t\tcube([windway_width,windway_length+wall/2+extra,windway_height], center=true);\n\t\t\t}\n\t\t\ttranslate([0,chamber_length/2+windway_length/2+wall,-chamber_height/2+windway_height/2]) {\n\t\t\t\tdifference() {\n\t\t\t\t\tcube([chamber_width+sidewall*2, chamber_length+wall*2, chamber_height+wall*2], center=true);\n\t\t\t\t\tcube([chamber_width,chamber_length,chamber_height], center=true);\n\t\t\t\t\ttranslate([0,-chamber_length/2-wall/2,chamber_height/2+wall-windway_height/2-wall])\n\t\t\t\t\tcube([windway_width, wall*2, windway_height], center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([0,windway_length/2-(chamber_height-windway_height)/2+0.001,-chamber_height/2-wall+0.001]) {\n\t\t\t\tdifference() {\n\t\t\t\t\tcube([chamber_width+sidewall*2,chamber_height-windway_height,chamber_height-windway_height], center=true);\n\t\t\t\t\ttranslate([0,-(chamber_height-windway_height)/2,-(chamber_height-windway_height)/2])\n\t\t\t\t\t\trotate([0,90,0])\n\t\t\t\t\t\t\tcylinder(r=chamber_height-windway_height, h=chamber_width+sidewall*2+1, center=true, $fn=30);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate([-windway_width/2,windway_length/2+opening_width+wall-opening_width/2,windway_height/2-0.01])\n\t\t\tramp_cutout();\n\t}\n}\nmodule ramp_cutout() {\n\t\t translate([0,-opening_width,0]) rotate([0,0,90]) rotate([90,0,0]) linear_extrude(height=windway_width)\n\t \t\tpolygon(points=[[0,0],[opening_width,0],[opening_width+ramp_length,wall+extra],[0,wall+extra]], paths=[[0,1,2,3,0]]);\n}",
    "description": "Okay, I'd like to design a customizable multi-tone whistle for 3D printing. I have a basic design idea in mind, but I need help making it fully parametric in OpenSCAD.\n\nHere's the core concept: I want to create a whistle that's essentially a series of individual whistles placed side-by-side. Each whistle should produce a different tone, and the user should be able to control the number of whistles as well as the length (and therefore the pitch) of each whistle.\n\nHere are the parameters I think I need, along with some initial values I'm using:\n\n**Overall Dimensions & Parameters:**\n\n*   `windway_width` = 12 mm (the width of the air channel)\n*   `windway_height` = 3 mm (the height of the air channel)\n*   `windway_length` = 16 mm (the length of the air channel)\n*   `sidewall` = 1 mm (the thickness of the side walls of the air channel)\n*   `wall` = 2 mm (general wall thickness)\n*   `extra` = 1 mm (extra length added to the ramp)\n*   `chamber_height` = 10 mm (the height of the resonating chamber)\n*   `chamber_width` =  `windway_width` (the width of the resonating chamber, same as windway width)\n*   `ramp_angle` = 12 degrees (angle of the ramp cut in the air channel)\n*   `opening_width` = 6 mm (width of the ramp opening in the air channel)\n*  `ramp_length` should be calculated based on `wall`, `extra`, and `ramp_angle`, i.e. `ramp_length = (wall+extra)/tan(ramp_angle)`\n* `length_for_a4` = 176.4 mm (length of the resonating chamber for A4 tone)\n\n**Multi-Whistle Parameters:**\n\n*   `num_whistles`:  An integer value to control the number of whistles (I'd like to start with a range of 1 to 5).\n*   `length1`, `length2`, `length3`, `length4`, `length5`: Individual lengths for the resonating chamber of each whistle. These lengths should relate to the pitch of each whistle. Let's start with default values like 88 mm, 78 mm, 74 mm, 66 mm, and 58 mm, and a range of [30:150] each. I need a function that will convert from musical notes to length - I'll provide the A4 length as a baseline.\n\n**Additional requirements:**\n\n*   The individual whistles should be constructed using a `whistle()` module\n*   Each whistle should be placed next to each other, separated by `windway_width + sidewall`, for example, the second whistle is translated in the x-direction by 1 \\* (`windway_width + sidewall`).\n* The core whistle design should be constructed from primitives; the model from my provided code is a good starting point (i.e., using `difference()`, `union()`, `cube()`, `cylinder()`, `linear_extrude()`, and `polygon()`).\n*   I'd like to have a `ramp_cutout()` module for that particular piece.\n*   The overall assembly should be based on simple translations based on the number of whistles.\n*   I also need two helper functions. One to calculate the frequency of a note, relative to A4 which is at 440 Hz, i.e.  `note_to_freq(halfstep_from_a4) = 440 * pow(1.059463094359, halfstep_from_a4)`. The second to calculate the whistle length to generate a particular note based on `length_for_a4`, i.e. `note_to_length(halfstep_from_a4) = 440/note_to_freq(halfstep_from_a4) * length_for_a4;`\n\nI believe this design requires no external OpenSCAD libraries.\n\nCould you please generate the OpenSCAD code for this parametric design, making sure the user can easily customize the parameters for different tones, and number of whistles? I'm aiming for a modular and maintainable design.\n"
  },
  {
    "object": "Hey cadmonkey, make me a customizable star",
    "scad": "number_of_points=5;\nheight=1;\ninner_radius=15;\nouter_radius=10;\nparametric_star(number_of_points, height, inner_radius, inner_radius+outer_radius) ;\nmodule parametric_star(N=5, h=3, ri=15, re=30) {\n  module tipstar(n) {\n     i1 =  [ri*cos(-360*n/N+360/(N*2)), ri*sin(-360*n/N+360/(N*2))];\n    e1 = [re*cos(-360*n/N), re*sin(-360*n/N)];\n    i2 = [ri*cos(-360*(n+1)/N+360/(N*2)), ri*sin(-360*(n+1)/N+360/(N*2))];\n    polygon([ i1, e1, i2]);\n  }\n    linear_extrude(height=h)\n    union() {\n      for (i=[0:N-1]) {\n         tipstar(i);\n      }\n      rotate([0,0,360/(2*N)]) circle(r=ri+ri*0.01,$fn=N);\n    }\n}",
    "description": "Okay, I'm looking to create a parametric star in OpenSCAD, similar to the one in the provided example, but with a few key differences and additions. I'd like it to be fully customizable through parameters.\n\nHere's what I need:\n\n1.  **Number of Points:** This should be a user-defined parameter, just like in the example, allowing for stars with any number of points (within a reasonable range, of course, maybe 3 to 24).\n\n2.  **Height/Thickness:** Like the example, the star should have a height or thickness, which is also controlled by a parameter.\n\n3. **Inner Radius:** The radius of the circle that determines the inner points of the star should be a parameter, also like the example.\n\n4. **Outer Radius:** Similar to the inner radius, the radius of the circle that determines the outer points of the star should be a parameter, and I'd like to be able to adjust it independently of the inner radius. In the example, the outer radius was defined as `inner_radius + outer_radius`. I'd like this to instead use a parameter `outer_radius`.\n\n5. **Twist Angle:** Here's where things get different from the example. I want to be able to twist the star as it is extruded, creating a sort of helical star.  This twist should be controlled by a parameter, specified as an angle (in degrees) over the height of the star. So a 360-degree twist would mean the top face of the star is rotated a full circle relative to the bottom.\n\n6. **Point Rounding/Filleting:** I want to be able to control how sharp or rounded the star points are. I'd like to specify a parameter for this, which would represent a radius used to fillet the internal corners.\n\n7. **Base Cylinder:** I'd like an option to add a cylinder on the bottom, with it's height specified, that also would also be controlled by a parameter, so that I can easily create a star on a base. The radius of this cylinder should match the inner radius of the star.\n\n8. **Customizable `fn` for Circles:** I'd like to be able to specify the `$fn` parameter used when generating circles used in the star, so that I can make it higher resolution as desired.\n\nI'd like the code to be well-documented and easy to understand and modify, similar to the example. I don't want to use any external libraries, such as BOSL, MCAD, etc., just the core OpenSCAD language.\n\nIn short, I need a parameterized star that has controls for: number of points, height, inner radius, outer radius, twist angle, fillet radius on the points, base cylinder height, and circle resolution.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Pluggable Ikea closet bar holder",
    "scad": "bar_thickness = 20;\nholder_bottom_thickness = 12;\nholder_top_thickness = 5;\nbase_thickness = 3;\nplug_depth = 10;\nplug_thickness = 5;\nplug_distance = 26;\nplugs_offset = -15;\no = 0.01;\ndistance = 6;\nbar_radius = bar_thickness/2;\nplug_radius = plug_thickness/2;\nbase_width = bar_thickness+holder_bottom_thickness*2;\nbase_height = base_width*1.75;\n$fa = 5;\n$fs = 1;\ninclude <MCAD/boxes.scad>\nbase();\ntranslate([0,0,base_thickness-o]) holder();\ntranslate([0,base_width/2+plug_radius*2+distance,0]) {\n  plug();\n  translate([plug_radius*4+distance,0,0]) plug();\n}\nmodule wall_mold() {\n  polygon(points=[[0,0],[0,10],[holder_top_thickness,10],[holder_bottom_thickness,0]]);\n}\nmodule holder() {\n  difference()\n  {\n    rotate_extrude(convexity = 10) translate([bar_radius, 0, 0]) wall_mold();\n    translate([base_width/2,0,15/2-0.1]) cube([base_width,base_width,15],center=true);\n  }\n  translate([-o,bar_radius,0]) rotate([90,0,90])\n    linear_extrude( height=bar_radius+2) wall_mold();\n  translate([bar_radius+2-o,-bar_radius,0]) rotate([90,0,-90])\n    linear_extrude(height=bar_radius+2) wall_mold();\n}\nmodule base() {\n  difference()\n  {\n     translate([0,0,base_thickness/2]) roundedBox([base_height,base_width, base_thickness], base_width/2, true);\n     translate([plugs_offset,0,0]) {\n      rotate([180,0,0]) translate([0,0,-base_thickness]) {\n        translate([plug_distance/2+plug_radius,0,0]) plug(true);\n        translate([-plug_distance/2-plug_radius,0,0]) plug(true);\n      }\n    }\n  }\n}\nmodule plug(remove=false) {\n  if(remove) {\n    translate([0,0,-base_thickness]) cylinder(base_thickness*2,plug_radius*3,plug_radius);\n  } else {\n    cylinder(base_thickness,plug_radius*2,plug_radius);\n  }\n  translate([0,0,base_thickness-o])\n    cylinder(plug_depth+o,plug_radius,plug_radius);\n}",
    "description": "Okay, I'm looking to create a closet rod holder that I can plug into the pre-drilled holes on the side of my IKEA closet. I've got some specifics on the dimensions and how I want it to work.\n\nEssentially, the design needs to consist of two main parts: a base that attaches to the closet side, and a holder that cradles the rod. The base needs to have two plug-like protrusions that fit into the standard 5mm IKEA holes. It should also be parametric so I can easily adjust the size for different rods and hole configurations.\n\nHere's a breakdown of the parameters I'd like to control:\n\n**General Dimensions:**\n\n*   **`bar_thickness`:** The diameter of the closet rod (with some added tolerance). Default should be 20mm, but I need to be able to adjust this. I'll probably set it somewhere between 5mm and 30mm.\n*   **`holder_bottom_thickness`:** The thickness of the holder material below the rod. Start this at 12mm, but range from 5mm-20mm.\n*   **`holder_top_thickness`:**  The thickness of the holder material above the rod. Start at 5mm, and range from 0-20mm.\n*   **`base_thickness`:** The thickness of the base plate that rests against the side of the closet. A good default should be 3mm, but a range from 2mm to 5mm is needed.\n\n**Plug Dimensions:**\n\n*   **`plug_depth`:** How deep the plugs should go into the holes (start around 10mm).\n*   **`plug_thickness`:** The diameter of the plugs themselves (start at 5mm).\n*   **`plug_distance`:** The distance between the centers of the two plugs (I'm guessing 26mm would be common).\n*   **`plugs_offset`:** How far from the vertical center of the base the plugs should be positioned (maybe -15mm).\n\n**Other Requirements:**\n\n*   I would like the base to be rounded with a radius of `base_width/2`.\n*   I'd like to use the `roundedBox` module from the MCAD library for creating the base.\n*   The base's height needs to be set to `base_width*1.75` and the base width should be `bar_thickness+holder_bottom_thickness*2`.\n*   I'd like to have a slight overlap variable `o` to help prevent z-fighting.\n*   I need to make the rod holder with the `rotate_extrude` and `linear_extrude` commands.\n*   I'd like a `wall_mold()` module to represent the cross-section of the rod holder.\n*   The plugs should be cylinders with some added tolerance.\n\nSo, to summarize, I need a parametric OpenSCAD file that generates a closet rod holder that can plug into the holes on the side of an IKEA closet, using the parameters described above, and the MCAD library.  Can you generate that file for me?\n"
  },
  {
    "object": "Hey cadmonkey, make me a PogoHolder",
    "scad": "tightL=4;\nwallt=1.5;\nhSolderPocket=5;\nwSolderPocket=1;\nholeos1=0.4 /2;\nholeos2=0.7 /2;\nIndexL=10;\nPogoHousing(pogor=1.02/2, Ncols=3, Nrows=2, L=33-8, colpitch=2.250,rowpitch=4.5,\n                             IndexPins=[ [-4, -1.455, 1.2/2], [4, -1.455, 1.2/2]]);\ntranslate([20,0,0])\nPogoHousing(pogor=1.37/2, Ncols=3, Nrows=1, L=33-8, colpitch=2.54,rowpitch=2.54);\ntranslate([40,0,0])\nPogoHousing(pogor=1.37/2, Ncols=3, Nrows=2, L=33-8, colpitch=2.250,rowpitch=4.5);\ntranslate([60,0,0])\nPogoHousing(pogor=0.6/2, Ncols=3, Nrows=2, L=25-8, colpitch=1.27,rowpitch=1.27,IndexPins=[ [-2.54, -(0.381+1.27/2), 0.9/2], [-2.54, 0.381+1.27/2, 0.9/2] ,  [2.54, 0, 0.9/2]]);\ntranslate([80,0,0])\nPogoHousing(pogor=1.37/2, Ncols=3, Nrows=2, L=25-8, colpitch=2.54, coloffset=-0.5, rowpitch=2.54,IndexPins=[ [-2.54*2, -1.27, 1.6/2]]);\nmodule IH(IndexPins,IndexL,OS) {\nfor (IP=IndexPins) {\n    translate([IP[0],IP[1],IndexL/2])\n    cylinder(h=IndexL, r=IP[2]+OS,center=true,$fn=10);\n    }\n}\nmodule BS(X,Y,L,wallt,wSolderPocket,xofs,IndexPins,IndexL) {\n\thull() {\n          translate([xofs,0,0.5])\n\t\tcube([X-wallt,Y-wallt,1],center=true);\n\t\ttranslate([xofs,0,5+L/2])\n\t\t\tcube([X,Y + 2*wSolderPocket ,L-5],center=true);\n        IH(IndexPins,IndexL,wallt);\n\t}\n}\nfunction Odd(N) = floor(N/2);\nmodule PogoHousing(pogor,Ncols,Nrows=1,L=25, colpitch=2.54,rowpitch=2.54,coloffset=0,IndexPins=[]) {\n   assign( X=colpitch*(Ncols-1+ abs(coloffset)) + 2*pogor+ 2*wallt,\n\t\t\t\tY= rowpitch*(Nrows-1) +  (pogor+wallt) *2)\n\tdifference () {\n\t\tBS(X,Y,L,wallt,wSolderPocket,coloffset*colpitch/2,IndexPins,IndexL);\n\t\ttranslate([0,0,L/2])\n\t\t\tfor (row=[1:Nrows]) {\n\t\t\t\tfor( col=[1:Ncols]) {\n\t\t\t\t  translate([(col-Ncols/2 -0.5)*colpitch + Odd(row)*coloffset*colpitch, (row-Nrows/2 -0.5) *rowpitch,0]) {\n\t\t\t\t\t  cylinder(r=pogor+holeos1,h=L+2,center=true,$fn=10);\n\t\t\t\t  translate([0,0,tightL])\n\t\t\t\t\t  cylinder(r=pogor+holeos2,h=L,center=true,$fn=10);\n\t\t\t\t  for (dy=[-wSolderPocket,wSolderPocket])\n\t\t\t\t      translate([0,dy,L/2+0.1]) cylinder(r=pogor+holeos2,h=hSolderPocket,center=true,$fn=10);\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}\n    IH(IndexPins,IndexL+0.2,holeos1);\n\t}\n}",
    "description": "Okay, I'd like to design a parameterized holder for pogo pins, similar to the attached `PogoHolder.scad` file, but with some changes and more flexibility.\n\nHere's what I need:\n\n**Core Functionality:**\n\n*   **Grid Layout:** The design should create a rectangular grid of holes for pogo pins, specified by the number of columns (`Ncols`) and rows (`Nrows`).\n*   **Pogo Pin Diameter:**  The pogo pin diameter should be parameterized (`pogor`).\n*   **Pitch:** Both column pitch (`colpitch`) and row pitch (`rowpitch`) should be independently adjustable.\n*   **Zig-Zag Option:** There should be an option to create a zig-zag pattern in the rows, which is achieved in the provided code with `coloffset`. This could also be a parameter and not just 0 or 0.5, if possible.\n*   **Overall Length:** The length of the pogo pin housing should be a parameter (`L`).\n*   **Tapered Body:** The main body should have a tapered shape, narrow at the base and wider at the top, similar to the provided design.\n*   **Solder Pockets:** There need to be pockets at the top of each hole for soldering wires to the pogo pins. The height of the pocket, `hSolderPocket`, and the extra width, `wSolderPocket`, need to be parameters.\n*   **Tight and Loose Fit:**  The pogo pin holes should have a section of tight fit (`tightL`), followed by a looser section.  The radius oversize for both the tight `holeos1` and loose holes `holeos2` should be adjustable.\n*   **Index Pins:**  Support for mechanical index pins is essential, specified as an array of [X, Y, R] values. The depth of these index pin holes, `IndexL`, should also be parameterized.\n*   **Wall Thickness:** The wall thickness of the housing should be parameterized (`wallt`).\n\n**New Functionality and Changes:**\n\n1.  **Rounded Corners:**  I'd like to add a parameter for corner radius. All sharp corners in the design should use this parameter, including in the main body and in the base.\n2.  **Base Height:** Add a parameter to set the height of the narrow base of the design (below the main tapered section) - I want a thin base, say 'baseh'.\n3.  **Hole Shape:** Instead of just a circle hole, I'd like an option to change the pin hole to a rectangle with rounded corners (a 'rrect' shape). It should have dimensions that roughly fit the pin and still allow solder to flow (like in the provided code). Add a parameter for the x-dimension `rrectx` and y-dimension `rrecty`, with an additional radius `rrectr` for the corners. This should be an optional parameter with a default value of `undef` for circular holes.\n4.  **Pogo Orientation:** Add a parameter to specify pogo orientation: top, bottom, or centered. This orientation should be relative to the overall body's z-axis. If set to top or bottom, all z-axis measurements are relative to that end.\n\n**Parameters I Need:**\n\n*   `pogor`: Pogo pin radius.\n*   `Ncols`: Number of columns of pogo pins.\n*   `Nrows`: Number of rows of pogo pins.\n*   `L`: Total length of the housing.\n*   `colpitch`: Spacing between columns.\n*   `rowpitch`: Spacing between rows.\n*   `coloffset`: Offset between rows for a zig-zag pattern (e.g., 0.5 for half-pitch zig-zag).\n*   `IndexPins`: Array of index pin positions and radii ([X, Y, R]).\n*   `IndexL`: Depth of index pin holes.\n*   `tightL`: Length of the tight-fit portion of the pogo pin hole.\n*  `wallt`: Wall thickness of the housing.\n*  `hSolderPocket`: Height of the solder pocket.\n* `wSolderPocket`: Extra width of the solder pocket.\n*  `holeos1`: Oversize for the tight-fit pogo hole.\n* `holeos2`: Oversize for the loose-fit pogo hole.\n*   `corner_radius`: Radius of all corners.\n*   `baseh`: Height of the base section.\n*   `rrectx`: x-dimension of the optional rectangular hole with rounded corners.\n*   `rrecty`: y-dimension of the optional rectangular hole with rounded corners.\n*  `rrectr`: corner radius of the optional rectangular hole with rounded corners.\n*   `pogo_orientation`: Orientation of pogo pins (top, bottom, or centered).\n\n**Libraries**\n\nI'm not using any special libraries in this design. I'm expecting a single self-contained `.scad` file that I can run in OpenSCAD.\n\nCould you generate the OpenSCAD code for this? Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizer Potentiometer Knobs",
    "scad": "01_knob_diameter_top = 20;\nknob_radius_top = 01_knob_diameter_top / 2;\n02_knob_diameter_bottom = 20;\nknob_radius_bottom = 02_knob_diameter_bottom / 2;\n03_knob_height = 16;\nknob_height = 03_knob_height / 1;\n04_knob_smoothness = 40;\nknob_smoothness = 04_knob_smoothness / 1;\n05_shaft_diameter = 6.2;\nshaft_radius = 05_shaft_diameter / 2;\n06_shaft_height = 13;\nshaft_height = 06_shaft_height / 1;\n07_shaft_smoothness = 20;\nshaft_smoothness = 07_shaft_smoothness / 1;\n08_shaft_hole_is_flatted = \"true\";\n09_shaft_hole_flat_size = 5.0;\nflat_size = 09_shaft_hole_flat_size / 1;\n10_set_screw = \"true\";\n11_set_screw_diameter = 3;\nset_screw_radius = 11_set_screw_diameter / 2;\n12_set_screw_depth = 9;\nset_screw_depth = 12_set_screw_depth / 1;\n13_set_screw_height = 4;\nset_screw_height = 13_set_screw_height / 1;\n14_quality_of_set_screw = 20;\nquality_of_set_screw = 14_quality_of_set_screw / 1;\n15_top_edge_smoothing = \"true\";\n16_top_edge_smoothing_radius = 5.0;\nsmoothing_radius = 16_top_edge_smoothing_radius / 1;\n17_top_edge_smoothing_smoothness = 20.0;\nsmooth = 17_top_edge_smoothing_smoothness / 1;\nct = -0.1 / 1;\ncircle_radius = knob_radius_top / 1;\ncircle_height = 1 / 1;\npad = 0.2 / 1;\n18_pointy_external_indicator = \"false\";\n19_pointy_external_indicator_height = 3;\npointy_external_indicator_height = 19_pointy_external_indicator_height / 1;\n20_pointy_external_indicator_pokey_outey_ness = 1.0;\npointy_external_indicator_pokey_outey_ness = 20_pointy_external_indicator_pokey_outey_ness * 1;\npokey_outey_value = pointy_external_indicator_pokey_outey_ness - 1 - pad;\npokey_outey = [pokey_outey_value, pokey_outey_value,0];\n00_pill_indicator = \"true\";\n00_pill_add_or_subtract = \"add\";\n00_pill_scale = 1.0;\n00_pill_height = 16.0;\n00_pill_length = 2.5;\n00_pill_location_x = 0.0;\n00_pill_location_y = 5.0;\n00_pill_location_z = 0.0;\npill_translate = [00_pill_location_x,00_pill_location_y,00_pill_location_z];\n21_top_of_knob_arrow_indicator = \"false\";\n22_arrow_head_scale = 2.0;\narrow_scale_head = 22_arrow_head_scale / 1;\n23_arrow_shaft_scale = 1.5;\narrow_scale_shaft = 23_arrow_shaft_scale / 1;\n24_arrow_indicator_scale = 1.3;\narrow_indicator_scale = 24_arrow_indicator_scale / 1;\n25_arrow_location_x = 0.0;\n26_arrow_location_y = 1.0;\n27_arrow_location_z = 16.0;\narrow_indicator_translate = [25_arrow_location_x,26_arrow_location_y,27_arrow_location_z];\n28_indentations_sphere = \"false\";\n29_sphere_number_of_indentations = 12;\nsphere_number_of_indentations = 29_sphere_number_of_indentations / 1;\n30_sphere_quality_of_indentations = 40;\nsphere_quality_of_indentations = 30_sphere_quality_of_indentations / 1;\n31_size_of_sphere_indentations = 4;\nsize_of_sphere_indentations = 31_size_of_sphere_indentations / 1;\n32_sphere_indentation_location_x = 12.0;\n33_sphere_indentation_location_y = 00.0;\n34_sphere_indentation_location_z = 15.0;\ntranslation_of_sphere_indentations = [32_sphere_indentation_location_x,33_sphere_indentation_location_y,34_sphere_indentation_location_z];\n35_sphere_indentation_starting_rotation = 30;\nsphere_starting_rotation = 35_sphere_indentation_starting_rotation / 1 + 90;\n36_indentations_cylinder = \"true\";\n37_number_of_cylinder_indentations = 6;\ncylinder_number_of_indentations = 37_number_of_cylinder_indentations / 1;\n38_smoothness_of_cylinder_indentations = 50;\ncylinder_quality_of_indentations = 38_smoothness_of_cylinder_indentations / 1;\n39_diameter_of_top_of_the_cylinder = 5.0;\nradius_of_cylinder_indentations_top = 39_diameter_of_top_of_the_cylinder / 2;\n40_diameter_of_bottom_of_the_cylinder = 5.0;\nradius_of_cylinder_indentations_bottom = 40_diameter_of_bottom_of_the_cylinder / 2;\n41_height_of_cylinder_indentations = 15.0;\nheight_of_cylinder_indentations = 41_height_of_cylinder_indentations / 1;\n42_position_of_cylinder_x = -0.0;\n43_position_of_cylinder_y = 0.0;\n44_position_of_cylinder_z = -5.0;\ntranslation_of_cylinder_indentations = [42_position_of_cylinder_x,43_position_of_cylinder_y,44_position_of_cylinder_z];\n45_cylinder_starting_rotation = -30;\ncylinder_starting_rotation = 45_cylinder_starting_rotation / 1 - 90;\nnegative_knob_radius = knob_radius_bottom*-1;\nmake_the_knob();\nmodule make_the_knob()\n{\ndifference()\n{\n\tunion()\n\t{\n\tdifference()\n\t\t{\n\t\tdifference()\n\t\t\t{\n\t\t\tdifference()\n\t\t\t\t{\n\t\t\t\tdifference()\n\t\t\t\t\t{\n\t\t\t\t\tunion()\n\t\t\t\t\t\t{\n\t\t\t\t\t\tdifference()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcylinder(r1=knob_radius_bottom,r2=knob_radius_top,h=knob_height, $fn=knob_smoothness);\n\t\t\t\t\t\t\tsmoothing();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\texternal_direction_indicator();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tset_screw_hole();\n\t\t\t\t}\n\t\t\tif(00_pill_add_or_subtract == \"subtract\")\n\t\t\t\t{\n\t\t\t\tpill();\n\t\t\t\t}\n\t\t\tarrow_indicator();\n\t\t\tindentations();\n\t\t\t}\n\t}\n\tif(00_pill_add_or_subtract == \"add\")\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpill();\n\t\t\t\t\t\t\t}\n\t}\nshaft_hole();\n}\n}\nmodule smoothing() {\n\t\t\t\tif(15_top_edge_smoothing == \"true\")\n\t\t\t\t\t{\n\t\t\t\t\t\ttranslate([0,0,knob_height])\n\t\t\t\t\t\trotate([180,0,0])\n\t\t\t\t\t\tdifference() {\n\t\t\t\t\t\t\trotate_extrude(convexity=10,  $fn = smooth)\n\t\t\t\t\t\t\ttranslate([circle_radius-ct-smoothing_radius+pad,ct-pad,0])\n\t\t\t\t\t\t\tsquare(smoothing_radius+pad,smoothing_radius+pad);\n\t\t\t\t\t\t\trotate_extrude(convexity=10,  $fn = smooth)\n\t\t\t\t\t\t\ttranslate([circle_radius-ct-smoothing_radius,ct+smoothing_radius,0])\n\t\t\t\t\t\t\tcircle(r=smoothing_radius,$fn=smooth);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n}\nmodule external_direction_indicator() {\n\t\t\t\tif(18_pointy_external_indicator == \"true\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\trotate([0,0,45])\n\t\t\t\t\t\ttranslate(pokey_outey)\n\t\t\t\t\t\tcube(size=[knob_radius_bottom,knob_radius_bottom,pointy_external_indicator_height],center=false);\n\t\t\t\t\t\t}\n}\nmodule shaft_hole() {\n\t\t\t\tdifference()\n\t\t\t\t\t{\n\t\t\t\t\ttranslate([ 0, 0, -1 ])\n\t\t\t\t\tcylinder(r=shaft_radius,h=shaft_height, $fn=shaft_smoothness);\n\t\t\t\t\tif(08_shaft_hole_is_flatted  == \"true\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\trotate( [0,0,90])\n\t\t\t\t\t\ttranslate([-7.5,-5,0])\n\t\t\t\t\t\tcube(size=[flat_size,10,13],center=false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n}\nmodule set_screw_hole() {\n\t\t\tif(10_set_screw == \"true\")\n\t\t\t\t{\n\t\t\t\trotate ([90,0,0])\n\t\t\t\ttranslate([ 0, set_screw_height, 1 ])\n\t\t\t\tcylinder(r=set_screw_radius,h=set_screw_depth, $fn=quality_of_set_screw);\n\t\t\t\t}\n}\nmodule arrow_indicator() {\n\t\tif(21_top_of_knob_arrow_indicator == \"true\")\n\t\t\t{\n\t\t\ttranslate(arrow_indicator_translate)\n\t\t\trotate([90,0,45])\n\t\t\tscale([arrow_indicator_scale*.3,arrow_indicator_scale*.3,arrow_indicator_scale*.3])\n\t\t\tunion()\n\t\t\t\t{\n\t\t\t\trotate([90,45,0])\n\t\t\t\tscale([arrow_scale_head,arrow_scale_head,1])\n\t\t\t\tcylinder(r=8, h=10, $fn=3, center=true);\n\t\t\t\trotate([90,45,0])\n\t\t\t\ttranslate([-10,0,0])\n\t\t\t\tscale([arrow_scale_shaft,arrow_scale_shaft,1])\n\t\t\t\tcube(size=[15,10,10],center=true);\n\t\t\t\t}\n\t\t\t}\n}\nmodule indentations() {\nif(28_indentations_sphere == \"true\")\n\t\t\t{\n\t\t\tfor (z = [0:sphere_number_of_indentations])\n\t\t\t\t{\n\t\t\t\trotate([0,0,sphere_starting_rotation+((360/sphere_number_of_indentations)*z)])\n\t\t\t\ttranslate(translation_of_sphere_indentations)\n\t\t\t\tsphere(size_of_sphere_indentations, $fn=sphere_quality_of_indentations);\n\t\t\t\t}\n\t\t\t}\nif(36_indentations_cylinder == \"true\")\n\t\t\t{\n\t\t\tfor (z = [0:cylinder_number_of_indentations])\n\t\t\t\t{\n\t\t\t\trotate([0,0,cylinder_starting_rotation+((360/cylinder_number_of_indentations)*z)])\n\t\t\t\ttranslate([negative_knob_radius,0,knob_height])\n\t\t\t\ttranslate(translation_of_cylinder_indentations)\n\t\t\t\tcylinder(r1=radius_of_cylinder_indentations_bottom, r2=radius_of_cylinder_indentations_top, h=height_of_cylinder_indentations, center=true, $fn=cylinder_quality_of_indentations);\n\t\t\t\t}\n\t\t\t}\n\t\t}\nmodule pill()\n{\nif(00_pill_indicator == \"true\")\n\t{\n\ttranslate(pill_translate)\n\trotate([0,0,90])\n\t\t{\n\t\tunion()\n\t\t\t{\n\t\t\tcylinder(00_pill_height,00_pill_scale,00_pill_scale, $fn=40);\n\t\t\ttranslate([0,-00_pill_scale,0])\n\t\t\t\t{\n\t\t\t\t\tcube([(00_pill_scale*2)*00_pill_length,00_pill_scale*2,00_pill_height]);\n\t\t\t\t}\n\t\t\ttranslate([(00_pill_scale*2)*00_pill_length,0,0])\n\t\t\t\t{\n\t\t\t\t\tcylinder(00_pill_height,00_pill_scale,00_pill_scale, $fn=40);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "description": "Okay, I'm looking to design a highly customizable potentiometer knob and I'd like some help creating an OpenSCAD file for it. I've seen a really good example, but it's a bit complex and I'd like to make sure I understand the parametric design process more fully by starting from scratch.\n\nHere are the key features I want, keeping in mind the example file \"potknob_parametric.scad\":\n\n**Overall Knob Shape:**\n\n*   I want a knob that's essentially a cylinder, but I'd like to be able to control the diameter at the top and the bottom independently, to create a slightly tapered or hourglass shape if desired.\n*   I need to set the overall height of the knob.\n*   I want to adjust the smoothness (number of facets) of the cylinder, so it can be more geometric or more rounded.\n\n**Shaft Hole:**\n\n*   I need a hole in the center for the potentiometer shaft.\n*   The diameter of this hole needs to be adjustable.\n*   I need to control how deep the shaft hole goes into the knob.\n*   The smoothness of the hole needs to be adjustable.\n*   Some potentiometers have a flat spot on their shaft, so I need a way to make the hole D-shaped using a separate flat-size parameter. The choice to include or omit the flat should be a toggle parameter.\n\n**Set Screw (Optional):**\n\n*   I need the *option* to include a set screw hole on the side of the knob, controlled with a toggle parameter.\n*   If a set screw is enabled, the diameter, depth (into the knob from the side), and height (from the top of the knob) need to be adjustable.\n*   I need to control the smoothness of the set screw hole.\n\n**Top Edge Smoothing (Optional):**\n\n*  I need an *option* to round the top edge of the knob, also controlled with a toggle parameter.\n* If enabled, I need to be able to control the radius of the rounded edge and its smoothness.\n\n**External Indicator (Optional):**\n\n*   I want the *option* of having a small, cube-shaped indicator that protrudes out from the bottom edge of the knob, which will be controlled with a toggle parameter.\n*   If included, I need to control how far out it protrudes and its height.\n\n**Pill-Shaped Indicator (Optional):**\n\n* I would like a *pill* shape to be able to be added or subtracted from the top of the knob, controlled with a toggle parameter.\n* There should be a parameter to determine if the pill is an addition or a subtraction.\n* I need to be able to adjust the scale of the pill.\n* I need to control the height of the pill.\n* I need to control the length of the pill.\n* I need to control the position of the pill on the x, y, and z axes.\n\n**Internal Arrow Indicator (Optional):**\n\n*   I'd like the *option* of having an arrow-shaped cutout on the top surface as an indicator, controlled with a toggle parameter.\n*   I need to control the scale of the arrow head and the arrow shaft separately.\n*   I need to control the overall scale of the arrow indicator\n*   I need to position the arrow on the x, y, and z axes.\n\n**Spherical Indentations (Optional):**\n\n*   I need the *option* to add spherical indentations along the side of the knob, controlled with a toggle parameter.\n*   I need to set the number of indentations, their quality (smoothness), and size.\n*   I need to set the position of the indentation spheres on the x, y, and z axes.\n*   I need to set the starting rotation so that the indentations line up with the front or the set screws.\n\n**Cylindrical Indentations (Optional):**\n* I need the *option* to add cylindrical indentations along the side of the knob, controlled with a toggle parameter.\n* I need to set the number of indentations and their smoothness.\n* I need to set the top and bottom diameter of the cylinder and its height.\n* I need to set the position of the cylinders along the x, y, and z axes.\n* I need to set the starting rotation so that the indentations line up with the front or the set screws.\n\nI want all dimensions to be in millimeters. I don't need any special libraries or anything too fancy in terms of programming structures, just the basic OpenSCAD functionalities. Thank you!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Snowflake",
    "scad": "seed=1;\necho(str(\"Seed \",seed));\nseeds=rands(0,1000000,7,seed);\necho(str(\"Seeds \",seeds));\nhex = rands(0,1,6,seeds[0]);\necho(\"hex \",hex);\nhsolid = rands(0,1,6,seeds[1]);\necho(\"hex solid \",hsolid);\nhhex = rands(0,1,6,seeds[2]);\necho(\"hhex \",hhex);\nlength = rands(5,20,6,seeds[3]);\necho(\"length \",length);\nwidth = rands(0.2,2,6,seeds[4]);\necho(\"width \",width);\nangle = rands(60,120,6,seeds[5]);\necho(\"angle \",angle);\ndepth = rands(1,4,1,,seeds[6])[0];\necho(\"depth \",depth);\nscaleh=0.8 * 1;\nheight0=2 * 1;\nheight=[height0,height0*scaleh,height0*pow(scaleh,2), height0*pow(scaleh,3), height0*pow(scaleh,4), height0*pow(scaleh,5), height0*pow(scaleh,6)];\nif (hex[0]) drawhex(length[1], height[1], hsolid[1]);\nfor (angle1 = [0 : 60 : 359]) {\n\trotate(angle1)arm();\n\t}\nmodule arm() {\n\ttranslate ([0,-width[1]/2,0]) {\n\t\tcube([length[1],width[1],height[1]]);\n\t\ttranslate ([length[1],width[1]/2,0]) {\n\t\t\tif (hex[1]>.5) drawhex(length[2], height[2], hsolid[2]);\n\t\t\tif (hhex[1]>.5) drawhex(length[2]/2, height[2], hsolid[2]);\n\t\t\tif (depth>1) {\n\t\t\t\trotate(-angle[1]) arm2();\n\t\t\t\tarm2();\n\t\t\t\trotate(angle[1]) arm2();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nmodule arm2() {\n\ttranslate ([0,-width[2]/2,0]) {\n\t\tcube([length[2],width[2],height[2]]);\n\t\ttranslate ([length[2],width[2]/2,0]) {\n\t\t\tif (hex[2]>.5) drawhex(length[3], height[3], hsolid[3]);\n\t\t\tif (hhex[2]>.5) drawhex(length[3]/2, height[3], hsolid[3]);\n\t\t\tif (depth>2) {\n\t\t\t\trotate(-angle[2]) arm3();\n\t\t\t\tarm3();\n\t\t\t\trotate(angle[2]) arm3();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nmodule arm3() {\n\ttranslate ([0,-width[3]/2,0]) {\n\t\tcube([length[3],width[3],height[3]]);\n\t\ttranslate ([length[3],width[3]/2,0]) {\n\t\t\tif (hex[3]>.5) drawhex(length[4], height[4], hsolid[4]);\n\t\t\tif (hhex[3]>.5) drawhex(length[4]/2, height[4], hsolid[4]);\n\t\t\tif (depth>3) {\n\t\t\t\trotate(-angle[3]) arm4();\n\t\t\t\tarm4();\n\t\t\t\trotate(angle[3]) arm4();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nmodule arm4() {\n\ttranslate ([0,-width[4]/2,0]) {\n\t\tcube([length[4],width[4],height[4]]);\n\t\ttranslate ([length[4],width[4]/2,0]) {\n\t\t\tif (hex[4]>.5) drawhex(length[5], height[5]);\n\t\t\tif (hhex[4]>.5) drawhex(length[5]/2, height[5]);\n\t\t\t}\n\t\t}\n\t}\nmodule drawhex(size, height, s) {\n\ttranslate([0,0,height/2]) difference() {\n\t\thexagon(size, height);\n\t\tif (s>0.5) translate([0,0,-0.5]) hexagon(size-height, height+1);\n\t\t}\n\t}\nmodule hexagon(size, height) {\n\tboxWidth = size/1.75;\n\tfor (r = [-60, 0, 60]) rotate([0,0,r])\n\t\tcube([boxWidth, size, height], true);\n\t}",
    "description": "Okay, I'd like to request a parametric OpenSCAD design for generating snowflakes, similar to the one I found on Thingiverse, but I want to be able to customize a few more things.\n\nThe basic idea is to have a central point from which six radial arms extend. Then, recursively, more arms branch out from the ends of those arms, for a variable number of layers. I also want the option to include hexagons at various locations within the structure.\n\nHere's a breakdown of the parameters I'd like control over:\n\n*   **Seed:** A number that initializes the random generation. Changing this seed should create different snowflakes.\n*   **Hexagon Presence:** A boolean (or similar) for each layer of the snowflake, controlling whether a hexagon should appear at the end of each arm.\n*   **Hexagon Solidity:**  A boolean (or similar) for each layer of the snowflake, controlling whether the hexagon should be a solid shape, or a hollow one.\n*   **Inner Hexagon Presence:** A boolean (or similar) for each layer of the snowflake, controlling whether a smaller hexagon should appear inside of each larger hexagon, if it exists.\n*   **Arm Length:** The length of the arm segments for each layer, configurable for each layer.\n*   **Arm Width:** The width of the arm segments for each layer, configurable for each layer.\n*   **Arm Angle:** The angle at which the next layer of arms branches out, also configurable per layer.\n*   **Depth:**  The number of layers (or levels) of recursion for the arms.\n*   **Overall Height:** A scalar value that determines the overall height of the 3D snowflake.\n*   **Layer Height Scaling:** A scalar to scale the height for each subsequent layer.\n\nI'd like to use the `rands()` function for the random parameter generation similar to the linked project and would be very helpful if your code was well documented with comments. Also, I don't need any libraries to be included, this can all be done using native OpenSCAD features.\n\nIdeally, this would be a single `.scad` file that generates the whole snowflake. The snowflake should be created with simple cubes to represent the arms, and simple hexagons.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Shapeoko Belt Clamp",
    "scad": "gThick = 8;\ngRibHeight = 6;\ngTopRoundoverRadius = 4;\ngSideRoundoverRadius = 4;\ngMainWidth = 16;\ngTopWidth = 30;\ngRibWidth = 3.4;\ngHoleSpacing = 20;\ngBeltWide = 14;\ngBeltPitch = 2.032;\ngBeltThick = 1.5;\ne = 0.02;\nM3 = [3.5, 6.4, 6.4];\nM5 = [5.5, 9.4, 9.4];\nM8 = [8, 13, 13];\nmodule InsetHole(x) {\n  d = x[0];\n  socket_head = x[1];\n  union() {\n    translate([0,0,-50]) cylinder(r=d/2, h=100);\n    cylinder(r=socket_head/2, h=10);\n  }\n}\nmodule NutHole(x) {\n  d = x[0];\n  nut_size = x[2];\n  union() {\n    translate([0,0,1]) cylinder(r=d/2, h=50);\n    cylinder(r=nut_size/2, $fn=6, h=6);\n  }\n}\nmodule Rib(t=4) {\n  translate([-t/2,0,-0.1])\n    rotate([90,0,90])\n      linear_extrude(height=t)\n        polygon(points=[[0,0],[40,0],[0,gRibHeight]],paths=[[0,1,2]]);\n}\nmodule Roundover(r) {\n  translate([0.1,0.1,-50])\n    difference() {\n      cube([r,r,100]);\n      translate([0,0,-1]) cylinder(r=r,h=102,$fn=20);\n    }\n}\nmodule Upright() {\n  difference() {\n    union() {\n      translate([0,-25,(gThick+gRibHeight)/2]) cube([gTopWidth,10,gThick+gRibHeight], center=true);\n      translate([0,0,gThick/2]) cube([gMainWidth,60,gThick], center=true);\n      translate([(gMainWidth-gRibWidth)/2,-20,gThick]) Rib(t=gRibWidth);\n      translate([-(gMainWidth-gRibWidth)/2,-20,gThick]) Rib(t=gRibWidth);\n    }\n    translate([gTopWidth/2-gTopRoundoverRadius,0,gThick+gRibHeight-gTopRoundoverRadius])\n      rotate([90,0,0])\n        Roundover(r=gTopRoundoverRadius);\n    translate([-(gTopWidth/2-gTopRoundoverRadius),0,gThick+gRibHeight-gTopRoundoverRadius])\n      rotate([90,0,180])\n        Roundover(r=gTopRoundoverRadius);\n    translate([gMainWidth/2-gSideRoundoverRadius,26,0])\n      Roundover(r=gSideRoundoverRadius);\n    translate([-(gMainWidth/2-gSideRoundoverRadius),26,0])\n      rotate([0,0,90])\n        Roundover(r=gSideRoundoverRadius);\n    translate([0,0,gThick-2]) InsetHole(M5);\n    translate([0,20,gThick-2]) InsetHole(M5);\n    translate([-gHoleSpacing/2,-16,(gThick+gRibHeight)/2]) rotate([90,-90,0]) NutHole(M3);\n    translate([gHoleSpacing/2,-16,(gThick+gRibHeight)/2]) rotate([90,-90,0]) NutHole(M3);\n  }\n}\nmodule Belt() {\n  translate([0,0,gBeltThick/2]) cube([gBeltWide,30,gBeltThick], center=true);\n  for(i = [0:30/gBeltPitch]) {\n    translate([0,i * gBeltPitch,-gBeltThick/2+e]) cube([gBeltWide,gBeltPitch / 2,gBeltThick], center=true);\n  }\n}\nmodule Top() {\n  rotate([-90,0,0]) difference() {\n    translate([0,-5,(gThick+gRibHeight)/2]) cube([gTopWidth,10,gThick+gRibHeight], center=true);\n    translate([-gHoleSpacing/2,20,(gThick+gRibHeight)/2]) rotate([90,-90,0]) NutHole(M3);\n    translate([gHoleSpacing/2,20,(gThick+gRibHeight)/2]) rotate([90,-90,0]) NutHole(M3);\n    translate([gTopWidth/2-gTopRoundoverRadius,0,gThick+gRibHeight-gTopRoundoverRadius])\n      rotate([90,0,0])\n        Roundover(r=gTopRoundoverRadius);\n    translate([-(gTopWidth/2-gTopRoundoverRadius),0,gThick+gRibHeight-gTopRoundoverRadius])\n      rotate([90,0,180])\n        Roundover(r=gTopRoundoverRadius);\n    translate([0,-12+(1.6*gBeltThick),0]) rotate([90,0,0]) Belt();\n  }\n}\nunion() {\n  Upright();\n  translate([0,-50,0]) Top();\n}",
    "description": "Okay, so I'm trying to design a really robust belt clamp for my Shapeoko CNC. I've seen a bunch of designs online, but they often feel flimsy, and I've even had some break on me. I've been messing around with OpenSCAD, and I've got a couple of files here that kind of show what I'm going for. Id like to work towards a single, parametric design that is easily configurable for different belt sizes and mounting options.\n\nEssentially, the clamp has two main parts: an \"upright\" and a \"top\" piece. The upright is the part that attaches to the machine, and the top is what actually clamps the belt.\n\nHeres what I'm thinking for the design:\n\n**Upright Part:**\n\n*   **Base:** It needs to be a solid base, probably a rectangular prism, with a thickness that's configurable.\n*   **Ribs:** I want to add ribs on either side to increase the stiffness.  The height and width of these ribs should be adjustable. I've been using a polygon with a linear extrude but I wonder if there is a more elegant way of doing this.\n*   **Mounting Holes:** I need two mounting holes for M5 screws, with proper clearance for socket heads, and positions that are configurable based on parameters.\n*   **Nut Traps:** I also need two nut traps for M3 nuts at the top for attaching the top piece. I want to control the spacing between these nut traps.\n*   **Roundovers/Chamfers:**  I want to round over all of the outer edges, especially near the top and bottom mounting holes. I'd like to be able to adjust the roundover radius.\n\n**Top Part:**\n\n*   **Base:** The top also has a base, a simple rectangular shape, with adjustable thickness.\n*   **Nut Traps:** Similar to the upright, it needs two M3 nut traps that will line up with the ones on the upright, with adjustable spacing and location.\n*   **Belt Channel:** The most important part: It needs a space for the belt, with a toothed pattern to help the belt grip. I was doing this with a bunch of cubes, but this seems inefficient and could be more robust. The width and tooth spacing of this channel needs to be configurable for different belt types. I'd like to define this using the standard belt parameters like pitch.\n*   **Roundovers/Chamfers:** Similar to the upright, all edges should be rounded over.\n\n**General Requirements:**\n\n*   **Parametric:** I want *everything* to be parametric: thicknesses, widths, heights, roundover radii, hole spacings, the belt width, the belt pitch, all of it.  I'd like to be able to quickly adjust these for different machine builds and belt types.\n*   **Robust:** The design should be robust and strong. I would like a comment on the design choices and how they impact the physical characteristics of the part.\n*   **Libraries:** I'm open to using libraries if they make things easier, but I'm not familiar with many beyond the basic OpenSCAD modules.\n\nI'd like the design in a single, well-commented OpenSCAD file, if possible. Could you help me generate an OpenSCAD file that I can use?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Wall / Gap Test Prints (Customizable)",
    "scad": "_1_style = 1;\n_2_start = 0.1;\n_3_end = 2.0;\n_4_increment = 0.1;\n_5_gap = 3.0;\n_6_height = 4;\n_7_length = 10;\n_8_baseHeight = 1.0;\n_9_numColumns = 10;\n$fn=60;\nmodule addWall(thickness, xspacing, yspacing, xpos, ypos, h) {\n\techo (ypos, xpos, thickness);\n\ttranslate([xspacing * xpos, -yspacing * ypos, 0]) {\n\t\tcube([thickness, _7_length, h]);\n\t}\n}\nmodule addWallGrid(wallHeight) {\n\tcount = round((_3_end-_2_start)/_4_increment)+1;\n\txspacing = _5_gap + _3_end;\n\tyspacing = _5_gap + _7_length;\n\ttranslate([_5_gap, -_5_gap - _7_length, 0]) {\n\t\tfor (index = [0:count-1]) {\n\t\t\tassign(thickness = _2_start + _4_increment * index) {\n\t\t\t\ttranslate([-thickness/2, 0, 0]) {\n\t\t\t\t\taddWall(thickness, xspacing, yspacing, index%_9_numColumns, floor(index/_9_numColumns), wallHeight);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule addBase(x, y, height) {\n\ttranslate([0, 0, -height*.75]) {\n\t\tminkowski() {\n\t\t\tcube([x, y, height/2]);\n\t\t\tcylinder(r=_5_gap,h=height/4);\n\t\t}\n\t}\n}\nmodule thinWallTest() {\n\tcount = round((_3_end-_2_start)/_4_increment)+1;\n\txspacing = _5_gap + _3_end;\n\tyspacing = _5_gap + _7_length;\n\txdim = xspacing * min(_9_numColumns, count);\n\tydim = yspacing * ceil(count/_9_numColumns)+_5_gap;\n\tif (_1_style == 1) {\n\t\tunion () {\n\t\t\taddBase(xdim, ydim, _8_baseHeight);\n\t\t\ttranslate([0, ydim, 0]) {\n\t\t\t\taddWallGrid(_6_height);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdifference () {\n\t\t\taddBase(xdim, ydim, _8_baseHeight);\n\t\t\ttranslate([0, ydim, -_8_baseHeight-1]) {\n\t\t\t\taddWallGrid(_8_baseHeight+2);\n\t\t\t}\n\t\t}\n\t}\n}\nthinWallTest();",
    "description": "Okay, I'm looking to create a customizable test print for evaluating my 3D printer's ability to produce thin walls and gaps. I've seen a design that's almost exactly what I need, but I'd like to make it more flexible and easier to reuse. \n\nThe core idea is to have a grid of either walls or gaps (selectable), where the thickness (or gap size) increases incrementally across the grid. The design should also include a base for stability.\n\nHeres a breakdown of the parameters I'd like to control in OpenSCAD:\n\n*   **`style`**: A selector to choose between generating a wall test or a gap test. Should have options like \"Wall\" or \"Gap\".\n\n*   **`start_thickness`**: The starting thickness (or gap) for the first sample. This is currently `_2_start`.\n\n*   **`end_thickness`**: The ending thickness (or gap) for the last sample. This is currently `_3_end`.\n\n*   **`thickness_increment`**: The increment between the thickness (or gap) of each sample. This is currently `_4_increment`.\n\n*   **`sample_spacing`**:  The space between each wall/gap sample, in both the X and Y directions, currently `_5_gap`.\n\n*   **`wall_height`**: The height of the walls or the depth of the gaps. This is currently `_6_height`.\n\n*   **`wall_length`**: The length of each individual wall or gap, currently `_7_length`.\n\n*   **`base_height`**: The height/thickness of the base on which the test samples are built, currently `_8_baseHeight`.\n\n*   **`num_columns`**: The number of columns of samples in the grid. This is currently `_9_numColumns`.\n\nThe design should:\n\n1.  Generate a grid of samples based on the given parameters, either as walls or gaps.\n2.  When `style` is set to \"Wall\", the output should be a series of walls of increasing thickness standing on the base.\n3.  When `style` is set to \"Gap\", the output should be a solid base with gaps of increasing thickness cut out of it.\n4.  The walls/gaps should be laid out in a grid pattern defined by `num_columns` and the other spacing parameters.\n5.  The sample spacing (`sample_spacing`) should be used to separate both the thickness and the length of each test feature.\n6.  Include a base of specified `base_height` to make it easy to print. The base should be a rounded rectangle using minkowski for stability.\n7. The layout should be such that it automatically adjusts based on the given parameters, as the current code seems to.\n8.  I'd prefer to not use fixed variables or the `$fn` variable. Instead, please use `round()` to make the number of samples flexible based on the thickness parameters and the increment.\n\nI'm not looking for fancy features, but something that is clear and easily customizable. I also prefer if you do not use any special libraries. Could you generate an OpenSCAD file that allows for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a parametric ceiling mounting bracket",
    "scad": "THING_WIDTH = 23;\nTHING_HEIGHT = 5;\nFINGER_DEPTH = 3;\nSTANDOFF_HEIGHT = 15;\nWALL_THICKNESS = 2;\nBRACKET_HEIGHT = 6;\nMOUNTING_SCREW_RADIUS = 2.5;\nmodule ceilingMountingBracket($fn=24) {\n  assign(outer_depth=2 * WALL_THICKNESS + THING_HEIGHT + max(0, STANDOFF_HEIGHT),\n         outer_width=THING_WIDTH + 2 * WALL_THICKNESS,\n         mounting_screw_height=max(BRACKET_HEIGHT / 2, WALL_THICKNESS + MOUNTING_SCREW_RADIUS)) {\n    difference() {\n      union() {\n        cube([outer_depth, outer_width, BRACKET_HEIGHT]);\n        translate([0, outer_width / 2, mounting_screw_height])\n        rotate([0, 90, 0])\n        cylinder(r=MOUNTING_SCREW_RADIUS + WALL_THICKNESS, h=WALL_THICKNESS);\n      }\n      translate([WALL_THICKNESS + max(0, STANDOFF_HEIGHT), WALL_THICKNESS, -1])\n      cube([THING_HEIGHT, THING_WIDTH, BRACKET_HEIGHT + 2]);\n      translate([WALL_THICKNESS, WALL_THICKNESS + FINGER_DEPTH, -1])\n      cube([outer_depth, THING_WIDTH - 2 * FINGER_DEPTH, BRACKET_HEIGHT + 2]);\n      translate([-1, outer_width / 2, mounting_screw_height])\n      rotate([0, 90, 0])\n      cylinder(r=MOUNTING_SCREW_RADIUS, h=WALL_THICKNESS + 2);\n      translate([WALL_THICKNESS, WALL_THICKNESS, WALL_THICKNESS])\n      cube([max(0, STANDOFF_HEIGHT - WALL_THICKNESS), THING_WIDTH, BRACKET_HEIGHT]);\n    }\n  }\n}\nceilingMountingBracket();",
    "description": "Okay, I'm looking for a ceiling-mounted bracket design, and I want to be able to customize it for different sized objects and mounting scenarios. I've got a basic idea in mind, but I need it to be parametric so I can easily adjust it.\n\nHere's what I need:\n\n**Overall Design:** I want a bracket that can hold a rectangular block-shaped object against the ceiling. The bracket should have a flat base that sits flush against the ceiling and arms that extend down to grip the sides of the block. It should also have a standoff feature, meaning the block being mounted doesn't have to be right up against the ceiling, but can be offset by a customizable distance. Finally, I want to be able to screw the bracket into the ceiling using a countersunk screw.\n\n**Specific Parameters (that should be customizable):**\n\n*   **`THING_WIDTH`**: The width of the rectangular object the bracket is going to hold.\n*   **`THING_HEIGHT`**: The height (thickness) of the rectangular object.\n*   **`FINGER_DEPTH`**: How deep the \"fingers\" or gripping portions of the arms should be (how much of the object the arms overlap).\n*   **`STANDOFF_HEIGHT`**: The distance between the top of the object being mounted and the ceiling. A value of zero would mean the block sits flush. This parameter should allow values of zero or greater; zero or negative values should be disallowed (this should be handled robustly).\n*   **`WALL_THICKNESS`**: The thickness of the bracket's walls.\n*   **`BRACKET_HEIGHT`**: The overall height of the bracket (how thick it is).\n*   **`MOUNTING_SCREW_RADIUS`**: The radius of the screw hole for mounting the bracket.\n*   **`MOUNTING_SCREW_CLEARANCE`**: The radial clearance value, which when added to the MOUNTING_SCREW_RADIUS, provides additional clearance for the screw. Defaults to 0.25.\n*   **`MOUNTING_SCREW_HEAD_RADIUS`**: The radius of the countersunk screw head.\n*   **`MOUNTING_SCREW_HEAD_ANGLE`**: The angle (in degrees) of the countersunk portion of the screw head.\n\n**Additional Design Requests:**\n\n*   **Screw Hole:** The screw hole should be centered on the bracket's width and placed on the ceiling-facing side. It should be countersunk for a flat head screw. It should be a through-hole.\n*   **Robustness:** The design should be robust enough to withstand some reasonable stresses.\n*   **Cleanliness:** The cutouts should be clean and free of artifacts.\n*   **Error Handling:** Ensure the design can handle invalid inputs such as negative values for thicknesses or radius parameters where it is not valid. It should at least generate an error message and ideally a reasonable alternative.\n*   **Modularity:** The design should be modular and well commented, so it's easy to understand and modify later.\n*   **Units:** Everything should be in millimeters.\n\nI'd like the output to be an OpenSCAD file, and I'd prefer it not to depend on any external libraries if possible. However, I'm comfortable with using BOSL2 if necessary. Could you generate that for me?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Lairds Customizable Clip",
    "scad": "gap=0.5;\nthickness=2;\ndiameter=7;\nsides=3;\n$fn=sides;\ndifference() {\n\trotate([0,0,360/sides/2]) cylinder(r=diameter/2+thickness, h=thickness);\n\ttranslate([0,0,-1]) {\n\t\trotate([0,0,360/sides/2]) cylinder(r=diameter/2, h=thickness+2);\n\t\ttranslate([0,-gap/2,0]) cube([diameter,gap,thickness+2]);\n\t\t}\n\t}",
    "description": "Okay, I need a parametric clip design, something I can customize to hold different diameter items. I've seen some designs that are basically a cylinder with a gap cut out, and I really like how simple they are.\n\nSpecifically, I want the clip to be a sort of ring with a gap. I need to be able to control the following:\n\n*   **Inner Diameter:** The diameter of the hole that the clip makes. I'll use this to make it fit snug around whatever I'm clipping.\n*   **Thickness:** How thick the clip's walls are. I need this so I can make it strong enough, but not so bulky that it wastes material.\n*   **Gap:** The width of the gap in the ring. This controls how much I have to flex the clip to get it over something. I want to control this because if its too large the clip won't be able to stay closed.\n*   **Sides/Smoothness:** I'd like the option to make it a polygon with a variable number of sides, so if I wanted a triangle or a hexagon or just something nearly smooth I could do that. I think the `$fn` variable can do that in OpenSCAD, so that should be easily adaptable.\n\nI want to make sure that the clip works with the following things:\n\n1.  The central area should be created by a cut away so that the interior of the clip is consistent and not created via the outside cylinder\n2.  The gap cut-out needs to be a block shape that goes through the entire clip\n\nI don't think I need any special features or specific libraries for this other than those standard to OpenSCAD. Can you provide an OpenSCAD file for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Chair/Table Foot ",
    "scad": "$fn=100;\nfoot_H=16;\nfoot_DB=51;\nfoot_DO=47;\nfoot_DI=43;\nfoot_T=3;\nW = foot_DB + foot_T;\nSH = (foot_DB-foot_DO)/2;\nunion() {\n\tdifference() {\n\t\tunion() {\n\t\t\trotate_extrude(convexity = 10, $fn = 100)\n\t\t\t\ttranslate([foot_DB/2 - foot_T, 0, 0])\n\t\t\t\t\tcircle(r=foot_T);\n\t\t\ttranslate([0,0, -foot_T])\n\t\t\t\tcylinder(h=foot_T, r=foot_DB/2 - 3);\n\t\t}\n\t\tcolor([1,0,0])\n\t\t\ttranslate([-W,-W,0])\n\t\t\t\tcube(W*2, false);\n\t}\n\tdifference() {\n\t\tcolor([0,0,1])\n\t\t\tcylinder(h=foot_H, r=foot_DO/2);\n\t\tcolor([0,1,0])\n\t\t\tcylinder(h=foot_H+1, r=foot_DI/2);\n\t\ttranslate([0,0,foot_H-SH]) color([1,0,0,0.5])\n\t\t\tdifference() {\n\t\t\t\t\tcylinder(h=SH, r1=foot_DB/2+ foot_T, r2=foot_DO/2);\n\t\t\t\t\tcylinder(h=SH + 1, r1=foot_DO/2, r2=foot_DI/2);\n\t\t}\n\t}\n}",
    "description": "Okay, I need a parametric OpenSCAD file for a chair foot, kind of like the one I already made but more flexible. I have a chair with tube legs and one of the plastic feet broke. I was able to model a replacement, but I want to make it easier to adjust for different chairs and leg sizes.\n\nHere's what I need:\n\n*   **Parametric Design:** The design should be driven by parameters that can be easily changed.\n*   **Base Foot:**\n    *   **Bottom Diameter (foot\\_DB):**  The diameter of the bottom of the foot.\n    *   **Outer Diameter (foot\\_DO):** The outer diameter of the main cylindrical body that contacts the floor.\n    *   **Inner Diameter (foot\\_DI):** The inner diameter of the cylindrical part where the chair leg tube fits in.\n    *   **Foot Height (foot\\_H):**  The overall height of the foot.\n    *   **Bottom Thickness (foot\\_T):** The thickness of the base plate of the foot.\n*   **Leg Socket:** The leg socket part of the foot should have a tapered shape to ensure a snug fit.\n    *  The taper should transition from the outer diameter to the inner diameter over a specified taper height, which should be a function of the input parameters.\n*   **Clearance:**  There needs to be some extra space between the leg socket and the inner diameter of the base to make it easy to insert the leg.\n*   **Construction:**\n    *   The foot should have a base plate on the floor side.\n    *   The main cylinder (foot\\_DO) should be on top of the base plate and should be hollow to be a \"socket\" for the chair leg.\n    *    The transition between the base plate and main cylinder should have a rounded shape to be smooth.\n*   **Easy to Modify:** The code should be straightforward to understand and easy to modify if needed.\n*   **No external Libraries:** It is important that there are no external library dependencies, I want to be able to run this in OpenSCAD standalone without any additional libraries.\n\nI'd like the design to be based on the attached OpenSCAD file I wrote. Basically, I want the same shape, but I want it to be fully parametric, easy to change and more polished.\n\nEssentially, I need a general-purpose parametric chair foot that I can easily adjust to fit different tubular chair legs. Can you help me create an OpenSCAD file that does this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Laird's Customizable Replicator Print Bed Adjuster",
    "scad": "len = 50*1;\nheight=5;\nt=1*1;\ntail=10*1;\naround=7*1;\nwidth=around+2*t;\ntranslate([-len/2,-width/2,0])\ndifference() {\n\tcube([len,width,height+tail]);\n\ttranslate([-1,t,height]) cube([len+2,around,tail+1]);\n\t}",
    "description": "Okay, I'm looking for an OpenSCAD design for a customizable clip to adjust the height of a 3D printer's print bed. Specifically, I want it to work on a Replicator-style printer, where the bed hits a Z-limit switch at the back. I've been using a simple scad file I found online, but I'd like something more parametric and easier to tweak.\n\nHere's the basic idea: It's a clip that fits around the back edge of the print bed, effectively lowering the point at which the Z-limit switch is triggered. This creates space for things like glass or wood plates that I put on top of the standard print surface.\n\nHere are the parameters I need to be able to control:\n\n*   **`len`:** The total length of the clip (in mm). This is the length that sits across the back of the bed. This is generally 50mm on Replicator style printers.\n*   **`height`:** How much the clip lowers the bed (in mm). This corresponds to the thickness of the glass or wood being added.\n*   **`t`:** The thickness of the \"wings\" of the clip (in mm), or the part that grips the bed.\n*   **`tail`:** How far the wings stick up above the lower, bed-contacting portion of the clip (in mm).\n*   **`around`:** How thick the bed edge is, plus a little clearance (in mm). This is the dimension across the bed edge that the clip grasps.\n\nEssentially, I want a rectangular prism, from which I'm going to cut another, shorter prism to create a U-shape that can be placed around the printer bed. I'm fine with a simple difference() operation, if needed. The original code looks something like this:\n\n```\n// Customizable Replicator Bed Adjustment Clip\n\n// How long a clip do you need, in mm? (50 fits Replicator)\nlen = 50*1;\n// How much do you want the clip to lower the Replicator print bed?\nheight=5;\n// How thick should the clip \"wings\" be?\nt=1*1;\n// How much should the \"wings\" stick up?\ntail=10*1;\n// How thick is the board it clips around, plus a little clearance?\naround=7*1;\t\n\nwidth=around+2*t;\n\ntranslate([-len/2,-width/2,0]) \ndifference() {\n\tcube([len,width,height+tail]);\n\ttranslate([-1,t,height]) cube([len+2,around,tail+1]);\n\t}\n```\n\nI'd like the code to be well-commented and easy to understand. I'd also like it to have descriptive variable names, if you can make them more descriptive. I expect to use this code with a Replicator-style 3D printer, but it would be nice if it was generally useful to anyone who needs to adjust a z-stop.\n\nI'm not looking for anything fancy, just a solid, parametric clip generator. I don't need any libraries, so please don't use anything like MCAD, BOSL, etc.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Tiny box for heat bed clips",
    "scad": "WIDTH = 50;\nLENGTH = 70;\nHEIGHT = 40;\nWALL = 2;\ndifference() {\n\tcube([WIDTH,LENGTH,HEIGHT]);\n\ttranslate([2,2,-1]) {\n\t\tcube([WIDTH-WALL*2,LENGTH-WALL*2,HEIGHT+2]);\n\t}\n}\ndifference() {\n\ttranslate([0,0,HEIGHT-2]) cube([WIDTH,LENGTH,2]);\n\ttranslate([3,3,HEIGHT-2.9]) cube([WIDTH-6,LENGTH-6,9]);\n}\ndifference() {\n\ttranslate([0,0,HEIGHT-3]) cube([WIDTH,LENGTH,2]);\n\ttranslate([2.5,2.5,HEIGHT-4]) cube([WIDTH-5,LENGTH-5,4]);\n}\ndifference() {\n\tunion() {\n\t\ttranslate([8,8,0]) cylinder(r=8,h=7);\n\t\tcube([16,8,7]);\n\t\tcube([8,16,7]);\n\t}\n\tunion() {\n\t\ttranslate([9,9,-1])  cylinder(r=2,h=9);\n\t\ttranslate([9,9,0])   cylinder(r1=4.5, r2=2, h=1.8, center=true);\n\t\ttranslate([9,9,3.1]) cylinder(r1=0,   r2=6, h=6,   center=false);\n\t}\n}\n$fn=300;",
    "description": "Okay, I'm looking to design a small box that I can screw onto my 3D printer, specifically to hold the binder clips I use for the print bed. I have a basic OpenSCAD file I've started, but I'd like to make it more parametric so I can easily adjust the size and other features.\n\nHeres what I'm envisioning:\n\n**General Requirements:**\n\n*   **Box Shape:** The box should be a simple rectangular prism.\n*   **Walls:** The walls should be of a specified thickness, and that thickness should be adjustable.\n*   **Top Lip:** I want a lip at the top of the box that's slightly thicker than the walls, and there should be a second layer of lip that extends out even further. This will help keep the clips from falling out.\n*   **Mounting:** There needs to be a screw hole (or perhaps two) with a countersunk head, to attach the box to the printer.\n*   **Parametric Design:** Everything should be adjustable via parameters so I can easily change dimensions without manually editing the geometry.\n\n**Specific Parameters I need:**\n\n*   `box_width`: Total width of the box.\n*   `box_length`: Total length of the box.\n*   `box_height`: Total height of the box.\n*   `wall_thickness`: Thickness of the box walls.\n*   `top_lip_height`: Height of the first top lip section that extends beyond the main box wall.\n*   `top_lip_thickness_1`: Thickness of the first top lip section that extends beyond the main box wall\n*   `top_lip_height_2`: Height of the second lip section extending beyond the first top lip\n*   `top_lip_thickness_2`: Thickness of the second top lip section that extends beyond the first top lip\n*   `screw_hole_x`: The x coordinate of the screw hole(s). (If there are multiple holes, should be an array.)\n*   `screw_hole_y`: The y coordinate of the screw hole(s). (If there are multiple holes, should be an array.)\n*   `screw_diameter`: Diameter of the screw head (used for countersink).\n*   `screw_shank_diameter`: Diameter of the screw shank.\n*   `screw_hole_depth`: The depth of the screw hole to use for the main shank depth\n*   `screw_countersink_depth`: The depth of the screw hole to use for the countersink\n\n**Additional Notes:**\n\n*   Id prefer to use the `difference()` function for cutting away the inside of the box and for the screw holes.\n*   I would like to specify the resolution, so that the default is 300, but this is also able to be changed.\n*   I'd like to use the BOSL library for this, specifically for the easy way of working with arrays of screws.\n\nI think this is everything. Let me know if you have any questions or need more clarification. I'm looking forward to seeing the parametric OpenSCAD file!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Chess Pawn Customizer",
    "scad": "resolution=16;\nsize=5;\npawn(size, resolution);\nmodule pawn(s, res){\n$fn=res;\ntranslate([0, 0, 12/5*s])\nsphere(r=s);\ncylinder(h = s*4, r1 = s, r2 = 2/5*s, center = true);\ntranslate([0, 0, 7/5*s])\ncylinder(h = 1/5*s, r=s);\ntranslate([0, 0, -2*s])\ncylinder(h = 6/5*s, r1 = 7/5*s, r2 = s);\ntranslate([0, 0, -11/5*s])\ncylinder(h = 1/5*s, r= 8/5*s);\n}",
    "description": "Okay, I'd like to design a chess pawn in OpenSCAD, and I want it to be parametric so I can easily adjust its size and resolution.\n\nThe pawn should be composed of a few basic shapes:\n\n1.  **A sphere for the top.** This sphere should have a radius equal to a size parameter 's'. Its center should be translated upwards by 12/5 * s.\n\n2.  **A conical body.** This should be a cylinder, centered, with a height of 4*s. The bottom radius should be 's' and the top radius should be 2/5 * s.\n\n3.  **A disc below the sphere.** This is a thin cylinder with a height of 1/5 * s, a radius of 's', and its center is translated up 7/5*s.\n\n4. **A tapered base.** This is a cylinder, centered, with a height of 6/5 * s. The bottom radius should be 7/5 * s and the top radius should be 's'.  It's translated downwards by 2 * s.\n\n5. **A bottom disc.** This is another thin cylinder with a height of 1/5 * s and a radius of 8/5 * s and its center is translated down 11/5*s.\n\nI'd like to control the overall size of the pawn using a parameter named `size`, where `size` is equal to 's' and can be any value from 2 to 100. I also want to control the smoothness of the curves by using a `resolution` parameter that represents the `$fn` value for the shapes. The resolution parameter should range from 2 to 128.\n\nCould you please generate the OpenSCAD code to create this pawn using a module called `pawn(size, resolution)`? I need to be able to set both `size` and `resolution` from the top-level so I can easily customize the design.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Flexible hose",
    "scad": "$fn=48;\nr=7;\nt=1;\nh = 0.7;\nd= 0.3;\nneck = 0.3;\ntube(r,t,h,neck,d);\nmodule tube(r,t,u,l1,l2)\n{\n  trunc_r = r*sqrt(1-u*u);\n  cone_h = (r+t)/l1 - (r+t)*l1;\n  cone_r = (r+t)*sqrt(1-l1*l1);\n  cone_factor = trunc_r/cone_r;\n  zscale = r/(r+t);\n  p = ((r+t)*l1+cone_h*(1-cone_factor))*zscale+r*u;\n  union() {\n    scale([1,1,zscale]) {\n      truncSphere(r+t,l2,l1);\n      translate([0,0,(r+t)*l1])cylinder(r1=cone_r,r2=cone_r*cone_factor,h=cone_h*(1-cone_factor));\n    }\n    translate([0,0,p])truncSphere(r,u,u);\n  }\n}\nmodule truncSphere(r,h1,h2) {\n  intersection() {\n    sphere(r);\n    translate(-r*[1,1,h1])cube(r*[2,2,h1+h2]);\n  }\n}",
    "description": "Okay, I'm looking to design a flexible hose made of interconnected segments, specifically tailored for 3D printing. I've seen similar designs before, like the one on Thingiverse (thing:17021), but I want something I can customize more easily and print reliably.\n\nHere's the breakdown of what I'm imagining:\n\n**Overall Structure:**\n\n*   The hose will be composed of repeating, interlocking segments.\n*   Each segment will consist of a spherical joint and a tapered neck leading into the next joint.\n*   The design needs to be printable without supports, meaning overhangs should be minimal and easily handled by a typical 3D printer.\n*   I want to be able to vary the segment length and the \"snappiness\" of the joint - how easily the segments articulate.\n\n**Key Parameters and Features:**\n\n*   **`r` (Radius):**  The radius of the main spherical joint.\n*   **`t` (Wall Thickness):** The thickness of the material forming the hose segment. This is crucial for printability and flexibility. I want to be able to easily tweak this to adjust the strength and flexibility.\n*   **`h` (Top Sphere Height):** The height of the truncated top portion of the joint sphere. This affects the max bending angle and also the inner diameter at that point of the tube.\n*   **`d` (Bottom Sphere Segment Height):** The height of the truncated bottom portion of the joint sphere. This controls how easily segments can be snapped together. I want to be able to easily vary this to change the force required to join sections.\n*   **`neck` (Neck Slope):** This parameter should control the slope of the neck connecting to the next joint. It should also affect the overall length of each segment, with lower values leading to longer sections, but this shouldn't go lower than `d`.\n\n**Specific Requests for OpenSCAD:**\n\n*   The design should be fully parametric, allowing me to adjust all the parameters (`r`, `t`, `h`, `d`, and `neck`) via variables at the top of the file.\n*   I need to be able to control the `$fn` variable, which determines the resolution of the spheres and cylinders used to make the part. It should be located at the top of the file.\n*   I'd like to see a single module which generates a single segment of the tube. I would like to be able to call that module to generate multiple segments as well, either by copy-pasting or by iterating over that module.\n*  The design must be easily printable - meaning that it should be possible to print each segment individually without supports. Therefore, all the internal surfaces of the tubes should be easy to print.\n\n**Libraries:**\n\nI don't need any special libraries for this design. I believe standard OpenSCAD primitives should be sufficient.\n\nEssentially, I'm looking for a parametric version of that flexible tube with the specific features and controls I've mentioned, and I'd like to be able to control how tightly the segments fit together using the parameters. Could you generate an OpenSCAD file that achieves this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Honeycomb Pencil Holder",
    "scad": "cell_radius = 8;\nhoneycomb_radius = 3;\nfloor_thickness = 2;\nheight = 50;\nmodule hexagon(radius){\n\tcircle(r=radius,$fn=6);\n}\nmodule cell(radius, height, floor_thickness){\n\tdifference(){\n\t\tlinear_extrude(height=height){hexagon(radius*1.2);}\n\t\ttranslate([0,0,floor_thickness]) linear_extrude(height=height){hexagon(radius*1.1);}\n\t}\n}\nmodule translate_to_hex(x_coord, y_coord, hex_width){\n\tx = x_coord*hex_width*1.75;\n\ty = (2*y_coord*hex_width)+(x_coord*hex_width);\n\ttranslate([x, y, 0]){\n\t\tchild(0);\n\t}\n}\nmodule rounded_cap(radius, hex_width, height){\n\tdifference(){\n\t\ttranslate([0,0,height]) cylinder(r=3*hex_width*radius,h=height,center=true);\n\t\ttranslate([0,0,height/2]) scale([1,1,1/radius]) sphere(r=3*hex_width*radius,center=true);\n\t}\n}\nmodule pencil_holder(radius, hex_width, height, floor_thickness){\n\tdifference(){\n\t\tunion(){\n\t\t\tfor(x = [-radius:radius]){\n\t\t\t\tfor(y = [-radius:radius]){\n\t\t\t\t\tassign(z=0-x-y){\n\t\t\t\t\t\tif(max(abs(x),abs(y),abs(z))<=radius){\n\t\t\t\t\t\t\ttranslate_to_hex(x, y, hex_width) cell(hex_width, height, floor_thickness);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trounded_cap(radius, hex_width, height);\n\t}\n}\npencil_holder(honeycomb_radius, cell_radius, height, floor_thickness);",
    "description": "Okay, I'd like to design a customizable honeycomb pencil holder, and I'm hoping you can help me with the OpenSCAD code. I want it to have a few key parameters that I can easily adjust.\n\nFirst, I need to be able to control the size of each individual cell in the honeycomb. Let's call this parameter `cell_radius`. I'd like the code to draw a hexagon for each cell, and this radius will define the size of that hexagon.\n\nNext, I need a parameter that controls the overall size of the honeycomb structure. This will determine how many cells there are from the center to the outer edge. Lets call this `honeycomb_radius`. So, if `honeycomb_radius` is 3, there will be three layers of hexagons out from the center hexagon.\n\nI also want to specify the thickness of the base of the pencil holder, which will be at the bottom of the cells. I'll call this parameter `floor_thickness`.\n\nFinally, I need a way to specify the overall height of the pencil holder. Let's call this `height`.\n\nI'd also like the top of the pencil holder to have a rounded cap that tapers nicely from the main body. The curvature of this cap should be dependent on the size of the honeycomb structure.\n\nI'd like the design to be in OpenSCAD, using only the built-in functions (like `circle`, `linear_extrude`, `translate`, `difference`, `union`, and `sphere` and `cylinder`). I don't want to use any external libraries.\n\nCould you generate the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizer Template",
    "scad": "include <utils/build_plate.scad>\nx_measurement = 10;\ny_measurement = 10;\nz_measurement = 10;\ntext_box = 10;\nanother_text_box = 10;\nnumber_drop_down_box = 1;\ntext_drop_down_box = \"yes\";\nlabeled_drop_down_box = 5;\nnumerical_slider = 1;\nhidden_option = 100*1;\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\ntranslate([0,0,z_measurement/2]) cube([x_measurement, y_measurement, z_measurement], center=true);",
    "description": "Okay, I'm looking to create a basic customizable box using OpenSCAD and the Thingiverse Customizer. I've found a template that seems like a good starting point, and I'd like to make a few modifications. \n\nThe core of the design is a simple cube, and the template already allows for customizing its x, y, and z dimensions using sliders. That's great. I would like to maintain the capability to adjust the x,y, and z dimensions using sliders. The template uses the `build_plate` library to show the build plate size and I want that to remain as well.\n\nSpecifically, I want to make the following changes and additions:\n\n1.  **Add a thickness parameter:** I need a new slider (numerical) that allows me to control the wall thickness of the box. This should apply equally to all sides (x, y, and z). The wall thickness slider should have a minimum value of 1 and a maximum value of half of whichever dimension is the smallest (x, y, z).\n\n2. **Hollow out the box**: The current cube is solid. I'd like to make it hollow, with the wall thickness defined by the new parameter. The box should remain a centered box.\n\n3.  **Remove the text box and numbered dropdown examples:** I don't need the example `text_box`, `another_text_box`, `number_drop_down_box`, `text_drop_down_box`, and `labeled_drop_down_box` customizer variables and their associated comments.\n\n4.  **Keep the build plate functionality:** I want to keep the `build_plate_selector` and manual build plate options (`build_plate_manual_x`, `build_plate_manual_y`) using the `utils/build_plate.scad` library. It's important to keep the cube sitting centered on the build platform, like it does in the current template.\n\n5.  **Keep the numerical slider example:** The `numerical_slider` example is fine, so that should also stay.\n\nSo, to summarize, I want a parametric OpenSCAD file that uses the `build_plate` library, creates a hollow, centered box, with configurable dimensions on the x,y,z axis, using sliders to define the dimensions, and a new numerical slider to define the wall thickness. It should also keep the ability to set a build platform, either via selection or manual dimensions.\n"
  },
  {
    "object": "Hey cadmonkey, make me a  Customizable Tri Glide",
    "scad": "_1_webbingWidth = 26;\n_2_webbingGap = 4;\n_3_edgeThickness = 2.4;\n_4_centerThickness = 4;\n_5_height = 2.4;\n_6_cornerRounding = 75;\nmodule makeBody(xsize, ysize, height, radius) {\n\ttranslate([0,0,height/2]) {\n\t\tminkowski() {\n\t\t\tcube(size=[xsize-2*radius,ysize-2*radius, height/2], center = true);\n\t\t\tcylinder(r=radius, h=height/2, center=true);\n\t\t}\n\t}\n}\nmodule makeCuts(width, gap, thickness, height) {\n\toffset = (thickness+gap)/2;\n\tfor (y = [-offset, offset]) {\n\t\ttranslate([0, y, height/2]) {\n\t\t\tcube(size=[width, gap, height*2], center=true);\n\t\t}\n\t}\n}\nmodule makeTriGlide(width, gap, edgeThickness, centerThickness, height, rounding, $fn=90) {\n\txsize = width + edgeThickness * 2;\n\tysize = centerThickness + edgeThickness * 2 + gap * 2;\n\tradius = edgeThickness*(rounding/100);\n\tdifference() {\n\t\tmakeBody(xsize, ysize, height, radius);\n\t\tmakeCuts(width, gap, centerThickness, height);\n\t}\n}\nmakeTriGlide(_1_webbingWidth, _2_webbingGap, _3_edgeThickness, _4_centerThickness, _5_height, _6_cornerRounding);",
    "description": "Okay, I'd like to request a parametric OpenSCAD design for a tri-glide buckle, similar to the one I have in the provided file, but with some additional features and flexibility.\n\nThe core functionality should remain the same: it needs to create a tri-glide with three slots for webbing, but I'd like more granular control over the shape and dimensions.\n\nHere's a breakdown of what I'd like to be able to customize:\n\n*   **Webbing Width:**  This should be a primary parameter controlling the inner width of the slots. Id like to be able to specify the width of the webbing that will pass through the tri-glide.\n*   **Webbing Gap:** The gap between the \"center beam\" of the tri-glide and the outer walls. This value should control the space for the webbing to slide through.\n*   **Edge Thickness:** The thickness of the outer walls of the tri-glide. This affects the overall strength.\n*   **Center Beam Thickness:** The thickness of the center beam of the tri-glide.\n*   **Overall Height:** The height of the tri-glide, which will affect the 3D print time.\n*   **Corner Rounding:** The radius of the rounded corners. Instead of a percentage, Id like to directly define a radius.\n*   **Number of Webbing Slots:** This is the big one. Instead of always being 3 slots, I want to specify the number of webbing slots/bars. This needs to automatically adjust the model so the outer edge is still smooth. For example, if I only want a single bar (making it a ladder lock) or if I want 4, 5 or more bars, I should be able to change that. This feature is *very important* to me.\n\n*   **Orientation Option:** I'd like an option to specify if the tri-glide should be designed with the bars aligned horizontally or vertically in the x-y plane (from a top-down view). This affects how the webbing would feed through.\n    *  For the vertical alignment, the slots would run vertically (up and down in the Y direction).\n    * For horizontal, the slots would run horizontally (left to right in the X direction).\n\n*   **Customizable Base Thickness:** I'd like an additional parameter to control the thickness of the base where the webbing slots are, separate from the 'edge thickness'. This would allow us to make a more robust base than the edges if desired.\n\n*  **Beveled Edges (Optional):** An optional parameter to bevel the edges, and a parameter to set the angle and the size of the bevel. If the user sets this parameter to zero, then there should be no bevel on the edges.\n\n*   **OpenSCAD Libraries:** I do not require any libraries, please write this with standard OpenSCAD commands.\n\nEssentially, I need a much more flexible tri-glide generator that can adapt to different webbing setups and design preferences.  I'm hoping this design can accommodate a wide variety of projects. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Nut calumet - helps bolting anything",
    "scad": "nut_d_base= 6;\nnut_tolerance= 0.2;\nnut_th= 2.3;\nhandle_len= 70;\nhandle_width= 5;\nhandle_th= 1.8;\nwall_th= 1.8;\nsee_through_hole_d= 3.1;\nopen_side= 0;\nsplit_head_th= 0.6;\nhead_angle= 10;\nhead_offset_x=0;\nhead_offset_y=0;\nhead_offset_z=1;\n$fn=20+0;\nhead_offset=[head_offset_x,-head_offset_y,head_offset_z+handle_th];\nnut_d= nut_d_base + nut_tolerance;\ndifference()\n{\n  union()\n  {\n    translate([-handle_width/2,0,0])\n      cube([handle_width, handle_len, handle_th]);\n    difference()\n    {\n      translate(head_offset) rotate([head_angle ,0,0]) difference()\n      {\n\thull()\n\t{\n\t  cylinder(r= nut_d/2+wall_th, h= nut_th);\n\t  rotate([-head_angle ,0,0]) translate(-head_offset) cylinder(r=handle_width/2,h=handle_th);\n\t}\n\ttranslate([0,0,tol]) rotate([0,0,open_side])\n\t{\n\t  if(open_side==0)\n\t    cylinder(r= nut_d/2, h= nut_th+2, $fn=6);\n\t  else hull()\n\t  {\n\t    cylinder(r= nut_d/2, h= nut_th+2, $fn=6);\n\t    translate([0,nut_d_base*2+10,0]) cylinder(r= nut_d/2, h= nut_th+1, $fn=6);\n\t  }\n\t}\n\tif(split_head_th>0)\n\t  rotate([0,0,open_side])\n\t    translate([-nut_d-wall_th,-split_head_th/2,1]) cube([(nut_d+wall_th)*2,split_head_th,nut_th+2]);\n      }\n    }\n  }\n  if(see_through_hole_d>0)\n      translate(head_offset) rotate([head_angle ,0,0]) difference()\n\t  cylinder(r=see_through_hole_d/2, h=300,center=true);\n  translate([-(nut_d+head_offset_x+wall_th+handle_width),-(nut_d+head_offset_y+wall_th+handle_width),(-nut_d-head_offset_z-wall_th) + 0.05])\n    cube([(nut_d+head_offset_x+wall_th+handle_width)*2,(nut_d+head_offset_y+wall_th+handle_width)*2 + handle_len, nut_d+head_offset_z+wall_th]);\n}",
    "description": "Okay, I need an OpenSCAD design for a nut holder, but I want it to be highly customizable. I'm thinking something like what's described in the \"nut_holder.scad\" file I've been working with. Let me break down what I need:\n\n**Core Functionality:**\n\n*   The main purpose is to hold a standard metric nut securely, but the nut size needs to be adjustable.\n*   It should have a handle for easy gripping and placement.\n*   The holder needs to have a head section that cradles the nut.\n*   There should be an option to create a see-through hole in the head.\n*   The head can be either fully enclosed around the nut or opened on one side to ease placement in tight spots.\n*   There is also an option to split open the head if needed.\n*   The head has an offset from the handle along x, y, and z axes.\n\n**Specific Parameters I'd like control over:**\n\n*   `nut_d_base`: The base diameter of the nut (width across corners).\n*   `nut_tolerance`: Additional tolerance for the nut hole, useful to account for shrinkage after printing.\n*   `nut_th`: The thickness of the nut.\n*   `handle_len`: The length of the handle.\n*   `handle_width`: The width of the handle.\n*   `handle_th`: The thickness of the handle.\n*   `wall_th`: Thickness of the wall surrounding the nut in the head section.\n*   `see_through_hole_d`: Diameter of the optional see-through hole (zero to disable).\n*   `open_side`:  Direction (in degrees) to open the head (e.g., 90, -90, 180 for left, right, top). 0 disables.\n*   `split_head_th`: Gap width to split the head (zero to disable).\n*  `head_angle`: The rotation of the head relative to the handle in degrees.\n*   `head_offset_x`: Head offset on the X axis.\n*  `head_offset_y`: Head offset on the Y axis.\n*  `head_offset_z`: Head offset on the Z axis.\n\n**Requirements:**\n\n*   The design should be parametric, meaning all dimensions can be adjusted through variables.\n*   I'd prefer the design use the `hull()` function to smoothly blend the head section and the handle to avoid abrupt transitions. This is shown in the file nut_holder.scad which I am not able to attach\n*   I want a proper `difference()` to remove material for the nut hole, the see-through hole, and to create the split head.\n* The design should include a large difference cube at the end to ensure nothing extends beneath the printing surface.\n* The default nut size should correspond to an M6 nut.\n*   I'd like it to be easily customizable with the Customizer interface on Thingiverse, so I think including comments above each variable to describe them would be nice.\n*   Please make sure to add comments inside the code to improve readability.\n\nI don't require any external libraries for this design. It would be great if you could produce an OpenSCAD file that takes all the above into account.\n"
  },
  {
    "object": "Hey cadmonkey, make me a  Customizable Round Trays",
    "scad": "trayDiameter = 48;\ntrayHeight = 15;\ntrayRounding = 4;\ntraySidewall = 0.8;\ntrayBottom = 1.6;\nresolution = 60;\n$fn = resolution;\nmodule torus(r1, r2) {\n\trotate_extrude(convexity = 4)\n\ttranslate([r1, 0, 0])\n\tcircle(r = r2);\n}\nmodule roundedCylinder(height, radius, fillet)\n{\n\thull() {\n\t\ttranslate([0, 0, height/2-fillet])\n\t\ttorus(r1 = radius-fillet, r2 = fillet);\n\t\ttranslate([0, 0, -(height/2-fillet)])\n\t\ttorus(r1 = radius-fillet, r2 = fillet);\n\t}\n}\nmodule roundTray(diameter, height, rounding, sidewall, bottom)\n{\n\tradius = diameter/2;\n\ttranslate([0, 0, height])\n\tdifference() {\n\t\troundedCylinder(height*2, radius, rounding);\n\t\troundedCylinder((height - bottom)*2, radius-sidewall, rounding - sidewall);\n\t\tcylinder(h=height*2, r=radius+1, center=false);\n\t}\n}\nroundTray(trayDiameter,trayHeight,trayRounding,traySidewall,trayBottom);",
    "description": "Okay, I'd like to request an OpenSCAD design for a tray, similar to the 'round_trays_v1-1.scad' file I found, but I need some significant improvements, especially around customization and a few extra features.\n\nThe current design has a basic rounded tray shape, created by subtracting a smaller rounded cylinder from a larger one. It uses `torus()` and `roundedCylinder()` modules, which I like. It's also got a good base set of parameters: diameter, height, rounding radius, sidewall thickness, and bottom thickness.\n\nHere's what I'd like to see in the improved parametric design:\n\n1.  **Parametric Shape Options**: Instead of *just* a round tray, I want to be able to choose from a few different shapes for the base. I'd like options for:\n    *   **Round** (as in the original design)\n    *   **Square** with rounded corners, where I can specify the corner radius.\n    *  **Hexagonal** (regular hexagon) with rounded corners. I'd also want control of the corner radius.\n\n2.  **Internal Dividers:** I want the option to add internal dividers that radiate from the center of the tray, creating pie-slice-shaped compartments. I should be able to specify:\n    *  The number of dividers\n    *  The thickness of the dividers\n    *  Optionally, the depth of the dividers (if they aren't to reach the bottom of the tray). This should default to the tray bottom depth.\n\n3.  **Stackable Feature:**  I want the option to create a small lip on the top edge of the tray, so the trays can be stacked on top of each other without slipping, effectively creating a stackable set. I need to specify:\n     * The lip height.\n     * The lip width (how much it extends inward from the edge).\n\n4.  **Mounting Features:** This is a bit more advanced, but ideally, Id like the option to add a set of mounting holes to the base of the tray. The number, size, and position of the holes should be configurable, perhaps using a radius and an offset angle for each hole (or more intuitively a way to specify evenly spaced holes). Perhaps 3 or 4 mounting holes would be good defaults.\n\n5.  **Improved Bottom Fillet**: I'd like to refine the bottom fillet a bit. The original design essentially uses a torus, but I'd like to see if we can make this a more gradual rounding. If there's an easy way to add a more sophisticated shape with a `hull()` command (or similar) to give a more smooth and natural curve, that would be great. This should also be optional and revert to the torus method as it is by default.\n\n6.  **Use of Libraries**: If this can be done efficiently using an existing OpenSCAD library, I'm open to it. Libraries like BOSL or BOSL2 seem like they might have relevant functions for things like the rounded corners of the square and hex shapes, or other complex geometry. We should try and avoid using very old libraries and instead try and use BOSL or BOSL2 first if they make sense here. I'm not asking for specific files in the library to be attached but rather that the code to use the libraries is correctly written.\n\n7.  **Clear Comments:** Please add plenty of comments so it's easy to understand how the code works and how I can modify it.\n\nEssentially, I want a much more versatile and feature-rich version of this tray design. Let me know if you need any more details!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Door Knob and Drawer Pull Maker",
    "scad": "01_stem_height = 20;\nstem_height = 01_stem_height + 0.0;\n02_stem_diameter = 18;\nstem_radius = 02_stem_diameter/2 + 0.0;\n03_taper_amount = 0.8;\ntaper_amount = 03_taper_amount + 0.0;\n04_angled_edges = \"Yes\";\nstem_chamfer = str(04_angled_edges, \"\");\n05_stem_shape = \"Straight\";\nstem_shape = str(05_stem_shape,\"\");\n06_screw_depth = 5;\nscrew_depth = 06_screw_depth + 1.0;\n07_screw_diameter = 3;\nscrew_radius = (07_screw_diameter+.75)/2.0;\n08_ornament_style = \"UFO\";\nornament_style = str(08_ornament_style,\"\");\n09_ornament_size = 30;\nornament_size = (09_ornament_size/2) + 0.0;\n10_indent_ornament = \"Bump\";\nindent_ornament = str(10_indent_ornament,\"\");\ndifference() {\n\tunion() {\n\t\tif (stem_height > 0) {\n\t\t\tcreateStem();\n\t\t}\n\t\tif (ornament_style != \"None\") {\n\t\t\tif (ornament_style == \"Ball\") {\n\t\t\t\tcreateBallOrnament();\n\t\t\t}\n\t\t\tif (ornament_style == \"Mushroom\") {\n\t\t\t\tcreateHalfBallOrnament();\n\t\t\t}\n\t\t\tif (ornament_style == \"UFO\") {\n\t\t\t\tcreateUfoOrnament();\n\t\t\t}\n\t\t\tif (ornament_style == \"Blimp\") {\n\t\t\t\tcreateBlimpOrnament();\n\t\t\t}\n\t\t\tif (ornament_style == \"Half Blimp\") {\n\t\t\t\tcreateHalfBlimpOrnament();\n\t\t\t}\n\t\t\tif (ornament_style == \"Triangle\") {\n\t\t\t\tcreateShapeOrnament(3);\n\t\t\t}\n\t\t\tif (ornament_style == \"Circle\") {\n\t\t\t\tcreateShapeOrnament(36);\n\t\t\t}\n\t\t\tif (ornament_style == \"Hexagon\") {\n\t\t\t\tcreateShapeOrnament(6);\n\t\t\t}\n\t\t\tif (ornament_style == \"Rectangle\") {\n\t\t\t\tcreateRectangleOrnament();\n\t\t\t}\n\t\t\tif (ornament_style == \"Square\") {\n\t\t\t\tcreateShapeOrnament(4);\n\t\t\t}\n\t\t}\n\t}\n\tif ((stem_height > 0) || (ornament_style != \"None\")) {\n\t\tcreateScrewHole();\n\t}\n}\nmodule createStem() {\n\tdifference() {\n\t\tcylinder(r1=max(stem_radius,screw_radius+1),r2=max(stem_radius*taper_amount,screw_radius+1),h=stem_height,$fn=48);\n\t\tif (stem_shape == \"Curved\") {\n\t\t\ttranslate([0,0,stem_height/1.55])\n\t\t\trotate_extrude(convexity = 10, $fn=24)\n\t\t\tscale([1,(stem_height*0.775)/stem_radius,1])\n\t\t\ttranslate([stem_radius*1.65, 0, stem_height])\n\t\t\tcircle(r = stem_radius, $fn=24);\n\t\t}\n\t\tif (stem_chamfer == \"Yes\") {\n\t\t\trotate_extrude(convexity = 10, $fn=64)\n\t\t\ttranslate([stem_radius+1, 0, -10])\n\t\t\tcircle(r = 2, $fn=6);\n\t\t\trotate_extrude(convexity = 10, $fn=64)\n\t\t\ttranslate([(stem_radius+1)*taper_amount, stem_height, -10])\n\t\t\tcircle(r = 2*taper_amount, $fn=6);\n\t\t}\n\t\tif (ornament_style == \"None\" && indent_ornament != \"None\") {\n\t\t\tif (indent_ornament == \"Bump\") {\n\t\t\t\trotate_extrude(convexity = 10, $fn=64)\n\t\t\t\ttranslate([(stem_radius*taper_amount)-3, stem_height, -10])\n\t\t\t\tcircle(r = 0.5, $fn=6);\n\t\t\t}\n\t\t\tif (indent_ornament == \"Reverse\") {\n\t\t\t\ttranslate([0,0,stem_height-0.5])\n\t\t\t\tcylinder(r1=stem_radius*taper_amount-3,r2=stem_radius*taper_amount-3,h=stem_height,$fn=48);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule createScrewHole() {\n\tif (stem_height > 5 ) {\n\t\ttranslate([0,0,-2]) cylinder(r1=screw_radius,r2=screw_radius,h=min(screw_depth+2,stem_height),$fn=24);\n\t} else {\n\t\ttranslate([0,0,-80]) cylinder(r1=screw_radius,r2=screw_radius,h=85,$fn=24);\n\t}\n}\nmodule createBallOrnament() {\n\tif ((ornament_size) >= stem_radius*taper_amount)\n\t{\n\t\ttranslate([0,0,(stem_height+(sqrt(pow(ornament_size,2)-pow(stem_radius*taper_amount,2)) ) )])\n\t\tdifference() {\n\t\t union() {\n\t\t\t\tif (indent_ornament == \"Bump\") {\n\t\t\t\t\tsphere(r=ornament_size-1, $fn=36);\n\t\t\t\t}\n\t\t\tdifference() {\n\t\t\t\tsphere(r=ornament_size, $fn=36);\n\t\t\t\tif (indent_ornament != \"None\") {\n\t\t\t\t\ttranslate([0,0,max(stem_height*0.5,ornament_size-1)]) sphere(r=ornament_size-1, $fn=36);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\t}\n \telse {\n\t\ttranslate([0,0,stem_height])\n\t\t union() {\n\t\t\tif (indent_ornament == \"Bump\") {\n\t\t\t\tsphere(r=ornament_size-1, $fn=36);\n\t\t\t}\n\t\t\tdifference() {\n\t\t\t\tsphere(r=ornament_size, $fn=36);\n\t\t\t\tif (indent_ornament != \"None\") {\n\t\t\t\t\ttranslate([0,0,10]) sphere(r=ornament_size-1, $fn=36);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule createHalfBallOrnament() {\n\ttranslate([0,0,stem_height])\n\tdifference() {\n\t\tunion() {\n\t\t\tif (indent_ornament == \"Bump\") {\n\t\t\t\tsphere(r=ornament_size-1, $fn=36);\n\t\t\t}\n\t\t\tdifference() {\n\t\t\t\tsphere(r=ornament_size, $fn=36);\n\t\t\t\tif (indent_ornament != \"None\") {\n\t\t\t\t\ttranslate([0,0,ornament_size-1]) sphere(r=ornament_size-1, $fn=36);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate([-35,-35,-70]) cube([70,70,70], center=false);\n\t}\n}\nmodule createUfoOrnament() {\n\tif ((ornament_size) >= stem_radius*taper_amount)\n\t{\n\t\tscale([1,1,0.2])\n\t\ttranslate([0,0,((stem_height*5)+(sqrt(pow(ornament_size,2)-pow(stem_radius*taper_amount,2)) ) )])\n\t\tunion() {\n\t\t\tif (indent_ornament == \"Bump\") {\n\t\t\t\tsphere(r=ornament_size-1, $fn=36);\n\t\t\t}\n\t\t\tdifference() {\n\t\t\t\tsphere(r=ornament_size, $fn=36);\n\t\t\t\tif (indent_ornament != \"None\") {\n\t\t\t\t\ttranslate([0,0,ornament_size-1]) sphere(r=ornament_size-1, $fn=36);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tscale([1,1,0.2])\n\t\ttranslate([0,0,stem_height*5])\n\t\tunion() {\n\t\t\tif (indent_ornament == \"Bump\") {\n\t\t\t\tsphere(r=ornament_size-1, $fn=36);\n\t\t\t}\n\t\t\tdifference() {\n\t\t\t\tsphere(r=ornament_size, $fn=36);\n\t\t\t\tif (indent_ornament != \"None\") {\n\t\t\t\t\ttranslate([0,0,ornament_size-1]) sphere(r=ornament_size-1, $fn=36);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule createBlimpOrnament() {\n\ttranslate([0,0,(stem_height+(sqrt(pow(ornament_size,2)-pow(stem_radius*taper_amount,2)) )/2 )])\n\tscale([1,0.5,0.5])\n\tunion() {\n\t\tif (indent_ornament == \"Bump\") {\n\t\t\tsphere(r=ornament_size-1, $fn=36);\n\t\t}\n\t\tdifference() {\n\t\t\tsphere(r=ornament_size, $fn=36);\n\t\t\tif (indent_ornament != \"None\") {\n\t\t\t\ttranslate([0,0,ornament_size-1]) sphere(r=ornament_size-1, $fn=36);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule createHalfBlimpOrnament() {\n\t\tscale([1,0.5,0.5]) translate([0,0,stem_height*2])\n\t\tdifference() {\n\t\tunion() {\n\t\t\tif (indent_ornament == \"Bump\") {\n\t\t\t\tsphere(r=ornament_size-1, $fn=48);\n\t\t\t}\n\t\t\tdifference() {\n\t\t\t\tsphere(r=ornament_size, $fn=48);\n\t\t\t\tif (indent_ornament != \"None\") {\n\t\t\t\t\ttranslate([0,0,ornament_size-1]) sphere(r=ornament_size-1, $fn=48);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate([-35,-35,-70]) cube([70,70,70], center=false);\n\t}\n}\nmodule createShapeOrnament(sides, scale) {\n\ttranslate([0,0,stem_height])\n\tscale([scale,scale,1])\n\tdifference() {\n\t\tcylinder(r=ornament_size, h=ornament_size/3, $fn=sides);\n\t\tif (indent_ornament != \"None\") {\n\t\t\ttranslate([0,0,ornament_size/3-1])\n\t\t\tdifference() {\n\t\t\t\tcylinder(r=ornament_size-4, h=10, $fn=sides);\n\t\t\t\tif (indent_ornament == \"Bump\") {\n\t\t\t\t\tcylinder(r=ornament_size-6, h=10, $fn=sides);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule createRectangleOrnament() {\n\ttranslate([0,0,stem_height])\n\tdifference() {\n\t\ttranslate([-ornament_size,-ornament_size/2,0])\n\t\tcube(size=[ornament_size*2,ornament_size,ornament_size/5], center=false);\n\t\tif (indent_ornament != \"None\") {\n\t\t\ttranslate([-ornament_size+2,-ornament_size/2+2,ornament_size/5-1])\n\t\t\tdifference() {\n\t\t\t\tcube(size=[ornament_size*2-4,ornament_size-4,ornament_size/5], center=false);\n\t\t\t\tif (indent_ornament == \"Bump\") {\n\t\t\t\t\ttranslate([2,2,0])\n\t\t\t\t\tcube(size=[ornament_size*2-8,ornament_size-8,ornament_size/5], center=false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "description": "Okay, I'm looking to create a custom door pull, and I'd like to be able to adjust several parameters to get exactly what I need. I'd like the design to be based on a stem with an optional ornament on top. \n\nHere are the features and parameters I want to be able to control:\n\n**Stem:**\n\n*   **Stem Height:** I need to set the height of the stem in millimeters. I'd like a minimum of 0mm and a maximum of 40mm.\n*   **Stem Diameter:** I need to set the diameter of the stem's base in millimeters. I need a minimum of 10mm and a maximum of 50mm.\n*   **Taper:** The stem should be able to taper from the base to the top. I need a parameter to control the taper. A value of 1 should mean no taper, 1.2 would mean a slightly larger top and 0.8 would mean a slightly smaller top. I'd like to be able to adjust this with a value as low as 0.5 and as high as 1.5, and maybe even higher if it's possible.\n*   **Angled Edges:** I'd like to be able to add angled edges to the top and bottom of the stem - a chamfered effect. I should have the option to enable or disable this. \n*   **Stem Shape:**  I'd like to have two stem shape options - straight or curved. If curved, the stem should have a rounded, almost vase like profile.\n\n**Screw Hole:**\n\n*   **Screw Depth:** I need to specify how far the screw should extend into the back of the stem in millimeters. I need a range from 3mm to 15mm.\n*   **Screw Diameter:** I need to specify the diameter of the screw thread in millimeters, it will be used to define the diameter of the hole.\n\n**Ornament:**\n\n*   **Ornament Style:** I want to be able to choose an ornament type at the top of the stem. It should include the options: None, Ball, Mushroom, UFO, Blimp, Half Blimp, Square, Triangle, Rectangle, Circle, and Hexagon.\n*   **Ornament Size:** I need to specify how large the ornament is in millimeters, which will determine the radius or size of the different ornament styles. It should have a range of 5mm to 50mm.\n*    **Indent Effect:** I need a way to specify an indent effect on the ornament and/or stem. Options should include None, Bump (a small raised bump), and Reverse (a recessed indent).\n\n**OpenSCAD details:**\n\n*   I would like this to be a fully parametric OpenSCAD file so that I can adjust all of these parameters directly within the Customizer.\n*   I do not need any external libraries.\n*   I need the code to work with OpenSCAD version 2021.01 or higher.\n\nCan you provide the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a cable binder/zip tie cut-assistant",
    "scad": "innerradius = 5;\nwallthickness = 2;\nradius = innerradius+wallthickness;\nheight = 7;\ncable_binder_width_plus_margin = 5;\ncable_binder_height_plus_margin = 2;\ncable_binder_position_in_percent = 50;\nopen_top = \"yes\";\nopening_angle = 90;\nmodule slice(r = 10, deg = 30) {\n\tdegn = (deg % 360 > 0) ? deg % 360 : deg % 360 + 360;\n\tdifference() {\n\t\tcircle(r);\n\t\tif (degn > 180)\n\t\t\tintersection_for(a = [0, 180 - degn])\n\t\t\t\trotate(a)\n\t\t\t\t\ttranslate([-r, 0, 0])\n\t\t\t\t\t\tsquare(r * 2);\n\t\telse\n\t\t\tunion()\n\t\t\t\tfor(a = [0, 180 - degn])\n\t\t\t\t\trotate(a)\n\t\t\t\t\t\ttranslate([-r, 0, 0])\n\t\t\t\t\t\t\tsquare(r * 2);\n\t}\n}\ndifference(){\n\tcylinder(h = height, r = radius, center = true);\n\tcylinder(h = height+2, r = innerradius, center = true);\n\ttranslate([0,-radius,0])\n\t\ttranslate([0,(radius*2)*cable_binder_position_in_percent/100, 0])\n\t\t\tcube(size = [radius*2, cable_binder_height_plus_margin, cable_binder_width_plus_margin], center = true);\nif (open_top == \"yes\"){\n\trotate(90 + opening_angle/2)\n\tlinear_extrude(height = height+2, center = true)\n\t\tslice(radius*2, opening_angle);\n}\n}",
    "description": "Okay, I'm looking to create a little tool to help with cutting cable ties. I've got an initial design in mind, but I'd like to make it more flexible using parameters and ensure it works as intended.\n\nThe basic idea is a cylindrical body with a slot through it, a bit like a clamp. The cable tie would be threaded through the slot before being used, and after its been tightened, youd be able to cut it by slipping a blade into the slot.\n\nHere are the key elements and parameters I have in mind:\n\n*   **Cylinder Body:**\n    *   `innerradius`: The radius of the hole through the cylinder. This needs to be adjustable for different size cable ties.\n    *   `wallthickness`: The thickness of the cylinder wall.\n    *   `height`: The height of the cylinder.\n\n*   **Cable Tie Slot:**\n    *   `cable_binder_width_plus_margin`: The width of the slot, allowing some space for the cable tie.\n    *   `cable_binder_height_plus_margin`: The height of the slot.\n    *   `cable_binder_position_in_percent`:  The vertical position of the slot as a percentage of the total cylinder radius. This is to allow different placements.\n\n*   **Top Opening (for Inserting the blade):**\n    *   `open_top`: A toggle (\"yes\" or \"no\") to enable or disable the top opening.\n    *  `opening_angle`: The angle of the opening if it exists.\n\nMy current implementation uses the `slice` module adapted from code I found online (from http://rocklinux.net/pipermail/openscad/2012-August/003170.html) - that code should be included in the file.\n\nI'd like a parametric OpenSCAD file that allows me to tweak all of these parameters easily. The current code uses `difference` and `cylinder` and `cube` and `linear_extrude`, which is great. I also need the `slice` function in the code.\n\nI'm not using any specific libraries, but please use a well-formatted and commented code.\n\nCan you help me with this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizer-able Containers",
    "scad": "potShape = 0;\nnumberSides = 4;\ndrawReceptacle(potShape,numberSides);\nmodule hSphere(r=1,t=0.1,ns,rot) {\n\tdifference() {\n\t\tsphere(r);\n\t\tsphere(r-t);\n\t}\n}\nrotationList=[0,0,0,60,0,-36,60,180/7,0,-20,36,180/11,0,-180/13,180/7,12,0,0,0,0,0,0];\nmodule drawReceptacle(number,sides) {\n\tns=(sides<3)?100:sides;\n\trotby=(ns>20)?0:rotationList[ns];\n\t\tif (number==1) { receptacle3(ns,rotby);\n\t} else if (number==2) { receptacle1(ns,rotby);\n\t} else if (number==3) { receptacle2(ns,rotby);\n\t} else if (number==4) { receptacle5(ns,rotby);\n\t} else if (number==5) { receptacle6(ns,rotby);\n\t} else if (number==6) { receptacle7(ns,rotby);\n\t} else if (number==7) { receptacle4(ns,rotby);\n\t} else if (number==8) { receptacle8(ns,rotby);\n\t} else if (number==9) { receptacle9(ns,rotby);\n\t} else if (number==10) { receptacle10(ns,rotby);\n\t} else if (number==11) { receptacle11(ns,rotby);\n\t} else if (number==12) { receptacle14(ns,rotby);\n\t} else if (number==13) { receptacle12(ns,rotby);\n\t} else if (number==14) { receptacle13(ns,rotby);\n\t} else {\n\t\t receptacle0(ns,rotby);\n\t}\n}\ndiameter=50;\nheight=100;\nquality=120;\n$fn=quality;\nnumbsides=100; rotation=0;\nmodule hSphere(r=1,t=0.1,ns,rot) {\n\tdifference() {\n\t\tsphere(r);\n\t\tsphere(r-t);\n\t}\n}\nmodule hTorus(r=1,t=0.1,ns,rot) {\n\tscale([1,1,2])difference() {\n\t\trotate([0,0,rot]) rotate_extrude(convexity=15,$fn=ns) translate([r*2/3, 0, 0]) circle(r/3,$fn=quality);\n\t\trotate([0,0,rot]) scale([1,1,1.2])rotate_extrude(convexity=15,$fn=ns) translate([r*2/3, 0, 0]) circle(r/3-t,$fn=quality);\n\t}\n}\nmodule nTorus(r=1,t=0.1,ns,rot) {\n\tscale([1,1,2])difference() {\n\t\trotate([0,0,rot]) rotate_extrude(convexity=15,$fn=ns) translate([r*2/3, 0, 0]) circle(r/3,$fn=quality);\n\t\trotate([0,0,rot]) scale([1,1,1.1])rotate_extrude(convexity=15,$fn=ns) translate([r*2/3, 0, 0]) circle(r/3-t,$fn=quality);\n\t}\n}\nmodule receptacle0(ns,rot) {\n\tintersection() { translate([0,0,0.5])cube(1,center=true);\n\t\tscale([1/122,1/122,1/112])translate([0,0,-2.64])difference() {\n\t\t\tscale([1,1,2]) translate([0,0,((30+6)*2*0.813)/2]) union() {\n\t\t\t\tdifference() {\n\t\t\t\t\trotate([0,0,rot]) { rotate_extrude(convexity = 10,$fn=ns) translate([31, 0, 0]) circle(30,$fn=quality);  }\n\t\t\t\t\trotate([0,0,rot]) { scale([1,1,1.08]) rotate_extrude(convexity = 10,$fn=ns) translate([31, 0, 0]) circle(24,$fn=quality); }\n\t\t\t\t\tcylinder(31*2.5,31*1.35,31*1.35,center=true,$fn=ns);\n\t\t\t\t}\n\t\t\t\ttranslate([0,0,22.95])cylinder(5,31*1.352,31*1.352,$fn=ns);\n\t\t\t\ttranslate([0,0,0-27.95])cylinder(4.9,31*1.352,31*1.352,$fn=ns);\n\t\t\t}\n\t\t\ttranslate([0,0,108])cylinder(9.1,42,36,center=true,$fn=ns);\n\t\t\ttranslate([0,0,112])cylinder(9,38,41,center=true,$fn=ns);\n\t\t}\n\t}\n}\nmodule receptacle1(ns,rot) {\n\tintersection() { translate([0,0,0.5])cube(1,center=true);\n\t\tscale([1/2,1/2,1/2])translate([0,0,0.5]) union() {\n\t\t\tdifference() {\n\t\t\t\thTorus(1,0.1,ns,rot);\n\t\t\t\tcylinder(1.8,0.83,0.83,center=true,$fn=ns);\n\t\t\t}\n\t\t\tscale([1.67,1.67,1]) translate([0,0,-0.5275]) cylinder(0.1,0.498,0.498,center=true,$fn=ns);\n\t\t\tdifference() {\n\t\t\t\tunion() {\n\t\t\t\t\tscale([1.67,1.67,1]) translate([0,0,0.96])  {\n\t\t\t\t\t\tintersection() {\n\t\t\t\t\t\t\thTorus(1,0.1,ns,rot);\n\t\t\t\t\t\t\tcylinder(1.5,0.5,0.5,center=true,$fn=ns);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trotate([0,0,rot]) translate([0,0,1.442])rotate_extrude(convexity = 10,$fn=ns) translate([0.83, 0, 0]) scale([0.4,1,1])circle(0.1,$fn=quality);\n\t\t\t\t}\n\t\t\t\tunion() {\n\t\t\t\t\ttranslate([0,0,0.6])cylinder(0.5,0.85,0.61,center=true,$fn=ns);\n\t\t\t\t\ttranslate([0,0,0.05])cylinder(0.6,0.85,0.85,center=true,$fn=ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule receptacle2(ns,rot) {\n\tintersection() { translate([0,0,0.5])cube(1,center=true);\n\t\tscale([1/2,1/2,1/3])translate([0,0,0.5]) union() {\n\t\t\tdifference() {\n\t\t\t\thTorus(1,0.1,ns,rot);\n\t\t\t\tcylinder(1.8,0.83,0.83,center=true,$fn=ns);\n\t\t\t}\n\t\t\tscale([1.67,1.67,1]) translate([0,0,-0.5275]) cylinder(0.1,0.498,0.498,center=true,$fn=ns);\n\t\t\tdifference() {\n\t\t\t\tscale([1,1,2]) union() {\n\t\t\t\t\tscale([1.67,1.67,1]) translate([0,0,0.96+((2-1)*-0.29)])  {\n\t\t\t\t\t\tintersection() {\n\t\t\t\t\t\t\thTorus(1,0.1,ns,rot);\n\t\t\t\t\t\t\tcylinder(1.5,0.5,0.5,center=true,$fn=ns);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trotate([0,0,rot]) translate([0,0,1.442+((2-1)*-0.29)])rotate_extrude(convexity = 10,$fn=ns) translate([0.83, 0, 0]) scale([0.4,1,1])circle(0.1,$fn=quality);\n\t\t\t\t}\n\t\t\t\tunion() {\n\t\t\t\t\ttranslate([0,0,0.6])cylinder(0.5,0.85,0.61,center=true,$fn=ns);\n\t\t\t\t\ttranslate([0,0,0.05])cylinder(0.6,0.85,0.85,center=true,$fn=ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule receptacle3(ns,rot) {\n\tintersection() { translate([0,0,0.5])cube(1,center=true);\n\t\tscale([1/2,1/2,1/1.75])translate([0,0,0.5]) union() {\n\t\t\tdifference() {\n\t\t\t\thTorus(1,0.1,ns,rot);\n\t\t\t\tcylinder(1.8,0.83,0.83,center=true,$fn=ns);\n\t\t\t}\n\t\t\tscale([1.67,1.67,1]) translate([0,0,-0.5275]) cylinder(0.1,0.498,0.498,center=true,$fn=ns);\n\t\t\tdifference() {\n\t\t\t\tscale([1,1,0.7]) union() {\n\t\t\t\t\tscale([1.67,1.67,1]) translate([0,0,1.215])  {\n\t\t\t\t\t\tintersection() {\n\t\t\t\t\t\t\thTorus(1,0.1,ns,rot);\n\t\t\t\t\t\t\tcylinder(1.5,0.5,0.5,center=true,$fn=ns);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trotate([0,0,rot]) translate([0,0,1.697])rotate_extrude(convexity = 10,$fn=ns) translate([0.83, 0, 0]) scale([0.4,1,1])circle(0.1,$fn=quality);\n\t\t\t\t}\n\t\t\t\tunion() {\n\t\t\t\t\ttranslate([0,0,0.6])cylinder(0.5,0.85,0.61,center=true,$fn=ns);\n\t\t\t\t\ttranslate([0,0,0.05])cylinder(0.6,0.85,0.85,center=true,$fn=ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule receptacle4(ns,rot) {\n\tintersection() {\n\t\tscale([0.5,0.5,0.47])translate([0,0,0.57]) union() {\n\t\t\tdifference() {\n\t\t\t\thTorus(1,0.1,ns,rot);\n\t\t\t\ttranslate([0,0,-1.38])cylinder(1.8,0.83,0.83,center=true,$fn=ns);\n\t\t\t\tcylinder(1.8,0.65,0.65,center=true,$fn=ns);\n\t\t\t\ttranslate([0,0,0.5])cylinder(1,1.1,1.1,center=true,$fn=ns);\n\t\t\t}\n\t\t\tscale([1.67,1.67,1]) translate([0,0,-0.5275]) cylinder(0.1,0.498,0.498,center=true,$fn=ns);\n\t\t\ttranslate([0,0,0.75])difference() {\n\t\t\t\tcylinder(1.5,1,1,center=true,$fn=ns);\n\t\t\t\tcylinder(2,0.9,0.9,center=true,$fn=ns);\n\t\t\t}\n\t\t\trotate([0,0,rot]) translate([0,0,1.5])rotate_extrude(convexity = 10,$fn=ns) translate([0.95, 0, 0]) circle(0.05,$fn=quality);\n\t\t}\n\t\ttranslate([0,0,0.5]) cube(1,center=true);\n\t}\n}\nmodule receptacle5(ns,rot) {\n\tintersection() {\n\t\tscale([0.39,0.39,0.445])translate([0,0,0.5752]) union() {\n\t\t\tdifference() {\n\t\t\t\thTorus(1,0.1,ns,rot);\n\t\t\t\ttranslate([0,0,-1.38])cylinder(1.8,0.83,0.83,center=true,$fn=ns);\n\t\t\t\tcylinder(1.8,0.65,0.65,center=true,$fn=ns);\n\t\t\t\ttranslate([0,0,0.5])cylinder(1,1.1,1.1,center=true,$fn=ns);\n\t\t\t}\n\t\t\tscale([1.67,1.67,1]) translate([0,0,-0.5275]) cylinder(0.1,0.498,0.498,center=true,$fn=ns);\n\t\t\ttranslate([0,0,0.5])difference() {\n\t\t\t\tcylinder(1,1,1,center=true,$fn=ns);\n\t\t\t\tcylinder(2,0.9,0.9,center=true,$fn=ns);\n\t\t\t}\n\t\t\trotate([0,0,rot]) translate([0,0,1.61])rotate_extrude(convexity = 10,$fn=ns) translate([1.24, 0, 0]) scale([1,3,1])circle(0.025,$fn=quality);\n\t\t\tscale([2.515,2.515,2])translate([0,0,0.25]) intersection() {\n\t\t\t\t\tnTorus(1,0.041,ns,rot);\n\t\t\t\t\tcylinder(1.5,0.5,0.5,center=true,$fn=ns);\n\t\t\t\t\ttranslate([0,0,0.5])cylinder(0.5,1,1,center=true,$fn=ns);\n\t\t\t\t}\n\t\t}\n\t\ttranslate([0,0,0.5]) cube(1,center=true);\n\t}\n}\nmodule receptacle6(ns,rot) {\n\tintersection() {\n\t\tscale([0.39,0.39,0.57])translate([0,0,0.5752]) union() {\n\t\t\tdifference() {\n\t\t\t\thTorus(1,0.1,ns,rot);\n\t\t\t\ttranslate([0,0,-1.38])cylinder(1.8,0.83,0.83,center=true,$fn=ns);\n\t\t\t\tcylinder(1.8,0.65,0.65,center=true,$fn=ns);\n\t\t\t\ttranslate([0,0,0.5])cylinder(1,1.1,1.1,center=true,$fn=ns);\n\t\t\t}\n\t\t\tscale([1.67,1.67,1]) translate([0,0,-0.5275]) cylinder(0.1,0.498,0.498,center=true,$fn=ns);\n\t\t\ttranslate([0,0,0.25])difference() {\n\t\t\t\tcylinder(0.5,1,1,center=true,$fn=ns);\n\t\t\t\tcylinder(2,0.9,0.9,center=true,$fn=ns);\n\t\t\t}\n\t\t\trotate([0,0,rot]) translate([0,0,1.11])rotate_extrude(convexity = 10,$fn=ns) translate([1.24, 0, 0]) scale([1,3,1])circle(0.025,$fn=quality);\n\t\t\tscale([2.515,2.515,2])translate([0,0,0]) intersection() {\n\t\t\t\t\tnTorus(1,0.041,ns,rot);\n\t\t\t\t\tcylinder(1.5,0.5,0.5,center=true,$fn=ns);\n\t\t\t\t\ttranslate([0,0,0.5])cylinder(0.5,1,1,center=true,$fn=ns);\n\t\t\t\t}\n\t\t}\n\t\ttranslate([0,0,0.5]) cube(1,center=true);\n\t}\n}\nmodule receptacle7(ns,rot) {\n\tintersection() {\n\t\tscale([0.39,0.39,0.8])translate([0,0,0.5752]) union() {\n\t\t\tdifference() {\n\t\t\t\thTorus(1,0.1,ns,rot);\n\t\t\t\ttranslate([0,0,-1.38])cylinder(1.8,0.83,0.83,center=true,$fn=ns);\n\t\t\t\tcylinder(1.8,0.65,0.65,center=true,$fn=ns);\n\t\t\t\ttranslate([0,0,0.5])cylinder(1,1.1,1.1,center=true,$fn=ns);\n\t\t\t}\n\t\t\tscale([1.67,1.67,1]) translate([0,0,-0.5275]) cylinder(0.1,0.498,0.498,center=true,$fn=ns);\n\t\t\trotate([0,0,rot]) translate([0,0,0.61])rotate_extrude(convexity = 10,$fn=ns) translate([1.24, 0, 0]) scale([1,3,1])circle(0.025,$fn=quality);\n\t\t\tscale([2.515,2.515,2])translate([0,0,-0.25]) intersection() {\n\t\t\t\t\tnTorus(1,0.041,ns,rot);\n\t\t\t\t\tcylinder(1.5,0.5,0.5,center=true,$fn=ns);\n\t\t\t\t\ttranslate([0,0,0.5])cylinder(0.5,1,1,center=true,$fn=ns);\n\t\t\t\t}\n\t\t}\n\t\ttranslate([0,0,0.5]) cube(1,center=true);\n\t}\n}\nmodule receptacle8(ns,rot) {\n\tintersection() {\n\t\tscale([0.5,0.5,0.48])translate([0,0,0.5]) union() {\n\t\t\ttranslate([0,0,0.25])difference() {\n\t\t\t\tcylinder(1.5,1,1,center=true,$fn=ns);\n\t\t\t\tcylinder(2,0.9,0.9,center=true,$fn=ns);\n\t\t\t}\n\t\t\ttranslate([0,0,-0.45]) cylinder(0.1,1,1,center=true,$fn=ns);\n\t\t\ttranslate([0,0,1])rotate([180,0,0])difference() {\n\t\t\t\thTorus(1,0.1,ns,rot);\n\t\t\t\ttranslate([0,0,-1.25])cylinder(1.8,0.83,0.83,center=true,$fn=ns);\n\t\t\t\tcylinder(1.8,0.65,0.65,center=true,$fn=ns);\n\t\t\t\ttranslate([0,0,0.5])cylinder(1,1.1,1.1,center=true,$fn=ns);\n\t\t\t}\n\t\t\trotate([0,0,rot]) translate([0,0,1.493])rotate_extrude(convexity = 10,$fn=ns) translate([0.83, 0, 0]) scale([1,3.5,1])circle(0.025,$fn=quality);\n\t\t}\n\t\ttranslate([0,0,0.5]) cube(1,center=true);\n\t}\n}\nmodule receptacle9(ns,rot) {\n\tintersection() {\n\t\tscale([0.5,0.5,0.48])translate([0,0,0.5]) union() {\n\t\t\ttranslate([0,0,0.25])difference() {\n\t\t\t\tcylinder(2.5,1,1,center=true,$fn=ns);\n\t\t\t\tcylinder(2.6,0.9,0.9,center=true,$fn=ns);\n\t\t\t}\n\t\t\ttranslate([0,0,-0.45]) cylinder(0.1,1,1,center=true,$fn=ns);\n\t\t\trotate([0,0,rot]) translate([0,0,1.5])rotate_extrude(convexity = 10,$fn=ns) translate([0.95, 0, 0]) circle(0.05,$fn=quality);\n\t\t}\n\t\ttranslate([0,0,0.5]) cube(1,center=true);\n\t}\n}\nmodule receptacle10(ns,rot) {\n\tintersection() {\n\t\tscale([0.5,0.5,0.48])translate([0,0,0.5]) union() {\n\t\t\tscale([2,2,2])translate([0,0,0.25]) intersection() {\n\t\t\t\t\tnTorus(1,0.041,ns,rot);\n\t\t\t\t\tcylinder(1.5,0.5,0.5,center=true,$fn=ns);\n\t\t\t\t\ttranslate([0,0,0.5])cylinder(0.5,1,1,center=true,$fn=ns);\n\t\t\t\t}\n\t\t\ttranslate([0,0,0.25])difference() {\n\t\t\t\tcylinder(1.5,0.795,0.795,center=true,$fn=ns);\n\t\t\t\tcylinder(2.1,0.717,0.717,center=true,$fn=ns);\n\t\t\t}\n\t\t\ttranslate([0,0,-0.45]) cylinder(0.1,0.795,0.795,center=true,$fn=ns);\n\t\t}\n\t\ttranslate([0,0,0.5]) cube(1,center=true);\n\t}\n}\nmodule receptacle11(ns,rot) {\n\tintersection() {\n\t\tscale([0.5,0.5,0.48])translate([0,0,0.5]) union() {\n\t\t\tscale([2,2,2])translate([0,0,0.25]) intersection() {\n\t\t\t\t\tnTorus(1,0.041,ns,rot);\n\t\t\t\t\tcylinder(1.5,0.5,0.5,center=true,$fn=ns);\n\t\t\t\t\ttranslate([0,0,-0.5])cylinder(0.5,1,1,center=true,$fn=ns);\n\t\t\t\t}\n\t\t\ttranslate([0,0,0.75])difference() {\n\t\t\t\tcylinder(1.5,0.795,0.795,center=true,$fn=ns);\n\t\t\t\tcylinder(2.1,0.717,0.717,center=true,$fn=ns);\n\t\t\t}\n\t\t\ttranslate([0,0,-0.45]) cylinder(0.1,0.95,0.9,center=true,$fn=ns);\n\t\t\trotate([0,0,rot]) translate([0,0,1.5])rotate_extrude(convexity = 10,$fn=ns) translate([0.76, 0, 0]) circle(0.035,$fn=quality);\n\t\t}\n\t\ttranslate([0,0,0.5]) cube(1,center=true);\n\t}\n}\nmodule receptacle12(ns,rot) {\n\tintersection() {\n\t\tscale([0.5,0.5,0.48])translate([0,0,0.5]) union() {\n\t\t\ttranslate([0,0,0.25])difference() {\n\t\t\t\tcylinder(2.5,0.5,1,center=true,$fn=ns);\n\t\t\t\tcylinder(2.6,0.4,0.9,center=true,$fn=ns);\n\t\t\t}\n\t\t\ttranslate([0,0,-0.45]) cylinder(0.1,0.55,0.55,center=true,$fn=ns);\n\t\t\trotate([0,0,rot]) translate([0,0,1.5])rotate_extrude(convexity = 10,$fn=ns) translate([0.947, 0, 0]) circle(0.052,$fn=quality);\n\t\t}\n\t\ttranslate([0,0,0.5]) cube(1,center=true);\n\t}\n}\nmodule receptacle13(ns,rot) {\n\tintersection() {\n\t\tscale([0.5,0.5,0.48])translate([0,0,0.5]) union() {\n\t\t\ttranslate([0,0,0.25])difference() {\n\t\t\t\tcylinder(2.5,1,0.6,center=true,$fn=ns);\n\t\t\t\tcylinder(2.6,0.9,0.5,center=true,$fn=ns);\n\t\t\t}\n\t\t\ttranslate([0,0,-0.45]) cylinder(0.1,0.9,0.9,center=true,$fn=ns);\n\t\t\trotate([0,0,rot]) translate([0,0,1.5])rotate_extrude(convexity = 10,$fn=ns) translate([0.554, 0, 0]) circle(0.045,$fn=quality);\n\t\t}\n\t\ttranslate([0,0,0.5]) cube(1,center=true);\n\t}\n}\nmodule receptacle14(ns,rot) {\n\tintersection() {\n\t\tscale([0.5,0.5,0.48])translate([0,0,0.5]) union() {\n\t\t\tscale([2,2,2])translate([0,0,0.25]) intersection() {\n\t\t\t\t\tnTorus(1,0.041,ns,rot);\n\t\t\t\t\tcylinder(1.5,0.5,0.5,center=true,$fn=ns);\n\t\t\t\t\ttranslate([0,0,0.5])cylinder(0.5,1,1,center=true,$fn=ns);\n\t\t\t\t}\n\t\t\ttranslate([0,0,0.5])difference() {\n\t\t\t\tcylinder(1,0.795,0.795,center=true,$fn=ns);\n\t\t\t\tcylinder(2.1,0.717,0.717,center=true,$fn=ns);\n\t\t\t}\n\t\t\tscale([2,2,2])translate([0,0,0.25]) intersection() {\n\t\t\t\t\tnTorus(1,0.041,ns,rot);\n\t\t\t\t\tcylinder(1.5,0.5,0.5,center=true,$fn=ns);\n\t\t\t\t\ttranslate([0,0,-0.5])cylinder(0.5,1,1,center=true,$fn=ns);\n\t\t\t\t}\n\t\t\ttranslate([0,0,-0.45]) cylinder(0.1,0.95,0.9,center=true,$fn=ns);\n\t\t}\n\t\ttranslate([0,0,0.5]) cube(1,center=true);\n\t}\n}",
    "description": "Okay, I'm trying to get this old OpenSCAD script working better and I think I need to redesign it from the ground up to be more parametric.\n\nEssentially, the script creates a variety of different pot-like receptacles, and the user selects which one they want and how many sides it has. Currently, I'm using a dropdown list for the pot shape, an integer slider for the number of sides, and a hardcoded list of rotation values. I'd like to have the shapes be more easily customized and the sides more configurable.\n\nHere's a breakdown of what I'm hoping to achieve:\n\n**Overall Goal:** Create a parametric OpenSCAD module for generating different receptacle shapes.\n\n**Key Parameters:**\n\n*   **`potShape`:**  Instead of a dropdown list from 0-14, I'd like to abstract the shape generation. I want to be able to choose parameters like how tall the main body is, the diameter, and curves. So, instead of selecting a pre-built shape, the user configures it. Maybe this could start with a basic shape like a cylinder or a torus, and then offer modifications from there. We can worry about things like tori or special shapes in the next iteration, I think, if we focus on the simple ones first.\n*   **`numberSides`:** An integer slider for controlling the number of sides of the receptacle. 0 should give a cylindrical shape, values greater than 2 should generate a polygonal shape.\n*    **`height`**: A parameter to control how tall the receptacle is.\n*  **`outerDiameter`**: A parameter to control how wide the base is.\n*  **`wallThickness`**: A parameter to control how thick the walls are.\n* **`baseThickness`**: A parameter to control how thick the base is.\n*  **`lipHeight`**: A parameter to control the height of the lip or rim (if any). \n*   **`lipThickness`**: A parameter to control how thick the lip or rim (if any) is.\n\n**Specific Features:**\n\n*   **Base Shape:** Start with simple shapes:\n    *   Cylinder (for `numberSides = 0`)\n    *   Prism with `numberSides` sides (for `numberSides` > 2)\n*   **Wall Extrusion:** Be able to control the wall thickness and height.\n*   **Lip/Rim Option:** Include parameters for adding a lip or rim at the top, with configurable height and thickness. This can just be a very simple extrusion for now.\n*   **Rotation:** The rotation of the object about its Z axis is currently determined by the number of sides, but I want to decouple this and make it a configurable parameter using a slider or integer field. This rotation will now be an independent parameter called `zRotation`.\n*   **Quality/Resolution:** I still need to set the `$fn` for the resolution, so I should be able to set a `quality` value with a slider.\n*   **Units:** Assume units are in millimeters.\n* **Simplified Code:** I'd like to start with a more easily read and understood piece of code.\n\n**User Interface:**\n\nI envision the following user interface, and I want the code to generate that interface when run in Customizer:\n\n*   A slider or an integer field for `numberSides`.\n*   A slider for `height`.\n*   A slider for `outerDiameter`.\n*   A slider for `wallThickness`.\n*  A slider for `baseThickness`.\n*   A slider for `lipHeight`.\n*   A slider for `lipThickness`.\n*   A slider or integer field for `zRotation`.\n*   A slider for `quality`\n\n**Libraries:**\n\nI do not want to use any third-party libraries for this at this time, just vanilla OpenSCAD primitives.\n\nEssentially, I'm trying to rebuild my old script to be more flexible, understandable, and user-friendly. Can you help me create an OpenSCAD file that does that?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Toy Car with Captured Wheels",
    "scad": "00_build_plate = 0;\n01_length = 60;\n02_width_factor = 50;\n03_wheel_size = 100;\n04_max_number_of_wheels = 8;\n05_wheel_facets = 24;\n06_tire_width_factor = 0;\n07_axel_radius_factor = 0;\n08_tread_density = 0;\n09_tread_depth_factor = 100;\n10_tread_size_factor = 50;\n11_wheel_well_coverage_factor = 50;\n12_platform_thickness = 0;\nlength = 01_length/1;\nwidth_factor = 02_width_factor/1;\nwheel_size = 03_wheel_size/1;\ntire_width_factor = 06_tire_width_factor/1;\nwheel_resolution = 05_wheel_facets/1;\naxel_radius_factor = 07_axel_radius_factor/1;\nplatform_thickness = 12_platform_thickness/1;\ntread_amount = 08_tread_density/1;\ntread_depth_factor = 09_tread_depth_factor/1;\ntread_size_factor = 10_tread_size_factor/1;\nwell_coverage_percent = 11_wheel_well_coverage_factor/1;\nmax_number_of_wheels = 04_max_number_of_wheels/1;\nwidth = length*(.5+(width_factor/200));\nwell_thickness = .8/1;\nwell_tolerance = .6/1;\nwheel_separation = 1/1;\nwheel_width = width/8*(.5+(tire_width_factor/200));\nmax_wheel_radius = 6 + (((length-30)/170)*34);\nmin_wheel_radius = 4 + (((length-30)/170)*12);\nwheel_radius = min_wheel_radius + (wheel_size/100*(max_wheel_radius-min_wheel_radius));\ninner_wheel_width = wheel_width*.8;\nheight = 10/1;\ntread_number = wheel_resolution*(1+(tread_amount/100));\ntread_depth = wheel_radius/10*(tread_depth_factor/100);\ntread_peak_width = wheel_radius*2*PI/wheel_resolution*(tread_size_factor/100);\ntread_valley_width = 0.1/1;\naxel_radius = wheel_radius*(.25+axel_radius_factor/500);\naxel_width = width/3;\nauto_num_wheels = length/(wheel_radius+wheel_separation)/2;\nwell_coverage = wheel_radius*2*(well_coverage_percent/100);\nfront_wheel_pos_total = length/2 - wheel_radius - well_thickness - well_tolerance;\nfudge = .05/1;\nbuild_plate();\nmain(length,height,width,wheel_width,inner_wheel_width,wheel_radius,axel_width,axel_radius,wheel_resolution,well_coverage,well_thickness,well_tolerance,max_number_of_wheels,auto_num_wheels,front_wheel_pos_total,tread_number,tread_depth,tread_valley_width,tread_peak_width,platform_thickness);\nmodule build_plate(){\n\ttranslate([0,0,-.5]){\n\t\tif(00_build_plate == 0){\n\t\t\t%cube([285,153,1],center = true);\n\t\t}\n\t\tif(00_build_plate == 1){\n\t\t\t%cube([225,145,1],center = true);\n\t\t}\n\t\tif(00_build_plate == 3){\n\t\t\t%cube([120,120,1],center = true);\n\t\t}\n\t}\n}\nmodule main(l,h,w,ww,iww,wr,aw,ar,res,wellco,wellth,wellto,mnw,anw,fwpt,tn,td,tvw,tpw,pt){\n\tnumber_of_wheels = 0;\n\ttranslate([0,0,width/2])\n\tif(mnw < floor(anw)){\n\t\tassign(number_of_wheels = mnw){\n\t\t\tcar(l,h,w,ww,iww,wr,aw,ar,res,wellco,wellth,wellto,fwpt,number_of_wheels,tn,td,tvw,tpw,pt);\n\t\t}\n\t} else {\n\t\tassign(number_of_wheels = floor(anw)){\n\t\t\tcar(l,h,w,ww,iww,wr,aw,ar,res,wellco,wellth,wellto,fwpt,number_of_wheels,tn,td,tvw,tpw,pt);\n\t\t}\n\t}\n}\nmodule car(l,h,w,ww,iww,wr,aw,ar,res,wellco,wellth,wellto,fwpt,nw,tn,td,tvw,tpw,pt){\n\tdifference(){\n\t\tcar_body(l,h,w,ww,wr,aw,ar,res,wellco,wellth,wellto,fwpt,nw,pt);\n\t\tfor(i = [0:nw-1]){\n\t\t\ttranslate([fwpt-(fwpt*2/(nw-1))*i,-h/2,0])\n\t\t\t\twheel_well(w+.05,ww,iww,wr,aw,ar,res,wellth,wellto);\n\t\t}\n\t}\n\tfor(i = [0:nw-1]){\n\t\ttranslate([fwpt-(fwpt*2/(nw-1))*i,-h/2,0])\n\t\t\twheel(w,ww,iww,wr,aw,ar,res,tn,td,tvw,tpw);\n\t}\n\tcar_top_simple();\n}\nmodule car_top_simple(){\n\tdifference(){\n\t\tunion(){\n\t\t\tdifference(){\n\t\t\t\ttranslate([0,wheel_radius-height/2+platform_thickness+well_thickness+well_tolerance-fudge,0])\n\t\t\t\t\tscale([1,.3,1])\n\t\t\t\t\t\tcylinder(h = width, r = length/2, center = true);\n\t\t\t\ttranslate([0,-length/4+wheel_radius-height/2+platform_thickness+well_thickness+well_tolerance,0])\n\t\t\t\t\tcube([length+fudge,length/2,width+fudge], center = true);\n\t\t\t}\n\t\t\tdifference(){\n\t\t\t\ttranslate([0,wheel_radius-height/2+platform_thickness+well_thickness+well_tolerance,0])\n\t\t\t\t\tscale([.6,.7,1])\n\t\t\t\t\tcylinder(h = width, r = length/2, center = true);\n\t\t\t\ttranslate([0,-length/4+wheel_radius-height/2+well_tolerance+well_thickness+platform_thickness,0])\n\t\t\t\t\tcube([length+fudge,length/2,width+fudge], center = true);\n\t\t\t}\n\t\t}\n\t\tdifference(){\n\t\t\ttranslate([0,wheel_radius-height/2+platform_thickness+well_thickness+well_tolerance,0])\n\t\t\t\tscale([.5,.6,1])\n\t\t\t\tcylinder(h = width+fudge, r = length/2, center = true);\n\t\t\ttranslate([0,-length/8+wheel_radius-height/2+platform_thickness+well_thickness+well_tolerance,0])\n\t\t\t\tcube([length+fudge,length/2,width+fudge*2], center = true);\n\t\t}\n\t}\n}\nmodule car_body(l,h,w,ww,wr,aw,ar,res,wellco,wellth,wellto,fwpt,nw,pt){\n\thull(){\n\t\thull(){\n\t\t\ttranslate([0,wr-h/2+wellth+wellto+pt-(wellth+wellto+pt+wellco)/2,0])\n\t\t\t\tcube([l,wellth+wellto+pt+wellco,w],center = true);\n\t\t\thull(){\n\t\t\t\ttranslate([0,(wr-h/2)/2,0])\n\t\t\t\t\tcube([l,wr-h/2,aw],center = true);\n\t\t\t\tfor(i = [0:1]){\n\t\t\t\t\ttranslate([fwpt-((fwpt*2))*i,-h/2,0])\n\t\t\t\t\t\t\tcylinder(h = aw, r = ar+wellto+wellth, $fn = res, center = true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule wheel_well(w,ww,iww,wr,aw,ar,res,wellth,wellto){\n\tunion(){\n\t\thull(){\n\t\t\ttranslate([0,0,w/2+(ww+2)/2-ww])\n\t\t\t\tcylinder(h = ww+2, r = wr+wellto, $fn = res, center = true);\n\t\t\ttranslate([0,0,w/2-ww-iww+.5])\n\t\t\t\tcylinder(h = 1, r = wr-iww+wellto, $fn = res, center = true);\n\t\t}\n\t\thull(){\n\t\t\ttranslate([0,0,w/2-ww-iww+.5])\n\t\t\t\tcylinder(h = 1, r = wr-iww+wellto, $fn = res, center = true);\n\t\t\ttranslate([0,0,axel_width/2+.5])\n\t\t\t\tcylinder(h = 1, r = ar+wellto, $fn = res, center = true);\n\t\t}\n\t\thull(){\n\t\t\ttranslate([0,0,-(axel_width/2+.5)])\n\t\t\t\tcylinder(h = 1, r = ar+wellto, $fn = res, center = true);\n\t\t\ttranslate([0,0,-(w/2-ww-iww+.5)])\n\t\t\t\tcylinder(h = 1, r = wr-iww+wellto, $fn = res, center = true);\n\t\t}\n\t\thull(){\n\t\t\ttranslate([0,0,-(w/2-ww-iww+.5)])\n\t\t\t\tcylinder(h = 1, r = wr-iww+wellto, $fn = res, center = true);\n\t\t\ttranslate([0,0,-(w/2+(ww+2)/2-ww)])\n\t\t\t\tcylinder(h = ww+2, r = wr+wellto, $fn = res, center = true);\n\t\t}\n\t\tcylinder(h = aw+1, r = ar+wellto, $fn = res, center = true);\n\t}\n}\nmodule wheel(w,ww,iww,wr,aw,ar,res,tn,td,tvw,tpw){\n\tdifference(){\n\t\tunion(){\n\t\t\thull(){\n\t\t\t\ttranslate([0,0,w/2-ww/2])\n\t\t\t\t\tcylinder(h = ww, r = wr, $fn = res, center = true);\n\t\t\t\ttranslate([0,0,w/2-ww-iww+.5])\n\t\t\t\t\tcylinder(h = 1, r = wr-iww, $fn = res, center = true);\n\t\t\t}\n\t\t\thull(){\n\t\t\t\ttranslate([0,0,w/2-ww-iww+.5])\n\t\t\t\t\tcylinder(h = 1, r = wr-iww, $fn = res, center = true);\n\t\t\t\ttranslate([0,0,axel_width/2+.5])\n\t\t\t\t\tcylinder(h = 1, r = ar, $fn = res, center = true);\n\t\t\t}\n\t\t\thull(){\n\t\t\t\ttranslate([0,0,-(axel_width/2+.5)])\n\t\t\t\t\tcylinder(h = 1, r = ar, $fn = res, center = true);\n\t\t\t\ttranslate([0,0,-(w/2-ww-iww+.5)])\n\t\t\t\t\tcylinder(h = 1, r = wr-iww, $fn = res, center = true);\n\t\t\t}\n\t\t\thull(){\n\t\t\t\ttranslate([0,0,-(w/2-ww-iww+.5)])\n\t\t\t\t\tcylinder(h = 1, r = wr-iww, $fn = res, center = true);\n\t\t\t\ttranslate([0,0,-(w/2-ww/2)])\n\t\t\t\t\tcylinder(h = ww, r = wr, $fn = res, center = true);\n\t\t\t}\n\t\t\tcylinder(h = aw, r = ar, $fn = res, center = true);\n\t\t}\n\t\tfor(i = [0:tn-1]){\n\t\trotate([0,0,360/tn*i])\n\t\ttranslate([wr,0,0])\n\t\thull(){\n\t\t\ttranslate([.1/2,0,0])\n\t\t\t\tcube([.1,tpw,w+.05],center = true);\n\t\t\ttranslate([-td+.1/2,0,0])\n\t\t\t\tcube([.1,tvw,w+.05],center = true);\n\t\t}\n\t\t}\n\t}\n}",
    "description": "Okay, I have this OpenSCAD file for a customizable toy car with captured wheels, and it's pretty neat, but I'd like to see if we can make it a bit more robust and user-friendly. It currently uses a bunch of sliders to control the design, but I think we could organize it better and add some more sophisticated options.\n\nHere's what I'm looking for:\n\n**Core Functionality:**\n\nThe core functionality of the car should remain the same: a central body with wheels that are captured inside wheel wells. The user should be able to customize:\n\n*   **Overall Length:** This should be a primary input.\n*   **Overall Width (Relative):** Instead of a direct width control, I'd like a factor that scales the car's width relative to its length (like the current `width_factor` but maybe better named). I want the car to maintain a proportional feel.\n*  **Wheel Size:** A slider or input to adjust the diameter of the wheels.\n*   **Number of Wheels:** Allow the user to specify a max number of wheels, and have the design calculate a default based on the length and wheel size.\n*   **Wheel Shape:** Currently the wheels have a fixed number of sides, but I'd like to use $fn for the wheel resolution and allow a slider to control this.\n*   **Tire Width:** A factor to make the tire wider or narrower relative to the wheel width.\n*   **Axle Radius:** A factor to determine the axle radius relative to the wheel radius.\n*   **Tire Treads:** Instead of simple cut-outs, I want more control:\n    *   **Tread Density:** Controls how many treads there are on a single tire.\n    *  **Tread Depth:** How deep each tread is cut into the tire.\n     *  **Tread Width:** How wide the \"peaks\" of the tread are, and how wide the valleys are.\n*   **Wheel Well Coverage:** A percentage representing how much the wheel well encloses the wheel.\n*  **Platform Thickness:** To add a base to the car.\n*  **Build Plate Display:** a toggle to show the outline of various printer build plates.\n\n**Improvements and Requests:**\n\n*   **Clearer Parameter Names:** The existing file has numbered variables (e.g., `01_length`). I'd prefer descriptive names (e.g., `car_length`, `wheel_diameter`).\n*   **Units in Comments:** Please add units to all variable comments (e.g., `// car length in mm`).\n*  **Automatic Spacing of wheels:** The wheels should be evenly spaced automatically along the body and placed with respect to the wheel diameter, and a minimum spacing, as well as the car length.\n*   **Error Handling/Clamping:** Implement basic checks to prevent impossible values. For example, the wheel radius shouldn't exceed the car's length, etc.\n*  **Default values:** Set reasonable defaults for all parameters so the car is still printable if the user doesn't change values.\n*   **Modularity:** Break the design into more logical modules.\n*   **Use $fn for curves:** I'd like to consistently use `$fn` where possible to control the resolution of curves. This makes it easier for the user to quickly change the fineness.\n\n**Libraries:**\n\nI'm not using any particular external libraries, but if it makes sense to, feel free to include functionality from a library like BOSL. Please don't assume any attached library files.\n\n**Output:**\n\nI'd like the final OpenSCAD file to be parametric and easy for a user to understand and modify. I also plan to use this as a learning tool, so it should be easy to read.\n\nI think these changes would greatly improve the flexibility and usability of the toy car design. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Box with rounded corners, customizable",
    "scad": "type=\"box\";\nheight=70;\nwidth=70;\ndepth=70;\nroundness=15;\n$fa=5;\nthickness=5;\nwiggle_room=1;\nflange_height=2;\ninner_radius=roundness-thickness;\nif(type==\"lid\"){\ntranslate([-width/2+roundness,-depth/2+roundness,0]){\ndifference(){\n\ttranslate([0,0,roundness]){\n\tminkowski(){\n\t\tcube([width-2*roundness,depth-2*roundness,70-2*roundness]);\n\t\tsphere(roundness);}\n}\ntranslate([-roundness-1,-roundness-1,roundness])\ncube([width+2,depth+2,roundness+70+1]);}\ntranslate([wiggle_room/2,wiggle_room/2,roundness]){\n\tlinear_extrude(height=flange_height){\n\t\tminkowski(){\n\t\tsquare([width-2*(inner_radius+thickness)-wiggle_room,depth-2*(inner_radius+thickness)-wiggle_room]);\n\tcircle(inner_radius);}\n}}}}\nif (type==\"box\"){\nif (inner_radius>0){\ntranslate([-width/2+roundness,-depth/2+roundness,0]){\ndifference(){\n\ttranslate([0,0,roundness]){\n\tdifference(){\n\tminkowski(){\n\t\tcube([width-2*roundness,depth-2*roundness,height-2*roundness]);\n\t\tsphere(roundness);}\n\tminkowski(){\n\t\tcube([width-2*(inner_radius+thickness),depth-2*(inner_radius+thickness),height-2*(thickness)]);\n\t\tsphere(inner_radius);}\n}}\ntranslate([-roundness,-roundness,height-roundness])\ncube([width,depth,roundness+1]);}}}}",
    "description": "Okay, I'm looking to create a customizable box with a lid, and I'd like the design to be parametric in OpenSCAD. I've been playing around with a file I found online, but it's not quite as flexible as I need it to be. I want to be able to control the following aspects:\n\n*   **Box/Lid Type:** The design should be able to generate either just the box *or* just the lid. I'd like to be able to toggle between these two options with a simple variable.\n*   **Outer Dimensions:** I need to specify the overall height, width, and depth of the box (and lid) from the outside.\n*   **Corner Roundness:** The corners of the box and lid should be rounded, and I need to control how round they are. This should be a radius value.\n*   **Roundness Smoothness:** I'd like to control the smoothness of the rounded corners. This is essentially the `$fa` value in OpenSCAD; I'd want to set it to a lower value for very smooth and higher value for less smooth.\n*   **Wall Thickness:** The thickness of the box walls should be controllable.\n*   **Lid Fit (Wiggle Room):** For the lid, I need a variable to control how much space is between the lid inset and the inside of the box - the wiggle room essentially,\n*   **Lid Inset Depth:** I need to be able to set how deep the lid inset is into the box.\n\nThe overall idea is to create a box and lid that fit together. I don't need any specific hinges or clasps on the lid for now.\n\nI'm not attached to any specific library, but it would be great if the solution used standard OpenSCAD or any widely used libraries. I'd also like the code to be relatively well-commented so it's easy for me to modify later on.\n\nHere's a summary:\n\n**Features:**\n\n*   Parametric box or lid generator\n*   Control over outer dimensions (height, width, depth)\n*   Control over corner roundness\n*   Control over roundness smoothness ($fa)\n*   Control over wall thickness\n*   Control over lid fit (wiggle room)\n*   Control over lid inset depth\n\nCan you generate an OpenSCAD file that does all this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Water Tap Fountain",
    "scad": "Fountain_Diameter = 10;\nTube_Diameter = 30;\nFountain_Size = 40;\nTube_Size = 30;\nWall = 4;\ndifference() {\nunion() { cylinder(Tube_Size,(Tube_Diameter/2)+Wall,(Tube_Diameter/2)+Wall); rotate([45,0,0]) cylinder(Fountain_Size,(Fountain_Diameter/2)+Wall,(Fountain_Diameter/2)+Wall);}\nunion() {  translate([0,0,-WheightTube/2])cylinder(Tube_Size*2,Tube_Diameter/2,Tube_Diameter/2); rotate([45,0,0]) cylinder(Fountain_Size+(Tube_Size/2),Fountain_Diameter/2,Fountain_Diameter/2);}\ntranslate([-Tube_Size,-Tube_Size,-(Tube_Size*2)]) cube([Tube_Size*2,Tube_Size*2,Tube_Size*2]);\n}",
    "description": "Okay, so I'm trying to design a little attachment for my faucet that turns it into a drinking fountain. I've got this starting point in OpenSCAD, but it's pretty rough and I think it could be way better.\n\nHere's the basic idea, and the existing code:\n\nThe goal is to create something that fits onto a standard faucet and directs the water upwards, so you can drink directly from the stream. I want it to be printable, so it shouldn't have any crazy overhangs. I'm envisioning two main parts: a base that attaches to the faucet, and a ramp/tube that directs the water.\n\nHere's the code I have so far, but it could use a serious upgrade!\n\n```openscad\n /* ----------------------------------------------------------------------------\n\tPublic Variables\n---------------------------------------------------------------------------- */\n//Less is more powerful:\nFountain_Diameter = 10; // [5:60]\n\n//Your tap diameter:\nTube_Diameter = 30; // [5:60]\n\n// Want elegance?\nFountain_Size = 40;\t // [30:100]\n\n//It's a pure design opinion:\nTube_Size = 30; // [20:70]\n\n//More, it'll be easier to print:\nWall = 4;//\t// [1:10]\n\n/* ----------------------------------------------------------------------------\n\tPiece Creation\n---------------------------------------------------------------------------- */\ndifference() {\nunion() { cylinder(Tube_Size,(Tube_Diameter/2)+Wall,(Tube_Diameter/2)+Wall); rotate([45,0,0]) cylinder(Fountain_Size,(Fountain_Diameter/2)+Wall,(Fountain_Diameter/2)+Wall);}\nunion() {  translate([0,0,-WheightTube/2])cylinder(Tube_Size*2,Tube_Diameter/2,Tube_Diameter/2); rotate([45,0,0]) cylinder(Fountain_Size+(Tube_Size/2),Fountain_Diameter/2,Fountain_Diameter/2);}\ntranslate([-Tube_Size,-Tube_Size,-(Tube_Size*2)]) cube([Tube_Size*2,Tube_Size*2,Tube_Size*2]);\n}\n```\n\n**Key features I'm looking for:**\n\n*   **Parametric Design:** It needs to be fully parametric. I want to be able to adjust things like the diameter of the faucet attachment (`Tube_Diameter`), the diameter of the water stream at the top (`Fountain_Diameter`), the length of the faucet tube (`Tube_Size`), the length of the fountain ramp (`Fountain_Size`), and the wall thickness (`Wall`). I've got some of those as parameters already, but it could be done better.\n*   **Smooth Transition:** The transition between the faucet tube and the ramp should be smooth, not just a sharp angle. Think a nice curve, maybe part of a torus or a spline.\n*   **Secure Faucet Fit:** I need a way to make sure it stays attached to the faucet.  Maybe a threaded section, or some sort of friction fit design - I'm open to suggestions. I'm assuming standard threads are going to be a pain to print cleanly, so maybe a simpler friction fit would be preferable.\n*   **Printability:**  It needs to be easy to print without supports, or with minimal support. This is why the existing code is problematic with the sharp angle and all those cylindrical sections colliding.\n*   **Robust:** I would also like the water stream ramp to not easily break, so maybe some kind of solid design, rather than just a thin tube.\n\n**Additional Considerations:**\n\n*   I'd like to avoid just directly using the code as it is. Its a start, but its overly complicated and it doesnt work the way I want. If it's helpful to reference, that's fine, but I'm thinking there's probably a simpler way to do it.\n*   I don't have any specific OpenSCAD libraries I need to use right now, but if there are any particularly useful ones you'd suggest to accomplish some of this more easily, feel free! I'm open to trying them out.\n\nLet me know what you come up with! I'm excited to see what you can do to improve this design.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Lamp Shade Reducer Ring",
    "scad": "difference() {\nunion() {\n\tcylinder(3,29,29);\n\tcylinder(9,21.7,21.7);\n}\n\t#cylinder(20,15,15);\n\ttranslate([0,0,3])\n\t#cylinder(20,19,19);\n}",
    "description": "Okay, so I'm trying to design a lamp shade adapter ring, and I've got a basic version working but it's not very flexible. I need something I can easily adjust for different lamp shades.\n\nHere's the gist: The adapter ring is basically a cylinder with a smaller cylinder inside of it, and then a couple of cylinders that cut out sections from it. I made one in OpenSCAD, but it's pretty hardcoded. Here's the current SCAD code. I'd really like a version where I can specify the important dimensions as parameters.\n\n```openscad\ndifference() {\n\nunion() {\n\n\tcylinder(3,29,29);\n\tcylinder(9,21.7,21.7);\n\n}\n\n\t#cylinder(20,15,15);\n\ttranslate([0,0,3])\n\t#cylinder(20,19,19);\n}\n```\n\nSo, what I'm imagining is this:\n\n*   **Outer Diameter:** I need to be able to set the outer diameter of the ring. My current one is 58mm (29mm radius * 2), which should fit a fairly common lamp shade opening.\n*   **Inner Diameter:**  I also need to set the inner diameter, which is 43.4mm(21.7mm radius * 2) in my current code, where the lamp will actually sit on.\n*   **Height:** I need to be able to set the overall height of the ring, which is 12mm in my current version (3mm + 9mm). I will need some flexibility for this height, as some shades are very thick.\n*   **Top Cutout Diameter:** I need to set the diameter of the top cutout, it's 30mm in this example, but I'd prefer it's parametric. Also, it would be nice to set the height of the cutout so that I don't remove too much material. My cutouts also start at z=3, which should be a parameter as well.\n*   **Bottom Cutout Diameter:**  Same as the top cutout but for the bottom. In this example, it's 38mm. The height and starting z are the same as the top cutout (z=3).\n\nIdeally, I'd like these to all be parameters at the top of the file. I'd really appreciate it if you could generate a parametric OpenSCAD file for me. I'm not using any libraries right now, but I'm open to them if it makes the design easier to generate.\n\nThanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Brick",
    "scad": "width = 3;\nlength = 3;\nthickness = 3;\nknob_diameter=4.8+0;\nknob_height=2+0;\nknob_spacing=8.0+0;\nwall_thickness=1.45+0;\nroof_thickness=1.05+0;\nblock_height=9.5+0;\npin_diameter=3+0;\npost_diameter=6.5+0;\nreinforcing_width=1.5+0;\naxle_spline_width=2.0+0;\naxle_diameter=5+0;\ncylinder_precision=0.1+0;\nblock(length,width,thickness/3,axle_hole=false,reinforcement=true);\nmodule block(width,length,height,axle_hole,reinforcement) {\n\toverall_length=(length-1)*knob_spacing+knob_diameter+wall_thickness*2;\n\toverall_width=(width-1)*knob_spacing+knob_diameter+wall_thickness*2;\n\tstart=(knob_diameter/2+knob_spacing/2+wall_thickness);\n\ttranslate([-overall_length/2,-overall_width/2,0])\n\t\tunion() {\n\t\t\tdifference() {\n\t\t\t\tunion() {\n\t\t\t\t\tcube([overall_length,overall_width,height*block_height]);\n\t\t\t\t\ttranslate([knob_diameter/2+wall_thickness,knob_diameter/2+wall_thickness,0])\n\t\t\t\t\t\tfor (ycount=[0:width-1])\n\t\t\t\t\t\t\tfor (xcount=[0:length-1]) {\n\t\t\t\t\t\t\t\ttranslate([xcount*knob_spacing,ycount*knob_spacing,0])\n\t\t\t\t\t\t\t\t\tcylinder(r=knob_diameter/2,h=block_height*height+knob_height,$fs=cylinder_precision);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttranslate([wall_thickness,wall_thickness,-roof_thickness]) cube([overall_length-wall_thickness*2,overall_width-wall_thickness*2,block_height*height]);\n\t\t\t\tif (axle_hole==true)\n\t\t\t\t\tif (width>1 && length>1) for (ycount=[1:width-1])\n\t\t\t\t\t\tfor (xcount=[1:length-1])\n\t\t\t\t\t\t\ttranslate([(xcount-1)*knob_spacing+start,(ycount-1)*knob_spacing+start,-block_height/2])  axle(height+1);\n\t\t\t}\n\t\t\tif (reinforcement==true && width>1 && length>1)\n\t\t\t\tdifference() {\n\t\t\t\t\tfor (ycount=[1:width-1])\n\t\t\t\t\t\tfor (xcount=[1:length-1])\n\t\t\t\t\t\t\ttranslate([(xcount-1)*knob_spacing+start,(ycount-1)*knob_spacing+start,0]) reinforcement(height);\n\t\t\t\t\tfor (ycount=[1:width-1])\n\t\t\t\t\t\tfor (xcount=[1:length-1])\n\t\t\t\t\t\t\ttranslate([(xcount-1)*knob_spacing+start,(ycount-1)*knob_spacing+start,-0.5]) cylinder(r=post_diameter/2-0.1, h=height*block_height+0.5, $fs=cylinder_precision);\n\t\t\t\t}\n\t\t\tif (width>1 && length>1) for (ycount=[1:width-1])\n\t\t\t\tfor (xcount=[1:length-1])\n\t\t\t\t\ttranslate([(xcount-1)*knob_spacing+start,(ycount-1)*knob_spacing+start,0]) post(height,axle_hole);\n\t\t\tif (width==1 && length!=1)\n\t\t\t\tfor (xcount=[1:length-1])\n\t\t\t\t\ttranslate([(xcount-1)*knob_spacing+start,overall_width/2,0]) cylinder(r=pin_diameter/2,h=block_height*height,$fs=cylinder_precision);\n\t\t\tif (length==1 && width!=1)\n\t\t\t\tfor (ycount=[1:width-1])\n\t\t\t\t\ttranslate([overall_length/2,(ycount-1)*knob_spacing+start,0]) cylinder(r=pin_diameter/2,h=block_height*height,$fs=cylinder_precision);\n\t\t}\n}\nmodule post(height,axle_hole=false) {\n\tdifference() {\n\t\tcylinder(r=post_diameter/2, h=height*block_height,$fs=cylinder_precision);\n\t\tif (axle_hole==true) {\n\t\t\ttranslate([0,0,-block_height/2])\n\t\t\t\taxle(height+1);\n\t\t} else {\n\t\t\ttranslate([0,0,-0.5])\n\t\t\t\tcylinder(r=knob_diameter/2, h=height*block_height+1,$fs=cylinder_precision);\n\t\t}\n\t}\n}\nmodule reinforcement(height) {\n\tunion() {\n\t\ttranslate([0,0,height*block_height/2]) union() {\n\t\t\tcube([reinforcing_width,knob_spacing+knob_diameter+wall_thickness/2,height*block_height],center=true);\n\t\t\trotate(v=[0,0,1],a=90) cube([reinforcing_width,knob_spacing+knob_diameter+wall_thickness/2,height*block_height], center=true);\n\t\t}\n\t}\n}\nmodule axle(height) {\n\ttranslate([0,0,height*block_height/2]) union() {\n\t\tcube([axle_diameter,axle_spline_width,height*block_height],center=true);\n\t\tcube([axle_spline_width,axle_diameter,height*block_height],center=true);\n\t}\n}",
    "description": "Okay, I'd like to design a customizable, Lego-like brick in OpenSCAD. I'm looking for a file that lets me adjust the following parameters:\n\n*   **width**: The number of studs wide the brick is. This should be an integer, probably with a reasonable range, say 1 to 99.\n*   **length**: The number of studs long the brick is. Again, an integer, likely in the range of 1 to 99.\n*   **thickness**: The height of the brick, expressed as a multiplier of a standard block height. This should be an integer, possibly from 1 to 9.\n\nThe basic design of the brick should include these elements:\n\n*   **Top Studs:** The top of the brick will have the classic cylindrical studs, positioned on a grid.\n*   **Base Plate:** The main body of the brick will be a rectangular prism with the studs integrated on top. There will also be a recessed area below the studs and a solid base.\n*   **Bottom Connectors:** If either the width or length is just 1, then the bottom of the brick should have single cylindrical pins for connecting to other blocks (like a 1xN Lego brick). If the width and length are both greater than 1, it should have internal posts and reinforcing ribs for connecting to other blocks.\n*   **Internal Support:** If both length and width are greater than 1, there should be internal posts and a system of intersecting support ribs connecting them.\n*   **Axle Holes (Optional):** If both length and width are greater than one, there should be a hole for a standard Lego axle through the center of the posts. The user should be able to turn this on/off with a parameter.\n\nI would also like the following, hard-coded values to be used as the base measurements:\n\n*   **knob_diameter=4.8;** //diameter of knobs on top of blocks\n*   **knob_height=2;** //height of knobs on top of blocks\n*   **knob_spacing=8.0;** //spacing between knobs\n*   **wall_thickness=1.45;** //thickness of walls\n*   **roof_thickness=1.05;** //thickness of material under the knobs\n*  **block_height=9.5;** //base height of a single block unit\n*   **pin_diameter=3;** //pin for bottom blocks with width or length of 1\n*   **post_diameter=6.5;** //diameter of internal posts\n*   **reinforcing_width=1.5;** //width of internal reinforcing ribs\n*   **axle_spline_width=2.0;** //width of the splines for the axle hole\n*   **axle_diameter=5;** //diameter of the axle hole\n*  **cylinder_precision=0.1;**  // $fs value for cylinders\n\nThe user should be able to turn the internal reinforcement on/off using a boolean variable.\n\nPlease generate the OpenSCAD code for this brick, keeping the structure modular and readable.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Walters Customizable Tri Glide with broken edges",
    "scad": "_1_webbingOpeningWidth = 38;\n_2_webbingGapWidth = 6;\n_3_sideEdgeWidth = 5;\n_4_mainEdgeWidth = 7;\n_5_centerWidth = 10;\n_6_overallHeight = 4;\n_7_cornerRoundingPercent = 50;\n_8_cornerBreakage = 0.75;\nmodule makeBody(xsize, ysize, height, radius) {\n\ttranslate([0,0,height/2]) {\n\t\tminkowski() {\n\t\t\tcube(size=[xsize-2*radius,ysize-2*radius, height/2], center = true);\n\t\t\tcylinder(r=radius, h=height/2, center=true);\n\t\t}\n\t}\n}\nmodule makeCuts(width, gap, thickness, height,b) {\n\toffset = (thickness+gap)/2;\n\tfor (y = [-offset, offset]) {\n\t\ttranslate([0, y, 0]) {\n\t\t\ttranslate([0, 0, height/2])\n\t\t\t\tcube(size=[width, gap, height*2], center=true);\n\t\t\ttranslate([0, 0, 0])\n\t\t\t\tmakeCutEnd(width, gap, thickness, height,b);\n\t\t\ttranslate([0, 0, height]) scale([1,1,-1])\n\t\t\t\tmakeCutEnd(width, gap, thickness, height,b);\n\t\t}\n\t}\n}\nmodule makeCutEnd(width, gap, thickness, height,b)\n{\n\thull(){\n\t\ttranslate([0,0,+b/2])\n\t\t\tcube(size=[width, gap, b], center=true);\n\t\ttranslate([0,0,-b/2])\n\t\t\tcube(size=[width+2*b, gap+2*b, b], center=true);\n\t}\n}\nmodule makeTriGlide(width, gap, edgeThicknessSide, edgeThicknessMain, centerThickness, height, rounding, b, $fn=90) {\n\txsize = width + edgeThicknessSide * 2;\n\tysize = centerThickness + edgeThicknessMain * 2 + gap * 2;\n\tradius = max(edgeThicknessSide,edgeThicknessMain)*(rounding/100);\n\tdifference() {\n        hull()\n        {\n\t\t  makeBody(xsize-2*b, ysize-2*b, height, radius);\n          translate([0,0,b])\n\t\t  makeBody(xsize, ysize, height-2*b, radius);\n        }\n\t\tmakeCuts(width, gap, centerThickness, height,b);\n\t}\n}\nmakeTriGlide\n  ( _1_webbingOpeningWidth\n  , _2_webbingGapWidth\n  , _3_sideEdgeWidth\n  , _4_mainEdgeWidth\n  , _5_centerWidth\n  , _6_overallHeight\n  , _7_cornerRoundingPercent\n  ,_8_cornerBreakage\n  );",
    "description": "Okay, I'd like to design a tri-glide buckle for webbing, similar to the one I have a SCAD file for (broken-edge-tri-glide_v1.1.scad), but I need it to be more flexible and have some additional parameters. \n\nHere's what I'm looking for:\n\n**Core Functionality:**\n\n*   It should be a tri-glide, with a central bar and two side openings for webbing to pass through.\n*   The overall shape should be a rounded rectangle, with the option to control the roundness of the corners.\n*   The tri-glide needs to have the ability to break or remove material on its outer edges, creating a chamfer or bevel on the top and bottom of the outer edges. I'm not looking to round the edges, but create a sharp chamfer or bevel on the top and bottom outer edges.\n*   I need to be able to control the thickness of the overall tri-glide piece as well as the center bar and side edges independently.\n\n**Parameters I Need:**\n\n*   **`webbingOpeningWidth`:** The width of the opening for the webbing (the internal width of the central area) - in mm.\n*   **`webbingGapWidth`:**  The space or gap between the webbing opening and the edge of the tri-glide (the internal gap) - in mm.\n*   **`sideEdgeWidth`:** The width/thickness of the side edges of the tri-glide (the outer edges) - in mm.\n*   **`mainEdgeWidth`:** The width/thickness of the main edges along the side opening (where the webbing bends around) - in mm.\n*   **`centerWidth`:** The width of the central bar - in mm.\n*   **`overallHeight`:** The overall thickness or height of the tri-glide piece - in mm.\n*   **`cornerRoundingPercent`:**  A percentage value controlling how much the corners are rounded. It should act as a percentage of the max possible radius value based on the minimum of edgeWidth. It needs to be adjustable from 1 to 100.\n*    **`cornerBreakage`:**  This parameter specifies how much material to remove from the outer edges to form the chamfer/bevel, in mm. This should remove material from the top and bottom, leaving the center thickness intact.\n\n**OpenSCAD Specific Requirements:**\n\n*   I'd like the design to be entirely parametric, allowing me to easily modify the dimensions using the parameters listed above.\n*   The design needs to use a `minkowski()` operation with a rounded cylinder to form the rounded rectangle with the correct corner radius as a base. This will help make sure the corners work smoothly. The chamfer should be applied to the main body.\n*   I'm looking to avoid using any external libraries if possible, I want this to be a clean, standalone SCAD file.\n\nSo, could you generate the OpenSCAD code for this? I'd really appreciate it.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Braille Name Plates/Keyrings",
    "scad": "Text=\"Paul\";\nSize=20;\nShow_Build=\"No\";\nBuild_Size=12;\nKey_Ring=\"No\";\nmodule Insert(Letter,TextSize){\n\tx=[-TextSize,TextSize,-TextSize,TextSize,-TextSize,TextSize];\n\ty=[2*TextSize,2*TextSize,0,0,-2*TextSize,-2*TextSize];\n\tdifference(){\n\t\tcube([4*TextSize,6*TextSize,1],center=true);\n\t\tcube([3.8*TextSize,5.8*TextSize,2],center=true);\n\t}\n\tfor (i=[0:5]){\n\t\tif ((Letter[i])==1) translate([x[i],y[i],0]) sphere(r=0.5*TextSize);\n\t}\n}\nmodule WORD(Word,TxtSize){\n\ta=[1,0,0,0,0,0];\n\tb=[1,0,1,0,0,0];\n\tc=[1,1,0,0,0,0];\n\td=[1,1,0,1,0,0];\n\te=[1,0,0,1,0,0];\n\tf=[1,1,1,0,0,0];\n\tg=[1,1,1,1,0,0];\n\th=[1,0,1,1,0,0];\n\ti=[0,1,1,0,0,0];\n\tj=[0,1,1,1,0,0];\n\tk=[1,0,0,0,1,0];\n\tl=[1,0,1,0,1,0];\n\tm=[1,1,0,0,1,0];\n\tn=[1,1,0,1,1,0];\n\to=[1,0,0,1,1,0];\n\tp=[1,1,1,0,1,0];\n\tq=[1,1,1,1,1,0];\n\tr=[1,0,1,1,1,0];\n\ts=[0,1,1,0,1,0];\n\tt=[0,1,1,1,1,0];\n\tu=[1,0,0,0,1,1];\n\tv=[1,0,1,0,1,1];\n\tw=[0,1,1,1,0,1];\n\tx=[1,1,0,0,1,1];\n\ty=[1,1,0,1,1,1];\n\tz=[1,0,0,1,1,1];\n\ttranslate([TxtSize*3,0,0])\n\tfor (i=[0:len(Word)-1]){\n\t\ttranslate([TxtSize*i*6,0,0]) {\n\t\t\tif (Word[i]==\"A\" || Word[i]==\"a\") Insert(a,TxtSize);\n\t\t\tif (Word[i]==\"B\" || Word[i]==\"b\") Insert(b,TxtSize);\n\t\t\tif (Word[i]==\"C\" || Word[i]==\"c\") Insert(c,TxtSize);\n\t\t\tif (Word[i]==\"D\" || Word[i]==\"d\") Insert(d,TxtSize);\n\t\t\tif (Word[i]==\"E\" || Word[i]==\"e\") Insert(e,TxtSize);\n\t\t\tif (Word[i]==\"F\" || Word[i]==\"f\") Insert(f,TxtSize);\n\t\t\tif (Word[i]==\"G\" || Word[i]==\"g\") Insert(g,TxtSize);\n\t\t\tif (Word[i]==\"H\" || Word[i]==\"h\") Insert(h,TxtSize);\n\t\t\tif (Word[i]==\"I\" || Word[i]==\"i\") Insert(i,TxtSize);\n\t\t\tif (Word[i]==\"J\" || Word[i]==\"j\") Insert(j,TxtSize);\n\t\t\tif (Word[i]==\"K\" || Word[i]==\"k\") Insert(k,TxtSize);\n\t\t\tif (Word[i]==\"L\" || Word[i]==\"l\") Insert(l,TxtSize);\n\t\t\tif (Word[i]==\"M\" || Word[i]==\"m\") Insert(m,TxtSize);\n\t\t\tif (Word[i]==\"N\" || Word[i]==\"n\") Insert(n,TxtSize);\n\t\t\tif (Word[i]==\"O\" || Word[i]==\"o\") Insert(o,TxtSize);\n\t\t\tif (Word[i]==\"P\" || Word[i]==\"p\") Insert(p,TxtSize);\n\t\t\tif (Word[i]==\"Q\" || Word[i]==\"q\") Insert(q,TxtSize);\n\t\t\tif (Word[i]==\"R\" || Word[i]==\"r\") Insert(r,TxtSize);\n\t\t\tif (Word[i]==\"S\" || Word[i]==\"s\") Insert(s,TxtSize);\n\t\t\tif (Word[i]==\"T\" || Word[i]==\"t\") Insert(t,TxtSize);\n\t\t\tif (Word[i]==\"U\" || Word[i]==\"u\") Insert(u,TxtSize);\n\t\t\tif (Word[i]==\"V\" || Word[i]==\"v\") Insert(v,TxtSize);\n\t\t\tif (Word[i]==\"W\" || Word[i]==\"w\") Insert(w,TxtSize);\n\t\t\tif (Word[i]==\"X\" || Word[i]==\"x\") Insert(x,TxtSize);\n\t\t\tif (Word[i]==\"Y\" || Word[i]==\"y\") Insert(y,TxtSize);\n\t\t\tif (Word[i]==\"Z\" || Word[i]==\"z\") Insert(z,TxtSize);\n\t\t}\n\t}\n}\nif (Show_Build==\"Yes\") { color(\"blue\") translate([-10,-10,-.9]) cube([Build_Size*25.4,Build_Size*25.4,1]);}\nif (Key_Ring==\"No\"){\n\ttranslate([0,0,0]) cube([Size*(len(Text)),Size*1.5,Size/10]);\n\ttranslate([0,Size*.75,Size/10]) WORD(Text,Size/6);\n} else {\n\tdifference(){\n\t\tcube([Size*(len(Text))+10,Size*1.5,Size/10]);\n\t\ttranslate([5,Size*.75,-2]) cylinder(r=3,h=Size);\n\t}\n\ttranslate([10,Size*.75,Size/10]) WORD(Text,Size/6);\n}",
    "description": "Okay, so I need an OpenSCAD design for making customizable Braille nameplates and keychains. I'd like it to be parametric, so I can easily change things like the text, size, and whether it's a keychain or just a nameplate.\n\nBasically, I want to be able to input some text, and have it rendered in Braille, with raised dots. I'd like to control the size of the Braille characters themselves, and the overall size of the nameplate/keychain. I'd also like to be able to specify whether it should include a hole for a keyring.\n\nHere's a breakdown of what I'm thinking:\n\n*   **Text Input:** A variable for the text to be displayed in Braille.\n*   **Size Control:** A variable for the overall height of the Braille characters. This should affect the size of the dots and the spacing.\n*   **Keychain Option:** A boolean or string variable to toggle between a nameplate and a keychain. If it's a keychain, it needs a hole for the keyring, ideally near the left edge.\n*   **Braille Encoding:** I'll need a method for converting the text into Braille. Each letter has a specific pattern of 6 dots, and I'll need to define these patterns. I don't know how to do that so will need the AI to figure that out.\n*   **Build Platform Indicator:** Optionally (but helpful), have a way to show the printer build area as a semi-transparent cube, so I can ensure it fits my printer's bed. I'd want to be able to turn this on/off.\n*   **Letter Spacing:** There should be a bit of horizontal space between each braille character, based on the font size (the one from the size control variable). This makes them easier to read/feel.\n*   **Base Plate:** There should be a base plate behind the braille characters, to keep them rigid and make them more printable. The height of this base plate should be adjustable as well.\n*  **Unit:** We should be working in mm.\n\nI think that covers it! This is similar to something I saw online but I want a custom design from the ground up. I'm new to OpenSCAD, so the more detailed the code, the better. I am not using any special libraries so any modules must be created from scratch. Can you create the OpenSCAD files for me?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Desk Hook w/ Hole for Headphone Cable",
    "scad": "width = 20;\ndesk_height = 35;\nhook_height = 20;\nthickness = 5;\ndepth=40;\njack = 10;\nmodule fillet(radius, height=100, $fn=16) {\n    translate([-radius, -radius, -height/2-0.01])\n        difference() {\n            cube([radius*2, radius*2, height+0.02]);\n            cylinder(r=radius, h=height+0.02, $fn=16);\n        }\n}\nmodule cube_negative_fillet(\n        size,\n        radius=-1,\n        vertical=[3,3,3,3],\n        top=[0,0,0,0],\n        bottom=[0,0,0,0],\n        $fn=0\n    ){\n    j=[1,0,1,0];\n    for (i=[0:3]) {\n        if (radius > -1) {\n            rotate([0, 0, 90*i])\n                translate([size[1-j[i]]/2, size[j[i]]/2, 0])\n                    fillet(radius, size[2], $fn=$fn);\n        } else {\n            rotate([0, 0, 90*i])\n                translate([size[1-j[i]]/2, size[j[i]]/2, 0])\n                    fillet(vertical[i], size[2], $fn=$fn);\n        }\n        rotate([90*i, -90, 0])\n            translate([size[2]/2, size[j[i]]/2, 0 ])\n                fillet(top[i], size[1-j[i]], $fn=$fn);\n        rotate([90*(4-i), 90, 0])\n            translate([size[2]/2, size[j[i]]/2, 0])\n                fillet(bottom[i], size[1-j[i]], $fn=$fn);\n    }\n}\nmodule cube_fillet_inside(\n         size,\n        radius=-1,\n        vertical=[3,3,3,3],\n        top=[0,0,0,0],\n        bottom=[0,0,0,0],\n        $fn=0\n    ){\n    if (radius == 0) {\n        cube(size, center=true);\n    } else {\n        difference() {\n            cube(size, center=true);\n            cube_negative_fillet(size, radius, vertical, top, bottom, $fn);\n        }\n    }\n}\nmodule cube_fillet(\n        size,\n        radius=-1,\n        vertical=[3,3,3,3],\n        top=[0,0,0,0],\n        bottom=[0,0,0,0],\n        center=false,\n        $fn=0\n    ){\n    if (center) {\n        cube_fillet_inside(size, radius, vertical, top, bottom, $fn);\n    } else {\n        translate([size[0]/2, size[1]/2, size[2]/2])\n            cube_fillet_inside(size, radius, vertical, top, bottom, $fn);\n    }\n}\nmodule desk_hook(width, desk_height, hook_height, thickness, depth, jack)\n{\n\tdifference() {\n\t\tcube_fillet([width, depth, thickness + desk_height + thickness + hook_height + thickness]);\n\t\ttranslate([0, 0, thickness]) {\n\t\t\tcube([width, depth - thickness, hook_height]);\n\t\t}\n\t\ttranslate([0, thickness, thickness + hook_height + thickness]) {\n\t\t\tcube([width,depth - thickness, desk_height]);\n\t\t}\n\t\tif(jack > 0)\n\t\t{\n\t\t\ttranslate([width/2, 0, thickness + hook_height /2])\n\t\t\t\trotate(90, [1, 0, 0])\n\t\t\t\tcylinder(r=jack/2, center=true, h=depth*3, $fs=0.05);\n\t\t}\n\t}\n}\ndesk_hook(width, desk_height, hook_height, thickness, depth, jack);",
    "description": "Okay, I'd like to design a parametric desk hook that I can 3D print. I need it to be adjustable so it can fit different desks and hold my headphones.\n\nHere are the features I need:\n\n1.  **Overall Shape:** The hook will have a flat, vertical section that clamps onto the desk, a horizontal section that extends under the desk, and a final vertical section that acts as the hook itself. Think of it like a 'C' shape that's been bent 90 degrees.\n2.  **Parametric Width:** I need to be able to specify the overall width of the hook, which will mostly be the width of the vertical section that clamps to the desk. I'll call this `width`.\n3.  **Parametric Desk Height:** I need a parameter for the thickness of the desk that the hook will be clamped to. This value will be the height of the middle, horizontal section of the hook. I'll call this `desk_height`.\n4.  **Parametric Hook Height:** The height of the actual hook part that holds my headphones needs to be adjustable as well. Let's call this `hook_height`.\n5.  **Parametric Thickness:** All of the parts of the hook should be a consistent thickness. Let's call this `thickness`.\n6.  **Parametric Depth:** The horizontal extension of the hook should be adjustable for different desk overhangs. Let's call this `depth`.\n7.  **Optional Headphone Cable Hole:** I would like to include an optional hole through the hook to feed my headphone cable through. This parameter will be the diameter of that hole and I'll call this `jack`. If the `jack` diameter is 0, no hole should be generated.\n8.  **Filleted Edges:** I would like for the edges of the hook to be rounded using fillets to make it look smoother. I would like for these to be controllable as parameters, and I would like to be able to control both vertical and horizontal fillets. I would also like to be able to specify a single fillet radius for all corners, if needed.\n\nI'd like this to be written in OpenSCAD and be entirely parametric, so I can tweak the design later without having to completely redesign it. I would like to be able to call the main module of the design using `desk_hook(width, desk_height, hook_height, thickness, depth, jack);`. I've looked into the source and I would like to use the helper module `fillet()` and `cube_negative_fillet()`, and `cube_fillet_inside()`, and `cube_fillet()` from the attached code. The module `fillet()` is a module that subtracts a cylinder from a cube to generate a fillet. The other modules modify a cube by applying fillets and subtracting them from the cube. Please do not include any specific libraries like MCAD or BOSL.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Container",
    "scad": "box_x = 120;\nbox_y =  80;\nbox_z =  50;\nframe        = 10;\nthickness    =  3;\nbottom_angle =  45;\nsides_angle  =  45;\npad_heigth = 0.5;\npad_radius = 10;\nstruts_number_x = 7;\nstruts_number_y = 7;\nstruts_number_z = 7;\nstruts_width    = 3;\nbo_thickness       = thickness;\nbo_frame           = frame;\nbo_struts_width    = struts_width;\nbo_1_struts_number = struts_number_x;\nbo_1_struts_width  = bo_struts_width;\nbo_1_struts_angle  = bottom_angle;\nbo_2_struts_number = struts_number_y;\nbo_2_struts_width  = bo_struts_width;\nbo_2_struts_angle  = bottom_angle+90;\nbo_3_struts_number = 0;\nbo_3_struts_width  = bo_struts_width;\nbo_3_struts_angle  = 45;\nbo_4_struts_number = 0;\nbo_4_struts_width  = bo_struts_width;\nbo_4_struts_angle  = -45;\nle_thickness       = thickness;\nle_frame           = frame;\nle_struts_width    = struts_width;\nle_1_struts_number = struts_number_z;\nle_1_struts_width  = le_struts_width;\nle_1_struts_angle  = sides_angle;\nle_2_struts_number = struts_number_y;\nle_2_struts_width  = le_struts_width;\nle_2_struts_angle  = sides_angle+90;\nle_3_struts_number = 0;\nle_3_struts_width  = le_struts_width;\nle_3_struts_angle  = 45;\nle_4_struts_number = 0;\nle_4_struts_width  = le_struts_width;\nle_4_struts_angle  = -45;\nri_thickness       = thickness;\nri_frame           = frame;\nri_struts_width    = struts_width;\nri_1_struts_number = struts_number_z;\nri_1_struts_width  = ri_struts_width;\nri_1_struts_angle  = sides_angle;\nri_2_struts_number = struts_number_y;\nri_2_struts_width  = ri_struts_width;\nri_2_struts_angle  = sides_angle+90;\nri_3_struts_number = 0;\nri_3_struts_width  = ri_struts_width;\nri_3_struts_angle  = 45;\nri_4_struts_number = 0;\nri_4_struts_width  = ri_struts_width;\nri_4_struts_angle  = -45;\nfr_thickness       = thickness;\nfr_frame           = frame;\nfr_struts_width    = struts_width;\nfr_1_struts_number = struts_number_x;\nfr_1_struts_width  = fr_struts_width;\nfr_1_struts_angle  = sides_angle;\nfr_2_struts_number = struts_number_z;\nfr_2_struts_width  = fr_struts_width;\nfr_2_struts_angle  = sides_angle+90;\nfr_3_struts_number = 0;\nfr_3_struts_width  = fr_struts_width;\nfr_3_struts_angle  = 45;\nfr_4_struts_number = 0;\nfr_4_struts_width  = fr_struts_width;\nfr_4_struts_angle  = -45;\nba_thickness       = thickness;\nba_frame           = frame;\nba_struts_width    = struts_width;\nba_1_struts_number = struts_number_x;\nba_1_struts_width  = ba_struts_width;\nba_1_struts_angle  = sides_angle;\nba_2_struts_number = struts_number_z;\nba_2_struts_width  = ba_struts_width;\nba_2_struts_angle  = sides_angle+90;\nba_3_struts_number = 0;\nba_3_struts_width  = ba_struts_width;\nba_3_struts_angle  = 45;\nba_4_struts_number = 0;\nba_4_struts_width  = ba_struts_width;\nba_4_struts_angle  = -45;\nmodule padded_cube(coords){\n\tcube(coords);\n\tif (pad_heigth > 0){\n\t\tcolor([0,0,1,1]){\n\t\t\tcylinder(r=pad_radius,h=pad_heigth, $fn=50);\n\t\t\ttranslate([coords[0],0,0])\n\t\t\t\tcylinder(r=pad_radius,h=pad_heigth, $fn=50);\n\t\t\ttranslate([coords[0],coords[1],0])\n\t\t\t\tcylinder(r=pad_radius,h=pad_heigth, $fn=50);\n\t\t\ttranslate([0,coords[1],0])\n\t\t\t\tcylinder(r=pad_radius,h=pad_heigth, $fn=50);\n\t\t}\n\t}\n}\nmodule struts (x, y, thickness, number_of_struts, struts_width, angle){\n\tangle2 = angle % 180;\n\thypotenuse = sqrt(pow(x,2)+pow(y,2));\n\tintersection(){\n\t\tcube([x,y,thickness]);\n\t\tif (angle2 <= 90 && angle >=0)\n\t\t\tassign (cosa = x/hypotenuse)\n\t\t\t\tfor ( i = [1 : number_of_struts] )\n\t\t\t\t\tassign ( start = ((hypotenuse - number_of_struts* (struts_width/(cos(angle2-acos(cosa))))) / (number_of_struts + 1))*i + (struts_width/(cos(angle2-acos(cosa))))*(i-1))\n\t\t\t\t\t\trotate([0,0,acos(cosa)])\n\t\t\t\t\t\t\ttranslate([start,0, 0])\n\t\t\t\t\t\t\t\trotate([0,0,angle2-acos(cosa)])\n\t\t\t\t\t\t\t\t\ttranslate([0,-hypotenuse, 0])\n\t\t\t\t\t\t\t\t\t\tcube([struts_width,2*hypotenuse,thickness]);\n\t\telse\n\t\t\tassign (cosa = y/hypotenuse)\n\t\t\t\ttranslate([x,0])\n\t\t\t\t\tfor ( i = [1 : number_of_struts] )\n\t\t\t\t\t\tassign ( start = ((hypotenuse - number_of_struts* (struts_width/(sin(angle2-acos(cosa))))) / (number_of_struts + 1))*i + (struts_width/(sin(angle2-acos(cosa))))*(i-1))\n\t\t\t\t\t\t\trotate([0,0,acos(cosa)])\n\t\t\t\t\t\t\t\ttranslate([0,start,0])\n\t\t\t\t\t\t\t\t\trotate([0,0,angle2-90-acos(cosa)])\n\t\t\t\t\t\t\t\t\t\ttranslate([-hypotenuse,0, 0])\n\t\t\t\t\t\t\t\t\t\t\tcube([2*hypotenuse,struts_width,thickness]);\n\t}\n}\nmodule side(x, y, thickness, width, number_of_struts_1, struts_width_1, angle1, number_of_struts_2, struts_width_2, angle2, number_of_struts_3, struts_width_3, angle3, number_of_struts_4, struts_width_4, angle4, pads=false){\n\tdifference(){\n\t\tif (pads) padded_cube([x,y,thickness]);\n\t\telse\n\t\t\tcube([x,y,thickness]);\n\t\ttranslate([width,width,-0.5])\n\t\t\tcube([x-2*width,y-2*width,thickness+1]);\n\t}\n\ttranslate([width,width,0]){\n\t\tif(number_of_struts_1 >0)\n\t\t\tstruts(x-2*width, y-2*width,thickness,number_of_struts_1,struts_width_1,angle1);\n\t\tif(number_of_struts_2 >0)\n\t\t\tstruts(x-2*width, y-2*width,thickness,number_of_struts_2,struts_width_2,angle2);\n\t\tif(number_of_struts_3 >0)\n\t\t\tstruts(x-2*width, y-2*width,thickness,number_of_struts_3,struts_width_3,angle3);\n\t\tif(number_of_struts_4 >0)\n\t\t\tstruts(x-2*width, y-2*width,thickness,number_of_struts_4,struts_width_4,angle4);\n\t}\n}\nmodule box(){\n\tside(box_x,box_y,bo_thickness,bo_frame,\n\t\tbo_1_struts_number, bo_1_struts_width , bo_1_struts_angle ,\n\t\tbo_2_struts_number, bo_2_struts_width , bo_2_struts_angle ,\n\t\tbo_3_struts_number, bo_3_struts_width , bo_3_struts_angle ,\n\t\tbo_4_struts_number, bo_4_struts_width , bo_4_struts_angle , true);\n\ttranslate([0,fr_thickness,0])\n\t\trotate([90,0,0])\n\t\t\tside(box_x,box_z,fr_thickness,fr_frame,\n\t\t\t\tfr_1_struts_number, fr_1_struts_width , fr_1_struts_angle ,\n\t\t\t\tfr_2_struts_number, fr_2_struts_width , fr_2_struts_angle ,\n\t\t\t\tfr_3_struts_number, fr_3_struts_width , fr_3_struts_angle ,\n\t\t\t\tfr_4_struts_number, fr_4_struts_width , fr_4_struts_angle );\n\ttranslate([0,box_y,0])\n\t\trotate([90,0,0])\n\t\t\tside(box_x,box_z,ba_thickness,ba_frame,\n\t\t\t\tba_1_struts_number, ba_1_struts_width , ba_1_struts_angle ,\n\t\t\t\tba_2_struts_number, ba_2_struts_width , ba_2_struts_angle ,\n\t\t\t\tba_3_struts_number, ba_3_struts_width , ba_3_struts_angle ,\n\t\t\t\tba_4_struts_number, ba_4_struts_width , ba_4_struts_angle );\n\ttranslate([box_x,0,0])\n\t\trotate([0,-90,0])\n\t\t\tside(box_z,box_y,ri_thickness,ri_frame,\n\t\t\t\tri_1_struts_number, ri_1_struts_width , ri_1_struts_angle ,\n\t\t\t\tri_2_struts_number, ri_2_struts_width , ri_2_struts_angle ,\n\t\t\t\tri_3_struts_number, ri_3_struts_width , ri_3_struts_angle ,\n\t\t\t\tri_4_struts_number, ri_4_struts_width , ri_4_struts_angle );\n\ttranslate([le_thickness,0,0])\n\t\trotate([0,-90,0])\n\t\t\tside(box_z,box_y,le_thickness,le_frame,\n\t\t\t\tle_1_struts_number, le_1_struts_width , le_1_struts_angle ,\n\t\t\t\tle_2_struts_number, le_2_struts_width , le_2_struts_angle ,\n\t\t\t\tle_3_struts_number, le_3_struts_width , le_3_struts_angle ,\n\t\t\t\tle_4_struts_number, le_4_struts_width , le_4_struts_angle );\n}\ntranslate([-box_x/2,-box_y/2,0])\n\tbox();",
    "description": "Okay, I need an OpenSCAD design for a customizable box, similar to the one I found on Thingiverse. The original design had a lot of options, but I want to make sure the following are included and can be changed through parameters:\n\n**Overall Box Dimensions:**\n\n*   `box_x`: The outer length of the box.\n*   `box_y`: The outer width of the box.\n*   `box_z`: The outer height of the box.\n\n**Frame and Thickness:**\n\n*   `frame`: The width of the frame around the edges of each side.\n*   `thickness`: The thickness of the box material.\n*   `bottom_angle`: Angle of struts on the bottom face.\n*  `sides_angle`: Angle of struts on the sides of the box.\n\n**Pads (for warping prevention):**\n\n*   `pad_heigth`: Height of the pads (set to 0 to remove pads). Should allow `0, 0.5, 1`.\n*   `pad_radius`: Radius of the pads at the corners.\n\n**Struts (Internal Supports):**\n\n*   `struts_number_x`: Number of struts in the X direction on the *bottom*, *front*, and *back* faces.\n*   `struts_number_y`: Number of struts in the Y direction on the *bottom*, *left*, and *right* faces.\n*   `struts_number_z`: Number of struts in the Z direction on the *left*, *right*, *front*, and *back* faces.\n*   `struts_width`: Width of the struts.\n\n**Advanced/Individual Side Settings (Hidden, but useful):**\n\nI'd like to have all of the above options customizable for each individual face of the box (bottom, left, right, front, back). Specifically this should be customizable for each face:\n\n*   `*_thickness`: Thickness of the face (e.g. `bo_thickness` for bottom, `le_thickness` for left, etc.).\n*   `*_frame`: Frame width of the face (e.g. `bo_frame` for bottom, `le_frame` for left, etc.).\n*    `*_struts_width`: Width of the struts on the face (e.g. `bo_struts_width` for bottom, `le_struts_width` for left, etc.).\n*    `*_1_struts_number`: Number of struts in the first direction on the face (e.g. `bo_1_struts_number`).\n*   `*_1_struts_width`: Width of struts in the first direction on the face.\n*   `*_1_struts_angle`: Angle of struts in the first direction on the face.\n*   `*_2_struts_number`: Number of struts in the second direction on the face (e.g. `bo_2_struts_number`).\n*   `*_2_struts_width`: Width of struts in the second direction on the face.\n*    `*_2_struts_angle`: Angle of struts in the second direction on the face.\n*   `*_3_struts_number`: Number of struts in the third direction on the face (e.g. `bo_3_struts_number`).\n*   `*_3_struts_width`: Width of struts in the third direction on the face.\n*   `*_3_struts_angle`: Angle of struts in the third direction on the face.\n*   `*_4_struts_number`: Number of struts in the fourth direction on the face (e.g. `bo_4_struts_number`).\n*   `*_4_struts_width`: Width of struts in the fourth direction on the face.\n*   `*_4_struts_angle`: Angle of struts in the fourth direction on the face.\n\nThe specific face prefixes should be the following:\n* `bo` for bottom\n* `le` for left\n* `ri` for right\n* `fr` for front\n* `ba` for back\n\n**Important Notes:**\n\n*   The struts should be generated based on the inner dimensions of the face (after subtracting the frame).\n*   The pads should only be generated for the bottom of the box.\n* The whole design should be placed at the origin.\n\nPlease let me know if anything is unclear. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Magnetic Marker Holder",
    "scad": "PEN_DIAMETER = 11;\nMAGNET_CUBE_SIZE = 6.55;\nMIN_WALL_THICKNESS = 1;\n$fn=32 + 0;\nTOTAL_H =  MAGNET_CUBE_SIZE + 2 * MIN_WALL_THICKNESS;\ndifference() {\n  union() {\n  \tcylinder(r=PEN_DIAMETER/2 + MIN_WALL_THICKNESS, h=MAGNET_CUBE_SIZE + 2 * MIN_WALL_THICKNESS);\n    translate([-TOTAL_H / 2, 0, 0])\n    cube([TOTAL_H, PEN_DIAMETER / 2 + TOTAL_H, TOTAL_H]);\n  }\n  translate([0, 0, -1])\n\tcylinder(r=PEN_DIAMETER/2, h=MAGNET_CUBE_SIZE + 2 * MIN_WALL_THICKNESS + 2);\n  translate([-MAGNET_CUBE_SIZE / 2, PEN_DIAMETER /2 + MIN_WALL_THICKNESS, MIN_WALL_THICKNESS])\n  cube([MAGNET_CUBE_SIZE,\n        MAGNET_CUBE_SIZE,\n        MAGNET_CUBE_SIZE + MIN_WALL_THICKNESS + 1]);\n}",
    "description": "Okay, I'm looking to create a parametric design for a magnetic marker holder, similar to the one I have now (attached as magnetic_marker_holder.scad, but I'd like to get it improved). The basic idea is to have a plastic part that holds both a whiteboard marker and a cube magnet, allowing you to stick the marker to a magnetic surface.\n\nHere are the key features and parameters I need in the design:\n\n*   **Marker Holder:** There should be a cylindrical hole to snugly hold a whiteboard marker. The diameter of this hole should be a parameter I can easily adjust.\n*   **Magnet Holder:** There should be a cube-shaped recess to hold a cube magnet. The side length of the cube should be another adjustable parameter. The magnet should fit securely.\n*   **Overall Structure:** The basic structure combines a cylinder and an intersecting rectangular solid to create the basic structure. This needs to have enough wall thickness so it's robust, and I would like this thickness to be a settable parameter.\n*   **Parametric Design:** I want all of these dimensions to be adjustable through OpenSCAD parameters. Specifically I need:\n    *   `pen_diameter`: The diameter of the marker to be held.\n    *   `magnet_cube_size`: The side length of the magnet cube.\n    *   `min_wall_thickness`: The minimum wall thickness of the plastic.\n*   **Clearance:** There should be a little bit of clearance around both the pen and the magnet, to make sure parts fit properly. This could be included in the parameters.\n*   **Robustness:** The structure shouldn't be too thin in any part, and should be able to handle some wear. I think having a `min_wall_thickness` parameter handles this, but if there are other areas that need reinforcing, please consider this.\n*   **Ease of 3D printing:** The design should print without supports. It should also be relatively simple for a 3D printer to produce.\n\nI don't think I need any specific libraries for this, just standard OpenSCAD functionality. Could you generate an OpenSCAD file that implements these requirements using these parameters?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Dixon Ticonderoga Pencil Clip",
    "scad": "include <MCAD/shapes.scad>\nuse <write.scad>\npencilRadius = 7/2;\nwallThickness = 3;\npencilWall = pencilRadius + wallThickness;\nheight = 38;\nlength = 35;\ndifference() {\nunion() {\ncylinder(height,pencilWall,pencilWall,true);\ndifference () {\ntranslate([-2,-length/2,0])\ncube([wallThickness,length,height],true);\ntranslate ([-4,-30,-15]) rotate ([90,0,90]) write(\"I\",h=30,t=2,font=\"orbitron.dxf\");\n}\ndifference () {\ntranslate([2,-length/2,0])\ncube([wallThickness,length,height],true);\nrotate ([90,90,90]) translate ([-12,-30,2]) write(\":)\",h=22,t=3,space=.7,font=\"orbitron.dxf\");\n}\n}\n#hexagon(pencilRadius*2, height+2);\n}\ntranslate([3.1,-(length+(wallThickness*0.5)),0])\ncylinder(height,wallThickness,wallThickness,true);\ntranslate([-3.1,-(length+(wallThickness*0.5)),0])\ncylinder(height,wallThickness,wallThickness,true);",
    "description": "Okay, I'm working on a pencil clip design and I'd like some help making it more parametric and easier to customize. I've already got a working file, but it's a bit messy and hard to change.\n\nHere's what I'm trying to achieve:\n\nI want a clip that holds a standard pencil, has a clip-like section to attach to a bag strap or notebook cover, and some simple text/iconography on the sides. I'm currently using the MCAD `shapes.scad` and a `write.scad` (specifically for using dxf fonts) libraries for the shapes and text.\n\nHere are the key features I'd like to parameterize:\n\n*   **Pencil Radius:**  The inner radius of the pencil holding section should be adjustable. I'd like to define it as a variable.\n*   **Wall Thickness:** The thickness of the walls of the pencil holder and the clip section should be variable.\n*   **Clip Length:** The length of the clip part that extends out to grab onto a surface should be variable.\n*   **Clip Height:** The overall height of the entire clip should be adjustable.\n*   **Text/Iconography:** I would like the text and iconography to be completely customizable. It should be easy to change the string, font, size, and spacing, and rotate the text on the face if needed.\n*   **Clip Post Radius:** The radius of the small cylindrical posts that provide the clip tension should be adjustable.\n*   **Post Placement:** The placement of those cylindrical posts relative to the main body of the clip should be configurable. This should be relative to the center of the clip.\n\nHere's how my current version works:\n\nThe main body is made using a difference of unions. First a cylinder is used to provide the central pencil holding area, then two cubes are cut from the sides to create the clip shape. Then text is added using the write module for a \"I\" and a smiley face \":)\".  Finally, two cylinders are used for the posts on the back of the clip.\n\nI'm looking for a parametric version, probably broken down into modules. I would like to be able to define the clip as a set of modules which allows me to define the various attributes and build the final part. This is what I'm looking for as an output.\n\nCan you help me create a parametric OpenSCAD file for this? Please make sure to use the `MCAD/shapes.scad` and a similar method to what I was doing with `write.scad` (perhaps defining a custom module that does what I was doing) for the text so it uses a dxf font. I want to be able to easily change the text, font, size, and spacing as parameters.\n"
  },
  {
    "object": "Hey cadmonkey, make me a customizable cube",
    "scad": "use <utils/build_plate.scad>\ncube_dimensions = 1;\nbuild_plate_selector = 3;\nbuild_plate_manual_x = 200;\nbuild_plate_manual_y = 200;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\ncube ([cube_dimensions,cube_dimensions,cube_dimensions]);",
    "description": "Okay, I'd like to create a customizable cube using OpenSCAD. I've started with a basic file, but I want to make it more flexible and user-friendly. \n\nHere's what I'm aiming for:\n\n**Core Functionality:**\n\n*   **Cube Dimensions:** I need a single parameter, `cube_dimensions`, to control the size of the cube. The cube should always be a perfect cube (all sides equal), and this parameter should control the length of each side. I'd like this to be a slider in the customizer, with a range from 1mm to 10mm, ideally in 0.1mm increments.\n*   **Build Plate Display:** I'm already using the `utils/build_plate.scad` library, which I'd like to keep. I want the ability to select from a predefined list of build plates (like Replicator 2, Replicator, Thingomatic) or to set manual dimensions with two parameters:\n    *   `build_plate_selector` should be a dropdown with the options \"Replicator 2\", \"Replicator\", \"Thingomatic\", and \"Manual\". This will drive the build plate display.\n    *   `build_plate_manual_x` and `build_plate_manual_y` should be sliders visible only when \"Manual\" is selected in the `build_plate_selector` dropdown. These should control the X and Y dimensions of the build plate, respectively. They should have a range of 100mm to 400mm each.\n\n**User Interface:**\n\n*   I'd like clear labels for each of these parameters in the Customizer.\n*   The `build_plate_manual_x` and `build_plate_manual_y` sliders should only be visible when the `build_plate_selector` is set to \"Manual\".\n*   The initial view in the preview should be the 'south', 'tilt', and 'top' views.\n\n**Libraries:**\n\n*   I'm using the `utils/build_plate.scad` library for the build plate display, so I need to keep that dependency intact. \n\n**General Requests:**\n\n*   Could you make sure the code is well-formatted and easy to read?\n*   I'd prefer the most concise and efficient way to achieve this in OpenSCAD.\n\nEssentially, I want to easily adjust the size of a cube and also customize and display a build plate in the viewer. Can you please provide the updated .scad file that does this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a  Customizable Round Containers",
    "scad": "_1_type = \"Base\";\n_2_outsideDiameter = 36;\n_3_baseHeight = 14;\n_4_cornerRadius = 3;\n_5_wallThickness = 0.8;\n_6_lidGap = 0.3;\n_7_lipHeight = 0.8;\n_8_resolution = 60;\nmodule torus(r1, r2) {\n\trotate_extrude(convexity = 4)\n\ttranslate([r1, 0, 0])\n\tcircle(r = r2);\n}\nmodule roundedCylinder(height, radius, fillet)\n{\n\tif (fillet <= 0) {\n\t\tcylinder(h=height, r=radius, center=true);\n\t} else {\n\t\thull() {\n\t\t\ttranslate([0, 0, height/2-fillet])\n\t\t\ttorus(r1 = radius-fillet, r2 = fillet);\n\t\t\ttranslate([0, 0, -(height/2-fillet)])\n\t\t\ttorus(r1 = radius-fillet, r2 = fillet);\n\t\t}\n\t}\n}\nmodule roundTray(diameter, height, rounding, sidewall, bottom)\n{\n\tradius = diameter/2;\n\ttranslate([0, 0, height])\n\tdifference() {\n\t\troundedCylinder(height*2, radius, rounding);\n\t\troundedCylinder((height - bottom)*2, radius-sidewall, rounding - sidewall);\n\t\tcylinder(h=height+rounding, r=radius+1, center=false);\n\t}\n}\nmodule roundLid(diameter, rounding, sidewall, gap, flatThickness, lipHeight) {\n\tradius = diameter/2;\n\tinsideRadius = radius - sidewall - gap;\n\teps = 0.1;\n\tunion() {\n\t\tif (rounding == 0) {\n\t\t\tcylinder(r=radius, h=flatThickness);\n\t\t} else {\n\t\t\tdifference() {\n\t\t\t\thull() {\n\t\t\t\t\ttorus(radius-rounding, rounding);\n\t\t\t\t}\n\t\t\t\ttranslate([0,0,-rounding-eps]) {\n\t\t\t\t\tcylinder(h=rounding+eps, r=radius+eps);\n\t\t\t\t}\n\t\t\t\thull() {\n\t\t\t\t\ttorus(insideRadius-rounding, rounding-sidewall);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate([0,0,-lipHeight]) {\n\t\t\tdifference() {\n\t\t\t\tcylinder(h=lipHeight+eps,r=insideRadius);\n\t\t\t\ttranslate([0,0,-eps]) {\n\t\t\t\t\tcylinder(h=lipHeight+3*eps,r=insideRadius - sidewall);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule run($fn = _8_resolution) {\n\thorizontalThickness = _5_wallThickness;\n\tif (_1_type == \"Base\") {\n\t\troundTray(_2_outsideDiameter,_3_baseHeight,_4_cornerRadius,_5_wallThickness,horizontalThickness);\n\t} else {\n\t\troundLid(_2_outsideDiameter,_4_cornerRadius,_5_wallThickness,_6_lidGap,horizontalThickness,_7_lipHeight);\n\t}\n}\nrun();",
    "description": "Okay, I'm looking to design a set of round containers with lids using OpenSCAD, and I need a bit of flexibility in the design. I've already experimented with something similar and have a working example that I'm happy with, but I'd like to rebuild it with more flexible and parametric controls.\n\nHere's what I need:\n\n**Core Shape:** The containers will be cylindrical, with rounded corners (filleted edges) on both the base and the lid. I want to control the radius of these rounded corners.\n\n**Container Type:** I need to be able to easily toggle between generating the *base* or the *lid* part of the container using a simple variable.\n\n**Dimensions:**\n*   **Outside Diameter:** The main outside diameter of the container should be adjustable. This includes the side walls.\n*   **Base Height:** For the base, I need to be able to set the total height of the base (including the bottom, but *not* any lid elements).\n*   **Wall Thickness:** The thickness of the walls, the bottom of the base, and the lid should all be the same and adjustable.\n*   **Lid Gap:** There should be a small, adjustable gap between the lid and the base for a proper fit.\n*   **Lip Height:** The lid has a lip that inserts into the base; I need to be able to control the height of this lip.\n\n**Rendering:** I'd like to control the resolution of the curved surfaces. It would be great if that could be defined through a variable too.\n\n**Specific Features:**\n*   The base will have a flat bottom.\n*   The lip on the lid should fit inside the base with the specified gap.\n*   The lid should also have rounded edges that match the base.\n\nEssentially, I want to recreate the attached design, but in a single parametric file instead of having some hardcoded values. Can you help me design an OpenSCAD file that can achieve this? I don't want to use any libraries except the standard ones that come with OpenSCAD. I'd prefer a solution without any external libraries if possible. The attached file is just an example of the general design I'm trying to achieve, not a set of requirements.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Round Foot for Bolt and Square Nut",
    "scad": "Units=1;\nBolt_Size=3.7;\nboltsize=Bolt_Size*Units;\nBolt_Depth=12.2;\nboltdepth=Bolt_Depth*Units;\nNut_Size=7.9375;\nnutsize=Nut_Size*Units;\nTotal_Height=40;\ntotalh=Total_Height*Units;\ntotalw=boltsize*4;\nnutdepth=(totalh-boltdepth)+0.1;\n$fn=55+0;\nin2mm=25.4+0;\nmodule bolthole()\n{\n  translate([0,0,totalh-boltdepth])\n    cylinder(h=boltdepth+.02,r=boltsize/2);\n}\nmodule nuthole()\n{\ntranslate([0,0,nutdepth/2])\n   {\n     cube(size=[nutsize,nutsize, nutdepth+.02],center=true);\n    }\n}\ntranslate([0,0,totalh])\nrotate ([180,0,0]) difference () {\n    cylinder(r=totalw/2,h=totalh,center=false);\n    bolthole();\n    nuthole();\n}",
    "description": "Okay, I'd like to design a customizable foot for electronics projects, specifically one that will hold a #6 bolt and a #6 square nut. I already have a basic version, but I need it to be parametric, and I'd like it to use a library for added flexibility in the future. I've attached the current SCAD file as `foot-round-custom.scad` for reference.\n\nHere are the key parameters I need to control:\n\n*   **Units:** I need to be able to switch between millimeters, inches, and mils.\n*   **Bolt Hole Diameter:**  This should be customizable, as I might need to use a different screw size in the future. I'm currently targeting a clearance hole for a #6 bolt, which is about 3.7mm, but I need to adjust this.\n*   **Bolt Hole Depth:** How deep the hole for the bolt goes. This needs to be adjustable to ensure the bolt engages the nut correctly.\n*   **Nut Size:** The size of the square nut (currently for a #6 nut).\n*   **Total Foot Height:** How tall the foot will be.\n\nI'd like the foot to be cylindrical, with a hole for the bolt going most of the way through, and then a square recess for the nut at the top. The square nut recess should be sized exactly for the selected nut, and the bolt hole diameter should also be adjustable, with an option to set that in mm, inches, or mils. \n\nIdeally, the new design should use the BOSL2 library, if possible, to potentially use more of its features in the future for other projects. I need to maintain the basic structure of a cylindrical foot, with the bolt hole and nut recess as in `foot-round-custom.scad` . I also need to ensure that the nut hole is cut after the bolt hole, so the cut is clean. \n\nCan you generate the OpenSCAD code for me?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Table leg clamp",
    "scad": "use <utils/build_plate.scad>\nleg_d = 34;\nleg_l = 84;\ngap = 0.5;\nclamp_h = 6;\nclamp_w = 6;\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nx = leg_l - leg_d;\nmodule ring(r,w) {\n\trotate([0,0,-45])\n\t\tintersection() {\n\t\t\tdifference() {\n\t\t\t\tcylinder(clamp_h, r+w, r+w, true, $fn=100);\n\t\t\t\tcylinder(clamp_h+1, r+gap, r+gap, true, $fn=100);\n\t\t\t}\n\t\t\ttranslate([0,0,-(clamp_h+1)/2]) {\n\t\t\t\tcube([r+w+1,r+w+1,clamp_h+1]);\n\t\t\t\trotate([0,0,45])\n\t\t\t\t\tcube([r+w+1,r+w+1,clamp_h+1]);\n\t\t\t}\n\t\t}\n}\nmodule legclamp() {\n\ttranslate([0,0,clamp_h/2]) {\n\t\ttranslate([x/2,0,0])\n\t\t\tring(leg_d/2,clamp_w);\n\t\ttranslate([-x/2,0,0])\n\t\t\trotate([0,180,0])\n\t\t\t\tring(leg_d/2,clamp_w);\n\t\ttranslate([0,(leg_d+clamp_w+gap)/2,0])\n\t\t\tcube([x+.002,clamp_w-gap,clamp_h], true);\n\t}\n}\nlegclamp();",
    "description": "Okay, so I have a problem and I'm hoping you can help me design something in OpenSCAD. I've got these two side tables, each with three legs, and when placed together, two legs from each table are right next to each other. My cat keeps tipping the tables over, so I want to make a clamp that connects the legs of the two tables together to increase stability.\n\nBasically, I need a clamp that can grab two adjacent table legs. The current tables have legs that are 34mm in diameter. When the two tables are placed next to each other, the distance between the center of these two legs is 84mm. I would like to be able to adjust these leg diameter and center-to-center distance so that the design can be used with different tables. The clamp should have two ring-like features that wrap around the legs, and some sort of connecting piece between the rings. I made something before, but I would like to generalize and improve the design. I used the following parameters in my previous design but I'm hoping you can handle this with parameters:\n\n*   `leg_d`: Diameter of the table legs (currently 34mm)\n*   `leg_l`: Center to center distance of the two legs being clamped (currently 84mm)\n*   `gap`: Gap for fitting the clamp (currently 0.5mm)\n*   `clamp_h`: Height of the clamp (currently 6mm)\n*  `clamp_w`: Width of the clamp (currently 6mm)\n\nI'd like the OpenSCAD file to be parametric so I can adjust these values as needed. I want the rings to have a reasonable thickness and to have a \"clamping\" action so that they grip the legs, so a slight negative tolerance on the ring diameter is okay. Also, I'd like to be able to specify the height and width of the clamp so that I can make the connecting piece stronger if needed.  I'd like to use the build_plate module of the `utils/build_plate.scad` library as well. I think a good way to start is to use a `ring` module to generate the clamp ring as a difference between two cylinders and an intersection with a cube and then use a `legclamp` module to put the two rings together and add a rectangle for the connecting piece.\n\nI think it would also be helpful if you could parameterize a few more things:\n*   A clamping gap percentage on the diameter of the ring so the user can control the negative tolerance of the ring inner diameter relative to `leg_d`. This should be a percentage of the leg diameter.\n*   A height offset for where to place the center of the clamp relative to the origin. This would allow me to move the clamp up or down on the table legs.\n\nPlease make the design customizable and easy to understand. Let me know if you have any questions.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Spool Holder for Replicator 2",
    "scad": "unit = 1;\nspool_width = 130;\nspool_hole_diameter = 30;\nspl_l=spool_width*unit;\nspl_d=spool_hole_diameter*unit;\n$fn=48*2;\nspl_r=spl_d/2*1;\nplt_w=spl_d*1.5*1;\nmodule plt_hld()\n{\n\tcube([34,5,spl_d]);\n\ttranslate([28-9,0,0]) cube([6,16,spl_d]);\n\ttranslate([28-9,11,0]) cube([plt_w,5,spl_d]);\n}\nmodule spl_ext()\n{\n\ttranslate([28-9+(plt_w/2)-(spl_r/5),16+5,spl_r]) rotate([270,0,0]) cylinder(5,spl_r,spl_r);\n\ttranslate([28-9+(plt_w/2)-(spl_r/5),16+5+spl_l+10,spl_r]) rotate([270,0,0]) cylinder(5,spl_r,spl_r);\n}\nmodule spl_hld()\n{\n\tunion()\n\t{\n\t\tdifference()\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\ttranslate([28-9+(plt_w/2),11,spl_r]) rotate([270,0,0]) cylinder(spl_l+15+10,spl_r,spl_r);\n\t\t\t\tspl_ext();\n\t\t\t}\n\t\t\ttranslate([28-9+(plt_w/2),0,0]) cube([spl_d,spl_l+16+25,spl_d]);\n\t\t}\n\ttranslate([28-9+(plt_w/2),11,spl_r]) rotate([270,0,0]) scale([.5,1,1]) cylinder(spl_l+15+10,spl_r,spl_r);\n\t}\n}\ntranslate([0,0,-spl_r/10]) intersection()\n{\n\tunion()\n\t{\n\t\tspl_hld();\n\t\tplt_hld();\n\t}\n\ttranslate([0,0,spl_r/10]) cube([28-9+plt_w,spl_l+16+20,spl_d-(spl_r/10*2)]);\n}",
    "description": "Okay, I'm looking to create a customizable spool holder for my MakerBot Replicator 2. I've found a good starting point with a design called \"Prm_R2_spool_holder.scad\", but it's not quite as flexible as I need it to be, and I'd like it to be more robust.\n\nSpecifically, the existing design allows for adjusting the spool width and the spool hole diameter, which is good. However, I want to add some more parameters and flexibility.\n\nHere are the specifics I'd like in my new parametric design, keeping some parameters from the existing design:\n\n*   **Spool Width:** This should still be adjustable. I need a parameter to control the distance between the vertical supports that hold the spool, like in the original.\n*   **Spool Hole Diameter:** I want to continue to be able to adjust the diameter of the hole that the spool will sit on.\n*   **Base Plate Thickness:** I need a parameter to adjust the thickness of the base plate that the support structure sits on. This wasn't adjustable in the original.\n*   **Support Arm Thickness:** I want a parameter to control the thickness of the vertical support arms that hold the spool rod.\n*   **Support Arm Height:** I need to be able to control the height of the support arms above the baseplate.\n*  **Spool Rod Diameter:** I also need a parameter to control the diameter of the rod that holds the spool, independent of the spool hole diameter. This will need to be slightly smaller than the spool hole diameter for ease of fit.\n*   **Mounting Hole Diameter:**  I want to add parameters to include mounting holes in the base plate and to control the diameter of these holes. I'll probably want two mounting holes.\n*  **Mounting Hole Placement:** I would also like to control the distance between the center of the mounting holes and the edges of the base plate.\n\nI'd like the design to be relatively robust and printable without supports. I'm comfortable with the basic OpenSCAD functions, but I'd like to take advantage of any helpful modules within the BOSL2 library. Specifically, I think some of the BOSL2 utility functions for creating fillets and rounded edges would be useful in making it look and print better.\n\nI'd like to keep the basic layout of the original design, where there is a base plate, two vertical support arms, and a rod that holds the spool. But I want all the above parameters to make it truly flexible and parametric for different types of spools and mounting situations.\n\nCould you design me a parametric OpenSCAD file that incorporates all of these features using BOSL2? I don't need the original scad file anymore, so I can just work from scratch.\n"
  },
  {
    "object": "Hey cadmonkey, make me a mouthpiece",
    "scad": "CupDiameter=12;\nCupDepth=6;\nCup_Sphere_Factor=75;\nRimWidth=6;\nRim_Radius=23;\nThroat_Radius=35;\nThroat_Diameter=35;\nBore_Diameter=8;\nFrontPipeDiameter=13;\nBack_Pipe_Diameter=95;\nMouthPieceLength=87;\nPrintingFootHeight=0;\n$fs=1;\n$fa=8;\nCupSphereFactor=Cup_Sphere_Factor/100;\nBackPipeDiameter=Back_Pipe_Diameter/10;\nRimRadius=Rim_Radius/10;\nThroatRadius=Throat_Radius/10;\nThroatDiameter=Throat_Diameter/10;\nBoreDiameter=Bore_Diameter;\nCupBottom=[ThroatDiameter/2+ThroatRadius*(0.17+CupSphereFactor*0.3),CupDepth+ThroatRadius*(0.43-CupSphereFactor*0.3)];\nCupTop=[CupDiameter/2+RimRadius*0.02,RimRadius-RimRadius*.2];\nCup45Deg=(0.5+CupSphereFactor*.15);\nCup30Deg=(0.25+CupSphereFactor*.1);\nCup60Deg=(0.75+CupSphereFactor*.1);\nCupshapePoint1=[Cup30Deg*CupTop[0]+Cup60Deg*CupBottom[0],Cup30Deg*CupTop[1]+Cup60Deg*CupBottom[1]];\nCupshapePoint2=[Cup45Deg*CupTop[0]+Cup45Deg*CupBottom[0],Cup45Deg*CupTop[1]+Cup45Deg*CupBottom[1]];\nCupshapePoint3=[Cup60Deg*CupTop[0]+Cup30Deg*CupBottom[0],Cup60Deg*CupTop[1]+Cup30Deg*CupBottom[1]];\ntranslate([0,0,MouthPieceLength+PrintingFootHeight])\nrotate ([180,0,0])\nrotate_extrude()\ndifference(){\nunion() {\npolygon( [\nCupTop,\n[CupDiameter/2+RimRadius,0],\n[CupDiameter/2+RimWidth-RimRadius,0],\n[CupDiameter/2+RimWidth,RimRadius],\n[CupTop[0]+RimWidth/2,CupTop[1]+RimWidth],\n[CupshapePoint3[0]+RimWidth/2,CupshapePoint3[1]+RimWidth*2],\n[CupshapePoint2[0]+RimWidth/2,CupshapePoint2[1]+RimWidth*2],\n[CupshapePoint1[0]+RimWidth/2,CupshapePoint1[1]+RimWidth*2],\n[FrontPipeDiameter/2,CupDepth+RimWidth*2],\n[BackPipeDiameter/2,MouthPieceLength],\n[BoreDiameter/2,MouthPieceLength],\n[ThroatDiameter/2,CupDepth+ThroatRadius],\nCupBottom,\nCupshapePoint1,\nCupshapePoint2,\nCupshapePoint3,\n]);\ntranslate([CupDiameter/2+RimRadius,RimRadius, 0])circle(RimRadius);\ntranslate([CupDiameter/2+RimWidth-RimRadius,RimRadius, 0])circle(RimRadius);\ntranslate([ThroatDiameter/2+ThroatRadius,CupDepth+ThroatRadius,0])circle(ThroatRadius);\ntranslate([BoreDiameter/2,MouthPieceLength,0]) square([10,PrintingFootHeight]);\n}\ntranslate([FrontPipeDiameter/1.4,CupDepth+RimWidth*2.5, 0])circle(RimRadius*1.5);\ntranslate([FrontPipeDiameter/1.5,CupDepth+RimWidth*3.5, 0])circle(RimRadius*1.3);\ntranslate([FrontPipeDiameter/1.6,CupDepth+RimWidth*4.5, 0])circle(RimRadius*1.1);\n}",
    "description": "Okay, I'm trying to design a customizable mouthpiece for a brass instrument, specifically something like a trumpet mouthpiece. I want to be able to adjust several parameters to fine-tune the playing characteristics.\n\nHere's what I'm looking for in this design:\n\n**Core Functionality:**\n\n*   **Parametric Design:** The design must be fully parametric so I can easily adjust dimensions like cup diameter, cup depth, rim width, etc., and re-generate the 3D model.\n*   **Rotational Extrusion:** The mouthpiece should be created via rotational extrusion of a 2D profile. This means I need a path that can be revolved to produce the 3D shape.\n\n**Key Parameters & Their Effects (Based on my existing, non-working, SCAD):**\n\n*   **`CupDiameter`**: The diameter of the cup opening. Larger diameters are better for lower ranges and produce a richer tone, while smaller diameters favor higher ranges. *Range: 10-20 units*\n*   **`CupDepth`**: How deep the cup is. Shallower cups are better for high ranges (but with less tone fullness) while deeper cups are more flexible in the low range and create a rich tone. *Range: 4-10 units*\n*   **`Cup_Sphere_Factor`**: Controls the shape of the cup, between conical and spherical. 0 is a conical cup, and 100 is a full sphere. Spherical cups are brighter, conical cups have less definition. *Range: 0-100*\n*   **`RimWidth`**: The width of the rim. Wider rims reduce pressure on the lips (improving stamina) but reduces flexibility. *Range: 4-10 units*\n*  **`Rim_Radius`**: How rounded the rim is.  Lower radii reduce stamina but increase control. More smoothed rims are common on deeper cups. It must be less than `RimWidth/2`.\n*   **`Throat_Radius`**: Radius of the throat area, controlling the smoothness of the transition. Sharper throats create a harsher, more projected tone; rounder ones make it richer.\n*   **`Throat_Diameter`**: The diameter of the throat. Larger throats give more volume but less control; smaller throats are more controllable with less volume.\n*   **`Bore_Diameter`**: The diameter of the bore (the cylindrical part after the throat). More conical backbores are richer, and cylindrical ones are brighter.\n*   **`FrontPipeDiameter`**: The diameter where the cup meets the next pipe. About 13 for a trumpet.\n*   **`Back_Pipe_Diameter`**: The diameter of the pipe where it meets the instrument. About 95 for a trumpet.\n*   **`MouthPieceLength`**: Total length of the mouthpiece. About 87 for a trumpet.\n*   **`PrintingFootHeight`**:  The height of a flat \"foot\" at the base of the mouthpiece for easier 3D printing, set to 0 for no foot.\n\n**Specific Design Elements:**\n\n*   **Cup Shape**: The cup is a complex curved shape; it's not just a cone or sphere. The `Cup_Sphere_Factor` should influence the curvature of the cup smoothly. I need to be able to have control points defining the shape.\n*   **Rim:**  I want the rim to be a rounded profile that has a specific radius. I'll need to create a couple of circles along the edge of the rim that will be used as a template to cut away.\n*   **Throat:** I also want the throat to have a smooth transition via a radius, similar to the rim. Again, I'll need a circle to act as a \"cutting template.\"\n*   **Backbore:** The backbore should taper slightly to the bore, but the bore itself is cylindrical.\n*   **Decorative Elements**: I have some simple decorative rims added as a test, but these are entirely optional.\n*   **Printing Foot:** I want a flat foot on the base for easier 3D printing.\n\n**Libraries/Frameworks:**\nI don't believe I will need any libraries, but if you think one would be needed, just let me know.\n\n**Output:**\nI need the design to output a single .scad file.\n\nCan you create an OpenSCAD file that implements this parametric mouthpiece design with all of those parameters adjustable?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Improved Customizable Sign",
    "scad": "use <write/Write.scad>\nsign_size = 0;\nmanual_length = 100;\nmanual_width = 100;\nmessage_one = \"Watch Out!\";\nfont_one_size = 48;\nmessage_one_offset_x = 40;\nmessage_one_offset_y = -30;\nmessage_two = \"We`re altering the future!\";\nfont_two_size = 32;\nmessage_two_offset_x = 0;\nmessage_two_offset_y = 5;\nFont = \"write/orbitron.dxf\";\nicon = 1;\nicon_size = 12;\nicon_rotation = 0;\nicon_offset_x = -75;\nicon_offset_y = 18;\nhole_radius = 2.5;\nemboss_style = 0;\nbuild_plate_size = sign_size;\nmanual_build_plate_length = manual_length;\nmanual_build_plate_width = manual_width;\nholeR = hole_radius;\nfont_one_scale = font_one_size/10;\nfont_two_scale = font_two_size/10;\nREP2length = 285/1;\nREP2width = 153/1;\nREP1length = 225/1;\nREP1width = 145/1;\nToMlength = 120/1;\nToMwidth = 120/1;\nheight = 5/1;\ncornerR = 15/1;\nUltimakerLength = 210/1;\nUltimakerWidth = 210/1;\nicon_rot = icon_rotation*-9;\nmain();\nicon_scale = icon_size/5;\nmodule main() {\n\tplateLength = 0;\n\tplateWidth = 0;\n\tif(build_plate_size == 0){\n\t\tassign(plateLength = REP2length - 20){\n\t\t\tassign(plateWidth = REP2width - 20){\n\t\t\t\techo(plateLength);\n\t\t\t\techo(plateWidth);\n\t\t\t\tsign(plateLength,plateWidth);\n\t\t\t}\n\t\t}\n\t}\n\tif(build_plate_size == 1){\n\t\tassign(plateLength = REP1length - 20){\n\t\t\tassign(plateWidth = REP1width - 20){\n\t\t\t\tsign(plateLength,plateWidth);\n\t\t\t}\n\t\t}\n\t}\n\tif(build_plate_size == 2){\n\t\tassign(plateLength = ToMlength - 20){\n\t\t\tassign(plateWidth = ToMwidth - 20){\n\t\t\t\tsign(plateLength,plateWidth);\n\t\t\t}\n\t\t}\n\t}\n\tif(build_plate_size == 3){\n\t\tassign(plateLength = manual_build_plate_length - 20){\n\t\t\tassign(plateWidth = manual_build_plate_width - 20){\n\t\t\t\tsign(plateLength,plateWidth);\n\t\t\t}\n\t\t}\n\t}\n\tif(build_plate_size == 10){\n\t\tassign(plateLength = UltimakerLength - 20){\n\t\t\tassign(plateWidth = UltimakerWidth - 20){\n\t\t\t\tsign(plateLength,plateWidth);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule sign(pL,pW) {\n\tplateLength = pL;\n\tplateWidth = pW;\n\ttranslate([-plateLength/2,-plateWidth/2,0])\n\tdifference(){\n\t\tif(emboss_style == 0){\n\t\t\tunion(){\n\t\t\t\ttranslate([(plateLength/2)+message_one_offset_x,plateWidth-20+message_one_offset_y,5])\n\t\t\t\t\tcolor([1,1,1])\n\t\t\t\t\t\tscale([font_one_scale,font_one_scale,5])\n\t\t\t\t\t\t\twrite(message_one,space=1.05,center = true,font = Font);\n\t\t\t\ttranslate([plateLength/2+message_two_offset_x,20+message_two_offset_y,5])\n\t\t\t\t\tcolor([1,1,1])\n\t\t\t\t\t\tscale([font_two_scale,font_two_scale,5])\n\t\t\t\t\t\t\twrite(message_two,space=1.05,center = true,font = Font);\n\t\t\t\tcolor([1,1,1]){\n\t\t\t\t\ttranslate([plateLength/2+icon_offset_x,plateWidth/2+icon_offset_y,5])\n\t\t\t\t\t\tlinear_extrude(height = 5, center = true, convexity = 10, slices = 5)\n\t\t\t\t\t\t\tscale([icon_scale,icon_scale,0]){\n\t\t\t\t\t\t\t\trotate([0,0,icon_rot]){\n\t\t\t\t\t\t\t\t\tif(icon == 0)\n\t\t\t\t\t\t\t\t\t\ttranslate([4,0,0])\n\t\t\t\t\t\t\t\t\t\tscale(.25)\n\t\t\t\t\t\t\t\t\t\tmakerbot_replicator_2();\n\t\t\t\t\t\t\t\t\tif(icon == 1)\n\t\t\t\t\t\t\t\t\t\tradiation();\n\t\t\t\t\t\t\t\t\tif(icon == 2)\n\t\t\t\t\t\t\t\t\t\tradiation_sign();\n\t\t\t\t\t\t\t\t\tif(icon == 3)\n\t\t\t\t\t\t\t\t\t\tscale(.2)\n\t\t\t\t\t\t\t\t\t\tskull_crossbones();\n\t\t\t\t\t\t\t\t\tif(icon == 4)\n\t\t\t\t\t\t\t\t\t\ttranslate([0,2,0])\n\t\t\t\t\t\t\t\t\t\tscale(.18)\n\t\t\t\t\t\t\t\t\t\thang_loose();\n\t\t\t\t\t\t\t\t\tif(icon == 5)\n\t\t\t\t\t\t\t\t\t\ttranslate([0,-1,0])\n\t\t\t\t\t\t\t\t\t\tscale(.15)\n\t\t\t\t\t\t\t\t\t\tmoney();\n\t\t\t\t\t\t\t\t\tif(icon == 6)\n\t\t\t\t\t\t\t\t\t\tbomb();\n\t\t\t\t\t\t\t\t\tif(icon == 7)\n\t\t\t\t\t\t\t\t\t\ttranslate([0,-1,0])\n\t\t\t\t\t\t\t\t\t\tscale([.8,.8,1])\n\t\t\t\t\t\t\t\t\t\tmakerbot_logo();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tunion(){\n\t\t\t\t\ttranslate([cornerR,0,0])\n\t\t\t\t\t\tcube([plateLength-cornerR*2,plateWidth,5]);\n\t\t\t\t\ttranslate([0,cornerR,0])\n\t\t\t\t\t\tcube([plateLength,plateWidth-cornerR*2,5]);\n\t\t\t\t\ttranslate([cornerR,cornerR,0])\n\t\t\t\t\t\tcylinder(h = height, r = cornerR);\n\t\t\t\t\ttranslate([cornerR+(plateLength-cornerR*2),cornerR,0])\n\t\t\t\t\t\tcylinder(h = height, r = cornerR);\n\t\t\t\t\ttranslate([cornerR,cornerR+(plateWidth-cornerR*2),0])\n\t\t\t\t\t\tcylinder(h = height, r = cornerR);\n\t\t\t\t\ttranslate([cornerR+(plateLength-cornerR*2),cornerR+(plateWidth-cornerR*2),0])\n\t\t\t\t\t\tcylinder(h = height, r = cornerR);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdifference(){\n\t\t\t\tunion(){\n\t\t\t\t\ttranslate([cornerR,0,0])\n\t\t\t\t\t\tcube([plateLength-cornerR*2,plateWidth,5]);\n\t\t\t\t\ttranslate([0,cornerR,0])\n\t\t\t\t\t\tcube([plateLength,plateWidth-cornerR*2,5]);\n\t\t\t\t\ttranslate([cornerR,cornerR,0])\n\t\t\t\t\t\tcylinder(h = height, r = cornerR);\n\t\t\t\t\ttranslate([cornerR+(plateLength-cornerR*2),cornerR,0])\n\t\t\t\t\t\tcylinder(h = height, r = cornerR);\n\t\t\t\t\ttranslate([cornerR,cornerR+(plateWidth-cornerR*2),0])\n\t\t\t\t\t\tcylinder(h = height, r = cornerR);\n\t\t\t\t\ttranslate([cornerR+(plateLength-cornerR*2),cornerR+(plateWidth-cornerR*2),0])\n\t\t\t\t\t\tcylinder(h = height, r = cornerR);\n\t\t\t\t}\n\t\t\t\tunion(){\n\t\t\t\t\ttranslate([plateLength/2+message_one_offset_x,plateWidth-20+message_one_offset_y,5])\n\t\t\t\t\t\tcolor([1,1,1])\n\t\t\t\t\t\t\tscale([font_one_scale,font_one_scale,5])\n\t\t\t\t\t\t\t\twrite(message_one,space=1.05,center = true,font = Font);\n\t\t\t\t\ttranslate([plateLength/2+message_two_offset_x,20+message_two_offset_y,5])\n\t\t\t\t\t\tcolor([1,1,1])\n\t\t\t\t\t\t\tscale([font_two_scale,font_two_scale,5])\n\t\t\t\t\t\t\t\twrite(message_two,space=1.05,center = true,font = Font);\n\t\t\t\t\tcolor([1,1,1]){\n\t\t\t\t\t\ttranslate([plateLength/2+icon_offset_x,plateWidth/2+icon_offset_y,5])\n\t\t\t\t\t\t\tlinear_extrude(height = 5, center = true, convexity = 10, slices = 5)\n\t\t\t\t\t\t\t\tscale([icon_scale,icon_scale,0]){\n\t\t\t\t\t\t\t\t\trotate([0,0,icon_rot]){\n\t\t\t\t\t\t\t\t\t\tif(icon == 0)\n\t\t\t\t\t\t\t\t\t\t\ttranslate([4,0,0])\n\t\t\t\t\t\t\t\t\t\t\tscale(.25)\n\t\t\t\t\t\t\t\t\t\t\tmakerbot_replicator_2();\n\t\t\t\t\t\t\t\t\t\tif(icon == 1)\n\t\t\t\t\t\t\t\t\t\t\tradiation();\n\t\t\t\t\t\t\t\t\t\tif(icon == 2)\n\t\t\t\t\t\t\t\t\t\t\tradiation_sign();\n\t\t\t\t\t\t\t\t\t\tif(icon == 3)\n\t\t\t\t\t\t\t\t\t\t\tscale(.2)\n\t\t\t\t\t\t\t\t\t\t\tskull_crossbones();\n\t\t\t\t\t\t\t\t\t\tif(icon == 4)\n\t\t\t\t\t\t\t\t\t\t\ttranslate([0,2,0])\n\t\t\t\t\t\t\t\t\t\t\tscale(.18)\n\t\t\t\t\t\t\t\t\t\t\thang_loose();\n\t\t\t\t\t\t\t\t\t\tif(icon == 5)\n\t\t\t\t\t\t\t\t\t\t\ttranslate([0,-1,0])\n\t\t\t\t\t\t\t\t\t\t\tscale(.15)\n\t\t\t\t\t\t\t\t\t\t\tmoney();\n\t\t\t\t\t\t\t\t\t\tif(icon == 6)\n\t\t\t\t\t\t\t\t\t\t\tbomb();\n\t\t\t\t\t\t\t\t\t\tif(icon == 7)\n\t\t\t\t\t\t\t\t\t\t\ttranslate([0,-1,0])\n\t\t\t\t\t\t\t\t\t\t\tscale([.8,.8,1])\n\t\t\t\t\t\t\t\t\t\t\tmakerbot_logo();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate([cornerR,cornerR+(plateWidth-cornerR*2),0])\n\t\t\tcylinder(h = height*4, r = holeR,center = true);\n\t\ttranslate([cornerR+(plateLength-cornerR*2),cornerR+(plateWidth-cornerR*2),0])\n\t\t\tcylinder(h = height*4, r = holeR,center = true);\n\t}\n}\nmodule radiation_sign() {\n  polygon(points=\n    [[1.129, -3.788], [0.798, -4.587], [0.000, -4.917], [-0.798, -4.587], [-1.129, -3.788], [-0.798, -2.990], [0.000, -2.660], [0.798, -2.990], [0.000, -5.482], [-0.853, -5.252], [-2.545, -8.181], [-1.339, -8.688], [0.000, -8.868], [1.339, -8.688], [2.545, -8.180], [0.854, -5.252], [1.708, -3.773], [1.707, -3.788], [5.084, -3.788], [4.921, -2.491], [4.408, -1.241], [3.582, -0.172], [2.540, 0.618], [0.857, -2.297], [1.473, -2.910], [-0.850, -2.293], [-2.540, 0.633], [-3.582, -0.156], [-4.408, -1.226], [-4.921, -2.477], [-5.084, -3.773], [-1.708, -3.773], [-1.471, -2.906], [13.832, -10.684], [0.975, 11.585], [0.535, 12.020], [0.000, 12.128], [-0.534, 12.020], [-0.975, 11.585], [-13.832, -10.684], [-13.981, -11.262], [-13.827, -11.812], [-13.432, -12.222], [-12.857, -12.383], [12.857, -12.383], [13.432, -12.222], [13.827, -11.811], [13.981, -11.262], [0.000, 8.757], [10.902, -10.125], [-10.902, -10.125]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 0, 0], [8, 9, 10, 11, 12, 13, 14, 15, 8, 8], [16, 17, 18, 19, 20, 21, 22, 23, 24, 16, 16], [25, 26, 27, 28, 29, 30, 31, 32, 25, 25], [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 33, 33], [48, 49, 50, 48, 48]]\n    );}\nmodule radiation(){\n\trad1();\n\trad2();\n\trad3();\n\trad4();\n}\nmodule rad1() {\n  polygon(points=\n    [[7.018, -11.155], [2.353, -3.148], [0.796, -3.660], [-0.117, -3.749], [-1.040, -3.660], [-2.605, -3.148], [-7.285, -11.155], [-5.350, -12.218], [-3.075, -12.948], [-0.056, -13.280], [2.932, -12.948], [5.155, -12.218]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0, 0, 0]]\n    );}\nmodule rad2() {\n  polygon(points=\n    [[-0.034, -1.810], [1.041, -1.592], [1.915, -0.998], [2.502, -0.120], [2.717, 0.953], [2.502, 2.031], [1.915, 2.913], [1.041, 3.508], [-0.034, 3.727], [-1.110, 3.508], [-1.988, 2.913], [-2.580, 2.031], [-2.797, 0.953], [-2.580, -0.120], [-1.988, -0.998], [-1.110, -1.592]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0]]\n    );}\nmodule rad3() {\n  polygon(points=\n    [[6.925, 13.117], [2.329, 5.064], [3.541, 3.977], [4.068, 3.232], [4.458, 2.369], [4.795, 0.729], [14.070, 0.739], [14.026, 2.934], [13.524, 5.263], [12.307, 8.042], [10.519, 10.471], [8.774, 12.034]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0, 0, 0]]\n    );}\nmodule rad4() {\n  polygon(points=\n    [[-14.057, 0.906], [-4.773, 0.906], [-4.445, 2.527], [-4.065, 3.372], [-3.526, 4.129], [-2.289, 5.231], [-6.898, 13.280], [-8.784, 12.138], [-10.553, 10.535], [-12.351, 8.088], [-13.559, 5.334], [-14.041, 3.047]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0, 0, 0]]\n    );}\nmodule bomb() {\n  polygon(points=\n    [[4.524, 11.943], [5.827, 12.172], [5.573, 10.404], [4.512, 9.325], [2.751, 9.059], [1.363, 9.795], [0.651, 11.207], [0.278, 11.893], [-0.435, 12.244], [-1.294, 12.113], [-1.822, 11.557], [-1.786, 9.807], [-0.483, 9.940], [0.253, 5.765], [3.952, 4.922], [6.671, 3.087], [8.621, 0.481], [9.616, -3.054], [9.581, -5.170], [9.143, -7.028], [7.504, -9.955], [5.111, -12.105], [1.833, -13.370], [-0.260, -13.535], [-2.245, -13.285], [-5.406, -11.898], [-7.750, -9.678], [-9.255, -6.662], [-9.621, -4.704], [-9.580, -2.632], [-8.458, 0.783], [-6.439, 3.310], [-3.644, 5.054], [-4.368, 9.252], [-3.077, 9.566], [-3.282, 11.026], [-2.908, 12.317], [-2.050, 13.184], [-0.797, 13.584], [0.256, 13.429], [1.061, 12.956], [1.954, 11.364], [2.447, 10.581], [3.330, 10.326], [4.273, 10.808]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 0, 0]]\n    );}\nmodule skull_crossbones() {\n  polygon(points=\n    [[-0.141, 68.518], [-8.246, 68.036], [-16.875, 66.590], [-25.281, 63.980], [-32.720, 60.007], [-32.720, 59.998], [-32.729, 59.998], [-38.887, 54.306], [-43.567, 47.249], [-46.438, 39.248], [-47.166, 30.727], [-47.157, 30.727], [-47.157, 30.718], [-46.182, 23.390], [-44.135, 16.606], [-41.131, 10.630], [-37.288, 5.724], [-38.100, 1.499], [-38.109, 1.438], [-38.109, 1.376], [-37.539, -7.221], [-36.202, -10.576], [-34.254, -13.070], [-34.254, -13.079], [-34.246, -13.079], [-34.122, -13.185], [-48.198, -6.112], [-49.915, -4.158], [-51.047, -1.914], [-52.689, 0.846], [-55.774, 3.563], [-55.906, 3.634], [-59.152, 4.639], [-61.630, 3.836], [-63.517, 1.632], [-63.623, 1.420], [-64.652, -2.617], [-64.893, -6.376], [-67.544, -8.756], [-70.220, -11.959], [-70.229, -11.968], [-71.225, -15.258], [-70.008, -17.939], [-68.001, -19.269], [-66.172, -19.835], [-66.172, -19.844], [-66.154, -19.844], [-62.319, -20.282], [-59.337, -19.949], [-54.363, -19.755], [-27.164, -32.782], [-27.172, -35.216], [-36.520, -40.073], [-46.460, -44.458], [-49.311, -44.736], [-51.496, -44.212], [-54.685, -43.799], [-59.513, -44.705], [-60.051, -44.996], [-61.668, -46.894], [-62.309, -49.150], [-61.887, -51.403], [-60.589, -53.357], [-60.545, -53.401], [-55.897, -57.829], [-55.077, -64.540], [-54.998, -64.911], [-53.409, -67.599], [-51.011, -68.897], [-48.466, -68.653], [-46.249, -67.398], [-45.949, -67.115], [-42.862, -63.244], [-42.853, -63.226], [-39.687, -58.331], [-22.419, -49.186], [-22.401, -49.177], [-18.613, -53.085], [-14.164, -55.774], [-14.129, -55.783], [-14.093, -55.800], [-7.127, -57.696], [0.256, -58.190], [7.502, -57.650], [14.314, -55.597], [18.755, -52.959], [22.569, -49.133], [39.511, -57.926], [42.483, -61.983], [43.560, -64.077], [45.473, -66.234], [45.464, -66.242], [45.579, -66.339], [47.775, -68.072], [50.112, -68.932], [52.598, -68.388], [54.574, -66.533], [54.707, -66.295], [55.976, -61.778], [56.338, -57.591], [61.251, -53.084], [61.277, -53.049], [62.573, -51.036], [62.865, -48.718], [61.804, -46.531], [59.672, -44.935], [59.540, -44.873], [55.585, -43.814], [51.091, -44.220], [51.073, -44.229], [48.795, -44.685], [46.284, -44.167], [46.284, -44.176], [27.375, -35.410], [27.367, -32.623], [27.437, -32.588], [54.010, -20.064], [54.019, -20.064], [56.508, -19.430], [58.252, -19.694], [60.457, -20.195], [63.597, -20.188], [63.641, -20.188], [66.430, -19.859], [68.923, -18.785], [70.755, -16.660], [71.322, -13.705], [71.031, -12.850], [64.981, -6.156], [64.588, -1.800], [63.341, 2.434], [63.147, 2.787], [61.544, 4.322], [59.249, 5.018], [58.922, 5.018], [56.557, 4.345], [54.169, 2.611], [54.107, 2.549], [54.019, 2.478], [51.950, 0.092], [50.808, -2.284], [47.986, -6.385], [34.784, -12.876], [36.714, -10.376], [38.039, -7.024], [38.602, 1.543], [38.594, 1.605], [38.585, 1.658], [37.650, 6.562], [41.657, 11.312], [44.858, 17.166], [46.892, 24.061], [47.395, 31.935], [47.395, 31.961], [46.202, 40.275], [43.210, 47.941], [38.470, 54.785], [32.032, 60.633], [32.014, 60.642], [26.067, 63.728], [18.415, 66.136], [3.969, 68.430], [3.969, 68.438], [3.881, 68.438], [0.926, 64.981], [3.792, 64.911], [3.836, 64.911], [3.881, 64.911], [17.524, 62.715], [24.828, 60.374], [29.924, 57.802], [29.933, 57.793], [29.942, 57.785], [35.831, 52.465], [40.123, 46.296], [42.806, 39.382], [43.868, 31.829], [43.868, 31.811], [43.868, 31.803], [43.550, 25.454], [42.127, 19.843], [39.828, 14.986], [36.883, 10.901], [36.627, 18.873], [36.636, 18.944], [36.636, 19.023], [37.775, 23.065], [39.132, 28.372], [39.132, 28.381], [39.343, 34.157], [38.659, 36.744], [37.024, 38.955], [34.695, 36.301], [35.833, 33.796], [35.621, 28.707], [35.621, 28.698], [34.350, 24.406], [33.126, 19.297], [33.108, 19.147], [33.117, 19.147], [33.502, 9.454], [35.101, 1.094], [35.101, 1.067], [34.463, -6.160], [32.394, -10.275], [32.385, -10.283], [28.849, -12.186], [25.003, -13.582], [24.968, -13.591], [24.968, -13.599], [18.362, -17.436], [18.291, -17.489], [18.230, -17.542], [15.476, -21.639], [14.737, -26.052], [8.306, -27.363], [0.415, -27.728], [0.406, -27.728], [-7.331, -27.507], [-14.252, -26.229], [-14.947, -21.915], [-17.683, -17.656], [-17.789, -17.542], [-17.912, -17.445], [-20.863, -15.338], [-24.580, -13.732], [-24.580, -13.723], [-28.681, -12.345], [-31.900, -10.451], [-31.909, -10.442], [-33.982, -6.294], [-34.598, 0.988], [-34.598, 1.023], [-33.006, 9.349], [-32.632, 18.988], [-32.623, 18.988], [-32.641, 19.129], [-33.865, 24.244], [-35.136, 28.540], [-35.348, 33.628], [-34.210, 36.133], [-36.539, 38.788], [-38.174, 36.576], [-38.858, 33.990], [-38.647, 28.213], [-38.647, 28.204], [-37.290, 22.898], [-36.151, 18.856], [-36.151, 18.785], [-36.142, 18.706], [-36.477, 10.133], [-41.369, 19.368], [-42.889, 24.948], [-43.638, 30.912], [-42.972, 38.480], [-40.383, 45.658], [-36.182, 52.015], [-30.683, 57.123], [-30.674, 57.132], [-23.675, 60.767], [-15.466, 63.200], [-6.960, 64.561], [-11.527, 17.348], [-12.859, 17.171], [-24.139, 15.646], [-27.046, 14.212], [-28.805, 12.098], [-29.522, 9.703], [-29.307, 7.426], [-26.608, 0.723], [-23.735, -2.417], [-20.849, -3.854], [-17.154, -4.077], [-13.679, -1.861], [-9.816, 3.087], [-6.747, 8.475], [-6.396, 11.497], [-7.142, 14.371], [-8.885, 16.516], [11.818, 17.348], [9.176, 16.516], [7.433, 14.371], [6.687, 11.497], [7.038, 8.475], [10.107, 3.087], [13.970, -1.861], [17.445, -4.077], [21.140, -3.854], [24.026, -2.417], [26.899, 0.723], [29.598, 7.426], [29.813, 9.703], [29.096, 12.098], [27.337, 14.212], [24.430, 15.646], [13.150, 17.171], [59.099, 1.490], [59.178, 1.490], [60.139, 0.900], [61.226, -2.939], [61.462, -6.809], [62.027, -8.202], [67.803, -14.420], [66.957, -15.857], [63.561, -16.660], [63.261, -16.686], [59.125, -16.272], [56.410, -15.965], [52.705, -16.783], [52.608, -16.827], [28.804, -28.046], [30.383, -18.970], [49.794, -9.428], [50.138, -9.207], [52.705, -6.306], [54.054, -3.660], [56.303, -0.212], [56.453, -0.079], [-59.301, 1.111], [-59.204, 1.111], [-57.564, 0.512], [-55.422, -1.330], [-54.239, -3.422], [-52.861, -6.093], [-50.315, -8.952], [-50.068, -9.119], [-30.145, -19.015], [-28.557, -28.196], [-53.119, -16.448], [-53.507, -16.316], [-57.115, -16.077], [-59.954, -16.475], [-65.307, -16.422], [-65.325, -16.422], [-67.512, -15.452], [-67.706, -15.081], [-67.230, -13.829], [-67.230, -13.820], [-61.877, -8.361], [-61.400, -7.276], [-60.413, -0.062], [-59.566, 0.979], [-0.873, -0.203], [-5.733, -5.283], [-7.585, -9.640], [-8.070, -14.129], [-7.333, -18.429], [-5.653, -19.949], [-3.677, -18.917], [-0.917, -15.981], [1.094, -0.256], [1.138, -16.034], [3.894, -18.975], [5.865, -20.011], [7.549, -18.486], [8.290, -14.182], [7.796, -9.701], [5.953, -5.345], [26.538, -16.783], [24.411, -22.627], [23.336, -28.804], [23.327, -29.042], [23.380, -29.272], [23.777, -36.398], [23.036, -40.657], [23.036, -40.675], [22.569, -42.095], [22.472, -42.342], [22.463, -42.359], [18.452, -48.278], [12.982, -52.325], [6.869, -54.204], [0.256, -54.662], [-6.523, -54.243], [-12.823, -52.511], [-12.823, -52.502], [-15.892, -50.621], [-18.817, -47.760], [-22.728, -41.037], [-22.807, -40.710], [-22.807, -40.701], [-23.574, -36.283], [-23.169, -29.272], [-23.116, -29.042], [-23.124, -28.804], [-24.183, -22.687], [-26.282, -16.898], [-25.611, -17.101], [-25.576, -17.110], [-25.541, -17.118], [-24.959, -17.286], [-21.793, -25.991], [-21.784, -26.008], [-19.870, -36.283], [-19.897, -36.301], [-19.870, -36.336], [-19.861, -36.371], [-19.835, -36.371], [-15.632, -40.079], [-10.793, -42.287], [-5.450, -43.387], [0.265, -43.771], [0.273, -43.771], [6.603, -43.352], [12.356, -41.804], [16.991, -39.376], [19.932, -36.168], [19.949, -36.168], [21.881, -25.805], [21.881, -25.788], [24.897, -17.445], [26.167, -16.916], [26.185, -16.907], [26.202, -16.898], [-22.586, -18.415], [-20.179, -20.161], [-18.169, -23.144], [-17.780, -26.158], [-17.692, -26.158], [-17.718, -26.211], [-16.492, -26.873], [-16.669, -26.873], [-16.766, -37.024], [-18.186, -35.586], [-20.099, -25.514], [-20.099, -25.506], [-20.099, -25.488], [22.401, -18.865], [20.196, -25.285], [20.188, -25.294], [20.188, -25.303], [18.256, -35.551], [16.986, -37.068], [16.871, -26.705], [18.115, -26.044], [18.089, -26.000], [18.265, -26.000], [18.698, -22.935], [20.611, -20.152], [15.478, -27.296], [15.522, -31.697], [13.026, -33.081], [13.000, -28.037], [-15.266, -27.384], [-12.850, -28.116], [-12.876, -33.055], [-15.302, -31.785], [11.589, -28.337], [11.615, -33.646], [8.766, -34.422], [8.714, -28.751], [-11.439, -28.416], [-8.617, -28.831], [-8.669, -34.448], [-11.465, -33.628], [7.302, -28.892], [7.355, -34.660], [5.036, -34.934], [5.009, -29.025], [-7.205, -28.963], [-4.798, -29.104], [-4.824, -35.057], [-7.267, -34.740], [3.598, -29.086], [3.625, -35.039], [0.900, -35.163], [0.900, -29.130], [-3.387, -29.148], [-0.512, -29.157], [-0.512, -35.198], [-3.413, -35.163], [15.540, -33.355], [15.584, -38.170], [13.061, -39.590], [13.035, -34.607], [-15.319, -33.417], [-12.885, -34.590], [-12.903, -39.599], [-15.372, -38.144], [-11.474, -35.128], [-8.687, -35.895], [-8.731, -41.037], [-11.500, -40.199], [11.624, -35.128], [11.650, -40.181], [8.819, -41.072], [8.775, -35.851], [7.364, -36.089], [7.417, -41.398], [5.071, -41.795], [5.045, -36.353], [-7.276, -36.168], [-4.833, -36.468], [-4.859, -41.680], [-7.329, -41.328], [3.634, -36.459], [3.660, -41.927], [0.900, -42.016], [0.900, -36.574], [-3.422, -36.574], [-0.512, -36.609], [-0.512, -41.980], [-3.448, -41.813], [-26.784, -38.999], [-26.246, -41.522], [-26.238, -41.548], [-26.097, -42.086], [-24.438, -46.258], [-41.698, -55.394], [-42.227, -55.827], [-45.914, -61.480], [-45.931, -61.498], [-48.507, -64.672], [-50.420, -65.422], [-51.593, -63.940], [-52.537, -56.567], [-53.022, -55.694], [-58.031, -50.923], [-58.031, -50.914], [-58.781, -49.283], [-58.031, -47.951], [-54.609, -47.276], [-52.414, -47.616], [-49.642, -48.200], [-45.499, -47.863], [-45.287, -47.801], [-35.642, -43.578], [26.978, -39.105], [44.864, -47.395], [44.926, -47.431], [48.833, -48.175], [52.096, -47.607], [52.114, -47.598], [55.206, -47.279], [58.129, -48.101], [59.381, -49.247], [58.622, -50.720], [58.596, -50.755], [53.419, -55.456], [52.899, -56.479], [52.465, -60.921], [51.576, -64.646], [50.544, -65.431], [47.845, -63.649], [47.730, -63.552], [45.693, -60.510], [44.325, -58.057], [41.707, -55.156], [41.363, -54.927], [24.544, -46.196], [26.273, -42.183], [26.326, -41.989], [26.449, -41.566], [26.449, -41.548], [26.458, -41.522], [26.458, -41.513], [26.485, -41.398]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 0, 0], [164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 164, 164], [262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 262, 262], [279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 279, 279], [296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 296, 296], [318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 318, 318], [342, 343, 344, 345, 346, 347, 348, 349, 342, 342], [350, 351, 352, 353, 354, 355, 356, 357, 350, 350], [358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 358, 358], [414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 414, 414], [427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 427, 427], [439, 440, 441, 442, 439, 439], [443, 444, 445, 446, 443, 443], [447, 448, 449, 450, 447, 447], [451, 452, 453, 454, 451, 451], [455, 456, 457, 458, 455, 455], [459, 460, 461, 462, 459, 459], [463, 464, 465, 466, 463, 463], [467, 468, 469, 470, 467, 467], [471, 472, 473, 474, 471, 471], [475, 476, 477, 478, 475, 475], [479, 480, 481, 482, 479, 479], [483, 484, 485, 486, 483, 483], [487, 488, 489, 490, 487, 487], [491, 492, 493, 494, 491, 491], [495, 496, 497, 498, 495, 495], [499, 500, 501, 502, 499, 499], [503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 503, 503], [527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 527, 527]]\n    );}\nmodule hang_loose() {\n  polygon(points=\n    [[-5.059, -96.457], [-12.154, -95.479], [-17.838, -94.735], [-25.983, -91.532], [-34.127, -88.330], [-35.322, -83.425], [-37.398, -72.452], [-38.279, -66.384], [-45.718, -52.326], [-53.157, -38.269], [-59.972, -13.380], [-67.126, 12.496], [-80.782, 30.789], [-94.099, 48.169], [-96.191, 55.218], [-98.283, 62.190], [-96.996, 65.119], [-95.708, 68.047], [-92.434, 69.190], [-89.160, 70.332], [-87.068, 69.793], [-84.488, 68.745], [-75.180, 57.793], [-50.315, 30.493], [-48.720, 34.212], [-47.323, 37.724], [-43.689, 39.388], [-40.054, 41.053], [-34.822, 40.703], [-29.590, 40.353], [-28.029, 42.017], [-22.297, 48.261], [-10.001, 51.164], [-6.683, 49.986], [-3.696, 48.925], [-2.637, 50.325], [4.471, 57.047], [10.962, 58.091], [16.954, 58.718], [23.366, 52.187], [29.778, 45.657], [34.309, 38.274], [38.840, 30.891], [39.812, 26.656], [43.624, 15.941], [48.586, 21.669], [63.251, 39.025], [65.556, 41.706], [70.606, 44.089], [80.454, 48.770], [86.251, 51.542], [90.766, 51.301], [94.752, 50.439], [97.539, 46.044], [99.857, 41.796], [98.340, 40.247], [93.060, 35.969], [89.297, 33.240], [84.684, 26.577], [76.405, 12.889], [68.147, -5.989], [63.556, -17.842], [55.584, -28.425], [39.705, -47.292], [31.011, -57.593], [30.342, -64.973], [30.481, -74.212], [30.501, -78.088], [27.114, -81.506], [10.986, -94.803], [7.881, -95.724], [-5.059, -96.457], [-0.684, -92.830], [-2.501, -83.549], [-5.194, -67.051], [-6.155, -59.329], [-6.646, -67.436], [-5.469, -87.234], [-4.918, -92.667], [-2.801, -93.054], [-9.873, -91.008], [-11.119, -78.280], [-12.330, -66.639], [-17.781, -68.203], [-28.554, -70.798], [-33.974, -72.297], [-32.473, -79.771], [-30.984, -86.668], [-20.843, -89.405], [-10.215, -92.175], [7.243, -91.214], [11.817, -90.221], [15.514, -86.644], [19.293, -82.628], [18.782, -80.495], [17.667, -68.020], [16.407, -62.392], [11.856, -63.277], [7.887, -64.029], [5.385, -62.873], [8.008, -61.109], [14.694, -60.363], [16.948, -59.530], [14.835, -59.361], [6.936, -58.907], [-0.740, -58.466], [-3.052, -59.128], [-2.821, -67.539], [-0.283, -82.612], [2.415, -92.207], [22.185, -77.041], [22.519, -66.608], [21.818, -59.305], [21.082, -59.382], [19.988, -60.945], [19.071, -62.252], [19.067, -66.012], [20.266, -75.181], [21.589, -80.470], [22.185, -77.041], [-21.145, -63.228], [-13.017, -61.274], [-10.689, -60.599], [-10.538, -61.798], [-8.893, -59.624], [-7.273, -56.250], [-8.360, -52.798], [-11.369, -46.112], [-13.290, -42.878], [-12.392, -36.428], [-10.870, -28.756], [-8.585, -23.743], [-6.925, -19.951], [-8.395, -18.371], [-9.866, -16.791], [-12.542, -18.207], [-17.980, -20.108], [-21.225, -20.180], [-29.612, -13.015], [-40.065, -4.095], [-42.617, -1.927], [-47.056, -1.222], [-51.495, -0.517], [-54.664, -1.822], [-57.898, -3.164], [-58.243, -5.159], [-58.524, -7.118], [-51.846, -28.990], [-45.168, -50.862], [-41.838, -56.083], [-38.509, -61.304], [-34.343, -63.051], [18.648, -54.804], [25.862, -54.138], [34.328, -47.532], [42.072, -41.149], [51.081, -30.022], [60.089, -18.894], [62.945, -10.183], [68.967, 4.651], [72.134, 10.774], [70.825, 11.353], [69.227, 11.932], [69.447, 12.496], [71.043, 13.061], [72.128, 13.259], [71.241, 14.372], [70.354, 15.288], [71.030, 15.431], [75.648, 16.496], [81.548, 25.479], [87.365, 34.368], [92.040, 37.755], [96.716, 41.142], [96.596, 43.034], [95.366, 46.703], [94.256, 48.479], [90.883, 48.938], [87.509, 49.397], [77.588, 44.705], [67.668, 40.013], [63.131, 34.533], [58.594, 29.053], [59.111, 28.183], [60.675, 25.552], [63.686, 18.925], [64.212, 17.593], [62.662, 18.584], [57.245, 23.105], [55.410, 25.256], [53.449, 23.321], [43.624, 9.933], [45.469, 4.524], [49.951, -4.260], [52.496, -8.067], [49.495, -5.544], [46.588, -2.918], [44.517, 1.332], [41.752, 7.131], [41.056, 8.679], [39.730, 6.284], [38.262, 0.800], [38.121, -2.289], [36.428, 0.307], [34.452, 2.831], [29.475, 0.241], [24.780, -2.278], [23.734, -4.416], [20.950, -8.472], [19.212, -10.390], [14.254, -12.152], [-2.626, -22.018], [-6.120, -25.205], [-8.059, -30.808], [-9.998, -36.855], [-3.250, -50.156], [-0.543, -54.249], [4.678, -54.699], [-15.360, -15.505], [-13.394, -13.260], [-14.691, -11.318], [-17.075, -12.016], [-18.980, -14.525], [-19.593, -16.390], [-18.252, -16.564], [-22.123, -14.808], [-18.577, -8.846], [-16.529, -6.468], [-19.356, -3.308], [-22.466, -5.513], [-26.066, -6.718], [-29.896, -6.656], [-30.882, -5.981], [-29.400, -5.441], [-23.794, -2.952], [-19.670, -0.909], [-22.032, 6.288], [-27.646, 27.828], [-29.677, 36.787], [-33.594, 37.985], [-37.295, 38.986], [-40.765, 37.956], [-44.235, 36.926], [-45.986, 34.874], [-47.737, 32.822], [-48.175, 29.559], [-48.613, 26.296], [-44.108, 12.139], [-39.546, -2.058], [-31.057, -9.053], [-22.531, -16.008], [3.034, -14.145], [5.802, -12.564], [4.517, -11.060], [1.850, -9.260], [-1.790, -9.981], [-4.048, -10.998], [-4.765, -13.151], [-5.482, -15.515], [-2.608, -15.726], [0.267, -15.726], [-7.305, -9.429], [-1.572, -6.684], [1.053, -6.365], [3.887, -7.954], [6.844, -9.420], [0.650, 3.465], [-2.317, 2.011], [-7.855, 0.031], [-12.839, 0.397], [-12.995, 1.126], [-9.656, 2.180], [0.012, 6.106], [-1.494, 11.368], [-3.374, 23.221], [-3.752, 37.458], [-3.648, 44.780], [-7.093, 47.008], [-10.539, 49.236], [-15.470, 47.974], [-20.401, 46.712], [-23.525, 43.943], [-26.650, 40.876], [-23.803, 24.632], [-20.954, 8.686], [-14.739, -0.980], [-8.343, -10.628], [13.368, -6.107], [17.749, -4.451], [16.356, -2.287], [14.677, -0.260], [8.734, -1.312], [7.159, -1.735], [6.395, -1.902], [7.357, -4.150], [9.074, -7.541], [22.252, 9.886], [24.051, 33.733], [24.404, 43.810], [27.282, 39.621], [27.635, 35.921], [27.962, 32.957], [29.564, 35.610], [31.167, 38.262], [27.729, 43.371], [24.292, 48.479], [18.961, 52.501], [13.175, 56.512], [3.585, 54.075], [1.373, 51.141], [-0.662, 48.459], [0.051, 32.528], [0.876, 16.486], [5.443, 16.151], [12.580, 14.964], [6.936, 14.042], [1.613, 13.185], [4.424, 4.327], [5.637, 2.054], [8.364, 2.856], [10.746, 3.657], [13.696, 2.499], [16.647, 1.341], [18.494, -1.258], [20.488, -3.865], [-55.321, 0.202], [-48.098, 1.213], [-44.494, 1.612], [-47.261, 5.399], [-49.920, 9.110], [-48.190, 8.660], [-46.559, 8.308], [-50.310, 17.464], [-51.484, 19.644], [-50.760, 19.545], [-49.666, 19.764], [-50.078, 21.857], [-50.386, 23.457], [-53.358, 21.598], [-58.809, 17.010], [-61.723, 13.601], [-62.500, 10.380], [-62.842, 7.840], [-61.215, 3.677], [-59.303, -0.486], [29.846, 3.827], [34.311, 5.925], [28.032, 6.416], [26.832, 6.429], [26.366, 4.594], [25.965, 2.054], [29.846, 3.827], [36.259, 9.991], [39.551, 11.895], [38.143, 18.000], [35.334, 27.587], [33.559, 31.593], [30.725, 28.460], [28.127, 25.264], [27.538, 21.810], [27.031, 18.122], [29.649, 19.414], [32.184, 20.938], [32.824, 20.337], [32.179, 17.943], [29.098, 13.484], [27.208, 9.681], [29.513, 8.944], [32.370, 8.584], [-56.334, 23.692], [-53.318, 26.633], [-57.975, 32.892], [-65.963, 39.082], [-67.039, 36.701], [-70.745, 30.327], [-73.377, 26.514], [-72.238, 23.834], [-67.535, 18.613], [-64.132, 15.648], [-61.741, 18.290], [-72.844, 32.040], [-66.724, 42.443], [-68.315, 44.491], [-73.707, 47.588], [-74.623, 47.429], [-74.201, 48.625], [-73.779, 50.160], [-76.707, 55.057], [-84.116, 63.711], [-89.213, 67.668], [-92.491, 66.292], [-95.667, 61.320], [-94.035, 54.517], [-92.230, 49.548], [-88.587, 44.610], [-84.944, 39.671], [-82.396, 40.523], [-78.436, 42.449], [-76.930, 43.092], [-79.707, 40.153], [-82.192, 38.071], [-75.415, 28.589]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 0], [72, 73, 74, 75, 76, 77, 78, 79, 72], [80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 80], [90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 90], [110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 110], [120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 120], [152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 152], [218, 219, 220, 221, 222, 223, 224, 218], [225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 225], [251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 251], [261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 261], [287, 288, 289, 290, 291, 292, 293, 294, 295, 287], [296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 296], [325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 325], [345, 346, 347, 348, 349, 350, 351, 345], [352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 352], [369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 369], [380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 380]]\n    );}\nmodule money() {\n  polygon(points=\n    [[-54.142, -63.317], [-54.142, -33.436], [-39.938, -33.436], [-39.727, -35.435], [-39.517, -41.853], [-38.936, -45.731], [-37.564, -49.159], [-35.398, -52.136], [-32.441, -54.663], [-24.149, -58.365], [-12.687, -60.266], [-12.687, -2.923], [-21.735, 3.705], [-36.913, 15.595], [-45.198, 24.117], [-48.749, 32.403], [-49.933, 43.582], [-48.999, 53.400], [-46.198, 62.126], [-41.529, 69.761], [-34.992, 76.304], [-29.646, 79.783], [-23.603, 82.328], [-16.862, 83.939], [-9.425, 84.616], [-9.425, 101.556], [0.360, 101.556], [0.360, 84.616], [17.589, 82.380], [33.924, 77.567], [33.924, 48.317], [19.720, 48.317], [19.509, 50.316], [19.194, 57.576], [17.622, 64.717], [13.959, 70.044], [8.205, 73.556], [0.360, 75.252], [0.360, 21.171], [12.144, 13.175], [23.836, 3.765], [32.188, -6.369], [37.199, -17.226], [38.451, -22.926], [38.869, -28.806], [37.988, -38.407], [35.344, -46.903], [30.938, -54.295], [24.770, -60.581], [19.292, -64.277], [12.854, -67.263], [5.456, -69.538], [-2.902, -71.103], [-2.902, -87.937], [-12.687, -87.937], [-12.687, -71.103], [-34.677, -68.473], [-2.902, -59.634], [3.411, -57.451], [7.830, -53.637], [11.224, -46.561], [12.355, -37.118], [10.934, -26.965], [6.673, -18.179], [2.649, -13.524], [-2.902, -8.815], [-10.056, 27.274], [-10.056, 74.516], [-15.948, 71.668], [-20.157, 66.914], [-22.682, 60.252], [-23.524, 51.684], [-22.682, 44.753], [-20.157, 38.374], [-15.948, 32.548]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 0], [57, 58, 59, 60, 61, 62, 63, 64, 65, 57], [66, 67, 68, 69, 70, 71, 72, 73, 74, 66]]\n    );}\nmodule makerbot_replicator_2() {\n  polygon(points=\n    [[-81.295, 41.859], [-80.882, 42.857], [-76.064, 47.675], [-75.066, 48.088], [-31.115, 48.088], [42.455, 48.088], [43.453, 47.675], [48.271, 42.857], [48.684, 41.860], [48.684, -47.468], [48.271, -48.466], [43.453, -53.284], [42.455, -53.697], [-75.066, -53.697], [-76.064, -53.284], [-80.882, -48.466], [-81.295, -47.468], [-2.326, -18.073], [-24.840, -40.588], [-25.774, -41.212], [-26.875, -41.431], [-62.903, -41.431], [-64.004, -41.212], [-64.937, -40.588], [-68.344, -37.181], [-68.968, -36.248], [-69.187, -35.146], [-69.187, 30.571], [-68.968, 31.672], [-68.344, 32.606], [-64.937, 36.012], [-64.004, 36.636], [-62.903, 36.855], [30.292, 36.855], [31.393, 36.636], [32.326, 36.012], [35.733, 32.606], [36.357, 31.672], [36.576, 30.571], [36.576, -14.799], [36.350, -15.919], [35.733, -16.833], [34.818, -17.450], [33.698, -17.676], [-1.367, -17.676], [33.781, -35.058], [31.846, -35.860], [0.123, -35.860], [-0.942, -35.645], [-1.812, -35.058], [-2.399, -34.188], [-2.614, -33.123], [-2.614, -22.399], [-2.399, -21.334], [-1.812, -20.464], [-0.942, -19.877], [0.123, -19.662], [22.731, -19.662], [31.846, -19.662], [33.781, -20.464], [35.379, -22.062], [36.181, -23.997], [36.181, -31.525], [35.379, -33.460]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 0], [17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 17, 17], [45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 45]]\n    );}\nmodule makerbot_logo() {\n  polygon(points=\n    [[0.001, 17.388], [-1.745, 17.300], [-3.456, 17.044], [-5.132, 16.621], [-6.764, 16.021], [-9.709, 14.425], [-12.293, 12.300], [-14.419, 9.716], [-16.015, 6.770], [-16.615, 5.138], [-17.038, 3.463], [-17.294, 1.752], [-17.382, 0.005], [-17.294, -1.741], [-17.038, -3.461], [-16.615, -5.136], [-16.015, -6.768], [-14.419, -9.713], [-12.293, -12.298], [-9.709, -14.432], [-6.764, -16.019], [-5.132, -16.619], [-3.456, -17.042], [-1.745, -17.298], [0.001, -17.386], [1.747, -17.298], [3.458, -17.042], [5.134, -16.619], [6.765, -16.019], [9.711, -14.432], [12.295, -12.298], [14.421, -9.713], [16.017, -6.768], [16.608, -5.136], [17.040, -3.461], [17.296, -1.741], [17.384, 0.005], [17.296, 1.752], [17.040, 3.463], [16.608, 5.138], [16.017, 6.770], [14.421, 9.716], [12.295, 12.300], [9.711, 14.425], [6.765, 16.021], [5.134, 16.621], [3.458, 17.044], [1.747, 17.300], [0.001, 14.972], [3.017, 14.672], [5.830, 13.799], [8.370, 12.414], [10.584, 10.589], [12.410, 8.375], [13.794, 5.835], [14.668, 3.022], [14.967, 0.005], [14.668, -3.020], [13.794, -5.824], [12.410, -8.373], [10.584, -10.587], [8.370, -12.412], [5.830, -13.797], [3.017, -14.670], [0.001, -14.970], [-3.015, -14.670], [-5.829, -13.797], [-8.369, -12.412], [-10.582, -10.587], [-12.408, -8.373], [-13.793, -5.824], [-14.666, -3.020], [-14.966, 0.005], [-14.666, 3.022], [-13.793, 5.835], [-12.408, 8.375], [-10.582, 10.589], [-8.369, 12.414], [-5.829, 13.799], [-3.015, 14.672], [-4.700, 11.418], [-5.661, 11.330], [-6.543, 11.065], [-7.354, 10.624], [-8.078, 10.007], [-8.686, 9.266], [-9.110, 8.463], [-9.374, 7.581], [-9.453, 6.629], [-9.453, -8.126], [-9.312, -9.008], [-8.880, -9.696], [-8.210, -10.146], [-7.363, -10.296], [-6.481, -10.146], [-5.793, -9.696], [-5.344, -9.008], [-5.203, -8.126], [-5.203, 7.132], [-2.098, 7.132], [-2.098, -8.126], [-1.957, -9.008], [-1.534, -9.696], [-0.872, -10.146], [0.001, -10.296], [0.865, -10.146], [1.535, -9.696], [1.959, -9.008], [2.100, -8.126], [2.100, 7.132], [5.196, 7.132], [5.196, -8.126], [5.345, -9.008], [5.795, -9.696], [6.483, -10.146], [7.356, -10.296], [8.212, -10.137], [8.882, -9.678], [9.314, -8.990], [9.455, -8.126], [9.455, 6.629], [9.367, 7.581], [9.111, 8.463], [8.679, 9.266], [8.079, 10.007], [7.347, 10.624], [6.545, 11.065], [5.663, 11.330], [4.702, 11.418]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 0, 0], [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 48, 48], [80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 80, 80]]\n    );}",
    "description": "Okay, I'd like to design a customizable sign, similar to the one Makerbot had back in the day. I want to be able to set the overall size of the sign, either by choosing from some common 3D printer build plate sizes (like the Makerbot Replicator 2, the Replicator 1, the Thing-o-Matic, and the Ultimaker) or by specifying a length and width manually. \n\nThen, I need to put some text on the sign, and be able to adjust things like the text content, font size, and the x and y offset for each line of text. I'd like to be able to specify which font I use, maybe have a few to choose from, like a basic one, a futuristic one, and maybe a fancy one. I'd like to have the text be embossed, and give me the option to have raised or cut-out text.\n\nFinally, I'd like to add an icon to the sign, and be able to select which one I want to use. I'm thinking of things like a radiation symbol, skull and crossbones, a \"hang loose\" hand, a money symbol, a bomb, or maybe even the old Makerbot logo. I'd need to control the size and rotation of the icon, as well as its position. And, it would be nice to have options to include mounting holes - either none, small or big holes in the corners.\n\nSo, to summarize, I'd like to be able to control:\n*   **Sign Size**: Choose from presets or specify manual length and width.\n*   **Text**: Two lines of text, with control over content, font size, x/y offsets, and a choice of a few fonts. Option to emboss the text with either a raised or cut-out effect.\n*   **Icon**: Choose from a list of icons (radiation, skull & crossbones, etc), and control size, rotation, and x/y offset.\n*   **Mounting Holes**: Option to include none, small or big holes.\n\nFor the text, I'd like it to use the `write` library, which I know has some nice options for displaying text, and I'd like it to be parametrically designed so that all these options I just listed are customizable.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Cylindrical Spacer",
    "scad": "h_measurement = 20;\nha_measurement = 0;\nD1_measurement = 10;\nD1a_measurement = 0;\nD2_measurement = 5;\nD2a_measurement = 0;\ndifference(){\ntranslate([0,0,0]) cylinder(h_measurement+ha_measurement, D1_measurement+D1a_measurement, D1_measurement+D1a_measurement, center=true);\ntranslate([0,0,0]) cylinder(h_measurement*2, D2_measurement+D2a_measurement, D2_measurement+D1a_measurement, center=true);\n}",
    "description": "Okay, I'm trying to design a simple cylindrical spacer, and I'd like to be able to customize its dimensions easily using parameters. I need an OpenSCAD file that lets me specify the following:\n\n1.  **Overall Thickness (Height):**  I need to be able to set the total thickness of the spacer. This will be a linear dimension along the Z-axis.\n2.  **Outer Diameter:** I need to specify the diameter of the outer cylinder of the spacer.\n3.  **Inner Diameter (Hole):** I need to specify the diameter of the through-hole in the center of the spacer.\n\nIt would be great if I could also include small fractional adjustments for all three of those, like `0.1`, `0.2` and so on up to `0.9`. I would like a way to make fine-tuning adjustments to the thickness, outer diameter, and inner diameter independently.\n\nI need the spacer to be a standard right circular cylinder with the hole also centered on the same axis. \n\nI'm not familiar enough with OpenSCAD to write this from scratch so please generate the SCAD file that I can then load in the Customizer app and adjust. I do not need any external library dependencies. Just basic OpenSCAD functionality. Thank you!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Ear Plug",
    "scad": "type     = 2;\npart     = 0;\ndiameter = 10;\nweight   = 11;\ngroove   = 1;\nedges    = 1;\ncursor   = 100;\nmargin   = 0.1;\n$fn = 50;\nmodule Curve(p1, p2, cursor, steps = 5, filled = true)\n{\n\tstepsize1 = (cursor - p1) / steps;\n\tstepsize2 = (p2 - cursor) / steps;\n\tfor (i = [0:steps - 1])\n\t{\n\t\tassign(point1 = p1 + stepsize1 * i)\n\t\tassign(point2 = cursor + stepsize2 * i)\n\t\tassign(point3 = p1 + stepsize1 * (i + 1))\n\t\tassign(point4 = cursor + stepsize2 * (i + 1))\n\t\t{\n\t\t\tassign(bpoint1 = point1 + (point2 - point1) * (i / steps))\n\t\t\tassign(bpoint2 = point3 + (point4 - point3) * ((i + 1) / steps))\n\t\t\t\tpolygon(points = [bpoint1, bpoint2, filled ? p1 : cursor]);\n\t\t}\n\t}\n}\nmodule plug(w = weight, d = diameter, g = groove, e = edges)\n{\n\tr = (d / 2) + g;\n\tp1 = [-e, 0];\n\tp2 = [0, e];\n\tp3 = [0, w - e];\n\tp4 = [-e, w];\n\tc1 = [0, 0];\n\tc2 = [-g * 2, w / 2];\n\tc3 = [0, w];\n\trotate_extrude($fn = 180)\n\t\ttranslate([r, 0, 0])\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tCurve(p1, p2, c1, 10, true);\n\t\t\t\tCurve(p2, p3, c2, 40, false);\n\t\t\t\tCurve(p3, p4, c3, 10, true);\n\t\t\t\tpolygon(points=[p1, p2, c2, p3, p4, [-r, w], [-r, 0]]);\n\t\t\t}\n}\nfunction percent(x, y) = ((y) / 100) * x;\nmodule hollowed_plug()\n{\n\td = percent(cursor, diameter - 3);\n\tdifference()\n\t{\n\t\tplug();\n\t\tif (d > 2)\n\t\t{\n\t\t\ttranslate([0, 0, -edges])\n\t\t\t\tplug(weight + (2 * edges), d);\n\t\t}\n\t}\n}\nmodule parametric_star(N = 5, h = 3, ri = 15, re = 30)\n{\n\tmodule tipstar(n)\n\t{\n\t\ti1 = [ri*cos(-360*n/N+360/(N*2)), ri*sin(-360*n/N+360/(N*2))];\n\t\te1 = [re*cos(-360*n/N), re*sin(-360*n/N)];\n\t\ti2 = [ri*cos(-360*(n+1)/N+360/(N*2)), ri*sin(-360*(n+1)/N+360/(N*2))];\n\t\tpolygon([ i1, e1, i2]);\n\t}\n\tlinear_extrude(height = h)\n\t\tunion()\n\t\t{\n\t\t\tfor (i=[0:N-1])\n\t\t\t\ttipstar(i);\n\t\t\trotate([0,0,360/(2*N)])\n\t\t\t\tcircle(r=ri+ri*0.01,$fn=N);\n\t\t}\n}\nmodule star_plug()\n{\n\td      = percent(cursor, (diameter / 2) - 1.5);\n\thalf_d = d / 2;\n\tif (part == 0)\n\t{\n\t\tdifference()\n\t\t{\n\t\t\tplug();\n\t\t\ttranslate([0, 0, -0.01])\n\t\t\t\tparametric_star(5, weight + 0.02, half_d, d);\n\t\t}\n\t}\n\telse parametric_star(5, weight, half_d - margin, d - margin);\n}\nmodule heart(s = 10, h = 10)\n{\n\ths= s / 2;\n\tqs= s / 4;\n\tp1 = [-hs, 0];\n\tp2 = [0, -3 * qs];\n\tp3 = [hs, 0];\n\tp4 = [(qs * cos(30)) - qs, qs * sin(30)];\n\tp5 = [(qs * cos(150)) + qs, qs * sin(150)];\n\tc1 = [-hs, -qs];\n\tc2 = [hs, -qs];\n\tc3 = [0, qs * sin(150) / 2];\n\ttranslate([0, qs, 0])\n\t\tlinear_extrude(height = h)\n\t\t\tunion()\n\t\t\t{\n\t\t\t\ttranslate([-qs, 0, 0])\n\t\t\t\t\tcircle(qs, $fn = 50);\n\t\t\t\ttranslate([qs, 0, 0])\n\t\t\t\t\tcircle(qs, $fn = 50);\n\t\t\t\tCurve(p1, p2, c1, 20, true);\n\t\t\t\tCurve(p2, p3, c2, 20, true);\n\t\t\t\tCurve(p4, p5, c3, 20, false);\n\t\t\t\tpolygon(points = [p1, p2, p3]);\n\t\t\t\tpolygon(points = [p4, c3, [0, 0]]);\n\t\t\t\tpolygon(points = [p5, c3, [0, 0]]);\n\t\t\t}\n}\nmodule heart_plug()\n{\n\td      = percent(cursor, diameter / 1.414);\n\thalf_d = d / 2;\n\ty      = ((half_d * 1.414) - half_d) / 3;\n\tif (part == 0)\n\t{\n\t\tdifference()\n\t\t{\n\t\t\tplug();\n\t\t\ttranslate([0, -y, -0.01])\n\t\t\t\theart(d, weight + 0.02);\n\t\t}\n\t}\n\telse heart(d - margin, weight);\n}\nmodule negative_sign_plug()\n{\n\td = percent(cursor, diameter - 3);\n\tif (part == 0)\n\t{\n\t\tdifference()\n\t\t{\n\t\t\tplug();\n\t\t\ttranslate([0, 0, -0.01])\n\t\t\t\tnegative_sign(d, weight + 0.02);\n\t\t}\n\t}\n\telse negative_sign(d - margin, weight);\n}\nmodule positive_sign(d, w)\n{\n\tnegative_sign(d, w);\n\trotate([0, 0, 90])\n\t\tnegative_sign(d, w);\n}\nmodule positive_sign_plug()\n{\n\td = percent(cursor, diameter - 3);\n\tif (part == 0)\n\t{\n\t\tdifference()\n\t\t{\n\t\t\tplug();\n\t\t\ttranslate([0, 0, -0.01])\n\t\t\t\tpositive_sign(d, weight + 0.02);\n\t\t}\n\t}\n\telse positive_sign(d - margin, weight);\n}\nif (type == 1)      hollowed_plug();\nelse if (type == 2) star_plug();\nelse if (type == 3) heart_plug();\nelse if (type == 4) negative_sign_plug();\nelse if (type == 5) positive_sign_plug();\nelse                plug();",
    "description": "Okay, I'm looking to get a custom earplug design created in OpenSCAD. I have a basic idea but need something that's parametric and easy to adjust for different sizes and shapes.\n\nHere's what I need:\n\n**Core Functionality:**\n\n*   **Basic Plug Shape:** The earplug should start with a rounded, roughly cylindrical shape that tapers slightly at both ends. Think of a typical earplug shape.\n*   **Customizable Dimensions:** I need to be able to control the overall diameter (ear hole size in mm) and the length or height of the plug (also in mm).\n*   **Groove:** I need a way to control a small groove or indentation around the main cylinder shape. This should be adjustable in size.\n*   **Smoothing:** A parameter for smoothing the curves/edges is needed.\n*   **Decoration Options:** Instead of a plain plug, I want to be able to add an inner shape or a cut-out from the basic cylinder. The overall plug shape remains intact, but the details will change\n*   **Decoration Size:** I need to control the size of the cut-out or inner shape. I would prefer it if it was specifiable as a percentage of the overall plug diameter.\n*  **Margin:** When the cut-out decoration is present, I also need a parameter to control the space between the outer plug and the decoration itself. This will allow for dual-extrusion printing.\n*   **Resolution:** A resolution control would be nice, something like the `$fn` parameter in OpenSCAD, to adjust the smoothness of curves.\n\n**Specific Shape Options (type):**\n\nI need the following options for the central cut-out/decoration:\n\n*   **Solid:**  A simple, filled plug with no cut-out or inner shape (the basic plug shape).\n*   **Hollowed:** This option should create a smaller, hollowed-out plug shape within the main plug.\n*   **Star:** A 5-pointed star shape as the cut-out or inner part.\n*   **Heart:**  A heart shape as the cut-out or inner part.\n*   **Negative Sign:** A minus sign shape as the cut-out or inner part.\n*   **Positive Sign:** A plus sign shape as the cut-out or inner part.\n\n**Dual Extrusion Support:**\n\nIt should be possible to use the design for dual-extrusion 3D printing. When this is used, the decoration and plug body should be separate objects. To achieve this, I should be able to change the value of the \"margin\" parameter to specify the gap between the main plug body and the decorative element. In this situation the margin must be set to 0 for the output of multiple STLs.\n\n**Parameters:**\n\nHere's a summary of the parameters I need:\n\n*   `type`: Integer parameter to choose the plug style (0: Solid, 1: Hollowed, 2: Star, 3: Heart, 4: Negative Sign, 5: Positive Sign).\n*  `part`: Integer parameter to choose between rendering the Plug (0) or Decoration (1).\n*   `diameter`: (mm) Overall diameter of the plug.\n*   `weight`: (mm) Height or length of the plug.\n*   `groove`: (mm) Size of the groove/indentation.\n*   `edges`: (mm) Smoothing factor for curves and edges.\n*   `cursor`: (%) Size of the inner shape or cutout (as a percentage of the diameter).\n*   `margin`: (mm) Space between the inner shape and the outer plug.\n*   `$fn`: Resolution setting for smoothness of curves.\n\n**Code Structure:**\n\nI'm assuming you can write the whole thing in a single OpenSCAD file, so I won't be specifying functions/modules in a particular library. I will not need any libraries like MCAD, BOSL, or similar.\n\nCan you generate an OpenSCAD file that implements this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Key / Luggage or anything else tag",
    "scad": "include <utils/build_plate.scad>\ninclude <write/Write.scad>\nuse <Write.scad>\nline1=\"line1\";\nline2=\"line2\";\nFont = \"write/orbitron.dxf\";\n textT=5;\nlength = 100 ;\nwidth = 50 ;\nradius = 15 ;\ntagThickness = 10 ;\nindent=5;\ntagH=20 ;\nedge=5 ;\nholeRad=5 ;\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nmodule tag(length,width,radius,thickness, tagH) {\n\t\thull(){\n\t\t\ttranslate(v = [length/2-radius,width/2-radius ,0 ]) { cylinder(h = thickness, r1 =radius , r2 =radius , center = true); }\n\t\t\ttranslate(v = [-(length/2-radius),width/2-radius ,0 ]) { cylinder(h = thickness, r1 =radius , r2 =radius , center = true); }\n\t\t\ttranslate(v = [-(length/2-radius),-(width/2-radius) ,0 ]) { cylinder(h = thickness, r1 =radius , r2 =radius , center = true); }\n\t\t\ttranslate(v = [length/2-radius,-(width/2-radius) ,0 ]) { cylinder(h = thickness, r1 =radius , r2 =radius , center = true); }\n\t\t\ttranslate(v = [length/2+tagH-radius,0 ,0 ]) { cylinder(h = thickness, r1 =radius , r2 =radius , center = true);  }\n\t\t}\n\t   }\nmodule RRect(length,width,radius,thickness) {\n\t\thull(){\n\t\t\ttranslate(v = [length/2-radius,width/2-radius ,0 ]) { cylinder(h = thickness, r1 =radius , r2 =radius , center = true); }\n\t\t\ttranslate(v = [-(length/2-radius),width/2-radius ,0 ]) { cylinder(h = thickness, r1 =radius , r2 =radius , center = true); }\n\t\t\ttranslate(v = [-(length/2-radius),-(width/2-radius) ,0 ]) { cylinder(h = thickness, r1 =radius , r2 =radius , center = true); }\n\t\t\ttranslate(v = [length/2-radius,-(width/2-radius) ,0 ]) { cylinder(h = thickness, r1 =radius , r2 =radius , center = true); }\n\t\t}\n\t   }\nbottomOfIndent=(tagThickness/2)-indent;\nmodule makeTag(){\ndifference() {\n\ttag(length,width,radius, tagThickness,tagH);\n\tunion() {\n\ttranslate(v = [length/2+tagH-radius,0 ,0 ]) { cylinder(h = tagThickness*2, r1 =holeRad , r2 =holeRad , center = true);  }\n\ttranslate(v = [0,0 , bottomOfIndent+indent/2+.5]) {\n\tRRect(length-2*edge,width-2*edge,radius-edge/2,indent+1);\n\t}}}}\nmodule WriteText(){\nindentWidth=width - (edge * 2) ;\ntextH=indentWidth/4;\ntranslate([0,(textH/2) +1/8*indentWidth   ,bottomOfIndent+textT/2-.5])\nwrite(line1,t=textT+1,h=textH+1,center=true,font=Font);\ntranslate([0,-((textH/2) +1/8*indentWidth)   ,bottomOfIndent+textT/2-.5])\nwrite(line2,t=textT+1,h=textH+1,center=true,font=Font);\n}\ntranslate ([0,0,tagThickness/2]) makeTag();\ntranslate ([0,0,tagThickness/2])\tWriteText();",
    "description": "Okay, I'd like to design a customizable key tag, luggage tag, or something similar, in OpenSCAD. I have a basic version, but I want to expand on it.\n\nThe current version, called `customizer_keytag_0.4.scad`, uses the `build_plate.scad` and `Write.scad` libraries and generates a tag with two lines of text. It looks like a rounded rectangle with a hole on one end and an indented area in the middle where the text is written. I want to make the text area more flexible and allow for more lines of text.\n\nHere's a breakdown of the existing parameters I'd like to keep and some changes Im requesting, and please add a couple more:\n\n**Existing Parameters (Keep and Modify if Necessary):**\n\n*   **`line1` and `line2`:** These define the text for the two lines. I want to be able to add more lines of text.\n*   **`Font`:**  The font for the text (currently set to \"write/orbitron.dxf\"). I like that I can select from dxf fonts.\n*   **`textT`:** The height of the text, needs to stay as a single parameter used for all lines of text.\n*   **`length`:** Overall tag length.\n*   **`width`:** Overall tag width.\n*   **`radius`:** The corner radius of the tag.\n*   **`tagThickness`:** The overall thickness of the tag.\n*   **`indent`:** The depth of the indented area for text.\n*   **`tagH`:**  The extension of the tag that adds an area for the hole.\n*  **`edge`:** The thickness of the edge surrounding the recessed area.\n*  **`holeRad`:** The radius of the hole.\n\n**Requested Changes and Additions:**\n\n*   **Multiple Lines of Text:** Instead of just `line1` and `line2`, I'd like to have a list of text strings, let's call this `textLines`.  The number of lines should be flexible, so it can be 1, 2, 3, or even more. Each line of text should be centered horizontally within the indented area, and each line should be equally spaced vertically.\n\n*  **Text Alignment:** It would be good to have a parameter that determines if the text is left-aligned, centered, or right-aligned within the recessed text area (e.g. `textAlignment = [\"left\", \"center\", \"right\"];`).\n\n* **Line Spacing**: I would like to add a `lineSpacing` parameter to control the vertical distance between lines of text. The default value should be similar to the current spacing.\n\n*  **Recessed Area Height**: Add a parameter called `recessedHeight` to allow the user to define the height of the recessed area instead of it being derived from the other parameters. We can maintain the current auto-calculation as the default value.\n\n*   **File Names**:  Please name this new design something like `customizable_keytag_v2.scad`, and please use the same file names for the included libraries (`build_plate.scad` and `Write.scad`).\n\n**Overall Goal:**\n\nThe main goal is to have a highly customizable key tag design that allows for a variable number of text lines, adjustable line spacing, and the ability to change alignment, while maintaining the core features and parameters of the original design.\n\nI want the design to be parametric, so all values are easily adjustable through the customizer.\n\nLet me know if you have any questions!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Horizontal Wall Test (Customizable)",
    "scad": "_1_start = 0.0;\n_2_increment = 0.05;\n_3_end = 1;\n_4_width = 4;\n_5_height = 6;\nmodule layerTest(start, increment, end, width, length) {\n\tcount = round((end-start)/increment)+1;\n\tradius = width/3;\n\teps = 0.1;\n\tunion() {\n\t\tfor (index = [0:count-1]) {\n\t\t\tassign (h = start + increment * index) {\n\t\t\t\techo(h);\n\t\t\t\tif (h > 0) {\n\t\t\t\t\ttranslate([index * width,0,0]) {\n\t\t\t\t\t\tdifference() {\n\t\t\t\t\t\t\tcube(size=[width+eps, length + (index-1)%10, h]);\n\t\t\t\t\t\t\tif (index%10 == 0) {\n\t\t\t\t\t\t\t\ttranslate([width/2,0,0]) {\n\t\t\t\t\t\t\t\t\tcylinder(r=radius, h=end*3, center=true, $fn=30);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (index%2 == 0) {\n\t\t\t\t\t\t\t\ttranslate([width/2,0,0]) {\n\t\t\t\t\t\t\t\t\tcylinder(r=radius/2, h=end*3, center=true, $fn=30);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nlayerTest(_1_start,_2_increment,_3_end,_4_width,_5_height);",
    "description": "Okay, I need to design a test print for my 3D printer, specifically to dial in the horizontal wall thickness. I'm using an Afinia H480 and have some Octave Gray Blue ABS filament. I've been using a modified version of a design I found online, but I want something more flexible and parameterized that I can easily adjust.\n\nBasically, I want to create a series of small wall samples, each with a slightly increasing thickness. These samples should be arranged side-by-side. Each sample should have a consistent length, but the length should also be parameterizable.\n\nHere are the key parameters I need:\n\n*   **Start Thickness:** The thickness of the very first sample (e.g., 0mm).\n*   **Thickness Increment:** The amount by which the thickness increases between each subsequent sample (e.g., 0.05mm).\n*   **End Thickness:** The maximum thickness of the last sample (e.g., 1mm).\n*   **Sample Width:** The width of each individual wall sample (e.g., 4mm).\n*   **Sample Length:** The length of each individual wall sample (e.g., 6mm).\n\nI also want to add some visual indicators so I can easily tell which sample is which. I want to make it so that every 10th sample has a larger cylindrical hole through it, and then every even sample (but not every tenth) has a smaller cylindrical hole through it. The cylinders should not be going all the way through each sample, but should go some distance (e.g. 3 * maximum thickness or something) to make them easily visible.  \n\nI'd like the design to be parametric using OpenSCAD, so I can easily adjust all those parameters. I want to define each of those parameters as variables at the top, so I don't have to go digging through the code to change them. Can you create a parametric OpenSCAD file that does this?  I'm not using any special libraries right now, so I don't have any dependencies I need you to include.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Huge Whistle Collection (Full Audio Fun Set)",
    "scad": "use<write.scad>\ndicke  =   2;\nbreite =   6;\nball   =   3;\nbuffer =   0;\ntexth  =   1;\ndotext =   false;\ndortxt =   false;\ndohold =   flase;\ndostay =   false;\ntranslate([0,  0.0,  0]) pfeife(\"\", 0.0, 40, 15, 35, true);\ntranslate([0,  5.0, 15]) pfeife(\"\", 0.0, 30, 15, 30, true);\ntranslate([0,  7.5, 30]) pfeife(\"\", 0.0, 25, 15, 25, true);\ntranslate([0, 10.0, 45]) pfeife(\"\", 0.0, 20, 15, 20, true);\nmodule pfeife(name,sizename,rad,hoehe,laenge, doball)\n{\n  if (dohold) rotate([90,0,0]) translate([-rad/2+0.1,hoehe/2,0])\n    scale([15/hoehe,1,1]) halter(hoehe);\n  if (dotext) rotate([0,0,0])  translate([0,0,hoehe]) texter(name, sizename);\n  if (dortxt)\n  {\n    writecylinder(name,[0,0,0],t=3,h=8,font=\"letters.dxf\",\n      space=1.0, rad/2+1,hoehe,face=\"top\");\n  }\n  difference()\n  {\n    union()\n    {\n      color([1,0,0,1]) translate([0,0,0]) cylinder(hoehe, r=rad/2, $fn = 35);\n      color(\"green\") translate([0,rad/2-breite,0]) cube([laenge,breite,hoehe]);\n      color(\"green\") translate([0,0,0]) cube([rad/2,rad/2,hoehe]);\n\t}\n    translate([0,0,dicke]) cylinder(hoehe-dicke*2+buffer, r=rad/2-dicke, $fn = 25);\n    translate([0,rad/2-breite+dicke,dicke])\n      cube([laenge+dicke,breite-dicke*2,hoehe-dicke*2+buffer]);\n    if (rad > 39)\n      translate([0,0,0]) cylinder(hoehe, r=(rad-25)/2-dicke, $fn = 25);\n    translate([dicke*5,rad/2-dicke/3,dicke]) rotate([0,0,150])\n      cube([dicke*5,dicke*2,hoehe-2*dicke]);\n    translate([4,rad/2-7.5,dicke]) rotate([0,0,0])\n      cube([rad/8,10,hoehe-2*dicke]);\n  }\n  if (dostay)\n    color(\"black\") translate([-rad/6,-rad/2,0]) cube([rad/3,dicke,hoehe]);\n  if (rad > 39)\n  {\n    difference() {\n      translate([0,0,dicke]) cylinder(hoehe-dicke*2, r=(rad-25)/2, $fn = 35);\n      translate([0,0,dicke]) cylinder(hoehe-dicke*2, r=(rad-25)/2-dicke, $fn = 25);\n    }\n  }\n  if (doball)\n  {\n    color(\"red\") translate([0,rad/2-7.5,dicke]) cylinder(1, r=1, $fn = 10);\n    difference()\n    {\n      color(\"red\") translate([0,rad/2-7.5,dicke+ball+1+1]) sphere(ball+1, $fn=25);\n      color(\"red\") translate([0,rad/2-7.5,dicke+ball+1+1]) sphere(ball, $fn=25);\n    }\n  }\n}\nmodule texter(gotname=\"NIS\", sizename=11)\n{\n  color([1,1,1])   translate([0.5,2,0]) rotate([0,0,40])\n    write(gotname,t=3,h=sizename,font=\"letters.dxf\", space=0.90, center=true);\n}\nmodule halter(hoehe)\n{\n  difference()\n  {\n    union()\n    {\n      color(\"red\") translate([0,0,-dicke]) cylinder(dicke*2, r=hoehe/2, $fn = 25);\n\t}\n    translate([0,0,-dicke]) cylinder(hoehe-dicke*2, r=hoehe/2-dicke*hoehe/15, $fn = 25);\n    translate([0,-hoehe,-dicke]) cube([hoehe,hoehe*2,dicke*2]);\n  }\n}",
    "description": "Okay, I'm looking to design a customizable whistle, and I've found this existing design that's pretty close to what I want. It's based on a parametric OpenSCAD file, and I want to refine it further. The existing file is called `3er_pfeife_v27_round.scad` and is based on this Thingiverse design: http://www.thingiverse.com/thing:41915\n\nHere's what I like and what I'd like to change or add:\n\n**Existing Features I Want to Keep (and make sure they are still parametric):**\n\n*   **Basic Whistle Shape:** The core design is a cylinder with a blowing slot cut into it, and an internal sphere that helps create the whistle sound.\n*   **Multiple Whistle Sizes:**  The provided code shows how to create a set of whistles with varying radii, and I like that; it should be a parameter to add more whistles on a single print.\n*   **Text Labeling:** The design already has functionality to add text, both regular and curved around the whistle, which is perfect for personalization. I want to keep both of those.\n*   **Optional Stand:** The functionality for a little stand, for displaying the whistle, is nice; it should be kept.\n*   **Holder/Handle:** There's a parametric holder that seems to attach to the side of the whistle; I want to ensure I have control over that size.\n*   **Parametric Design:** I like that the parameters for wall thickness, slot width, sphere size, etc., are all customizable. These should remain parametric.\n\n**Changes/Additions I'd Like:**\n\n1.  **More Granular Control Over the Internal Sphere:** I need a parameter to precisely control the vertical *and* horizontal position of the inner sphere. Right now, it seems tied to the whistle's radial dimensions which might not always be ideal. I also want to be able to independently control the size of the stand that supports the sphere. I'm thinking separate radius for the sphere and separate radius and height for that small support.\n2.  **Multiple Whistle Profiles:** While the main body is currently a simple cylinder, I'd like to be able to choose between a few different body profiles - for example, a cylinder, a slightly conical shape (truncated cone), or maybe a curved, rounded profile. I think it would be easiest to control the curved profile by interpolating between two radii: one at the base, and one at the top. I want to keep the existing cylindrical profile as well.\n3.  **Whistle Tone Control:** I need some control over the whistle's tone. It would be great if the script could use parameters to make a simple adjustment the blowing slit shape to change the tone, for example by adjusting the angle of that slot. I'm open to ideas here. Maybe the size and angle of that block? I would also like to separately control the depth and width of the main blowing slot.\n4.  **Improved Handle:** The handle currently uses a scale operation. I would like to be able to independently control its height, radius, and thickness, as a single parametric shape instead.\n5.  **Material Properties:** I'd like to have a parameter for material thickness, with the script calculating tolerances to account for material thickness (so everything will fit together properly when printed).\n6.  **Clearer Code:** I'm not super familiar with OpenSCAD; it would be great if the code could be organized to be a bit easier to understand.\n\n**Libraries:**\n\nThe provided code uses `write.scad` for the text functionality, so we will need to include that.\n\n**Summary:**\n\nI would like a parametric whistle generator, based on the provided code, that allows me to customize the overall shape of the body (including cylindrical, conical, and curved options), have more control over the position and size of the internal sphere and its stand, the ability to fine-tune the whistle's tone, have parametric control of the handle's size and shape, control for material tolerances, and generally be easier to use and understand. The text capabilities from the existing code should be kept as well.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Test",
    "scad": "MouthX=0;\nMouthY=0;\nMouthSize=25;\nMouthRotate=0;\nMouth=\"Very\";\nheight=5;\nradius=25;\nthing(Mouth, height,radius,MouthSize,MouthX);\nmodule thing(Mouth){\n$fn=64;\n\tcolor([0,1,1])\n\tcylinder(h=height,r=radius,center=true);\n\tif (Mouth==\"Super\"){\nrotate([0,0,MouthRotate])\n1happyMouth( );\n\t}else if (Mouth==\"Very\"){\nrotate([0,0,MouthRotate])\nhappyMouth( );\n\t}\n}\nmodule 1happyMouth(){\ntranslate([MouthX,MouthY,height/2]){\n\tdifference(){\n\t\tcylinder(r=MouthSize-MouthSize/4,h=2,center=true);\n\t\ttranslate([MouthX,23,0])\n\t\tcube([1000,MouthSize*2,100],center=true);\n}\n}\n}\nmodule happyMouth( ){\ntranslate([MouthX,MouthY,height/2]){\n\tdifference(){\n\t\tcylinder(r=MouthSize-MouthSize/4,h=3,center=true);\n\t\ttranslate([MouthX,17.5,0])\n\t\tcube([500,MouthSize+10,20],center=true);\n\t\tcylinder(r=MouthSize/2,h=20,center=true);\n\t}\n}\n}",
    "description": "Okay, I'm working on a simple design for a customizable face that I want to 3D print, and I need some help turning my idea into a more flexible OpenSCAD file.\n\nRight now, I have a basic shape  a cylinder  which represents the face itself. I'd like to add a mouth that is somewhat customizable in terms of its position, size, and rotation.\n\nSpecifically:\n\n1.  **Base Shape:** The base is a cylinder with a defined `height` and `radius`. These should both be customizable parameters.\n2.  **Mouth:** I want to add a mouth to the face. The mouth's shape is based on a cylinder that has a rectangular section cut out. This gives a nice curved smile.\n3. **Mouth Variations:** I want to have two different mouth styles. One will have a more exaggerated smile. I am thinking of labeling these as \"Very\" and \"Super.\"\n4.  **Mouth Size:** The mouth's \"size\" (really, the radius of the underlying cylinder) should be a customizable parameter I can control.\n5. **Mouth Position:** The mouth should be positionable along the X and Y axis, using `MouthX` and `MouthY` parameters. \n6.  **Mouth Rotation:** The mouth should also be able to rotate around the Z-axis using the `MouthRotate` parameter. This would be useful to create different expressions like a frown if the rotation is 180 degrees.\n7.  **\"Super\" Mouth:** The \"Super\" mouth should have a larger rectangular cut-out.\n8.  **\"Very\" Mouth:** The \"Very\" mouth is a less aggressive smile with smaller cutouts.\n9.  **Color:** For visualization, the base cylinder should be colored cyan.\n\nI have started on a design, but I need help making it cleaner, more flexible, and parametric.\n\nCan you create a parametric OpenSCAD file that accomplishes these goals? I do not want to use any libraries. I am new to OpenSCAD, so I need the full code in one block, no includes or external files.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Wall Mount Key Holder",
    "scad": "numOfSlots = 1;\ntotalHeight = 4;\ntotalWidth = 15;\nedgeGap = 1;\nkeyGap = 0.4;\nscrewHoleDiameter = 0.5;\nscrewHeadDiameter = 0.75;\nfunction getInterp(p) = lookup(p, [[0, -(totalHeight-edgeGap)/2], [(numOfSlots-1)/2, 0], [(numOfSlots-1), (totalHeight-edgeGap)/2]]);\nfunction getGapInterp(p) = lookup(p, [[0, -(totalHeight-edgeGap)/2], [(numOfSlots-1)/2, 0], [(numOfSlots-1), (totalHeight-edgeGap)/2]]);\ndifference(){\n\tunion() {\n\ttranslate([0, 0, 2.25]) cube(size=[totalHeight, totalWidth-totalHeight, 4.5], center=true);\n\ttranslate([0, totalWidth/2-totalHeight/2, 0]) cylinder(h=4.5, r1=totalHeight/2, r2=totalHeight/2, $fn=60);\n\ttranslate([0, -(totalWidth/2-totalHeight/2), 0]) cylinder(h=4.5, r1=totalHeight/2, r2=totalHeight/2, $fn=60);\n\t}\n\tdifference(){\n\t\tif (numOfSlots > 2){\n\t\t\tfor (i =[0 : numOfSlots-1]){\n\t\t\t\ttranslate([getInterp(i), 0, 2.75]) cube(size=[keyGap, totalWidth, 3.6], center=true);\n\t\t\t}\n\t\t}\n\t\tif (numOfSlots == 2){\n\t\t\tfor (i =[0 : numOfSlots-1]){\n\t\t\t\ttranslate([getInterp(i)/1.5, 0, 2.75]) cube(size=[keyGap, totalWidth, 3.6], center=true);\n\t\t\t}\n\t\t}\n\t\tif (numOfSlots == 1){\n\t\t\tfor (i =[0 : numOfSlots-1]){\n\t\t\t\ttranslate([0, 0, 2.75]) cube(size=[keyGap, totalWidth, 3.6], center=true);\n\t\t\t}\n\t\t}\n\t\tdifference(){\n\t\t\ttranslate([0, totalWidth/2-totalHeight/2+2.5, 3]) cube(size=[5, 5, 5], center=true);\n\t\t\ttranslate([0, totalWidth/2-totalHeight/2, -1]) cylinder(h=7, r1=(totalHeight/2)-edgeGap/2+keyGap/2, r2=(totalHeight/2)-edgeGap/2+keyGap/2, $fn=60);\n\t\t\t}\n\t\tdifference(){\n\t\t\ttranslate([0, -(totalWidth/2-totalHeight/2)-2.5, 3]) cube(size=[5, 5, 5], center=true);\n\t\t\ttranslate([0, -(totalWidth/2-totalHeight/2), -1]) cylinder(h=7, r1=(totalHeight/2)-edgeGap/2+keyGap/2, r2=(totalHeight/2)-edgeGap/2+keyGap/2, $fn=60);\n\t\t\t}\n\t}\n\ttranslate([0, totalWidth/2-totalHeight/2, 0]) cylinder(h=15, r1=screwHoleDiameter/2, r2=screwHoleDiameter/2, $fn=60, center=true);\n\ttranslate([0, totalWidth/2-totalHeight/2, 2.0]) cylinder(h=15, r1=screwHeadDiameter/2, r2=screwHeadDiameter/2, $fn=60);\n\ttranslate([0, -(totalWidth/2-totalHeight/2), 0]) cylinder(h=15, r1=screwHoleDiameter/2, r2=screwHoleDiameter/2, $fn=60, center=true);\n\ttranslate([0, -(totalWidth/2-totalHeight/2), 2.0]) cylinder(h=15, r1=screwHeadDiameter/2, r2=screwHeadDiameter/2, $fn=60);\n}",
    "description": "Okay, I'd like to design a key holder that can be mounted to a wall. I'm looking for a parametric OpenSCAD design that I can customize.\n\nHere's what I have in mind:\n\n*   **Key Slots:** The holder should have a configurable number of slots for keys. I want to be able to specify how many slots, ideally between 1 and 5, though more could be useful later. These slots should be vertically oriented, with space between them to accommodate key rings.\n*   **Overall Shape:** The base of the holder should be roughly a rectangular shape with rounded ends. I want to have parameters for the overall length of the holder, the height of the holder, and the thickness.\n*   **Wall Mounting:** There should be two screw holes, one on each of the rounded ends, for mounting to a wall. I'd like to specify the diameter of the screw holes and the diameter of a countersink area for the screw heads.\n*   **Gaps:** I need some control over the gap size for the keys to slide into, and also the space around the edges of the design.\n*   **Code Style:** I would like the code to be nicely commented, use clear variable names, and be easy to understand.\n\nSo, specifically, I'd like to be able to customize the following:\n\n*   `numOfSlots`: The number of key slots (integer, range 1-5).\n*   `totalHeight`: The total height of the holder.\n*   `totalWidth`: The overall length/width of the holder.\n*   `edgeGap`: The space between the edge of the holder and the key slots.\n*   `keyGap`: The width of the slots for the keys to hang.\n*   `screwHoleDiameter`: The diameter of the screw holes.\n*   `screwHeadDiameter`: The diameter of the countersunk area for the screw heads.\n\nI'm not looking for any crazy complex features, but I want the design to be configurable and robust. Please provide an OpenSCAD file that I can use to generate this key holder. Im not using any libraries currently, so it doesnt need to depend on anything external.\n"
  },
  {
    "object": "Hey cadmonkey, make me a  Customizable Lantern",
    "scad": "use <utils/build_plate.scad>;\n_1_type = \"Top\";\n_2_lanternDiameter = 40;\n_3_topHeight = 4;\n_4_windowHeight = 60;\n_5_baseHeight = 6;\n_6_windowThickness = 0.2;\n_7_windowGap = 0.5;\n_8_notchWidth = 2.4;\n_9_addLedClip = 0;\nmodule ledSide(width, offset) {\n\tthickness = 1.4;\n\tradius = 4;\n\theight = 10;\n\teps = 0.1;\n\twireDepth = 0.5;\n\tyoffset = width/2 - radius;\n\ttranslate([offset,0,0])\n\ttranslate([thickness,0,0])\n\trotate(a=[0,-2.5,0])\n\ttranslate([-thickness,0,0]) {\n\t\tdifference() {\n\t\t\tunion() {\n\t\t\t\thull() {\n\t\t\t\t\ttranslate([0,-9,0]) {\n\t\t\t\t\t\tcube(size=[thickness, width, 1]);\n\t\t\t\t\t}\n\t\t\t\t\tfor(y=[-yoffset, yoffset]) {\n\t\t\t\t\t\ttranslate([0,y,height - radius]) {\n\t\t\t\t\t\t\trotate(a=[0,90,0]) {\n\t\t\t\t\t\t\t\tcylinder(r=radius,h=thickness);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttranslate([thickness,0,0])\n\t\t\t\tscale(v=[1,1,2])\n\t\t\t\tdifference() {\n\t\t\t\t\ttranslate([0,0,-0.1])\n\t\t\t\t\trotate([0,45,0]) {\n\t\t\t\t\t\tcube(size=[1.0,width,1.0], center=true);\n\t\t\t\t\t}\n\t\t\t\t\ttranslate([0,0,-1.1]) {\n\t\t\t\t\t\tcube(size=[2.0,width,2.0], center=true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(y=[0:2.0:6]) {\n\t\t\t\tfor(flip=[-1,1]) {\n\t\t\t\t\ttranslate([-eps, -0.3 + y * flip, -eps]) {\n\t\t\t\t\t\tcube(size=[wireDepth+eps, 0.8, height + 2*eps]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\thull() {\n\t\t\t\tcube(size=[wireDepth*2, width+eps, 8], center=true);\n\t\t\t\tcube(size=[0.001, width+eps, 10], center=true);\n\t\t\t}\n\t\t\ttranslate([0,0,height])\n\t\t\tscale(v=[1,1,3])\n\t\t\trotate([0,45,0]) {\n\t\t\t\tcube(size=[0.8,width+eps,0.8], center=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule addLedClip() {\n\twidth = 18;\n\tgap=3.5;\n\tledSide(width, gap/2);\n\tmirror() {\n\t\tledSide(width, gap/2);\n\t}\n}\nmodule makeTop(diameter, height, windowGap, notchWidth, windowInset) {\n\tinset = min(windowInset, height-1.0);\n\twallThickness = 1.1;\n\tradius1 = diameter/2 - windowGap/2;\n\tradius2 = radius1 + windowGap;\n\tradius3 = radius2 + wallThickness;\n\teps = 0.1;\n\ttranslate([0,0,height]) {\n\t\tdifference() {\n\t\t\ttranslate([0,0,-height]) {\n\t\t\t\tdifference() {\n\t\t\t\t\tcylinder(r=radius3, h=height);\n\t\t\t\t\ttranslate([0,0,-eps]) {\n\t\t\t\t\t\tcylinder(r=radius1-wallThickness, h=height + 2*eps);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([0,0,-inset]) {\n\t\t\t\tdifference() {\n\t\t\t\t\tcylinder(r=radius2, h=inset+eps);\n\t\t\t\t\ttranslate([0,0,-eps]) {\n\t\t\t\t\t\tcylinder(r=radius1, h=inset + 3*eps);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (notchWidth > 0) {\n\t\t\t\ttranslate([-notchWidth/2,radius1-wallThickness*2,-inset]) {\n\t\t\t\t\tcube(size=[notchWidth,wallThickness*2,inset+eps], center=false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule makeBase(diameter, height, windowGap, notchWidth, windowInset, clip) {\n\tradius = diameter/2 + windowGap/2 + 1.0;\n\tbaseThickness = 1.0;\n\tunion() {\n\t\tmakeTop(diameter, height, windowGap, notchWidth, windowInset);\n\t\tcylinder(r=radius, h=baseThickness);\n\t\tif (clip == 1) {\n\t\t\ttranslate([0,0,baseThickness]) {\n\t\t\t\taddLedClip();\n\t\t\t}\n\t\t}\n\t}\n}\nmodule makeFlatWindow(diameter, height, thickness) {\n\twidth = diameter * 3.14159265359;\n\tseamWidth = 1.0;\n\tseamDepth = 1.5;\n\txoffset = -width/2 + seamWidth/2;\n\tunion() {\n\t\tcube(size=[width, height, thickness], center=true);\n\t\tfor (x = [-xoffset,xoffset]) {\n\t\t\ttranslate([x,0,seamDepth/2]) {\n\t\t\t\tcube(size=[seamWidth, height, seamDepth], center=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule makeRoundWindow(diameter, height, thickness) {\n\tradius = diameter/2;\n\teps = 0.1;\n\tdifference() {\n\t\tcylinder(r=radius + thickness/2, h=height);\n\t\ttranslate([0,0,-eps]) {\n\t\t\tcylinder(r=radius - thickness/2, h=height + 2*eps);\n\t\t}\n\t}\n}\nmodule run($fn=180) {\n\tif (_1_type == \"Top\") {\n\t\tmakeTop(_2_lanternDiameter, _3_topHeight, _7_windowGap, _8_notchWidth, 4.0);\n\t} else if (_1_type == \"Flat Window\") {\n\t\tmakeFlatWindow(_2_lanternDiameter, _4_windowHeight, _6_windowThickness);\n\t} else if (_1_type == \"Round Window\") {\n\t\tmakeRoundWindow(_2_lanternDiameter, _4_windowHeight, _6_windowThickness);\n\t} else {\n\t\tmakeBase(_2_lanternDiameter, _5_baseHeight, _7_windowGap, _8_notchWidth, 4.0, _9_addLedClip);\n\t}\n}\nbuild_plate(3,140,140);\nrun();",
    "description": "Okay, I'm looking to design a customizable LED lantern and I'd like to use OpenSCAD. I have a basic design concept that I've modeled before, but I want to make it more parametric and easier to adjust for different sizes and purposes.\n\nHere's what I'm envisioning:\n\nThe lantern should consist of three main parts: a top, a base, and a window section. The window can be either flat or cylindrical. I'd like to be able to choose which of these parts I'm creating, using a variable to specify either \"Top\", \"Base\", \"Flat Window\" or \"Round Window.\"\n\n**Key Parameters:**\n\n*   **Lantern Diameter:** The diameter of the lantern at the window section (where the window inserts). I need to be able to set this (e.g., 40mm), and it should affect the size of the other parts appropriately.\n*   **Top Height:** The height of the top part of the lantern.\n*   **Window Height:** The height of the window section (both flat and cylindrical).\n*   **Base Height:** The height of the base part of the lantern.\n*   **Window Thickness:** The thickness of the window material. I want this to be very thin, especially for printing, and perhaps configurable to be a single layer.\n*   **Window Gap:** A small gap between the window and the top/base for insertion.\n*   **Notch Width:** The width of a notch that helps to hold the flat window in place. If I want a round window, this value should effectively be 0.\n*   **LED Clip:** A boolean option (Yes/No) to add an integrated LED clip to the base.\n\n**Desired Features**\n\n*   **Top:** The top piece should be a cylinder with an inset to hold the window. The inset should be adjustable.\n*   **Base:** The base should have a similar inset as the top for holding the window, as well as the option to include the LED clip. This clip is for a small, cylindrical LED, and should have guides for wires. The bottom of the base should also be a cylinder that is wider than the sides.\n*   **Flat Window:** The flat window should be a rectangle, with a small seam/tab on each side for assembly.\n*   **Round Window:** The round window should be a cylinder with a given thickness.\n\n**Specific Requirements:**\n\n*   I'd like to use `build_plate` from a `utils/build_plate.scad` file that I have. This is mostly for visualization purposes. Please ensure that this is at the bottom of the generated OpenSCAD code. I already have the `build_plate` module, so you don't need to include that in the response.\n*   The code should be well-commented.\n*   I need the model to be easily customizable through the use of variables, including descriptive names for the variables (e.g., `_1_type`, `_2_lanternDiameter`, etc.).\n\nCould you generate the OpenSCAD code for this design? I'm looking for a clean and parametric design that I can easily modify for different sizes and configurations.\n"
  },
  {
    "object": "Hey cadmonkey, make me a parametric moustache",
    "scad": "showruler = \"no\";\nrulerheight = 2;\nrulerlenght = 300;\ncircle_1 = 5;\ncircle_2 = 1;\nlenght = 20;\nheight = 5;\nrepeat = 8;\nshift_x = 2;\nshift_y = 5;\nrotate = 10;\nscale =1;\nnoseclip_openingangle = 100;\nnoseclip_diameter = 10;\nnoseclip_wallthickness = 2;\nnoseclip_endcircle = 2;\nnoseclip_x = 0;\nnoseclip_y = -6;\nrealshift_x = shift_x/10;\nrealshift_y = shift_y/10;\nrealscale = scale/10;\nif(showruler == \"yes\"){\n\truler();\n}\nfull(circle_1,circle_2,lenght,height);\nnoseclip();\nmodule ruler(){\n\ttranslate([0,-noseclip_diameter,rulerheight + height]){\n\t\tdifference(){\n\t\t\tcube([rulerlenght,10,rulerheight], center = true);\n\t\t\tfor(i=[0:30]){\n\t\t\t\ttranslate([(i*10)-150,0,0]){\n\t\t\t\t\tcube([1,5,rulerheight+2], center = true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule noseclip(){\ntranslate([noseclip_x,noseclip_y,height/2]){\n\tdifference(){\n\t\tunion(){\n\t\t\tcylinder(h = height, r = noseclip_diameter/2+noseclip_wallthickness, center = true);\n\t\t}\n\t\tcylinder(h = height+2, r = noseclip_diameter/2, center = true);\n\t\trotate(180+90 + noseclip_openingangle/2)\n\t\t\tlinear_extrude(height = height+2, center = true)\n\t\t\t\tslice(noseclip_diameter*2, noseclip_openingangle);\n\t}\nrotate(noseclip_openingangle/2)\n\ttranslate([0,-noseclip_diameter/2,0]){\n\t\tcylinder(h = height, r = noseclip_endcircle, center = true);\n\t}\nrotate(-noseclip_openingangle/2)\n\ttranslate([0,-noseclip_diameter/2,0]){\n\t\tcylinder(h = height, r = noseclip_endcircle, center = true);\n\t}\n}\n}\nmodule slice(r = 10, deg = 30) {\n\tdegn = (deg % 360 > 0) ? deg % 360 : deg % 360 + 360;\n\tdifference() {\n\t\tcircle(r);\n\t\tif (degn > 180)\n\t\t\tintersection_for(a = [0, 180 - degn])\n\t\t\t\trotate(a)\n\t\t\t\t\ttranslate([-r, 0, 0])\n\t\t\t\t\t\tsquare(r * 2);\n\t\telse\n\t\t\tunion()\n\t\t\t\tfor(a = [0, 180 - degn])\n\t\t\t\t\trotate(a)\n\t\t\t\t\t\ttranslate([-r, 0, 0])\n\t\t\t\t\t\t\tsquare(r * 2);\n\t}\n}\nmodule full() {\n\thalf(circle_1,circle_2,lenght,height);\n\tmirror([ 1, 0, 0 ])\n\t\thalf(circle_1,circle_2,lenght,height);\n}\nmodule half() {\n\tfor(i=[0:repeat]){\n\t\ttranslate([i*realshift_x,i* realshift_y, 0]){\n\t\t\trotate([0,0,i*-rotate]){\n\t\t\t\ttranslate([-circle_1,0,0]){\n\t\t\t\t\tscale(v = [(i*realscale)+1,(i*realscale)+1, 1])\n\t\t\t\t\t\telement(circle_1,circle_2,lenght,height);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule element(circle_1,circle_2,lenght,height) {\n linear_extrude(height=height)\n \thull() {\n \t\ttranslate([circle_1, circle_1, 0])\n \t\t\tcircle(r=circle_1,center = true);\n \t\ttranslate([circle_1 ,  circle_1+ lenght, 0])\n \t\t\tcircle(r=circle_2,center = true);\n \t}\n}",
    "description": "Okay, I'd like to design a customizable 3D printable moustache with a nose clip, and I need some help with the OpenSCAD code. \n\nHere's what I'm envisioning:\n\n**Overall Structure:**\n\nThe moustache should be symmetrical and made of a series of repeated, scaled, and rotated elements. It should also include a nose clip.\n\n**Moustache Elements:**\n\nEach moustache element should be a sort of teardrop shape formed by extruding a hull between two circles:\n   *   **circle\\_1:**  Radius of the first circle. This should be a parameter that can be adjusted by the user (e.g. `circle_1 = 5;`)\n   *   **circle\\_2:** Radius of the second circle, smaller than the first circle (e.g. `circle_2 = 1;`). Also adjustable.\n   *   **lenght:** The distance between the centers of the two circles, determining the length of the element (e.g. `lenght = 20;`). Also adjustable.\n   *   **height:** The height of the extrusion for the element (e.g. `height = 5;`) . Adjustable.\n\nThese elements will be repeated to form the shape of the moustache.\n\n**Repetition and Transformation:**\n\nThe elements need to be repeated to form a \"full\" moustache shape. I need these parameters for that repetition:\n    *   **repeat:** The number of elements to repeat on each side of the moustache (e.g. `repeat = 8;`).\n    *  **shift\\_x:** The shift in x direction between each repeated element (e.g. `shift_x = 2;`).  This will be multiplied by the element number before being applied.\n    *   **shift\\_y:** The shift in y direction between each repeated element (e.g. `shift_y = 5;`).  This will be multiplied by the element number before being applied.\n    *   **rotate:** The rotation of the element (in degrees) (e.g. `rotate = 10;`).  This will be multiplied by the element number before being applied.\n    *  **scale:** The scale of each element, where the scale is multiplied by the element number (e.g. `scale = 1;`).\n\n**Nose Clip:**\n\nThe nose clip should be a simple clamp-like structure that can be adjusted.\n   * **noseclip\\_openingangle:** The angle the nose clip is open (e.g. `noseclip_openingangle = 100;`).\n   * **noseclip\\_diameter:** The diameter of the noseclip (e.g. `noseclip_diameter = 10;`).\n   * **noseclip\\_wallthickness:** The wall thickness of the noseclip (e.g. `noseclip_wallthickness = 2;`).\n    * **noseclip\\_endcircle:** The radius of the small circles at the end of the noseclip (e.g. `noseclip_endcircle = 2;`).\n     * **noseclip\\_x:** Shift in the x direction for the entire noseclip (e.g. `noseclip_x = 0;`).\n    * **noseclip\\_y:** Shift in the y direction for the entire noseclip (e.g. `noseclip_y = -6;`).\n\n**Units:**\nI'm working in mm, and all provided numbers are in mm, except where otherwise specified (e.g. `rotate` is in degrees). Please note that when using shift_x and shift_y a value of `1` represents `0.1mm` to allow for easier adjustment of the final design.  Similarly, the `scale` parameter is divided by 10.\n\n**Optional Ruler:**\n\nI'd like an optional ruler, primarily for testing.\n   *   **showruler:**  A boolean option to show a ruler beneath the moustache (`showruler = \"yes\";` or `showruler = \"no\";`). If set to yes the ruler should be 300mm long with tick marks every 10mm and height of 2mm beneath the mustache.\n\n**Functionality**\nThe final code needs to have the following modules:\n   * ruler - generates the optional ruler (as described above).\n   * noseclip - generates the nose clip.\n   * slice - generates a slice of a circle for use in the noseclip.\n   * full - the top-level function that puts the mustache together.\n   * half - generates half the mustache.\n   * element - generates the individual moustache element.\n\nCould you generate the OpenSCAD file for me based on these parameters? I don't need any libraries to be included.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Retro Font Word Pen",
    "scad": "use <MCAD/fonts.scad>\nword = \"BrandonW6\";\nfont_scale = 2.1\t;\nfont_spacing = 0.81;\npen_inner_diameter = 4.3 *1;\npen_inner_radius = pen_inner_diameter / 2;\npen_length = 130;\npen_thickness = 8*1;\nmodule penword()\n{\nthisFont=8bit_polyfont();\nx_shift=thisFont[0][0] * font_spacing;\ny_shift=thisFont[0][1];\n\ttheseIndicies=search(word,thisFont[2],1,1);\n\twordlength = (len(theseIndicies))* x_shift;\n\tdifference() {\n\t\tunion() {\n\t\t\tscale([font_scale,font_scale,1]){\n\t\t\tfor( j=[0:(len(theseIndicies)-1)] )\n\t\t\t\ttranslate([ j*x_shift + 1, -y_shift/2 ,-pen_thickness/2])\n\t\t\t\t{\n\t\t\t\t\tlinear_extrude(height=pen_thickness) polygon(points=thisFont[2][theseIndicies[j]][6][0],paths=thisFont[2][theseIndicies[j]][6][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([1*font_scale+3\t,-y_shift*.45,-pen_thickness/2]) cube([pen_length - 3,y_shift * 0.9,pen_thickness * 0.8]);\n\t\t\trotate(a=[0,90,0])\n\t\t\t\t{\n\t\t\t\t\ttranslate([pen_thickness*0.1,0,0\t])\tcylinder(h = 5, r = pen_thickness*.4, $fn=50);\n\t\t\t\t\ttranslate([pen_thickness*0.1,0,-5\t])\tcylinder(h = 5, r1 = 1, r2 = pen_thickness*.4, $fn=50);\n\t\t\t\t}\n\t\t}\n\t\t\ttranslate([0,-pen_inner_diameter/2,-pen_thickness/2+pen_thickness*.15]) cube([pen_length + 20,pen_inner_diameter,pen_inner_diameter]);\n\t\t\trotate(a=[0,90,0])translate([pen_thickness*.1,0,-15])\tcylinder(h = 30, r = pen_inner_radius, $fn=100);\n\t}\n}\npenword();",
    "description": "Okay, I'd like to create a customizable pen with text extruded on the side, using an 8-bit font. I'd like the design to be parametric in OpenSCAD, so I can easily change things like the text, font size, spacing, pen length, thickness, and the diameter of the hole for the pen insert.\n\nHere's a breakdown of what I'm looking for:\n\n**Overall Structure:**\n*   The pen should have a main body, a hole running through it for a pen refill, an extruded text on the side, and a small conical tip at the writing end.\n*   The design should use the `MCAD/fonts.scad` library to handle the 8-bit font.\n\n**Parameters (that I want to be able to adjust):**\n*   **`word`**: The text to display on the pen. This should be a string.\n*   **`font_scale`**: A scaling factor to control the font size.\n*   **`font_spacing`**:  A factor to control character spacing.\n*   **`pen_inner_diameter`**: The diameter of the hole for the pen refill.\n*   **`pen_length`**: The overall length of the pen.\n*   **`pen_thickness`**: The overall thickness of the pen.\n\n**Specific Design Details:**\n*   **Text:** The text should be extruded outwards from the main body. Use the 8-bit polyfont from `MCAD/fonts.scad`. The text should be positioned along the length of the pen. There should be a small offset from the start of the pen body.\n*   **Main Body:** The main body should be a rectangular prism with rounded corners along the height axis. This body should extend almost to the end of the conical tip.\n*   **Pen Tip:** The pen tip should be a combination of a cylinder and a cone. The conical tip should be smaller in diameter where it meets the paper. The base of the pen tip should meet the pen body.\n*   **Hole:** The hole for the pen refill should run the full length of the pen body. It should be centered. I'd like the hole to be circular, and I'd like the user to be able to define it by diameter, rather than radius.\n*   **Cutouts:** When creating the text, I'd like the cut out to include a little buffer on the start and end of the pen.\n*   **All components:** I'd like the text, main body, pen tip, and hole to all be centered within the bounds of the design.\n\n**Expected Output:**\n*   I would like to receive a single OpenSCAD file (.scad) with all of the above parameters defined at the beginning of the file.\n*  I want the design to use the `MCAD/fonts.scad` library for the font. I would expect that you do not provide code for this library in your response.\n*  I'd expect the OpenSCAD file to be fully functional, meaning, when I open it with OpenSCAD, I can change the parameters and render the design.\n\nCan you generate the OpenSCAD code for this? I'm really excited to see what you come up with!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Shelf/Drawer Bracket",
    "scad": "width = 15;\nside_len = 27.5;\nside_ht = 14.5;\nlength = 30;\nup_ht = 17.75;\nthick = 2;\nside_thk = 1.75;\nfillet_rad = 3.25;\nbase_hole_gap = 4.5;\nside_hole_gap = 5.25;\nhole_dia = 6.75;\nhole_wid = 9.75;\ndt = 0.1;\nmodule hole(){\n\thull(){\n\t\tfor (i=[-1,1]){\n\t\t\ttranslate([0,i*(hole_wid-hole_dia)/2,-dt/2])\n\t\t\tcylinder(r=hole_dia/2,h=thick+dt,center=false);\n\t\t}\n\t}\n}\nmodule side(){\n\thull(){\n\t\tcube([dt,side_thk,side_ht], center=false);\n\t\ttranslate([side_len-thick,0,0])\n\t\tcube([dt,side_thk,thick], center=false);\n\t}\n}\nmodule base(long){\n\ttranslate([0,0,thick/2])\n\thull(){\n\t\tcube([dt,width,thick], center=true);\n\t\tfor (i=[-1,1]){\n\t\t\ttranslate([long-fillet_rad,i*(width/2-fillet_rad),0])\n\t\t\tcylinder(r=fillet_rad,h=thick,center=true);\n\t\t}\n\t}\n}\nmodule upright(long){\n\ttranslate([thick,0,0])\n\trotate([0,-90,0])\n\tbase(long);\n}\ndifference(){\n\tunion(){\n\t\tbase(length);\n\t\tupright(up_ht);\n\t\tfor (i=[-width/2+dt, width/2-side_thk-dt]){\n\t\t\ttranslate([thick-3*dt,i,0])\n\t\t\tside();\n\t\t}\n\t}\n\ttranslate([length-base_hole_gap-hole_dia/2,0,0])\n\thole();\n\ttranslate([thick,0,side_hole_gap+hole_wid/2])\n\trotate([0,-90,0])\n\trotate([0,0,90])\n\thole();\n}",
    "description": "Okay, I'm looking to get an OpenSCAD file for a simple bracket, something similar to the \"Drawer_bracket.scad\" I've been using, but with a few modifications and additional options. I need it to be fully parametric, as I often adjust the dimensions for different projects.\n\nHere's what I need:\n\n**Core Structure:**\n\n*   The bracket should consist of a horizontal base and a vertical upright, joined at a 90-degree angle.\n*   It should have triangular reinforcement gussets on each side where the base and upright meet.\n*   I'd like to have rounded fillets where the base and upright meet, as well as where the gussets connect to the base and upright.\n\n**Parameters (with desired ranges):**\n\n*   `width`: Width of the bracket (and thus the width of the base and upright).  Range: 2-25 units.\n*   `side_len`: Length of the side reinforcement triangles along the base and upright.  Range: 5-50 units.\n*   `side_ht`: Height of the side reinforcement triangles along the upright. Range: 5-50 units.\n*   `length`: Length of the horizontal base. Range: 5-50 units.\n*   `up_ht`: Height of the vertical upright. Range: 5-50 units.\n*   `thick`: Thickness of the base and upright. Range: 0.25-2.5 units.\n*   `side_thk`: Thickness of the side reinforcement triangles. Range: 0.25-2.5 units.\n*   `fillet_rad`: Radius of corner fillets. Range: 0.5-5 units.\n*   `base_hole_gap`: Distance between the end of the horizontal base and the center of the horizontal screw hole. Range: 1-10 units.\n*   `side_hole_gap`: Distance between the top of the vertical upright and the center of the vertical screw hole. Range: 1-10 units.\n*   `hole_dia`: Short axis (diameter) of the screw holes. Range: 1-10 units.\n*   `hole_wid`: Long axis (length) of the screw holes. Range: 2-20 units.  (These should be slots.)\n*   `dt`: A small fudge factor for overlaps (I'd prefer if this was small, for example a range of 0.001, 0.01, or 0.1).\n\n**New additions/modifications:**\n\n*   **Gusset Fillets:** I want to be able to control the radius of the fillets where the side gussets meet the base and upright independently. So I will need a `gusset_fillet_rad` parameter with the same range of 0.5 - 5 units.\n\n*   **Additional Horizontal Holes:** I need an option to include more than one hole along the length of the base. I'd like a new `base_hole_count` parameter with a default value of 1, and a range of 1 to 5. When this is set to a value greater than 1, the holes along the base should be evenly spaced, with the same `base_hole_gap` as the distance from the edge to the center of the end holes. \n\n*   **Countersunk Holes:** I want an option to create countersunk screw holes. This should be a boolean parameter called `countersunk`. When true, it should create a 45-degree countersink on top of each hole. The diameter of the countersink should be slightly larger than the hole's long axis (`hole_wid`) when `countersunk` is true. Maybe something like 1.2 times the hole width should be sufficient.\n\n*   **Support for a second vertical hole:** I want to be able to add a second, optional, vertical hole. There should be a `second_side_hole` boolean parameter, that defaults to `false`. When set to `true`, a second vertical hole with the same parameters as the first, at the same `side_hole_gap`, should be added. The vertical holes should be offset so that they are on the same vertical line, with each hole being `side_len` from the edge of the bracket. \n\n**Code Structure:**\n\n* I'd prefer if the code were well structured, with modules for each of the parts - hole, side gusset, base, and upright.\n\nI think that should be everything. Please provide an OpenSCAD file based on these requirements. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable simple pin connector",
    "scad": "pin_length = 67;\npin_radius = 3.5;\npin_head_length = 4;\npin_head_lip = 0.6;\nslot_length = 10;\nslot_width = 2;\nsides = 30;\nflat = 0.2;\ntotal_pin_radius = pin_radius + pin_head_lip;\nmodule pin_head()\n{\n\tunion()\n\t{\n\t\tcylinder( r1 = pin_radius*0.75, r2 = pin_radius+pin_head_lip, h = pin_head_length*2/4, $fn = sides);\n\t\ttranslate([0,0, pin_head_length*3/4])cylinder( r1 = pin_radius+pin_head_lip, r2 = pin_radius, h = pin_head_length*1/4, $fn = sides);\n\t\ttranslate([0,0, pin_head_length*2/4])cylinder( r1 = pin_radius+pin_head_lip, r2 = pin_radius+pin_head_lip, h = pin_head_length*1/4, $fn = sides);\n\t}\n}\nmodule slot()\n{\n\tslot_depth = 2*total_pin_radius + 0.1;\n\tunion()\n\t{\n\t\ttranslate([ -slot_depth/2, -slot_width/2, 0])cube([slot_depth, slot_width, slot_length]);\n\t\trotate([0, 90, 0])cylinder( r1 = slot_width/2, r2 = slot_width/2, h = slot_depth, center = true, $fn = sides);\n\t\ttranslate([0, 0, slot_length])rotate([0, 90, 0])cylinder( r1 = slot_width/2, r2 = slot_width/2, h = slot_depth, center = true, $fn = sides);\n\t}\n}\nmodule shaft()\n{\n\tunion()\n\t{\n\t\tpin_head();\n\t\ttranslate([0,0, pin_head_length])cylinder( r1 = pin_radius, r2 = pin_radius, h = pin_length - 2*pin_head_length + 0.1, $fn = sides);\n\t\ttranslate([0, 0, pin_length ])rotate([0,180,0])pin_head();\n\t}\n}\nmodule flat()\n{\n\tflat_depth = flat*total_pin_radius;\n\tflat_width = 2*total_pin_radius;\n\tunion()\n\t{\n\t\ttranslate([total_pin_radius - flat_depth, 0, pin_length/2])cube([flat_depth*2, 2*total_pin_radius, pin_length + 0.1], center = true);\n\t\ttranslate([-(total_pin_radius - flat_depth), 0, pin_length/2])cube([flat_depth*2, 2*total_pin_radius, pin_length + 0.1], center = true);\n\t}\n}\nmodule pin()\n{\n\trotate([0, 90, 0])\n\tdifference()\n\t{\n\t\tshaft();\n\t\tslot();\n\t\ttranslate([0,0,pin_length - slot_length])slot();\n\t\tflat();\n\t}\n}\npin();",
    "description": "Okay, I'd like to design a new type of pin connector and need some help creating an OpenSCAD model. \n\nHere's what I'm envisioning:\n\n**Overall Shape:** The pin will have a cylindrical shaft with a head on each end. Think of it as a double-ended nail with a lip at the base of each head. There's also a slot cut into the shaft along its length, and two flat surfaces cut on opposite sides of the shaft to prevent rotation.\n\n**Dimensions and Features (All dimensions are in mm unless otherwise specified):**\n\n*   **Total Pin Length:** This should be a variable, let's call it `pin_length`, and it should be set to 67mm initially.\n*   **Pin Shaft Radius:** This is the radius of the main cylindrical shaft. It should be a variable called `pin_radius` and set to 3.5mm initially.\n*   **Pin Head Length:** This is the length of one of the heads (both heads will be the same). Let's call this `pin_head_length`, and set it to 4mm. The head should have a stepped profile with a larger diameter base leading into a smaller diameter cylindrical section, as in the provided example.\n*   **Pin Head Lip:** There's a lip around each pin head where it meets the shaft. This is the section that grips the sides of the pin hole. Call this variable `pin_head_lip`, and it should start at 0.6mm.\n*   **Slot Length:** The slot that's cut into the shaft has its own length, `slot_length`, and should be 10mm by default. There should be a slot on both sides of the central portion of the shaft.\n*  **Slot Width:** The slot also has a width, `slot_width`, which should start at 2mm.\n*  **Number of Sides:** The pin is going to be roughly cylindrical, but we should generate the cylinder using a finite number of sides, call it `sides`. We'll initially set this to 30.\n*   **Flat:** There are two flats on the sides of the shaft that run along the full length of the pin (not including the head). The distance from the original radius to the depth of the flat should be a fraction of the total pin radius, `flat`. For instance, a value of `0.1` would make the flats 0.1 * radius deep. The default value for `flat` should be 0.2.\n\n**Specific Design Details:**\n\n*   The pin head should be a smooth transition from a slightly larger diameter at the base (where it connects to the pin shaft) to the final diameter at the top.\n*   The slot should be a rectangular cut, but with rounded ends, as generated by the provided code.\n* The flats on the sides should be perfectly flat, and should be the same length as the cylindrical portion of the shaft.\n*   The pin should be oriented along the Z-axis, with the bottom head at z=0.\n\n**Parametric Design:**\nI'd like all of the dimensions I've listed to be defined as variables at the beginning of the file, so that they can be easily modified later.\n\n**Output:**\nI need a single OpenSCAD file (.scad). Please make use of modules to define all of the shapes so that the code is easy to read and modify.\n\nCould you generate an OpenSCAD file that creates this pin design? I'm not using any external libraries for this design.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable brick-image creator kit (ministeck)",
    "scad": "$fn=50/1;\nsingle_piece_size = 4;\nblock_thickness = 2;\nstick_length = 3;\nthing_type = \"test set\";\nbase_plate_x_count = 20;\nbase_plate_y_count = 20;\nhow_many = 1;\nspace_between_things = 2;\nif (thing_type == \"test set\")\n{\n\tCreateSingleBlock();\n\ttranslate([(single_piece_size+space_between_things),0,0]) CreateTwoBlock();\n\ttranslate([2*(single_piece_size+space_between_things),0,0]) CreateThreeBlock();\n\ttranslate([3*(single_piece_size+space_between_things),0,0]) CreateFourBlock();\n\ttranslate([5*(single_piece_size+space_between_things),0,0]) CreateCornerBlock();\n\tdifference()\n\t{\n\t\ttranslate([0,4*single_piece_size,0]) cube([single_piece_size*4,single_piece_size*4,stick_length]);\n\t      translate([0,4*single_piece_size,0]) for (x = [0: 4])\n\t\t{\n\t\t\ttranslate([0,x*(single_piece_size),0])\n\t\t\tfor (y = [0: 4])\n\t\t\t{\n\t\t\t\ttranslate([y*(single_piece_size),0,0]) CreateBasePlateHole();\n\t\t\t}\n\t\t}\n\t}\n}\nif (thing_type == \"complete block set\")\n{\n\tfor (z = [0: how_many-1])\n\t{\n    \t\ttranslate([z*((single_piece_size+space_between_things)*3), 0, 0])\n\t\t\tCreateSetRow();\n\t}\n}\nif (thing_type == \"base plate\")\n{\n\tdifference()\n\t{\n\t\tcube([single_piece_size*base_plate_x_count,single_piece_size*base_plate_y_count,stick_length]);\n\t\tfor (x = [0: base_plate_x_count])\n\t\t{\n\t\t\ttranslate([0,x*(single_piece_size),0])\n\t\t\tfor (y = [0: base_plate_y_count])\n\t\t\t{\n\t\t\t\ttranslate([y*(single_piece_size),0,0]) CreateBasePlateHole();\n\t\t\t}\n\t\t}\n\t}\n}\nif (thing_type == \"one-block\")\n{\n\tfor (z = [0: how_many-1])\n\t{\n    \t\ttranslate([z*(single_piece_size+space_between_things), 0, 0]) CreateSingleBlock();\n\t}\n}\nif (thing_type == \"two-block\")\n{\n\tfor (z = [0: how_many-1])\n\t{\n    \t\ttranslate([z*(single_piece_size+space_between_things), 0, 0]) CreateTwoBlock();\n\t}\n}\nif (thing_type == \"three-block\")\n{\n\tfor (z = [0: how_many-1])\n\t{\n    \t\ttranslate([z*(single_piece_size+space_between_things), 0, 0]) CreateThreeBlock();\n\t}\n}\nif (thing_type == \"corner-block\")\n{\n\tfor (z = [0: how_many-1])\n\t{\n    \t\ttranslate([z*((single_piece_size*2)+space_between_things), 0, 0]) CreateCornerBlock();\n\t}\n}\nif (thing_type == \"four-block\")\n{\n\tfor (z = [0: how_many-1])\n\t{\n    \t\ttranslate([z*((single_piece_size*2)+space_between_things), 0, 0]) CreateFourBlock();\n\t}\n}\nmodule CreateSetRow()\n{\n\tCreateSingleBlock();\n\ttranslate([0,(single_piece_size+space_between_things),0])\tCreateFourBlock();\n\ttranslate([0,(single_piece_size*3+space_between_things*2),0])\tCreateFourBlock();\n\ttranslate([0,(single_piece_size*5+space_between_things*3),0])\tCreateCornerBlock();\n\ttranslate([0,(single_piece_size*7+space_between_things*4),0])\tCreateThreeBlockTurned();\n\ttranslate([0,(single_piece_size*8+space_between_things*5),0])\tCreateThreeBlockTurned();\n\ttranslate([0,(single_piece_size*9+space_between_things*6),0])\tCreateThreeBlockTurned();\n\ttranslate([0,(single_piece_size*10+space_between_things*7),0])\tCreateTwoBlockTurned();\n\ttranslate([0,(single_piece_size*11+space_between_things*8),0])\tCreateTwoBlockTurned();\n\ttranslate([0,(single_piece_size*12+space_between_things*9),0])\tCreateTwoBlockTurned();\n\ttranslate([0,(single_piece_size*13+space_between_things*10),0])\tCreateTwoBlockTurned();\n\ttranslate([0,(single_piece_size*14+space_between_things*11),0])\tCreateTwoBlockTurned();\n\ttranslate([0,(single_piece_size*15+space_between_things*12),0])\tCreateTwoBlockTurned();\n\ttranslate([0,(single_piece_size*16+space_between_things*13),0])\tCreateTwoBlockTurned();\n\ttranslate([0,(single_piece_size*17+space_between_things*14),0])\tCreateTwoBlockTurned();\n\ttranslate([0,(single_piece_size*18+space_between_things*15),0])\tCreateThreeBlockTurned();\n\ttranslate([0,(single_piece_size*19+space_between_things*16),0])\tCreateThreeBlockTurned();\n\ttranslate([0,(single_piece_size*20+space_between_things*17),0])\tCreateThreeBlockTurned();\n\ttranslate([0,(single_piece_size*21+space_between_things*18),0])\tCreateCornerBlock();\n\ttranslate([0,(single_piece_size*23+space_between_things*19),0])\tCreateFourBlock();\n\ttranslate([0,(single_piece_size*25+space_between_things*20),0])\tCreateFourBlock();\n}\nmodule CreateTwoBlock()\n{\n\tCreateSingleBlock();\n\ttranslate([0,single_piece_size,0]) CreateSingleBlock();\n}\nmodule CreateTwoBlockTurned()\n{\n\tCreateSingleBlock();\n\ttranslate([single_piece_size,0,0]) CreateSingleBlock();\n}\nmodule CreateThreeBlock()\n{\n\tCreateSingleBlock();\n\ttranslate([0,single_piece_size,0]) CreateSingleBlock();\n\ttranslate([0,single_piece_size+single_piece_size,0]) \tCreateSingleBlock();\n}\nmodule CreateThreeBlockTurned()\n{\n\tCreateSingleBlock();\n\ttranslate([single_piece_size,0,0]) CreateSingleBlock();\n\ttranslate([single_piece_size+single_piece_size,0,0]) \tCreateSingleBlock();\n}\nmodule CreateFourBlock()\n{\n\tCreateSingleBlock();\n\ttranslate([single_piece_size,0,0]) CreateSingleBlock();\n\ttranslate([single_piece_size,single_piece_size,0]) \tCreateSingleBlock();\n\ttranslate([0,single_piece_size,0]) \tCreateSingleBlock();\n}\nmodule CreateCornerBlock()\n{\n\tCreateSingleBlock();\n\ttranslate([single_piece_size,0,0]) CreateSingleBlock();\n\ttranslate([0,single_piece_size,0]) \tCreateSingleBlock();\n}\nmodule CreateSingleBlock()\n{\n\tstick_radius = ( single_piece_size / 2 ) - 1;\n\tunion()\n\t{\n\t\tcube([single_piece_size,single_piece_size,block_thickness]);\n\t\ttranslate([single_piece_size/2,single_piece_size/2,block_thickness]) cylinder(h=stick_length, r=stick_radius);\n\t}\n}\nmodule CreateBasePlateHole()\n{\n\twallThickness = 1;\n\ttranslate([wallThickness,wallThickness,0-stick_length]) cube([single_piece_size-(wallThickness*2),single_piece_size-(wallThickness*2),stick_length*3]);\n}",
    "description": "Okay, I'm looking to create a customizable set of building blocks, kind of like Ministeck. I've already got a basic OpenSCAD file that does some of this, but I'd like a much more robust and parametric version. \n\nHere's what I'm hoping to achieve:\n\n**Core Requirements:**\n\n1.  **Individual Block:**  The basic building block is a small square with a peg on top and a corresponding hole on the bottom for connecting to other pieces or a baseplate.\n    *   The size of the single square block should be a parameter, let's call it `single_piece_size`.\n    *   The thickness of the block itself (excluding the peg) should also be a parameter, say `block_thickness`.\n    *   The peg's length should be a parameter named `stick_length`.  The peg should be a cylinder. I think I got the radius calculation right, so let's leave that.\n    *   The hole should also be parametric and slightly larger than the peg, so the blocks connect easily. I made this a hole with a given wall thickness, but maybe there is a more intuitive way.\n\n2.  **Different Block Shapes:** I need several different shapes derived from the basic block, including:\n    *   A \"two-block\" piece (two single blocks side by side). I actually have two versions for this and they should both be separate primitives. A two-block should be oriented along x, and a two-block-turned should be oriented along y.\n    *   A \"three-block\" piece (three single blocks in a line). Same deal, with two primitives called three-block and three-block-turned, for different orientations.\n    *   A \"four-block\" piece (two single blocks on top of two single blocks, so an L or reversed L shape)\n    *   A \"corner-block\" piece (two single blocks adjacent to each other, forming a corner)\n\n3.  **Baseplate:** I also need a base plate, which is essentially a grid of holes that match the pegs on the bottom of the blocks.\n    *   The base plate should be defined by `base_plate_x_count` and `base_plate_y_count` parameters, representing the number of block units along the x and y axes, respectively.\n\n4.  **Set Generation:** I'd like to be able to generate a pre-defined \"set\" that includes various numbers of the basic blocks, including the \"turned\" blocks and single blocks. The positioning within the \"set\" is okay as I have it in my old code.\n\n5.  **Placement and Spacing:**\n    *   A parameter `space_between_things` should control the spacing between multiple instances of blocks when generating a set or multiple copies of a single type of block.\n    *  When generating multiple copies, they should be translated along the x-axis.\n\n6. **Thing Type**: A parameter named `thing_type` should define which type of output should be rendered.\n   *   This should support an output of the type \"test set\" to render one each of the block shapes plus a small section of the baseplate to check that they fit.\n   *   This should also support the output \"complete block set\", \"base plate\", \"one-block\", \"two-block\", \"three-block\", \"corner-block\", and \"four-block\". Each of the block types should support rendering multiple copies of the primitive by using a parameter `how_many`.\n\n**Parametric Design Requirements:**\n\n*   All dimensions (size, thickness, peg length, spacing, etc.) should be controlled by parameters, as I have set in the code I am using.\n*   The final OpenSCAD file should be well-structured, modular, and easy to read and modify.\n*   I would like to be able to choose which specific type of block to render, or to render a whole set.\n*  I'd like to use clear naming conventions for both parameters and modules so that I can easily understand them.\n*   Ideally, the design should be flexible enough to potentially support even more complex block shapes or variations in the future, if I want to extend it.\n\n**Example Parameters:**\n\n```\nsingle_piece_size = 4; // [3:10]\nblock_thickness = 2; // [1:5]\nstick_length = 3; // [2:5]\nthing_type = \"test set\"; // [complete block set,base plate,one-block,two-block,three-block,corner-block,four-block, test set]\nbase_plate_x_count = 20; // [5:40]\nbase_plate_y_count = 20; // [5:40]\nhow_many = 1; // [1:50]\nspace_between_things = 2; // [2;10]\n```\n\nI am not including any libraries, but I would be open to using libraries if they could add clarity or functionality. I am currently not familiar with any libraries, so the response will need to be self-contained to work in a single file.\n\nCould you generate an OpenSCAD file that meets these requirements?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable General Purpose Knob",
    "scad": "fillet_r = 5.588;\nmin_r = 11.862;\nmax_r = 13.335;\nbase_h = 20.188;\ncyl_h = base_h - fillet_r;\nbase_res = 17;\nshaft_r = 5.607;\nshaft_h = 18.1;\nshaft_in_r = 2.9335;\nshaft_in_min_wid = 4.6355;\nshaft_res = 30;\nkey_th = 1.625;\nkey_wid = 3.183;\nBIG = 40;\ndt = 0.01;\nunion(){\n\thull(){\n\t\trotate_extrude(convexity = 10){\n\t\t\ttranslate([min_r-fillet_r, 0])\n\t\t\tcircle(r = fillet_r,$fn=base_res);\n\t\t}\n\tcylinder(r1=min_r,r2=max_r,h=cyl_h,center=false,$fn=base_res);\n\t}\n\ttranslate([0,0,cyl_h-dt])\n\tdifference(){\n\t\tcylinder(r=shaft_r,h=shaft_h,center=false,$fn=shaft_res);\n\t\tdifference(){\n\t\t\tcylinder(r=shaft_in_r,h=shaft_h+2*dt,center=false,$fn=shaft_res);\n\t\t\ttranslate([shaft_in_min_wid-shaft_in_r,-BIG/2,-BIG/2])\n\t\t\tcube([BIG,BIG,BIG],center=false);\n\t\t}\n\t}\n\ttranslate([shaft_r-dt,-key_th/2,cyl_h-dt])\n\tcube([key_wid,key_th,shaft_h+2*dt],center=false);\n}",
    "description": "Okay, I'm looking for an OpenSCAD design for a general-purpose knob, something that could potentially replace a broken knob on a variety of household items. I want it to be parametric so I can easily adjust the dimensions.\n\nHere's what I'm envisioning:\n\n**General Shape:** The knob should have a base with a rounded fillet at the bottom transitioning into a cylindrical shape, that then flares out slightly to a wider top. Think of a truncated cone with a rounded base. On top of that base, there's a shaft with a flat section, and an inner cylindrical hole with a key slot.\n\n**Specific Features and Parameters:**\n\n*   **Fillet Radius (`fillet_r`):** The radius of the rounded part at the bottom of the base. I want to be able to adjust this. I'd imagine it to be between 1mm and 10mm.\n*   **Minimum Base Radius (`min_r`):** The radius of the narrowest part of the base. Adjustable from about 5mm to 20mm.\n*   **Maximum Base Radius (`max_r`):** The radius of the widest part of the base, which would be at the top. Adjustable from about 5mm to 20mm.\n*   **Base Height (`base_h`):** The total height of the base including the fillet. Adjustable from about 5mm to 50mm.\n*   **Base Resolution (`base_res`):** Number of facets for the circular base. I'd like to pick values from 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, or 20.\n*   **Shaft Outer Radius (`shaft_r`):** The outer radius of the shaft. Adjustable from 1mm to 10mm.\n*   **Shaft Height (`shaft_h`):** The height of the shaft extending from the base. Adjustable from 5mm to 50mm.\n*   **Shaft Inner Radius (`shaft_in_r`):** The radius of the inner hole in the shaft. Adjustable from 0.5mm to 8mm.\n*   **Shaft Inner Minimum Width (`shaft_in_min_wid`):** The width of flat part inside the shaft. Adjustable from 0.5mm to 16mm.\n*   **Shaft Resolution (`shaft_res`):** Number of facets for the circular shaft. Allow picking from values 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, and 40.\n*   **Key Thickness (`key_th`):** Thickness of the key on the side of the shaft. Adjustable from 0.25mm to 4mm.\n*   **Key Width (`key_wid`):**  How far the key extends out from the shaft. Adjustable from 1mm to 20mm.\n\n**General Requirements:**\n\n*   The design should use `hull()` to connect the fillet to the base cylinder to make a smooth transition.\n*   The base should be a truncated cone that smoothly transitions from `min_r` at the bottom to `max_r` at the top.\n*   The inner hole and the key slot should be created using `difference()`.\n*   The parameters should be easy to find and modify at the beginning of the file.\n*   Use `$fn` for resolution parameters.\n\nI don't need any external libraries.\n\nCan you create the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Sphere",
    "scad": "sphere_radius = 10;\nsphere(sphere_radius);",
    "description": "Okay, I'm looking to create a more versatile sphere generator in OpenSCAD. Right now, I've got this simple file (I'll paste it below), but it's way too basic. I want to be able to control more than just the radius.\n\n```\nsphere_radius = 10;//[1:100]\nsphere(sphere_radius);\n```\n\nSpecifically, I'd like to be able to control the following:\n\n1.  **Radius:** This should be a variable, as it is now, but ideally with a slider in the customizer to easily adjust it. Let's keep the comment `[1:100]` next to it.\n2.  **Segments:**  I want to control the number of segments used to draw the sphere. This will let me make it smoother or more faceted, depending on the need.  Please use a variable called `segments`,  and add a slider with the values `[3:100]` in the comments for that variable.\n3. **Center:** Instead of having the sphere be centered at the origin, I want to be able to specify the `x`, `y`, and `z` coordinates for the sphere's center using variables `x_center`, `y_center` and `z_center`. This should allow me to position the sphere anywhere in space. Also, please add comments like `[-50:50]` so that there are sliders in the customizer to move the sphere around.\n4. **Color:** Finally, I'd like to be able to specify the color of the sphere using the color() module. Please use variables `r_color`, `g_color` and `b_color` to specify the color. This should allow me to use sliders to adjust the color from 0 to 1 for each of those variables.\n\nSo, I need a parametric OpenSCAD file that does all that. I'm *not* looking for any extra libraries, just standard OpenSCAD.  Could you generate that for me?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Universal Device Mount: Bar",
    "scad": "connector=\"universal\";\ndevice_width=100;\ndevice_width=87.2;\nbar_height=20;\nbar_width=4;\nlatch_space=10;\nconnector_depth=2.4;\nmodule hook () {\n  linear_extrude(height=bar_height)translate([0,-2,0])polygon(points=[[-latch_space,0],[0,0],[0,-0.8],[0.4,-0.8],[1.2,0],[12.5,0],[12.5, 0.5],[-latch_space+2,2],[-latch_space,bar_width/2]]);\n}\nmodule latch () {\n  hook();\n  mirror([0,1,0])hook();\n};\nmodule cutout () {\n  translate([0,connector_depth,0])rotate([90,0,0])linear_extrude(height=connector_depth*2)polygon(points=[[0,0],[12,0],[12,5.4],[5,5.4],[5,2.9],[0,2.9]]);\n}\nmodule beam () {\n  beam_length=device_width/2-latch_space;\n  linear_extrude(height=bar_height)polygon(points=[[0,0],[beam_length-bar_width,0],[beam_length,bar_width],[beam_length,2*bar_width],[beam_length-(bar_width*2-connector_depth),connector_depth],[0,connector_depth]]);\n}\nmodule universal_connector () {\n difference() {\n  union () {\n    translate([-55/2,0,0])cube([55,connector_depth,30]);\n    beam();\n    mirror()beam();\n  }\n  translate([-21,0,3])union() {\n    union() {\n      cutout();\n      translate([30,0,0])cutout();\n    }\n    translate([0,0,23.8])mirror([0,0,1]) {\n      cutout();\n      translate([30,0,0])cutout();\n    }\n  }\n }\n}\nmodule m6_connector () {\n  beam();\n  mirror()beam();\n  difference() {\n    hull() {\n      translate([0,-18,0])cylinder(r=6,h=4, $fn=40);\n      translate([0, -1.75, 2])cube([19.4, 3.5, 4], center=true);\n    }\n    translate([0,-18,-1])cylinder(r=3.5,h=6, $fn=40);\n  }\n  difference () {\n    difference () {\n      translate([0, -1.75, 2])cube([26.4, 3.5, 4], center=true);\n      translate([14.5, -4.8, -1])cylinder(r=5, h=6, $fn=40);\n    }\n    translate([-14.5, -4.8, -1])cylinder(r=5, h=6, $fn=40);\n  }\n};\ntranslate([device_width/2,bar_width*1.5,0])latch();\ntranslate([-device_width/2,bar_width*1.5,0])mirror()latch();\nif (connector==\"universal\") {\n  universal_connector();\n} else {\n  m6_connector();\n};",
    "description": "Okay, I'm looking to design a universal mounting system for various electronic devices, primarily for car mounts. I need an OpenSCAD file that can generate two types of connectors: one designed to interface with a standard \"universal\" car mount plate (the kind with the little rectangular cutouts) and another with a simple M6 screw hole.\n\nHeres what I envision and the parameters I need to control:\n\n**Core Design:**\n\n*   The mount will consist of two brackets that grip the sides of the device, connected by a central beam. This beam is where the connector (either the universal plate interface or the M6 screw connector) will be located.\n*   The brackets should have a hook-like latching mechanism to securely hold the device.\n*   The design should be fully parametric to allow adjustment for different device widths.\n\n**Parameters:**\n\n*   `device_width`: (Required) The width of the device being mounted, measured from the outside of one bracket to the outside of the other.\n*   `connector`: (Dropdown)  A choice between \"universal\" for the universal plate connector or \"screw\" for the M6 screw hole connector.\n*   `bar_height`: The height of the beam connecting the brackets.\n*   `bar_width`: The width of the beam connecting the brackets.\n*   `latch_space`: The space for the latching mechanism to grip the device.\n*   `connector_depth`: The thickness of the material where the universal connector is cut out and the depth of the beam material.\n\n**Specific Connector Requirements:**\n\n*   **Universal Connector:**\n    *   It should include a rectangular plate with two sets of cutouts (mirrored on top and bottom of the plate) that are compatible with common universal car mount plates like [this one](http://dx.com/p/car-windshield-360-degree-rotation-swivel-mount-holder-for-samsung-i9000-black-65864).\n    *   The cutouts should have the appropriate depth to allow secure connection with the mating parts.\n*   **M6 Screw Connector:**\n    *   It should feature a central M6 screw hole with an adequate flat base around it to accept a mounting bolt or screw with a washer if needed.\n    *   The connector should have some material to maintain structural integrity.\n\n**General Design Notes:**\n\n*   The brackets should latch securely onto the device without damaging it.\n*   The design should be relatively easy to 3D print and structurally sound.\n*   The connector should be centered and symmetrical.\n*   I would prefer the use of standard OpenSCAD primitives and operations, without requiring external libraries like MCAD or BOSL.\n\n**Additional Considerations:**\n\n*   I would like the mounting brackets to automatically adjust to fit different device sizes based on the `device_width` parameter.\n*   I'm including a sample model I made already to help communicate the idea. I'd like to see how the AI would approach the same idea.\n\nI think that's all. Could you please generate the OpenSCAD code?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Revisited & customizable: universal hose coupler and funnel maker",
    "scad": "cone2_max=30;\ncone2_min=28;\ncone2_height=20;\ncone2_wall=3;\ncone2_barb_width=0;\ncone1_min=15;\ncone1_max=18;\ncone1_height=30;\ncone1_wall=2;\ncone1_barb_width=0.8;\njoin_height=3;\nbarb_flatness_ratio=2;\nbarb_spacing_ratio=2;\nbarb_skew_ratio=0.15;\ncheck_guts=0;\ntol=1*0.05;\nfunction xpos(dmin, dmax, height, hpos) = ( dmin+(dmax-dmin)*hpos/height )/2;\nmodule hollow_cone(dmin, dmax, height, wall, barb_width)\n{\n\tif(dmin>0 && dmax>0 && height>0)\n\t{\n\t\tdifference()\n\t\t{\n\t\t\tcylinder(r1=dmin/2, r2=dmax/2, h=height);\n\t\t\tif(wall>0)\n\t\t\t\ttranslate([0,0,-tol])\n\t\t\t\t\tcylinder(r1= dmin/2-wall, r2= dmax/2-wall, h=height+2*tol);\n\t\t}\n\t\tif(barb_width>0 && barb_flatness_ratio!=0)\n\t\t{\n\t\t\tfor(bs=[barb_width*barb_flatness_ratio : 1 : barb_width*barb_flatness_ratio])\n\t\t\t{\n\t\t\t\tfor(hpos=[\n\t\t\t\t\tbs/2\n\t\t\t\t\t: barb_width * barb_flatness_ratio * (1 + barb_spacing_ratio)\n\t\t\t\t\t: height - bs/2]\n\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\ttranslate([0,0,hpos])\n\t\t\t\t\trotate_extrude()\n\t\t\t\t\t\tpolygon( points=[\n\t\t\t\t\t\t\t[xpos(dmin,dmax,height,hpos)-tol, 0],\n\t\t\t\t\t\t\t[xpos(dmin,dmax,height,hpos + bs*(1-barb_skew_ratio)) + barb_width, bs * (1-barb_skew_ratio)],\n\t\t\t\t\t\t\t[xpos(dmin,dmax,height,hpos + bs)-tol, bs],\n\t\t\t\t\t\t] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\tdifference()\n\t{\n\t\tunion()\n\t\t{\n\t\t\tcolor([1,0,0])\n\t\t\thollow_cone(cone1_min, cone1_max, cone1_height, cone1_wall, cone1_barb_width);\n\t\t\tcolor([0,0,1])\n\t\t\t\ttranslate([0,0,cone1_height+join_height+cone2_height])\n\t\t\t\t\trotate([180,0,0])\n\t\t\t\t\t\thollow_cone(cone2_min, cone2_max, cone2_height, cone2_wall, cone2_barb_width);\n\t\t\tif(join_height>0)\n\t\t\t{\n\t\t\t\tcolor([0,1,0])\n\t\t\t\ttranslate([0,0,cone1_height])\n\t\t\t\trotate_extrude()\n\t\t\t\t\tpolygon( points=[\n\t\t\t\t\t\t[ cone1_max/2-cone1_wall, 0],\n\t\t\t\t\t\t[ cone1_max/2, 0],\n\t\t\t\t\t\t[ max(cone1_max,cone2_max)/2, join_height/2],\n\t\t\t\t\t\t[ cone2_max/2, join_height],\n\t\t\t\t\t\t[ cone2_max/2-cone2_wall, join_height],\n\t\t\t\t\t\t[ min(cone1_max/2-cone1_wall,cone2_max/2-cone2_wall), join_height/2],\n\t\t\t\t\t] );\n\t\t\t}\n\t\t}\n\t\tif(check_guts!=0)\n\t\t{\n\t\t\tscale([0.5,1,1]) rotate([0,0,45]) translate([0,0,-tol]) cube([100,100,100]);\n\t\t}\n\t}",
    "description": "Okay, so I'm trying to design a universal hose adapter, kind of like a double-ended cone with barbs to help keep hoses from slipping off. I found this SCAD file online, but I'd like to have more control over the parameters and have the option of more complex barbs, maybe. I'd also like it to be easier to change the basic shape without diving deep into the code.\n\nHere's a breakdown of what I need and what I'm thinking:\n\n**Overall Shape:**\n\n*   The adapter is essentially two hollow cones connected by a short cylindrical or slightly tapered section.\n*   One cone is intended for a smaller hose, the other for a larger hose.\n*   The cones have different diameters at their base and top, and they have different heights and wall thicknesses.\n*   The connection between the cones (the junction) also has a height.\n*   All dimensions should be adjustable using parameters.\n\n**Specific Parameters I need:**\n\n*   **Top Cone:**\n    *   `cone2_max`: Base diameter of the top cone (usually slightly bigger than the top diameter).\n    *   `cone2_min`: Top diameter of the top cone (usually slightly smaller than the base radius).\n    *   `cone2_height`: Height of the top cone.\n    *   `cone2_wall`: Wall thickness of the top cone.\n    *   `cone2_barb_width`: Protruding width of barb-like outer rings on the top cone (0 to disable).\n*   **Bottom Cone:**\n    *   `cone1_min`: Base diameter of the bottom cone (outside of the lower cone).\n    *   `cone1_max`: Top diameter of the bottom cone.\n    *   `cone1_height`: Height of the bottom cone.\n    *   `cone1_wall`: Wall thickness of the bottom cone.\n    *   `cone1_barb_width`: Protruding width of barb-like outer rings on the bottom cone (0 to disable).\n*   **Junction:**\n    *   `join_height`: Height of the connecting section between the cones.\n*   **Barb Parameters (advanced):**\n    *   `barb_flatness_ratio`:  Sets barb height as a factor of barb size. (e.g., 1.0 means 45 barbs, 2.0 makes flatter barbs)\n    *   `barb_spacing_ratio`: Sets barb spacing as a factor of barb height. (0 means adjacent barbs, 1 gives an identical flat space as the barbs).\n    *   `barb_skew_ratio`: Adjusts the barb shape to avoid overhangs.  (0.5 is symmetrical, <0.5 is concave, >0.5 is reversed/probably useless)\n*   **Other:**\n    *   `check_guts`: A boolean to enable or disable a slice through the adapter to check the internal shape, though I'd like to have a more robust method for debugging and verifying the model before printing.\n\n**Enhancements I'd Like:**\n\n*   **Simplified shape control:** Instead of `cone1_min`, `cone1_max`, etc. I'd prefer using a more generic `outer_diameter_1`, `inner_diameter_1` and a similar one for each cone as well as the connection zone. Similarly, height for each cone and connection, wall thickness, etc.\n*   **More Barb Shape Options:**  I'd like to explore beyond the triangular profile used in the original SCAD file. Maybe options for rounded barbs, or sawtooth barbs. Perhaps a user-defined profile could be provided for the barb.\n*   **Barb Placement Control:** The original code has a fairly simple approach to barb placement. Perhaps an option for a fixed number of barbs at each part of the cones, or even a pattern (like different spacing in different cone sections.)\n*   **Preview:** A more robust option to make sure the adapter meets my needs before I print, as well as easy visual differentiation (for example via color) of the various parts.\n*   **Parameter Naming:** More descriptive parameter names for ease of use (e.g. `top_cone_base_diameter` instead of `cone2_max`)\n\n**Libraries:**\n\nI'm not sure about which specific libraries you would suggest, but having access to a library with standard OpenSCAD primitives would help, including some of the more advanced features that may be present in some of them.\n\nEssentially, I want a fully parametric and customizable universal hose adapter that's easy to tweak. I prefer to specify the diameters instead of the radius, so please use `diameter` and not `radius`.\n\nCan you generate the SCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Nintendo DS Game Card Box",
    "scad": "stuffz = 2/1;\nfuzz = 0.2/1;\nreal_card_length = 34.95/1;\nreal_card_width = 32.75/1;\nreal_card_thick = 3.8/1;\ncard_length = real_card_length + fuzz;\ncard_width = real_card_width + fuzz;\ncard_thick = real_card_thick + fuzz;\nbox_height_addition = 25;\ngutter_height = 2;\ngutter_width = 3;\nnumber_of_cards = 5;\ncard_spacing = 4;\n$fn = 20;\ncube_r = 3;\nbox(number_of_cards);\nmodule card(){\n  cube([card_width,card_thick,card_length]);\n}\nmodule box(number){\n  box_x = card_width + stuffz*2;\n  box_y = card_spacing + (card_thick + card_spacing) * number;\n  box_z = gutter_height+ stuffz + box_height_addition;\n  card_x_trans = box_x / 2 - card_width /2;\n  difference(){\n    roundCornerCube(box_x,box_y,box_z,cube_r);\n    translate([(box_x/2) - (gutter_width/2),-fuzz,-fuzz])\n    cube([gutter_width, box_y + (fuzz*2),gutter_height+fuzz]);\n    for (i = [0 : number-1]){\n      #translate([card_x_trans, card_spacing + (card_thick + card_spacing)*i,gutter_height+stuffz]) card();\n    }\n  }\n}\nmodule roundCornerCube(x,y,z,r_sphere){\nr = r_sphere;\nif (x < r) {echo (\"roundCornerCube: error: x < r !!\");}\nif (y < r) {echo (\"roundCornerCube: error: y < r !!\");}\nif (z < r) {echo (\"roundCornerCube: error: z < r !!\");}\n\thull(){\n\t\ttranslate([r,y-r,z-r]) sphere(r_sphere);\n\t\ttranslate([x-r,y-r,z-r]) sphere(r_sphere);\n\t\ttranslate([r,r,z-r]) sphere(r_sphere);\n\t\ttranslate([x-r,r,z-r]) sphere(r_sphere);\n\t\ttranslate([r,y-r,r]) sphere(r_sphere);\n\t\ttranslate([x-r,y-r,r]) sphere(r_sphere);\n\t\ttranslate([r,r,r]) sphere(r_sphere);\n\t\ttranslate([x-r,r,r]) sphere(r_sphere);\n\t}\n}",
    "description": "Okay, I'm looking for an OpenSCAD design for a box to hold Nintendo DS game cards. I've seen some designs online but they're often too large for my printer, or not quite what I need.\n\nHere's what I need in this box:\n\n*   **Card Dimensions:** The actual DS game cards are roughly 35mm long, 33mm wide, and 3.8mm thick. I need a little wiggle room, so let's add 0.2mm to each of these dimensions.\n*   **Customization:** I want to be able to set how many cards the box will hold, from 1 up to 20. The number of cards should be a parameter.\n*   **Card Spacing:** The cards need to be spaced apart so they aren't rubbing. I want a parameter for the spacing between the cards, and I'd like that to be able to vary from 2mm to 7mm.\n*   **Box Shape:**  The box should have a base and four walls and a rounded rectangle type of base. Let's make the corners rounded with a radius setting, and that radius can be set from 1mm to 5mm. There needs to be a gutter along one side.\n*   **Gutter:** The box will need a gutter or indent at the base of the box along the back so that the user can more easily grab the cards. The gutter will need a depth setting and width setting. The gutter depth should be set from 1mm to 5mm, and so should the width.\n*   **Wall Thickness/Clearance:** The wall of the box needs to be thick enough to be printable, and there needs to be extra space around the cards so they slide in and out easily, let's make that an additional 2mm on either side of the card, for each card.\n*   **Box Height:**  The box needs to be tall enough to hold the cards plus an additional amount of space, and that should be a parameter, from 10mm to 32mm in addition to the height of the cards and the gutter.\n\nSo, to recap, I'd like these to be customizable parameters:\n\n*   `number_of_cards` (1-20)\n*   `card_spacing` (2-7mm)\n*   `cube_r` - the radius of the rounded corners (1-5mm)\n*   `gutter_height` (1-5mm)\n*   `gutter_width` (1-5mm)\n*   `box_height_addition` (10-32mm)\n\nI need it to be a single, parametric OpenSCAD file, and I don't need any external libraries.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Greek Temple",
    "scad": "pillars_per_row=7;\nfloor_width=12;\nfloor_length=24;\npillar_height=8;\npillar_width=1.2;\npillar_style=0;\navoid_extreme_overhangs=-1;\nunit = 1;\nscale(unit) union()\n{\ntranslate([floor_width/-2+6,floor_length/-2+12,0]) union()\n{\ntranslate([(-1/(10/12))+floor_width/10,(-1/(22/24))+floor_length/22,0]) scale([floor_width*10/12,floor_length*11/12,1.5]) cube(1);\ntranslate([(-1.5/(11/12))+floor_width/11,(-1.5/(23/24))+floor_length/23,0]) scale([floor_width*11/12,floor_length*11.5/12,1]) cube(1);\ntranslate([-2+floor_width/12,-2+floor_length/24,0]) scale([floor_width,floor_length,0.5]) cube(1);\n}\ntranslate([2+(pillar_width-1.2),2+(pillar_width-1.2),1]) pillar_row();\ntranslate([8-(pillar_width-1.2),2+(pillar_width-1.2),1]) pillar_row();\ntranslate([1,1,pillar_height+1.25]) scale([8,20,0.5]) cube(1);\ntranslate([1.5,1,pillar_height+1.75]) scale([7,20,0.5]) cube(1);\ntranslate([2,1,pillar_height+2.25]) scale([6,20,0.5]) cube(1);\n}\nmodule pillar()\n{\nPTopBot();\n translate([0,0,0]) scale([pillar_width/20,pillar_width/20,pillar_height]) cylinder(r=10,h=1);\n}\nmodule pillar_row()\n{\nfor(prog=[0:pillars_per_row-1])\n{\n translate([0,pilldist*prog,0]) pillar();\n}\n}\nmodule PTopBot()\n{\nscale((avoid_extreme_overhangs-1)/-2) union()\n {\n translate([0,0,pillar_height-0.25]) scale([pillar_width/12,pillar_width/12,.075]) sphere(10);\n translate([0,0,pillar_height-0.25]) scale([pillar_width/12,pillar_width/12,0.5]) cylinder(r=10,h=1);\n}\nscale((avoid_extreme_overhangs+1)/2) union()\n {\ntranslate([0,0,pillar_height-0.25]) scale([pillar_width/12,pillar_width/12,pillar_width/12]) sphere(10);\n translate([0,0,pillar_height-0.25]) scale([pillar_width/12,pillar_width/12,0.5]) cylinder(r=10,h=1);\n }\ntranslate([]) scale(pillar_style) union()\n {\nscale((avoid_extreme_overhangs-1)/-2) union()\n {\n translate([0,0,1]) scale([pillar_width/12,pillar_width/12,.075]) sphere(10);\n translate([0,0,0.5]) scale([pillar_width/12,pillar_width/12,0.5]) cylinder(r=10,h=1);\n }\nscale((avoid_extreme_overhangs+1)/2) union()\n {\n translate([0,0,1]) scale([pillar_width/12,pillar_width/12,pillar_width/12]) sphere(10);\n translate([0,0,0.5]) scale([pillar_width/12,pillar_width/12,0.5]) cylinder(r=10,h=1);\n }\n }\n}\npilldist=(18-2*(pillar_width-1.2))/(pillars_per_row-1);",
    "description": "Okay, I'm looking for an OpenSCAD design for a customizable Greek temple, similar to the one I found online, but I'd like to improve the customizability and fix some issues.\n\nHere's what I need:\n\n**Core Structure:**\n\n*   **Floor:** A rectangular base. I need to be able to set the `floor_width` and `floor_length` as parameters. The base should have multiple layers, like in the example file, where the bottom layer is slightly smaller than the top and middle layers. The top should be larger than the middle. This should be controlled with scale. I would like to see the scaling factors on this to be able to scale all floors at once.\n*   **Pillars:** Cylindrical pillars, arranged in rows along the sides of the temple. I need parameters for:\n    *   `pillars_per_row`: The number of pillars on each side.\n    *   `pillar_height`: The height of the pillars.\n    *   `pillar_width`: The diameter of the pillars.\n    *   The pillar spacing should be calculated automatically so the pillars are equally spaced based on the floor length and the pillar width.\n*   **Roof:** A multi-layered, stepped roof, again, like in the example file, which has three layers decreasing in size. I should be able to control `roof_length` and `roof_width` as in the example. The roof should be placed centered on top of the pillars.\n\n**Customization:**\n\n*   **Pillar Base/Top:** I'd like to be able to add a decorative base and capital (top) to the pillars. These should be spheres and cylinders as in the example file and should be able to be optional. The parameter should be called `pillar_style` which accepts 0 for no base, or 1 for a base.\n*   **Overhangs:** There's a setting called `avoid_extreme_overhangs` in the example. I'm not sure what this is doing, but I'd like an explanation as to what this is doing and why a sphere might be scaled differently. I'd also like a better solution to extreme overhangs than scaling the sphere between 0 and 1.\n\n**Units:**\n\n*   I need to be able to specify the units for the design. I'd like a parameter called `unit` that can be set to 1 for millimeters, 10 for centimeters, and 25.4 for inches, or any similar approach to unit conversions.\n\n**Improvements over the Example:**\n\n*   The floor in the example file has weird numbers, like (-1/ (10/12)). I would like these to be more straight forward. I think that scaling factor would make more sense. The same applies for the rest of the floors.\n*   I'm not sure what `pilldist` is supposed to be, and think a more explicit solution might be helpful.\n*   I'd like the scaling to use proper floats rather than the current implementation.\n*   The roof in the example file is placed arbitrarily. I'd like it centered on top of the pillars.\n*   The pillar_row function is explicitly translated. It would be helpful to make it relative to the center of the floor.\n*   I would like there to be an option to add a gable to the front and rear of the roof. I'm looking for a simple triangle, with the height and length controlled by parameters.\n*   I'd also like to add a parameter for the number of roof layers. This should allow me to add or remove layers.\n*   The pillars currently only appear on 2 sides. I'd like pillars to also exist on the front and back.\n\n**Libraries:**\n\n*   I am not using any specific libraries for this design.\n\nCould you generate an OpenSCAD file that fulfills these requirements? Please make it as parametric and robust as possible.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Loaded Trick Dice",
    "scad": "Number=1;\nmodule Dice(Side){\n\tmodule One(){\n\t\tsphere(r=2.75,$fn=20);\n\t}\n\tmodule Two(){\n\t\ttranslate([5.75,5.75,0]) One();\n\t\ttranslate([-5.75,-5.75,0]) One();\n\t}\n\tmodule Three(){\n\t\tOne();\n\t\tTwo();\n\t}\n\tmodule Four() {\n\t\ttranslate([5.75,5.75,0]) One();\n\t\ttranslate([-5.75,-5.75,0]) One();\n\t\ttranslate([-5.75,5.75,0]) One();\n\t\ttranslate([5.75,-5.75,0]) One();\n\t}\n\tmodule Five(){\n\t\tFour();\n\t\tOne();\n\t}\n\tmodule Six(){\n\t\tFour();\n\t\ttranslate([5.75,0,0]) One();\n\t\ttranslate([-5.75,0,0]) One();\n\t}\n\tdifference(){\n\t\tminkowski(){\n\t\t\tcube([20,20,20],center=true);\n\t\t\tsphere(r=3);\n\t\t}\n\t\tunion(){\n\t\t\trotate([0,180,0]) translate([0,0,14]) One();\n\t\t\trotate([0,90,0]) translate([0,0,14]) Two();\n\t\t\trotate([90,0,0]) translate([0,0,14]) Three();\n\t\t\trotate([-90,0,0]) translate([0,0,14]) Four();\n\t\t\ttranslate([0,0,14]) Five();\n\t\t\trotate([0,-90,0]) translate([0,0,14]) Six();\n\t\t\trotate(Side) translate([0,0,5.5]) cube([15,15,8], center=true);\n\t\t}\n\t}\n}\nLoaded_One=[0,180,0];\nLoaded_Two=[0,90,0];\nLoaded_Three=[90,0,0];\nLoaded_Four=[-90,0,0];\nLoaded_Five=[0,0,0];\nLoaded_Six=[0,-90,0];\nif (Number==1){ Dice(Loaded_One);\n} else if (Number==2) { Dice(Loaded_Two);\n} else if (Number==3) {Dice(Loaded_Three);\n}else if (Number ==4) {Dice(Loaded_Four);\n} else if (Number==5) {Dice(Loaded_Five);\n} else if (Number==6) {Dice(Loaded_Six); }",
    "description": "Okay, I'd like to design a loaded die, similar to the one I have attached, but I'd like it to be more parametric and easier to customize.\n\nHere's what I'm looking for:\n\n**Core Functionality:**\n\n*   **Loaded Number Selection:** The user should be able to specify which face of the die is weighted (i.e. the number that is more likely to be rolled). This should be a parameter ranging from 1 to 6.\n*   **Hollow Cavity:** Instead of a fixed cube, I'd like to be able to control the size and depth of the hollow spot below the loaded number. Specifically, I want to be able to define these parameters:\n    *   `cavity_width`: The width and depth (since it will be a cube) of the cavity.\n    *   `cavity_depth_ratio`: This should be a ratio relative to the radius of the sphere. For example, a ratio of 0 would mean no depth, while a ratio of 1 would go to the center of the die.\n    *   `cavity_offset_ratio`: This should be a ratio that allows for offset of the cube within the sphere, as a ratio relative to the sphere's radius.\n\n*   **Sphere Radius:** The radius of the sphere used to make the rounded die should be a customizable parameter.\n*   **Dice Size:** The overall size of the dice, which is currently fixed at 20mm on each side, should be parameterized. I'd prefer to specify the *edge length* of the die.\n*   **Dot Size:** The dots on each side of the dice should be parameterized by the dot sphere radius.\n*   **Dot Depth:** The depth that the dots indent should be parameterized.\n*   **Number Placement:** The dots on each face should be placed automatically based on the face value (1-6) and parameters.\n*  **Number Rotations:** The loaded number should be rotated to the top face.\n\n**Specific OpenSCAD Requirements:**\n\n*   The design should use the `minkowski()` function for creating the rounded die shape, like the existing file.\n*   It should use the `difference()` function to subtract the hollow cavity from the dice body.\n*   It should use the `translate()` and `rotate()` functions to position the dot on the various faces, and correctly rotate the cavity.\n*   The dots should be made from spheres and translated/rotated accordingly\n*   It would be helpful if the dot creation modules could be made more modular.\n\n**User Interface/Parameters:**\n\nThe OpenSCAD file should clearly define the following parameters at the top:\n\n*   `loaded_number` (integer, 1-6): The face that will be more likely to be rolled.\n*   `dice_edge_length` (float): The length of one edge of the die cube before the minkowski.\n*   `sphere_radius` (float): The radius of the sphere used in the `minkowski()`.\n*   `cavity_width` (float): The width/depth of the hollow cavity cube.\n*   `cavity_depth_ratio` (float): The depth of the cavity as a ratio of the sphere's radius.\n*   `cavity_offset_ratio` (float): The offset of the cavity as a ratio of the sphere's radius.\n*   `dot_sphere_radius` (float): The radius of the spheres used to create the dots.\n*   `dot_depth` (float): The depth that the dots indent.\n*   `fn` (integer): The $fn value for spheres\n\n**Output:**\n\nThe output should be a single 3D model of the loaded die, ready for STL export.\n\n**Libraries:**\n\n* I will not be including any code. Please do not assume I am attaching any OpenSCAD libraries, but if you use libraries in your response, please name them explicitly in the response.\n\nEssentially, I want to take the existing concept and make it more customizable and parameter driven. I'm hoping this will make it easier to play around with the loading and the overall shape of the die.\n"
  },
  {
    "object": "Hey cadmonkey, make me a  Customizable Lens Filter Case",
    "scad": "_1_filterDiameter = 52.3;\n_2_filterHeight = 5.2;\n_3_sidewallThickness = 1.0;\n_4_edgeThickness = 1.6;\n_5_magnetDiameter = 3.95;\n_6_magnetHeight = 2.2;\n_7_magnetWall = 1.4;\nmodule hinge(y, radius, height) {\n\ttranslate([0,y,0]) {\n\t\tcylinder(h = height, r = radius);\n\t}\n}\nmodule outsideShell(radius, outsideHeight, hingeY, hingeRadius) {\n\thull () {\n\t\tcylinder(h = outsideHeight, r = radius);\n\t\thinge(hingeY, hingeRadius, outsideHeight);\n\t\thinge(-hingeY, hingeRadius, outsideHeight);\n\t}\n}\nmodule filter(radius, height) {\n\tcylinder(h = height, r = radius);\n}\nmodule rightCut(radius, height) {\n\ttranslate([0,-radius*2,0]) {\n\t\tcube([radius * 2, radius * 4, height+1]);\n\t}\n}\nmodule chamfer(direction, hingeY, hingeRadius, diameter, mDiameter, height) {\n\tsq2 = sqrt(2);\n\tpolyhedron(\n  \t\tpoints=[ \t[0,hingeY-hingeRadius*4 * direction,0],\n\t\t\t\t\t[0,0,height],\n\t\t\t\t\t[-diameter/(2*sq2),diameter/(2*sq2) * direction,height],\n\t\t\t\t\t[0,hingeY+mDiameter/2 * direction,height] ],\n\t\ttriangles=[ [3,1,2],[3,0,1],[1,0,2],[0,3,2] ]\n\t);\n}\nmodule filterTray(diameter, height, side, edge, mDiameter, mHeight, mWall, $fn = 180) {\n\tradius = diameter/2 + edge;\n\thingeY = diameter/2 + mDiameter/2 + mWall;\n\thingeRadius = mDiameter/2 + mWall;\n\toutsideHeight = height + side;\n\tdifference () {\n\t\tunion() {\n\t\t\tdifference () {\n\t\t\t\ttranslate([0,0,-side]) {\n\t\t\t\t\toutsideShell(radius, outsideHeight, hingeY, hingeRadius);\n\t\t\t\t}\n\t\t\t\tfilter(diameter/2, height+1);\n\t\t\t\trightCut(radius, height);\n\t\t\t}\n\t\t\thinge(hingeY, hingeRadius, height);\n\t\t\thinge(-hingeY, hingeRadius, height);\n\t\t}\n\t\ttranslate([0,0,height/2]) {\n\t\t\thinge(hingeY, hingeRadius + 0.2, height);\n\t\t\thinge(-hingeY, hingeRadius + 0.2, height);\n\t\t}\n\t\ttranslate([0,0,height/2 - mHeight]) {\n\t\t\thinge(hingeY, mDiameter/2, mHeight+1);\n\t\t\thinge(-hingeY, mDiameter/2, mHeight+1);\n\t\t}\n\t\tchamfer(1, hingeY, hingeRadius, diameter, mDiameter, height);\n\t\tchamfer(-1, -hingeY, hingeRadius, diameter, mDiameter, height);\n\t}\n}\nfilterTray(_1_filterDiameter, _2_filterHeight, _3_sidewallThickness, _4_edgeThickness, _5_magnetDiameter, _6_magnetHeight, _7_magnetWall);",
    "description": "Okay, I'm looking to design a customizable case for my camera lens filters. I've seen a similar design that uses magnets as a hinge and a closure system, and I think that's a great approach. I'm imagining a two-part case that holds the filter securely and can stack with other cases of the same design thanks to the magnets.\n\nHere's what I need:\n\n*   **Filter Compatibility:** The case needs to accommodate circular lens filters of varying diameters and thicknesses. I'll need to specify these dimensions as parameters. I need a way to specify a filter diameter and filter height.\n*   **Case Thickness:** The case will need some wall thickness to protect the filter, and some edge thickness. I'll need to specify the sidewall thickness, and the edge thickness (the thickness extending past the filter).\n*   **Magnetic Hinge:** I want to use small cylindrical magnets as a hinge mechanism, and to help keep the case closed. I'll need to define the diameter and height of the magnets used and the wall thickness around the magnet recess. The magnets should be recessed into the case so they are flush or slightly below the outer surface.\n*   **Stackability:** The design needs to stack with identical cases. The magnets should be placed so that they attract and align.\n*   **Chamfers:** I'd like to have chamfered edges where the case closes together and where the two halves meet, mostly for aesthetics and slightly improved printability.\n\nI'd prefer the design be fully parametric so I can adjust all dimensions easily and generate cases for different filters and magnet sizes. I'm thinking of using OpenSCAD for this.\n\nCan you generate the necessary OpenSCAD code for me? Please don't use any libraries.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Filament Spool ",
    "scad": "unit = 1;\nspool_width = 20;\nspool_walls_diameter = 100;\nspool_walls_width = 3;\nspool_hole_diameter = 30;\nfilament_diameter = 2;\nspl_l=spool_width*unit;\nspl_w_d=spool_walls_diameter*unit;\nspl_w_w=spool_walls_width*unit;\nspl_h_d=spool_hole_diameter*unit;\n$fn=48*2;\nspl_w_r=spl_w_d/2*1;\nspl_h_r=spl_h_d/2*1;\nfil_r=filament_diameter/2*1;\ntranslate([-spl_w_d/2-3,0,0]) difference()\n{\n\tunion()\n\t{\n\t\tcylinder(spl_w_w,spl_w_r,spl_w_r);\n\t\tcylinder(spl_w_w+spl_l,spl_h_r+5,spl_h_r+5);\n\t}\n\ttranslate([0,0,-1]) cylinder(spl_l+2,spl_h_r,spl_h_r);\n\ttranslate([0,0,spl_w_w]) cylinder(spl_w_w+spl_l+2,spl_h_r+3.1,spl_h_r+3.1);\n\ttranslate([0,0,spl_w_w+fil_r]) rotate(90,[1,0,0]) cylinder(spl_h_d+11,fil_r,fil_r,true);\n\ttranslate([0,0,spl_w_w+spl_l-fil_r]) rotate(90,[0,1,0]) cylinder(spl_h_d+11,fil_r,fil_r,true);\n\tdifference()\n\t{\n\t\tdifference()\n\t\t{\n\t\t\ttranslate([0,0,-1]) cylinder(spl_w_w+2,spl_w_r-spl_w_w*2,spl_w_r-spl_w_w*2);\n\t\t\tfor(i=[0:6])\n\t\t\t{\n\t\t\t\trotate(i*360/7,[0,0,1]) translate([0,-spl_w_w,-1]) cube([spl_w_r,spl_w_w*2,spl_w_w+2]);\n\t\t\t}\n\t\t}\n\t\ttranslate([0,0,-2]) cylinder(spl_w_w+4,spl_h_r+spl_w_w*2+5,spl_h_r+spl_w_w*2+5);\n\t}\n}\ntranslate([spl_w_d/2+3,0,0]) difference()\n{\n\tunion()\n\t{\n\t\tcylinder(spl_w_w,spl_w_r,spl_w_r);\n\t\tcylinder(spl_w_w+spl_l,spl_h_r+3,spl_h_r+3);\n\t}\n\ttranslate([0,0,-1]) cylinder(spl_l+2,spl_h_r,spl_h_r);\n\ttranslate([0,0,spl_w_w]) cylinder(spl_w_w+spl_l+2,spl_h_r+1,spl_h_r+1);\n\tdifference()\n\t{\n\t\tdifference()\n\t\t{\n\t\t\ttranslate([0,0,-1]) cylinder(spl_w_w+2,spl_w_r-spl_w_w*2,spl_w_r-spl_w_w*2);\n\t\t\tfor(i=[0:6])\n\t\t\t{\n\t\t\t\trotate(i*360/7,[0,0,1]) translate([0,-spl_w_w,-1]) cube([spl_w_r,spl_w_w*2,spl_w_w+2]);\n\t\t\t}\n\t\t}\n\t\ttranslate([0,0,-2]) cylinder(spl_w_w+4,spl_h_r+spl_w_w*2+5,spl_h_r+spl_w_w*2+5);\n\t}\n}",
    "description": "Okay, I'm looking to design a parametric filament spool for my 3D printer. I have some leftover filament I'd like to wind onto a smaller spool than the standard ones. I'd like to be able to adjust the size of the spool based on a few key dimensions:\n\n*   **Spool Width:** I need to be able to specify the inner width of the spool (where the filament winds), I need this to be adjustable. I'm thinking it should be at least 10mm, but should be adjustable.\n\n*   **Spool Outer Diameter:** I need control over the outer diameter of the spool walls, that's the diameter of the circles that hold the filament in. I think it would be useful to be able to set this between 70mm and 150mm, but again, it should be adjustable.\n\n*   **Spool Wall Thickness:** I need to define how thick the walls of the spool are, I think at least 3mm is necessary.\n\n*   **Spool Hole Diameter:** I also need to define the diameter of the central hole of the spool. This should be at least 25mm, but should be adjustable.\n\n*   **Filament Diameter:** The spool will also hold a specific diameter of filament. I'll want to be able to choose between 1.75mm and 3mm filament.\n\nMy design should create a spool with two outer walls connected by a central core. I'd like the walls to have some kind of recessed area on their inner facing side, possibly with some reinforcing ribs, to help hold the filament in place. I would also like the inner walls to be as smooth as possible. \n\nI'd like the OpenSCAD file to be completely parametric, and use variables for all of these dimensions. I would also like the units to be adjustable, with both mm and inch options, but mm should be the default.\n\nI would like to use a library for the generation of threads in the central hole and for any connectors if they are added. I think the BOLTS library would be useful for this as I know it supports both inch and metric threads.\n\nCan you generate an OpenSCAD file based on these specifications?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Gauntlet",
    "scad": "LayoutMode=\"Assembled\";\nFingerThick=22;\nFingerHeight=100;\nFingerWidth=85;\nPalmLength=80;\nHandThick=30;\nWT=2;\nHand=\"Right\";\nRivetSize=4;\nFCA=0;\nCR=25;\nmodule FingerLug(FT,FH,FW){\n\tdifference(){\n\t\tunion(){\n\t\t\tcylinder(h=FH/4+FT/2,r=FT/2+WT,$fn=CR);\n\t\t\ttranslate(v=[0,FW-FT,0]){cylinder(h=FH/4+FT/2,r=FT/2+WT,$fn=CR);}\n\t\t\ttranslate(v=[-FT/2-WT,0,0]){cube([FT+WT*2,FW-FT,FH/4+FT/2]);}\n\t\t\ttranslate(v=[0,-FT/2-WT,0]){cube([FT/2+WT,FT/2+WT,FH/4+FT/2]);}\n\t\t\ttranslate(v=[0,FW-FT,0]){cube([FT/2+WT,FT/2+WT,FH/4+FT/2]);}\n\t\t\ttranslate(v=[FT/4+WT/2,-FT/2-WT,FT/4]){sphere(r=WT,$fn=CR);}\n\t\t\ttranslate(v=[FT/4+WT/2,-FT/2-WT,FH/4+FT/2-FT/4]){sphere(r=RivetSize,$fn=CR);}\n\t\t\ttranslate(v=[FT/4+WT/2,FW-FT/2+WT,FT/4]){sphere(r=WT,$fn=CR);}\n\t\t\ttranslate(v=[FT/4+WT/2,FW-FT/2+WT,FH/4+FT/2-FT/4]){sphere(r=RivetSize,$fn=CR);}\n\t\t\ttranslate(v=[-FT/2-WT*1.5,FT/2,FH/4]){rotate(a=[45,0,0]){cube([WT,FT/2,FT/2],center=true);}}\n\t\t\ttranslate(v=[-FT/2-WT*1.5,FW-FT*1.5,FH/4]){rotate(a=[45,0,0]){cube([WT,FT/2,FT/2],center=true);}}\n\t\t\ttranslate(v=[-FT/2-WT*2,0,FH/4-FT/2]){cube([WT,FW-FT,FT/2]);}\n\t\t\ttranslate(v=[-FT/2-WT*1.5,(FW-FT)/2,FH/4+FT/6]){cube([WT,(FW-FT*2),FT/3],center=true);}\n\t\t\ttranslate(v=[-FT/2-WT,(FW-FT)/2,FH/4-FT/2]){rotate(a=[0,45,0]){cube([WT*1.5,FW-FT,WT*1.5],center=true);}}\n\t\t}\n\t\tunion(){\n\t\t\ttranslate(v=[0,0,-0.5]){cylinder(h=FH/4+FT/2+1,r=FT/2,$fn=CR);}\n\t\t\ttranslate(v=[0,FW-FT,-0.5]){cylinder(h=FH/4+FT/2+1,r=FT/2,$fn=CR);}\n\t\t\ttranslate(v=[-FT/2,0,-0.5]){cube([FT+WT+1,FW-FT,FH/4+FT/2+1]);}\n\t\t\ttranslate(v=[0,-FT/2,-0.5]){cube([FT/2+WT+1,FT/2+1,FH/4+FT/2+1]);}\n\t\t\ttranslate(v=[0,FW-FT-1,-0.5]){cube([FT/2+WT+1,FT/2+1,FH/4+FT/2+1]);}\n\t\t\ttranslate(v=[-FingerThick/2-WT*1.1,-FingerThick/2-WT,FingerHeight/4]){cube([FingerThick/2+WT*1.1,FingerWidth+WT*2,FingerThick/2+0.5]);}\n\t\t}\n\t}\n\ttranslate(v=[-FT/2-WT,-FT/2-WT,-PL]){ThumbGuard(HT,PL);}\n}\nmodule ThumbGuard(HT,PL){\n\tunion(){\n\t\tdifference(){\n\t\t\tunion(){\n\t\t\t\ttranslate(v=[0,0,0]){cube([WT,HT,PL/2]);}\n\t\t\t\ttranslate(v=[0,HT,PL/2]){rotate(a=[135,0,0]){cube([WT,HT*1.75,HT*1.75]);}}\n\t\t\t}\n\t\t\tunion(){\n\t\t\t\ttranslate(v=[-WT/2,-HT*1.75,0]){cube([WT*2,HT*1.75,PL]);}\n\t\t\t}\n\t\t}\n\t\tdifference(){\n\t\t\ttranslate(v=[0,0,0]){rotate(a=[45,0,45]){cube([WT,((HT+PL/2)/2)*1.4142,((HT+PL/2)/2)*1.4142]);}}\n\t\t\ttranslate(v=[-HT,0,0]){cube([HT,HT,PL]);}\n\t\t}\n\t}\n}\nif(LayoutMode==\"Assembled\"){\n\tif(FCA==0){\n\t\tcolor(\"red\") FingerLug(FingerThick,FingerHeight,FingerWidth);\n\t\ttranslate(v=[0,WT,FingerHeight/4]){color(\"green\") FingerLug(FingerThick,FingerHeight,FingerWidth-WT*2);}\n\t\ttranslate(v=[0,WT*2,FingerHeight/2]){color(\"blue\") FingerLug(FingerThick,FingerHeight,FingerWidth-WT*4);}\n\t\ttranslate(v=[0,WT*3,FingerHeight-FingerHeight/4]){color(\"pink\") FingerTip(FingerThick,FingerHeight,FingerWidth-WT*6);}\n\t} else{\n\t\ttranslate(v=[FingerThick/4+WT/2,0,FingerThick/4]){\n\t\t\trotate(a=[0,FCA,0]){translate(v=[-FingerThick/4-WT/2,0,-FingerThick/4]){\n\t\t\t\tcolor(\"red\") FingerLug(FingerThick,FingerHeight,FingerWidth);}\n\t\t\ttranslate(v=[0,WT,FingerHeight/4]){\n\t\t\t\trotate(a=[0,FCA,0]){translate(v=[-FingerThick/4-WT/2,0,-FingerThick/4]){\n\t\t\t\t\tcolor(\"green\") FingerLug(FingerThick,FingerHeight,FingerWidth-WT*2);}\n\t\t\t\ttranslate(v=[0,WT,FingerHeight/4]){\n\t\t\t\t\trotate(a=[0,FCA,0]){translate(v=[-FingerThick/4-WT/2,0,-FingerThick/4]){\n\t\t\t\t\t\tcolor(\"blue\") FingerLug(FingerThick,FingerHeight,FingerWidth-WT*4);}\n\t\t\t\t\ttranslate(v=[0,WT,FingerHeight/4]){\n\t\t\t\t\t\trotate(a=[0,FCA,0]){translate(v=[-FingerThick/4-WT/2,0,-FingerThick/4]){\n\t\t\t\t\t\t\tcolor(\"pink\") FingerTip(FingerThick,FingerHeight,FingerWidth-WT*6);}}}}}}}}}\n\t\t}\n\tif(Hand==\"Right\"){\n\t\tBackHand(FingerThick,FingerHeight,FingerWidth,HandThick,PalmLength);\n\t}else{\n\t\ttranslate(v=[0,FingerWidth-FingerThick,0]){mirror([0,1,0]){BackHand(FingerThick,FingerHeight,FingerWidth,HandThick,PalmLength);}}\n\t}\n}else{\n\tcolor(\"red\") FingerLug(FingerThick,FingerHeight,FingerWidth);\n\ttranslate(v=[FingerThick+WT*4,WT,0]){color(\"green\") FingerLug(FingerThick,FingerHeight,FingerWidth-WT*2);}\n\ttranslate(v=[(FingerThick+WT*4)*2,WT*2,0]){color(\"blue\") FingerLug(FingerThick,FingerHeight,FingerWidth-WT*4);}\n\ttranslate(v=[(FingerThick+WT*4)*3,WT*3,0]){color(\"pink\") FingerTip(FingerThick,FingerHeight,FingerWidth-WT*6);}\n\tif(Hand==\"Right\"){\n\t\ttranslate(v=[0,-HandThick-WT*4-RivetSize,PalmLength]){rotate(a=[0,0,-90]){BackHand(FingerThick,FingerHeight,FingerWidth,HandThick,PalmLength);}}\n\t}else{\n\t\ttranslate(v=[0,-HandThick-WT*4-RivetSize,PalmLength]){rotate(a=[0,0,90]){mirror([0,1,0]){BackHand(FingerThick,FingerHeight,FingerWidth,HandThick,PalmLength);}}}\n\t}\n}",
    "description": "Okay, I'm trying to design a custom gauntlet for a costume, and I'd like to do it in OpenSCAD so I can adjust it easily. I've seen some examples, and I want something similar to the gauntlet in the example I'm providing.\n\nHere's what I need it to do:\n\n**Core Functionality:**\n\n*   **Parametric Design:** The design needs to be fully parametric, meaning I can easily adjust all key dimensions using variables. I want to be able to customize things like finger thickness, finger length, hand width, palm length, overall thickness, etc.\n*   **Finger Segments:** The gauntlet should have multiple articulated finger segments, like the example. Ideally, this would be 3 or 4 segments per finger, plus a fingertip.\n*   **Wrist/Palm Segment:** It also needs a wrist/palm section connecting the fingers. This segment should also be parametrically adjustable in length and width, and it should connect to the finger segments using a solid and robust join.\n*   **Finger Curl Animation/Adjustment:** I'd like a variable that lets me adjust the angle at which the fingers are curled, or \"make a fist\". This isn't just for rendering in OpenSCAD; I'd like to be able to print it in different fist positions.\n\n**Specific Parameters I want control over:**\n\n*   `FingerThick`: Thickness of a finger (like a diameter), I plan to need values between 15 and 30mm\n*   `FingerHeight`: Length of a finger from tip to knuckle, I'll need to be able to go from 50 to 140mm\n*   `FingerWidth`: Width of the hand at the knuckles, I'll need this from 50 to 100mm\n*   `PalmLength`: Length of the back of the hand, from knuckles to wrist, I want 50 to 140mm range\n*   `HandThick`: Thickness of the hand below the pinky finger, I want a range of 15 to 45mm\n*   `WT`: Wall thickness of the armor, likely 1 to 5mm\n*   `Hand`: Select Right or Left hand\n*   `RivetSize`: Size of decorative rivet-looking connections, range 1 to 8mm\n*   `FCA`: Finger Curl Angle, from 0 (open) to 40 (tightly curled), maybe more later.\n*  `CR`: Circle Resolution, or fineness of curved edges\n\n**Key Design Features and Logic:**\n\n*   **\"Assembled\" vs \"Print\" Layout:** I want a variable that lets me choose between two layout modes, one where the pieces are arranged as they would be when worn and another where they are laid out flat for printing. It seems like I need to lay them out with some offset to account for wall thickness\n*   **Rounded Corners:** I want all the segments to have rounded corners and edges.\n*   **Solid Connections:**  I need reliable connections between the finger segments. Snap locks and rivet-like connections seem good. I'd like a solid guard section that is also solid in the final version.\n*  **Thumb Cutout:** The design needs to be such that it can allow for the thumb, which is why I need the Right/Left selector. I'm not worried about an articulated thumb in this design.\n\n**Libraries:**\n\n*   I'd like this to be done in \"vanilla\" OpenSCAD if possible, but if necessary I think I'd prefer to use the BOSL2 library for any advanced functions. It doesn't look like any other libraries are needed. I will not be using the MCAD library.\n\nCan you provide me with an OpenSCAD file that meets these requirements? I'd like to be able to fully adjust and print this gauntlet.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Strap Clamp Corner Bracket",
    "scad": "StrapWidth = 40;\nStrapThickness = 3;\nClampThickness = 2;\nClampLength = 60 ;\nClampAngle = 90;\ndifference()\n{\n\tCornerBracket();\n\thull()\n\t{\n\t\tcylinder(h = StrapWidth + ClampThickness * 2, r=ClampThickness * .5 , $fs=0.01);\n\t\ttranslate([ClampThickness  , -ClampThickness   , 0]) cylinder(h = StrapWidth + ClampThickness * 2, r=ClampThickness * .75 , $fs=0.01);\n\t}\n}\nmodule CornerBracket()\n{\n\tframe();\n\trotate(a = ClampAngle, v = [ 0, 0, -1]) mirror([0, 1, 0]) frame();\n\thull ()\n\t{\n\t\tOutsideCorner();\n\t\trotate(a = ClampAngle, v = [ 0, 0, -1]) mirror([0, 1, 0]) OutsideCorner();\n\t}\n}\nmodule frame ()\n{\n     hull(){\n\t\ttranslate(v = [ClampLength, 0, 0]) cylinder(h = ClampThickness, r=ClampThickness * .5, $fs=0.01);\n\t\ttranslate(v = [-ClampThickness * .5, ClampThickness * .5, 0]) cylinder(h = ClampThickness, r=ClampThickness , $fs=0.01);\n\t\ttranslate(v = [0,  (ClampThickness  * 2 + StrapThickness)  , 0])  cylinder(h = ClampThickness , r=ClampThickness * .5 , $fs=0.01);\n\t\ttranslate(v = [ClampLength,  (ClampThickness + StrapThickness) , 0])  cylinder(h = ClampThickness , r=ClampThickness * .5, $fs=0.01);\n\t}\n\thull(){\n\t\ttranslate(v = [ClampLength, 0, 0]) cylinder(h = StrapWidth + ClampThickness * 2, r=ClampThickness * .5, $fs=0.01);\n\t\ttranslate(v = [-ClampThickness * .5, ClampThickness * .5, 0]) cylinder(h = StrapWidth + ClampThickness * 2, r=ClampThickness , $fs=0.01);\n\t}\n\thull(){\n\t\ttranslate(v = [0,  (ClampThickness  * 2 + StrapThickness)  , 0])  cylinder(h = StrapWidth * .1 + ClampThickness , r=ClampThickness  * .5, $fs=0.01);\n\t\ttranslate(v = [ClampLength,  (ClampThickness + StrapThickness) , 0])  cylinder(h = StrapWidth * .1 + ClampThickness , r=ClampThickness * .5, $fs=0.01);\n\t}\n\thull(){\n\t\ttranslate(v = [0,  ClampThickness *.5  , StrapWidth + ClampThickness * 2 - StrapThickness])  cylinder(h = StrapThickness , r=ClampThickness , $fs=0.01);\n\t\ttranslate(v = [ClampLength,  0  , StrapWidth + ClampThickness * 2 - StrapThickness])  cylinder(h = StrapThickness , r=ClampThickness * .5, $fs=0.01);\n\t\ttranslate(v = [-ClampThickness * 1.5,  ClampThickness * 1.5 , StrapWidth + ClampThickness * 2 - .1])  cylinder(h = .1 , r=ClampThickness  * .5, $fs=0.01);\n\t\ttranslate(v = [ClampLength,  ClampThickness *.5  , StrapWidth + ClampThickness * 2 - .1])  cylinder(h = .1 , r=ClampThickness * .5, $fs=0.01);\n\t}\n}\nmodule OutsideCorner()\n{\n\tcylinder(h = ClampThickness, r=ClampThickness * .5 , $fs=0.01);\n\ttranslate(v = [0,  (ClampThickness  * 2 + StrapThickness)  , 0])  cylinder(h = ClampThickness , r=ClampThickness * .5 , $fs=0.01);\n}",
    "description": "Okay, I'm working on a big woodworking project and I'm short on pipe clamps. I saw this cool corner bracket design that uses ratchet straps, and it looks like it could be really helpful! I'm hoping you can help me create a parametric version in OpenSCAD.\n\nEssentially, I need a corner bracket that can hook onto a ratchet strap and provide a firm clamping surface for wood pieces. Here's what I'm envisioning, drawing from the description I saw:\n\n*   **Strap Accommodation:** The bracket needs to have a channel or recess for the strap to fit into, with a small gap so that it can hook on but not be too tight. The user defined this as the `StrapWidth` and `StrapThickness`.\n*   **Corner Construction:** The main structure should be a corner shape with a defined clamping angle `ClampAngle`. I need to be able to adjust the clamping angle.\n*   **Clamp Length:** I need to be able to adjust how long the \"arms\" of the bracket are that contact the wood (ClampLength).\n*   **Clamp Thickness:** There should be a minimum thickness `ClampThickness` of the bracket to maintain its strength. The corner itself should be twice as thick as this base thickness.\n*   **Glue Expansion Area:** There should be a small recess in the corner area to allow for glue squeeze-out, so the bracket doesn't get glued to the wood.\n\nSpecifically, I want to be able to control these parameters:\n\n*   `StrapWidth`: Width of the ratchet strap plus a bit of play (e.g., 40mm).\n*   `StrapThickness`: Thickness of the ratchet strap (e.g., 3mm).\n*   `ClampThickness`: Minimum thickness of the bracket (e.g., 2mm).\n*   `ClampLength`: Length of the bracket's arms from the corner (e.g., 60mm).\n*  `ClampAngle`: Angle of the corner (e.g. 90 degrees for a right angle), the current code already creates the mirror image for the other side, I'd prefer if that was done only if necessary and that the second part was optional based on a bool parameter.\n\nIdeally, the design would use a `hull()` function to provide a smooth, connected form rather than a bunch of separate shapes, and a `difference()` to create the glue expansion area. I'd also like it to use comments to explain what's going on in the code, as the example code did.\n\nI'd also like to minimize the number of `translate` and `rotate` functions used by doing all of it in one function call if possible.\n\nCould you create an OpenSCAD file that implements this parametric design? I don't need it to use any external libraries.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Every rod connector 3.0",
    "scad": "insideRadius=8;\noutsideRadius=10;\nlengthOfArm=50;\nshape=30;\n$fn=shape;\nx1angle=90;\nx2angle=0;\nx3angle=0;\nx4angle=0;\nx5angle=0;\nx6angle=0;\nx7angle=0;\nx8angle=0;\nx9angle=0;\nx10angle=0;\ny1angle=90;\ny2angle=45;\ny3angle=0;\ny4angle=0;\ny5angle=0;\ny6angle=0;\ny7angle=0;\ny8angle=0;\ny9angle=0;\ny10angle=0;\nz1angle=0;\nz2angle=90;\nz3angle=0;\nz4angle=0;\nz5angle=0;\nz6angle=0;\nz7angle=0;\nx8angle=0;\nz9angle=0;\nz10angle=0;\nif (x1angle>0){\n rotate([x1angle,0,0])\narm();}\nif (x2angle>0){\n rotate([x2angle,0,0])\narm();}\nif (x3angle>0){\n rotate([x3angle,0,0])\narm();}\nif (x4angle>0){\n rotate([x4angle,0,0])\narm();}\nif (x5angle>0){\n rotate([x5angle,0,0])\narm();}\nif (x6angle>0){\n rotate([x6angle,0,0])\narm();}\nif (x7angle>0){\n rotate([x7angle,0,0])\narm();}\nif (x8angle>0){\n rotate([x8angle,0,0])\narm();}\nif (x9angle>0){\n rotate([x9angle,0,0])\narm();}\nif (x10angle>0){\n rotate([x10angle,0,0])\narm();}\nif (y1angle>0){\n rotate([0,y1angle,0])\narm();}\nif (y2angle>0){\n rotate([0,y2angle,0])\narm();}\nif (y3angle>0){\n rotate([0,y3angle,0])\narm();}\nif (y4angle>0){\n rotate([0,y4angle,0])\narm();}\nif (y5angle>0){\n rotate([0,y5angle,0])\narm();}\nif (y6angle>0){\n rotate([0,y6angle,0])\narm();}\nif (y7angle>0){\n rotate([0,y7angle,0])\narm();}\nif (y8angle>0){\n rotate([0,y8angle,0])\narm();}\nif (y9angle>0){\n rotate([0,y9angle,0])\narm();}\nif (y10angle>0){\n rotate([0,y10angle,0])\narm();}\nif (z1angle>0){\n rotate([0,0,z1angle])\narm();}\nif (z2angle>0){\n rotate([0,0,z2angle])\narm();}\nif (z3angle>0){\n rotate([0,0,z3angle])\narm();}\nif (z4angle>0){\n rotate([0,0,z4angle])\narm();}\nif (z5angle>0){\n rotate([0,0,z5angle])\narm();}\nif (z6angle>0){\n rotate([0,0,z6angle])\narm();}\nif (z7angle>0){\n rotate([0,0,z7angle])\narm();}\nif (z8angle>0){\n rotate([0,0,z8angle])\narm();}\nif (z9angle>0){\n rotate([0,0,z9angle])\narm();}\nif (z10angle>0){\n rotate([0,0,z10angle])\narm();}\nheel();\nmodule arm(){\ndifference(){\ncylinder (lengthOfArm,outsideRadius,outsideRadius);\ncylinder (lengthOfArm+1,insideRadius,insideRadius);}\n}\nmodule heel(){\nsphere(outsideRadius);\n$fn=50;}",
    "description": "Okay, I have this OpenSCAD file that's a good start for a multi-connector, but I want to make it much more flexible and easier to use. Im envisioning a connector where I can specify a central hub and then attach any number of arms at different angles, all with independent size, angle and orientation. I also want the ability to control the shape of the hub and how the arms attach. I'm looking for some significant improvements over what I have right now.\n\nHere's a breakdown of what I need:\n\n**Core Requirements:**\n\n1.  **Parametric Hub:**\n    *   **Shape:** I need to be able to choose the shape of the central hub, including at least the following: Triangle, Square, Pentagon, Hexagon, Octagon, and Circle.\n    *   **Size:** The hub needs a variable radius/diameter.\n    *   **Thickness:**  The hub should have a specified thickness.\n\n2.  **Independent Arms:**\n    *   **Number:** I need to be able to specify a variable number of arms (e.g. from 1 to, say, 20 or even more).\n    *   **Length:** Each arm should have a variable length.\n    *   **Inner Radius:** Each arm needs an inner radius to create a hollow tube (for rods to pass through).\n    *   **Outer Radius:** Each arm needs an outer radius to define its size.\n    *   **Independent Angles:** Each arm should have an independent rotation angle in all three axes (X, Y, and Z). It would be nice to have a way to set this using either Euler angles or a direction vector.\n    *   **Attachment to Hub:** Arms should smoothly transition from the central hub.\n\n3.  **User Interface and Ease of Use:**\n    *   **Parameter Control:** I'd like all of these options to be easy to adjust within OpenSCAD, preferably through well-named parameters.\n    *   **Preview:** It should be easy to quickly preview the result and visually check angles.\n\n**Specific Improvements Over My Current Code:**\n\n*   My current method uses a large set of `if` statements and variables (`x1angle`, `x2angle`...) which is tedious to manage and doesnt scale well when I want to add more arms. Id prefer to work with lists or vectors to define the arm parameters.\n*   The \"heel\" module I have is a little rough, I'd like something cleaner, or perhaps a better way to attach an arm to the hub.\n* I want the inner and outer diameter of the arms to be variable, not fixed.\n\n**Additional Considerations:**\n\n*   Im hoping that this can be implemented without using third party libraries.\n*   I'm aiming for a design that's clean, well-organized, and easily modified.\n\nCould you please design a parametric OpenSCAD file that achieves all of these features? Let me know if you have any questions.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Door Stop",
    "scad": "widgetWidth = 20;\nwidgetThickness = 20;\nwidgetHeight = 50;\nstepSize = 3;\nmodule theL(theWidth, theThickness, theHeight, theStep) {\n  cylinder(h=theWidth, r=theThickness/2, center=true);\n  translate(v=[0, 80, 0]) cube(size=[theThickness, 160, theWidth], center=true);\n  translate(v=[60, 0, 0]) cube(size=[120, theThickness, theWidth], center=true);\n  for (i = [1:55]) {\n    translate(v=[-1*theThickness/2, i*theStep*1.2+1, 0]) cylinder(h=theWidth, r=theStep/2, center=true);\n  }\n  for (i = [1:5]) {\n    translate(v=[i*theWidth/3, -1*theThickness/2, -1*theWidth/3]) sphere(r = theWidth/8);\n    translate(v=[i*theWidth/3, -1*theThickness/2, 0]) sphere(r = theWidth/8);\n    translate(v=[i*theWidth/3, -1*theThickness/2, 1*theWidth/3]) sphere(r = theWidth/8);\n  }\n}\ndifference() {\n  translate(v=[widgetThickness/2-widgetHeight, -0.5*widgetThickness, 0]) rotate([0, 0, -30]) theL(widgetWidth, widgetThickness, widgetHeight, stepSize);\n  translate(v=[200, 50, 0]) cube(size=[400, 800, 100], center=true);\n}",
    "description": "Okay, I'm looking to design a door stop, kind of like a chunky \"L\" shape that sits on the floor and prevents a door from swinging too far. I have an initial design, but I want to make it parametric so I can easily adjust the dimensions.\n\nHere's what I'm thinking:\n\nThe main structure should be an L shape. It's made up of three parts: a central cylinder, and then two rectangular cuboids attached to it at a 90 degree angle. Let's call these the \"long side\" and the \"short side.\" The orientation is such that if you think of the L as having a \"back\" and a \"front\" the central cylinder is in the center of the \"back,\" the long side is attached to the top, and the short side is on the side. The three parts should all be centered on the origin before any translation.\n\nI'd like several parameters that I can control.\n*   **`widgetWidth`**: This parameter controls the width of the central cylinder and the short side of the L. It also seems to control the size of spheres added.\n*   **`widgetThickness`**: This is the thickness of the cylinder and rectangular cuboids.\n*   **`widgetHeight`**: This parameter seems to control the offset of the main structure.\n\nI'd like to add the following features to it:\n*   **Spindles**: Along the back of the main cylinder, I need multiple small cylinders that stick out. These should be offset from each other and increase with an increment using a `stepSize` parameter. The parameter I'm using to increment the position is `i`. There are 55 of these spindles.\n*   **Spheres**: I also want a line of spheres along the bottom face of the \"short side\", using the `widgetWidth` and parameter `i`. There should be three rows of five spheres each.\n\nFinally, the entire \"L\" shape should be rotated -30 degrees around the z-axis, and then translated from the origin to position it on the floor. I need to take the `widgetThickness` and `widgetHeight` into account when doing so.\n\nI need all of the parameters to be adjustable using comments in the OpenSCAD code (using `// [min:max]`). Also, I need the OpenSCAD to make the actual doorstop using the difference operation, subtracting the L shape from a large block, and I need to translate the block to a new position before using the difference operation.\n\nCan you provide an OpenSCAD file that implements this with all the requested parameters? Please make sure to name the file \"doorWidget_parametric.scad\" or something similar.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Walters Customizable Tri Glide with broken edges and eyelet",
    "scad": "_1_webbingWidth = 26;\n_2_webbingGap = 4.5;\n_3_edgeThickness = 3.5;\n_4_centerThickness = 4.5;\n_5_height = 3;\n_6_cornerRounding = 75;\n_7_cornerBreakage = 0.66;\n_8_eyeDiameter = 7;\n_9_eyeRimThickness = 4;\nmodule makeBody(xsize, ysize, height, radius,edgeThickness,eyeRad,eyeRim) {\n\ttranslate([0,0,height/2]) {\n\t\tminkowski() {\n\t\t\tcube(size=[xsize-2*radius,ysize-2*radius, height/2], center = true);\n\t\t\tcylinder(r=radius, h=height/2, center=true);\n\t\t}\n\t}\n\ttranslate([0,ysize/2+eyeRad,0])\n\t\tcylinder(r=eyeRad+eyeRim,h=height);\n}\nmodule makeCuts(width, gap, thickness, height,b,eyeRad,eyeRim) {\n    eps=0.05;\n\toffset = (thickness+gap)/2;\n\tfor (y = [-offset, offset]) {\n\t\ttranslate([0, y, 0]) {\n\t\t\ttranslate([0, 0, height/2])\n\t\t\t\tcube(size=[width, gap, height*2], center=true);\n\t\t\ttranslate([0, 0, 0])\n\t\t\t\tmakeCutEnd(width, gap, thickness, height,b);\n\t\t\ttranslate([0, 0, height]) scale([1,1,-1])\n\t\t\t\tmakeCutEnd(width, gap, thickness, height,b);\n\t\t}\n\ttranslate([0,2*offset+gap/2 +eyeRad,-height*0.1])\n\t\tcylinder(r=eyeRad,h=height*1.2);\n\ttranslate([0,2*offset+gap/2 +eyeRad,-eps])\n\t\tcylinder(r1=eyeRad+b,r2=eyeRad,h=b);\n\ttranslate([0,2*offset+gap/2 +eyeRad,height-b+eps])\n\t\tcylinder(r1=eyeRad,r2=eyeRad+b,h=b);\n\t}\n}\nmodule makeCutEnd(width, gap, thickness, height,b)\n{\n\thull(){\n\t\ttranslate([0,0,+b/2])\n\t\t\tcube(size=[width, gap, b], center=true);\n\t\ttranslate([0,0,-b/2])\n\t\t\tcube(size=[width+2*b, gap+2*b, b], center=true);\n\t}\n}\nmodule makeTriGlide(width, gap, edgeThickness, centerThickness, height, rounding,\n                    b, eyeDiam, eyeRim ,$fn=90) {\n\txsize = width + edgeThickness * 2;\n\tysize = centerThickness + edgeThickness * 2 + gap * 2;\n\tradius = edgeThickness*(rounding/100);\n\tdifference() {\n        hull()\n        {\n\t\t  makeBody(xsize-2*b, ysize-2*b, height, radius,edgeThickness,eyeDiam/2,eyeRim);\n          translate([0,0,b])\n\t\t  makeBody(xsize, ysize, height-2*b, radius,edgeThickness,eyeDiam/2,eyeRim);\n        }\n\t\tmakeCuts(width, gap, centerThickness, height,b,eyeDiam/2,eyeRim);\n\t}\n}\nmakeTriGlide(_1_webbingWidth, _2_webbingGap, _3_edgeThickness, _4_centerThickness, _5_height, _6_cornerRounding,_7_cornerBreakage,_8_eyeDiameter,_9_eyeRimThickness);",
    "description": "Okay, I'd like to get a parametric OpenSCAD file for a tri-glide buckle with an integrated eyelet. I'm using the existing tri-glide design from my current SCAD file as a starting point, but I want to make it fully configurable and more robust.\n\nHere's what I'm looking for:\n\n**Core Tri-Glide Functionality (Based on the provided SCAD):**\n\n*   **Webbing Width:**  The primary parameter should be the width of the webbing that passes through the tri-glide (e.g., 1 inch, which is 25.4mm). I need to be able to specify this as a parameter. Let's call it `webbingWidth`.\n*   **Webbing Gap:** The space between the center bar and the outer edges where the webbing passes. This should also be a parameter, `webbingGap`.\n*   **Edge Thickness:** The thickness of the material forming the outer edges of the tri-glide. This is a parameter, `edgeThickness`.\n*   **Center Thickness:** The thickness of the center bar. Another parameter, `centerThickness`.\n*   **Height:** The overall height of the tri-glide, or rather, how much the tri-glide is extruded in the Z-axis. I need this to be a parameter, `triGlideHeight`.\n*   **Corner Rounding:** I want to specify a percentage for how rounded the corners are, which is a percentage where 0% is no rounding and 100% is fully rounded. This should also be a parameter. `cornerRounding`.\n*   **Corner Breakage:** How much to break off the corners, to prevent sharp edges. This needs to be a parameter, `cornerBreakage`.\n\n**Eyelet:**\n\n*   **Eyelet Diameter:** I need an eyelet feature for attaching rings, hooks, or ropes. The diameter of the hole through the eyelet should be a parameter, `eyeletDiameter`.\n*   **Eyelet Rim Thickness:** The thickness of the rim around the eyelet opening, this needs to be a parameter as well, `eyeletRimThickness`.\n*   **Eyelet Placement:** The eyelet should be centered on the top of the tri-glide.\n\n**General Requirements:**\n\n*   **Parametric:** All of the dimensions specified above need to be controlled by parameters. It should be easy to modify the code to change any of these values.\n*   **Clean Code:** The code should be well-organized and easy to read. Please use meaningful variable names.\n*   **Robust:**  The design should be reasonably robust to parameter changes, without creating obvious errors.\n*   **Comments:** Include clear comments that explain what different sections of the code are doing.\n\n**Libraries:**\n* No libraries are needed\n\n**Final notes:**\n\nI need to be able to render this object in OpenSCAD and have it work correctly. Please generate an OpenSCAD file that accomplishes this.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Retro Font Word Pen Rat Mod",
    "scad": "use <MCAD/fonts.scad>\ncreate_pen = true;\ncreate_stub = true;\ncreate_cap = true;\ncreate_clip = true;\nword = \"AWESOME\";\nfont_scale = 2.2\t;\nfont_spacing = 0.9;\npen_inner_diameter = 4.3 *1;\npen_inner_radius = pen_inner_diameter / 2;\npen_length = 130;\npen_thickness = 8*1;\nfont_start_dist = 7;\nstub_length = pen_thickness + 0;\nend_length = pen_thickness + 0;\n\tcap_length = 25;\nmodule penword()\n{\nthisFont=8bit_polyfont();\nx_shift=thisFont[0][0] * font_spacing;\ny_shift=thisFont[0][1];\n\ttheseIndicies=search(word,thisFont[2],1,1);\n\twordlength = (len(theseIndicies))* x_shift;\n\tdifference() {\n\t\tunion() {\n\t\t\tscale([font_scale,font_scale,1]){\n\t\t\tfor( j=[0:(len(theseIndicies)-1)] )\n\t\t\t\ttranslate([ j*x_shift + font_start_dist, -y_shift/2 ,-pen_thickness/2])\n\t\t\t\t{\n\t\t\t\t\tlinear_extrude(height=pen_thickness) polygon(points=thisFont[2][theseIndicies[j]][6][0],paths=thisFont[2][theseIndicies[j]][6][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([1*font_scale+3\t,-y_shift*.45,-pen_thickness/2]) cube([pen_length - 3,y_shift * 0.9,pen_thickness * 0.8]);\n\t\t\trotate(a=[0,90,0])\n\t\t\t\t{\n\t\t\t\t\ttranslate([pen_thickness*0.1,0,0\t])\tcylinder(h = 5, r = pen_thickness*.4, $fn=50);\n\t\t\t\t\ttranslate([pen_thickness*0.1,0,-5\t])\tcylinder(h = 5, r1 = 1, r2 = pen_thickness*.4, $fn=50);\n\t\t\t\t}\n\t\t}\n\t\t\ttranslate([0,-pen_inner_diameter/2,-pen_thickness/2+pen_thickness*.15]) cube([pen_length + 20,pen_inner_diameter,pen_inner_diameter]);\n\t\t\trotate(a=[0,90,0])translate([pen_thickness*.1,0,-15])\tcylinder(h = 30, r = pen_inner_radius, $fn=100);\n\t}\n}\nif (create_stub == true) {\n\tunion(){\n\t\trotate([0,90,0]) translate([-pen_thickness/2-(end_length-pen_thickness), 10, 0]) cube([end_length, pen_thickness, pen_thickness*0.8]);\n\t\trotate([0,90,0]) translate([-stub_length-(end_length-pen_thickness),10+(pen_thickness/2)-(pen_inner_diameter*0.95/2),pen_thickness*.15]) cube([stub_length+1,pen_inner_diameter*0.95,pen_inner_diameter*0.95]);\n\t}\n}\nif (create_cap == true && create_clip == false){\n\t\tdifference(){\n\t\t\ttranslate([20-pen_thickness,15-pen_thickness/2,-pen_thickness/2]) cube([pen_thickness,pen_thickness, cap_length]);\n\t\t\ttranslate([20-pen_thickness/2,15,-pen_thickness/2+cap_length-19.9]) cylinder(h = cap_length,r = pen_thickness*0.8/2,$fn=100);\n\t}\n}\nif (create_cap == true && create_clip == true) {\n\tunion(){\n\t\tdifference(){\n\t\t\ttranslate([20-pen_thickness,15-pen_thickness/2,-pen_thickness/2]) cube([pen_thickness,pen_thickness, cap_length]);\n\t\t\ttranslate([20-pen_thickness/2,15,-pen_thickness/2+cap_length-19.9]) cylinder(h = cap_length,r = pen_thickness*0.90/2,$fn=100);\n\t\t}\n\ttranslate([20,13,-pen_thickness/2]) cube([3,4,4]);\n\ttranslate([21.5,13,-pen_thickness/2]) cube([1.5,4,19]);\n\ttranslate([21.75,17,-pen_thickness/2+19])rotate([90,0,0])cylinder(h=4, r=1.25, $fn=100);\n\t}\n}\nif (create_pen == true) {\npenword();\n}",
    "description": "Okay, I'm looking to design a customizable pen using OpenSCAD. I have a pretty good starting point, but I want to make it even more flexible and user-friendly. I'm basing my design on the \"Retro_Word_Pen_Rat_Mod.scad\" file, which I'll describe the functionality of below.\n\nFirst, it uses the `MCAD/fonts.scad` library, which it depends on heavily for the text features. I'd prefer not to depend on a specific version of the MCAD fonts library, if possible. \n\nHere's a breakdown of what the current design does:\n\n*   **Text Display:** The pen body has a word displayed on it, created using a font from the MCAD library. I need to be able to control the text (obviously!), its scale, the spacing between letters, and the starting position of the text relative to the pen's tip.\n*   **Pen Body:** The pen body itself is a roughly cylindrical shape with a flat portion for the text to go on. The length and thickness of the pen are customizable. It includes a hollow core for the pen insert. I also need to be able to control the tip where the pen insert will go.\n*   **Stub/Plug:** It also creates a stub or plug to fit into the pen's end, which can be useful for a clean finish. The length of this stub and how much is displayed at the end needs to be customizable, and ideally should allow for a slightly tighter fit by being a customizable percentage smaller than the inner diameter.\n*   **Cap:** There's an optional cap, with or without a clip, that fits over the pen's tip. The length of the cap and whether or not to include a clip should be parameters, and the clip should also be parametrically adjustable.\n\n**My Desired Improvements and Features:**\n\n1.  **True Parametric Design:** I want *every* dimension and feature to be controlled by variables. This includes things like the radius of the pen body, the size of the flat portion for the text, the radius of the cylinder for the pen insert, the thickness of the pen wall, the length of the pen, and all the dimensions of the end stub and cap.\n\n2.  **Font Selection:** I'd like the ability to choose from *any* font installed on my system, not just the 8-bit one from the MCAD library. I know OpenSCAD can access system fonts. Ideally, this should also allow for specifying the font family, not just a font name if supported.\n\n3.  **Text Placement Flexibility:** Right now, the text sits on one flat side. I'd like more flexibility with the placement of the text, such as being able to wrap it around the pen body or be placed on multiple sides, or perhaps even have the text be used as relief.\n\n4.  **Cap and Clip Refinement:** The cap and clip design is basic. I'd like to be able to control the shape and size of the clip, perhaps with more flexible placement on the cap. It would be great to have options for rounded cap edges or other aesthetic features, and maybe even have the ability to add a small hole to the top of the cap. \n\n5.  **Units:** I'd like to make sure the design is using millimeters for units, and make that explicit in the code.\n\n6.  **Comments:** It should be thoroughly commented, so I know what each part of the code is doing.\n\n7.  **Configurable Tolerances:** Allow me to configure tolerances to account for printer tolerances; such as when the stub inserts into the pen body, and the cap into the pen body.\n\n8.  **Advanced Text Options** Text extrusion direction, e.g. outward (engraving) and inward (embossing) as well as the text depth if possible.\n\n**Specific Variable Requirements:**\n\nI'm not specifying all of the variable names here because many of them are in the code I've given you. What I want is for each of the values in the current code be easily changed by a parameter. \n\n**In summary**, I want a fully parametric, highly customizable pen design that is easy to use and modify, allows system font selection, more text placement control, and refinements to the cap and clip. I want a single OpenSCAD file that includes all these features. I need help designing the code itself since that's where I'm stuck. Let me know if you need any other information.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Circular Gallifreyan Coin",
    "scad": "word = \"thingiverse\";\nouter_radius = 32;\ncoin_thickness = 2;\npendant_radius = 20;\nletter_radius = 10;\nline_thickness = 1;\nline_height = 1;\nlarge_circle_radius = letter_radius;\nsmall_circle_radius = letter_radius/4;\nlarge_dot_radius = letter_radius/7;\nsmall_dot_radius = letter_radius/8;\ndot_offset = large_circle_radius/4*3;\nchars_in_word = lenWord(word, 0, len(word));\nspacing_angle = 360 / chars_in_word;\nif (len(word) > 0 && isValidWord(word))\n{\n  difference()\n  {\n    linear_extrude(height=coin_thickness)\n      circle(outer_radius);\n    translate([0,0,coin_thickness-line_height])\n      linear_extrude(height=line_height+0.1)\n      rotate([0,0,-90])\n      write_circle();\n  }\n}\nelse\n{\n  echo(\"invalid input\");\n}\nfunction isVowel(t,p,l) = (l - p > 0)\n                       && (t[p] == \"a\" || t[p] == \"e\" || t[p] == \"i\" || t[p] == \"o\" || t[p] == \"u\");\nfunction isConsWithH(t,p,l) = (l - p > 1)\n                           && (t[p+1] == \"h\")\n                           && (t[p] == \"t\" || t[p] == \"s\" || t[p] == \"c\");\nfunction isConsNG(t,p,l) = (l - p > 1)\n                        && t[p] == \"n\"\n                        && t[p+1] == \"g\";\nfunction isConsQU(t,p,l) = (l - p > 1)\n                        && t[p] == \"q\"\n                        && t[p+1] == \"u\";\nfunction isCons2(t,p,l) = isConsWithH(t,p,l) || isConsNG(t,p,l) || isConsQU(t,p,l);\nfunction isCons1(t,p,l) = (l - p > 0)\n                       && (t[p] == \"b\" || t[p] == \"d\" || t[p] == \"f\" || t[p] == \"g\" || t[p] == \"h\" ||\n                           t[p] == \"j\" || t[p] == \"k\" || t[p] == \"l\" || t[p] == \"m\" || t[p] == \"n\" ||\n                           t[p] == \"p\" || t[p] == \"t\" || t[p] == \"r\" || t[p] == \"s\" || t[p] == \"v\" ||\n                           t[p] == \"w\" || t[p] == \"y\" || t[p] == \"z\" || t[p] == \"x\");\nfunction isCons2WithVowel(t,p,l) = isVowel(t,p+2,l) && isCons2(t,p,l);\nfunction isCons1WithVowel(t,p,l) = isVowel(t,p+1,l) && isCons1(t,p,l);\nfunction isValid(t,p,l) = l == p ? true\n                        : isVowel(t,p,l) ? isValid(t,p+1,l)\n                        : isCons2(t,p,l) ? isValid(t,p+2,l)\n                        : isCons1(t,p,l) ? isValid(t,p+1,l) : false;\nfunction lenWord(t,p,l) = isVowel(t,p,l) ? 1 + lenWord(t,p+1,l)\n                        : isCons2WithVowel(t,p,l) ? 1 + lenWord(t,p+3,l)\n                        : isCons1WithVowel(t,p,l) ? 1 + lenWord(t,p+2,l)\n                        : isCons2(t,p,l) ? 1 + lenWord(t,p+2,l)\n                        : isCons1(t,p,l) ? 1 + lenWord(t,p+1,l)\n                        : 0;\nfunction isValidWord(txt) = isValid(txt,0,len(txt));\nfunction isLetterStart(s,t,p,l) = s == p ? true\n                                : s < p ? false\n                                : isVowel(t,p,l) ? isLetterStart(s,t,p+1,l)\n                                : isCons2WithVowel(t,p,l) ? isLetterStart(s,t,p+3,l)\n                                : isCons1WithVowel(t,p,l) ? isLetterStart(s,t,p+2,l)\n                                : isCons2(t,p,l) ? isLetterStart(s,t,p+2,l)\n                                : isCons1(t,p,l) ? isLetterStart(s,t,p+1,l)\n                                : false;\nfunction whichLetter(s,t,p,l) = s <= p ? 0\n                                : isVowel(t,p,l) ? 1 + whichLetter(s,t,p+1,l)\n                                : isCons2WithVowel(t,p,l) ? 1 + whichLetter(s,t,p+3,l)\n                                : isCons1WithVowel(t,p,l) ? 1 + whichLetter(s,t,p+2,l)\n                                : isCons2(t,p,l) ? 1 + whichLetter(s,t,p+2,l)\n                                : isCons1(t,p,l) ? 1 + whichLetter(s,t,p+1,l)\n                                : 0;\nmodule write_circle()\n{\n  for (letter = [0 : len(word)-1])\n  {\n    if (isLetterStart(letter, word, 0, len(word)))\n    {\n      rotate([0, 0, spacing_angle * whichLetter(letter, word, 0, len(word))])\n        translate([pendant_radius, 0, 0])\n        write_circle_letter(word, letter, len(word));\n    }\n  }\n}\nmodule write_circle_letter(t,p,l)\n{\n  if (p < l)\n  {\n    if (isVowel(t,p,l))\n    {\n      translate([-pendant_radius, 0, 0])\n        arc_segment(spacing_angle, pendant_radius);\n      write_vowel(t[p]);\n    }\n    else if (isCons2(t,p,l))\n    {\n      write_consonant(str(t[p],t[p+1]), isCons2WithVowel(t,p,l) ? t[p+2] : undef);\n    }\n    else if (isCons1(t,p,l))\n    {\n      write_consonant(t[p], isCons1WithVowel(t,p,l) ? t[p+1] : undef);\n    }\n    else\n    {\n      echo(\"wha? invalid character\");\n    }\n  }\n}\nmodule write_vowel(c)\n{\n  if (c == \"a\")\n  {\n    translate([letter_radius/2,0,0])\n      circle_line(small_circle_radius);\n  }\n  else if (c == \"e\")\n  {\n    circle_line(small_circle_radius);\n  }\n  else if (c == \"i\")\n  {\n    circle_line(small_circle_radius);\n    rotate([0,0,180])\n      translate([small_circle_radius,0,0])\n      line(letter_radius - small_circle_radius);\n  }\n  else if (c == \"o\")\n  {\n    translate([-letter_radius/2,0,0])\n    circle_line(small_circle_radius);\n  }\n  else if (c == \"u\")\n  {\n    circle_line(small_circle_radius);\n    translate([small_circle_radius,0,0])\n      line(letter_radius - small_circle_radius);\n  }\n  else\n  {\n    echo(\"wha? invalid vowel\");\n  }\n}\nmodule write_consonant(c,v)\n{\n  if (c == \"b\" || c == \"ch\" || c == \"d\" || c == \"f\" || c == \"g\" || c == \"h\")\n  {\n    difference()\n    {\n      union()\n      {\n        translate([-pendant_radius, 0, 0])\n          arc_segment(spacing_angle, pendant_radius);\n        translate([-large_circle_radius,0,0])\n          circle_line(large_circle_radius);\n      }\n      square(small_circle_radius*2, center=true);\n    }\n    translate([-large_circle_radius,0,0])\n    {\n      if (c == \"ch\")     write_circle_modifier(1);\n      else if (c == \"d\") write_circle_modifier(2);\n      else if (c == \"f\") write_circle_modifier(3);\n      else if (c == \"g\") write_circle_modifier(4);\n      else if (c == \"h\") write_circle_modifier(5);\n      if (v) write_vowel(v);\n    }\n  }\n  else if (c == \"j\" || c == \"k\" || c == \"l\" || c == \"m\" || c == \"n\" || c == \"p\")\n  {\n    translate([-pendant_radius, 0, 0])\n      arc_segment(spacing_angle, pendant_radius);\n    translate([-large_circle_radius-large_dot_radius,0,0])\n    {\n      circle_line(large_circle_radius);\n      if (c == \"k\")      write_circle_modifier(1);\n      else if (c == \"l\") write_circle_modifier(2);\n      else if (c == \"m\") write_circle_modifier(3);\n      else if (c == \"n\") write_circle_modifier(4);\n      else if (c == \"p\") write_circle_modifier(5);\n      if (v) write_vowel(v);\n    }\n  }\n  else if (c == \"t\" || c == \"sh\" || c == \"r\" || c == \"s\" || c == \"v\" || c == \"w\")\n  {\n    difference()\n    {\n      translate([-pendant_radius, 0, 0])\n        arc_segment(spacing_angle, pendant_radius);\n      circle(large_circle_radius - line_thickness/2);\n    }\n    difference()\n    {\n      rotate(180) arc_segment(180, large_circle_radius);\n      difference()\n      {\n        translate([-pendant_radius,0,0]) circle(pendant_radius+large_circle_radius);\n        translate([-pendant_radius,0,0]) circle(pendant_radius);\n      }\n    }\n    if (c == \"sh\")     write_circle_modifier(1);\n    else if (c == \"r\") write_circle_modifier(2);\n    else if (c == \"s\") write_circle_modifier(3);\n    else if (c == \"v\") write_circle_modifier(4);\n    else if (c == \"w\") write_circle_modifier(5);\n    if (v) write_vowel(v);\n  }\n  else if (c == \"th\" || c == \"y\" || c == \"z\" || c == \"ng\" || c == \"qu\" || c == \"x\")\n  {\n    translate([-pendant_radius, 0, 0])\n      arc_segment(spacing_angle, pendant_radius);\n    circle_line(large_circle_radius);\n    if (c == \"y\")       write_circle_modifier(1);\n    else if (c == \"z\")  write_circle_modifier(2);\n    else if (c == \"ng\") write_circle_modifier(3);\n    else if (c == \"qu\") write_circle_modifier(4);\n    else if (c == \"x\")  write_circle_modifier(5);\n    if (v) write_vowel(v);\n  }\n  else\n  {\n    echo(\"wha? invalid consonant\");\n  }\n}\nmodule write_circle_modifier(y)\n{\n  if (y == 1)\n  {\n    rotate(-45) translate([-dot_offset,0,0]) circle(large_dot_radius);\n    rotate(-70) translate([-dot_offset,0,0]) circle(small_dot_radius);\n  }\n  else if (y == 2)\n  {\n    rotate(-40) translate([-dot_offset,0,0]) circle(small_dot_radius);\n    rotate(-65) translate([-dot_offset,0,0]) circle(large_dot_radius);\n    rotate(-90) translate([-dot_offset,0,0]) circle(small_dot_radius);\n  }\n  else if (y == 3)\n  {\n    rotate(180+15) translate([large_circle_radius,0,0]) line(letter_radius);\n    rotate(180   ) translate([large_circle_radius,0,0]) line(letter_radius);\n    rotate(180-15) translate([large_circle_radius,0,0]) line(letter_radius);\n  }\n  else if (y == 4)\n  {\n    rotate(180   ) translate([large_circle_radius,0,0]) line(letter_radius);\n  }\n  else if (y == 5)\n  {\n    rotate(180+15) translate([large_circle_radius,0,0]) line(letter_radius);\n    rotate(180-15) translate([large_circle_radius,0,0]) line(letter_radius);\n  }\n}\nmodule arc_segment(angle, radius, thick)\n{\n  pos_x = cos(angle/2) * radius * 1.5;\n  pos_y = sin(angle/2) * radius * 1.5;\n  intersection()\n  {\n    if (angle < 360)\n      polygon([ [0,0], [pos_x,-pos_y], [radius * 1.5,0], [pos_x,+pos_y] ]);\n    circle_line(radius);\n  }\n}\nmodule circle_line(radius)\n{\n  difference()\n  {\n    circle(radius + line_thickness/2);\n    circle(radius - line_thickness/2);\n  }\n}\nmodule line(length)\n{\n  translate([0,-line_thickness/2,0])\n    square([length, line_thickness]);\n}",
    "description": "Okay, I want to create a circular coin with some text written in a circular Gallifreyan style. I have a basic SCAD file that does this, but it's a bit hard to tweak and I'd like something more parametric.\n\nHeres what Im looking for:\n\n**Overall Design:**\n\n*   A circular coin shape.\n*   Circular Gallifreyan text arranged in a circle around the coin's center, basically like a ring.\n*   The text should be engraved (or cut out). I don't need a raised text effect.\n*   The coin and text should both be parametric.\n\n**Parameters:**\n\n*   **`word`**: The text to be displayed (string).\n*   **`outer_radius`**: The radius of the coin.\n*   **`coin_thickness`**: The thickness of the coin.\n*   **`pendant_radius`**: The radius of the circle on which the text is written, like a circle where you'd place the center of each letter.\n*  **`letter_radius`**: The radius of the large circles used in each letter.\n*   **`line_thickness`**: The thickness of the lines used to draw the text elements (small circles, lines).\n*   **`line_height`**: The depth/height of the engraved text (depth if cutting, height if extruding).\n\n**Gallifreyan Text Logic:**\n\nI have a custom way of interpreting letters as circular gallifreyan characters. I've included the letter conversion rules in the SCAD file (functions like `isVowel`, `isCons1`, `isCons2`, `write_vowel`, `write_consonant`, etc.). The code already has that defined so just use the same logic from that. It's based on the idea of consonants and vowels, and it groups consonants in a specific way.\n\n**Details:**\n\n*   The letters should be evenly spaced around the `pendant_radius`.\n*   There are a few different types of \"marks\" in the text: circles (both large and small), dots, and short lines. These should be customizable with the parameters listed above, such as `letter_radius`.\n*   There are some calculations for dot spacing as well (look for `large_dot_radius`, `small_dot_radius`, `dot_offset` calculations).\n*   The code uses a few helper modules like `arc_segment`, `circle_line`, and `line` which you could recreate for use in the code.\n\n**Requirements:**\n\n*   The code needs to use the same logic that I provided for valid words and rendering letters, including the `isLetterStart` and `whichLetter` functions. This logic is a bit complex and the function names should be kept the same so that you don't miss anything.\n* The code should be written in a parametric way, so that changing any of the parameters above changes the rendering.\n*   The coin should be cut out using a `difference()` and extrusion.\n*   The code should have error checking for invalid words, outputting an `echo(\"invalid input\")` if there's a problem.\n*   I'd like the code to be as readable as possible.\n*   I don't need any libraries beyond the standard OpenSCAD library, and the code should be self contained.\n\nIve included my existing .scad file for reference which you can use to make sure you've captured all of the details. Please provide the new parametric OpenSCAD code.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Tetris Bookshelf",
    "scad": "use <utils/build_plate.scad>\n_1_piece = \"T\";\n_2_size = 60;\n_3_depth = 60;\n_4_thickness = 2;\nmodule createPart(type, size, depth, thickness) {\n\teps = 0.1;\n\ttranslate([0,0,depth/2]) {\n\t\tif (type == \"I\") {\n\t\t\tdifference() {\n\t\t\t\tcube(size=[size*4, size, depth], center=true);\n\t\t\t\tcube(size=[size*4-thickness*2, size-thickness*2, depth+eps], center=true);\n\t\t\t}\n\t\t} else if (type == \"O\") {\n\t\t\tdifference() {\n\t\t\t\tcube(size=[size*2, size*2, depth], center=true);\n\t\t\t\tcube(size=[size*2-thickness*2, size*2-thickness*2, depth+eps], center=true);\n\t\t\t}\n\t\t} else if (type == \"T\" || type == \"L\") {\n\t\t\ttranslate([0, -size/2,0])\n\t\t\tdifference() {\n\t\t\t\tunion() {\n\t\t\t\t\tcube(size=[size*3, size, depth], center=true);\n\t\t\t\t\ttranslate([type == \"L\" ? size : 0, size/2,0]) {\n\t\t\t\t\t\tcube(size=[size, size*2, depth], center=true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcube(size=[size*3-thickness*2, size-thickness*2, depth+eps], center=true);\n\t\t\t\ttranslate([type == \"L\" ? size : 0, size/2,0]) {\n\t\t\t\t\tcube(size=[size-thickness*2, size*2-thickness*2, depth+eps], center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (type == \"Z\") {\n\t\t\tdifference() {\n\t\t\t\tunion() {\n\t\t\t\t\tcube(size=[size, size*2, depth], center=true);\n\t\t\t\t\ttranslate([size/2, size/2,0]) {\n\t\t\t\t\t\tcube(size=[size*2, size, depth], center=true);\n\t\t\t\t\t}\n\t\t\t\t\ttranslate([-size/2, -size/2,0]) {\n\t\t\t\t\t\tcube(size=[size*2, size, depth], center=true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcube(size=[size - thickness*2, size*2 - thickness*2, depth+eps], center=true);\n\t\t\t\ttranslate([size/2, size/2,0]) {\n\t\t\t\t\tcube(size=[size*2 - thickness*2, size - thickness*2, depth+eps], center=true);\n\t\t\t\t}\n\t\t\t\ttranslate([-size/2, -size/2,0]) {\n\t\t\t\t\tcube(size=[size*2 - thickness*2, size - thickness*2, depth+eps], center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nbuild_plate(0);\ncreatePart(_1_piece, _2_size, _3_depth, _4_thickness);",
    "description": "Okay, I've been experimenting with some 3D printed shelves and I'd like to explore this concept further. I have a basic OpenSCAD design that creates tetris-shaped shelves, but its a bit limited and I want to make it much more flexible.\n\nCurrently, I have a file `tetris_bookshelf_v1-0.scad` that creates a single tetris piece. It uses a `build_plate.scad` file for the base. The current parameters are:\n*   `_1_piece`: Defines the tetris piece type (currently set to \"T\", but can be \"I\", \"Z\", \"L\", or \"O\").\n*   `_2_size`: Defines the base size of a single block within the tetris piece (currently 60mm).\n*   `_3_depth`: Defines the depth of the tetris piece (currently 60mm).\n*   `_4_thickness`: Defines the wall thickness of the piece (currently 2mm).\n\nMy goal is to create a more modular bookshelf system that I can customize easily, and I need your help creating a new OpenSCAD file that builds upon this concept. Here's what I'd like the new design to do:\n\n**Core Functionality & Parameters:**\n\n1.  **Tetris Piece Options:** Maintain the ability to create \"I\", \"Z\", \"L\", \"T\", and \"O\" tetris pieces. I would like to make this modular, so that instead of needing to change the letter in a variable, the user is able to select a specific module with a clear name.\n\n2.  **Parametric Piece Dimensions:**\n    *   Instead of using a base size for the \"block\" use separate, independent parameters for overall `width`, `height`, and `depth` of each type of piece. \n     * Make the default value of `width` equal to `height` so that an I is a square.\n    *   Maintain a `thickness` parameter for the wall thickness.\n    *   Allow scaling of each piece independently along X, Y and Z axes to permit more design options.\n\n3. **Assembly System**\n   * Design a system where pieces can be connected via interlocking dovetail joints, like puzzle pieces. The exact shape and dimensions of the connectors should be configurable parameters, for example `dovetail_width`, `dovetail_height`, and `dovetail_depth`.  Make it so that these dovetail joints can optionally be added to any number of sides of any individual piece.\n   * The connector system should support joining of individual pieces side-to-side or up and down.\n    *  There will need to be an offset between the dovetails and the face of the part. The user should specify the size of this offset through a parameter called `dovetail_offset`.\n\n4.  **Array Placement:**  I want to be able to easily arrange these tetris pieces in a grid or other pattern.\n    *   Include parameters for `x_spacing`, `y_spacing`, and `z_spacing` to control the gaps between pieces when arraying them, if any.\n    *   Support a basic array placement function, where I can specify the number of rows and columns (and potentially layers later) and have the chosen tetris piece repeated accordingly.\n\t*   Include a way for the user to control the orientation (rotation about the Z axis) of each piece in the array.\n\t* Add a way to specify which piece should be used in each cell of the array.\n\n5.  **Customization:**\n    *   Include an option to add a small cylindrical hole (parameter controlled `hole_radius` and `hole_depth`) on any or all faces.\n    *   It should be easy to choose to fillet or chamfer the outer edges of each tetris piece with configurable parameters for radius/length.\n\n6. **File Management**\n  *  Each piece should be rendered separately as its own STL file.\n\n**Library Requirements:**\n\nI would prefer that you do not use libraries not built into OpenSCAD.\n\n**Output:**\n\nI need a single, well-organized OpenSCAD file that implements this functionality. Include comments to help me understand the code, and try to use descriptive variable names. I'm also happy to have suggestions that you think I might find helpful, since youre the expert.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Toy train track",
    "scad": "track_length=50;\nrotate (a=[90,0,0]) linear_extrude(height =track_length, center = true) polygon(points = [ [0,0], [0,9], [1,12],[4,12],[5,9],[10,9],[11,12],[29,12],[30,9],[35,9],[36,12], [39,12],[40,9], [40,0]], path = [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]]);\nmodule peg(){\n\ttranslate ([0,-12.5,0])\n\tunion(){\n\t\tcylinder(12,5.9,5.9);\n\t\ttranslate ([-3,5,0]) cube(size=[6,8,12]);\n\t}\n}\ntranslate ([20,-track_length/2,0]) peg();\ntranslate ([20,track_length/2,0]) rotate(a=[0,0,180]) peg();",
    "description": "Okay, I'm trying to design a toy train track system that's compatible with Thomas the Tank Engine and other wooden train sets. I've got a basic track segment working, but I want to make it parametric so I can easily adjust things like the length and the peg dimensions. Here's what I've got so far:\n\nMy current design, which I've included below, uses a linear extrusion to make the track shape with a polygon and then adds a peg at each end for connecting pieces.\n\n```\ntrack_length=50;\n\nrotate (a=[90,0,0]) linear_extrude(height =track_length, center = true) polygon(points = [ [0,0], [0,9], [1,12],[4,12],[5,9],[10,9],[11,12],[29,12],[30,9],[35,9],[36,12], [39,12],[40,9], [40,0]], path = [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]]);\n\n//peg\nmodule peg(){\n\ttranslate ([0,-12.5,0])\n\tunion(){\n\t\tcylinder(12,5.9,5.9);\n\t\ttranslate ([-3,5,0]) cube(size=[6,8,12]);\n\t}\n}\n\ntranslate ([20,-track_length/2,0]) peg();\n\ntranslate ([20,track_length/2,0]) rotate(a=[0,0,180]) peg();\n```\n\nHere's what I'd like:\n\n1.  **Parametric Track Length:** The `track_length` variable should still control the length of the straight track segment, but the entire design should automatically adjust to maintain the same proportions if it's altered. This is the most important parameter.\n\n2.  **Parametric Peg:** The peg should be a module with its own set of parameters:\n    *   `peg_radius`: The radius of the cylindrical part of the peg.\n    *   `peg_length`:  The length of the cylindrical part.\n    *   `peg_tab_width`: The width of the rectangular tab.\n    *   `peg_tab_height`: The height of the rectangular tab.\n    *   `peg_tab_depth`: The depth of the rectangular tab.\n    *   `peg_tab_offset`:  The amount the tab is offset from the peg.\n\n3.  **Parametric Track Profile:**  The profile of the track is defined by the `polygon` points. I'd like to be able to scale the whole track's width and height using a variable or potentially specify parameters for the overall width and height and have the system automatically scale all of the points appropriately, but maintaining the same relative proportions between all of the points that define the profile. The exact points in the polygon aren't crucial to expose as variables, but the ability to scale it up/down proportionally is. This is lower priority than #1 and #2, but would be very useful.\n\n4.  **Proper Peg Placement:** The pegs are currently positioned by fixed `translate` operations, and these should automatically adjust based on the `track_length` to make sure that the peg is centered at each end along the length. The same goes for the location that the peg is placed relative to the track's profile itself.\n\n5.  **Clear Variable Naming:** Please make sure the variable names are clear and easy to understand.\n\n6.  **Comments:** Include comments to explain the logic and how the parameters are used to construct the model.\n\n7.  **No MCAD or BOSL**: I do *not* want to use external libraries for this - just pure OpenSCAD code.\n\nCan you generate a new OpenSCAD file that implements this parametric design?\n"
  },
  {
    "object": "Hey cadmonkey, make me a 110 Film Scanner with Nikon Camera",
    "scad": "tlength=65;\nlense=47.5*1;\ntube=lense+6;\ndifference () {\n    translate([0,0,-tlength/2]) cylinder(h=2,r=lense/2,$fn=100);\n    translate([0,0,-tlength/2+1]) cylinder(h=4,r=11, center=true);\n}\ndifference() {\n    translate([0,0,0]) cylinder(h=tlength,r=lense/2+3,$fn=100, center=true);\n    translate([0,0,0]) cylinder(h=tlength+2,r=lense/2,$fn=100, center=true);\n}\nintersection() {\n    translate([0,0,tlength/2-2]) rotate([0,7,0]) rotate_extrude(convexity = 10, $fn = 100)  translate([tube/2-3, 0, 0]) circle(r = 1.7, $fn = 4);\n    translate([0,0,0]) cube([tube/2,tube/2,tlength]);\n}\nrotate([0,0,120])\nintersection() {\n    translate([0,0,tlength/2-2]) rotate([0,7,0]) rotate_extrude(convexity = 10, $fn = 100)  translate([tube/2-3, 0, 0]) circle(r = 1.7, $fn = 4);\n    translate([0,0,0]) cube([tube/2,tube/2,tlength]);\n}\nrotate([0,0,-120])\nintersection() {\n    translate([0,0,tlength/2-2]) rotate([0,7,0]) rotate_extrude(convexity = 10, $fn = 100)  translate([tube/2-3, 0, 0]) circle(r = 1.7, $fn = 4);\n    translate([0,0,0]) cube([tube/2,tube/2,tlength]);\n}",
    "description": "Okay, I'm trying to design a film scanner adapter for my Nikon camera, specifically for 110 film negatives. I've got a basic design in OpenSCAD, but it's not very flexible and I'd like to make it more parametric so I can adjust it for different lenses or film formats later. \n\nHere's the idea: I'm using a lens reversing ring which allows me to get very close to the negative and achieve the magnification I need. The design consists of three main parts:\n\n1.  **Negative Holder:** This is a flat surface with a small recess that holds the 110 film negative. The negative sits flat on this surface and there is a small lip to stop it from moving around.\n2.  **Spacing Tube:** This is a hollow tube that goes between the negative holder and the lens mount, ensuring the correct distance for focusing. The current design has the tube depth at 65mm and uses a diameter just slightly larger than the lens mount's.\n3. **Lens Mount:** This is a three-legged mount that will mate with the lens reversing ring. Currently, these are fixed, but I would like to make the attachment points flexible in terms of their spacing and how many there are (I might want 4 in the future).\n\nMy current code hardcodes a lot of values, so I need an OpenSCAD file that can handle changes to several variables. Here's what I'd like to parameterize:\n\n*   **`negative_area_diameter`**: The diameter of the flat surface where the negative sits.\n*   **`negative_lip_diameter`**: The diameter of the small recess/lip in the negative holder.\n*   **`tube_length`**: The length of the spacing tube.\n*   **`lens_mount_diameter`**: The diameter of the lens mount.\n*   **`lens_mount_attach_diameter`**: The diameter of the circle on which the mount arms are attached.\n*   **`mount_arm_count`**: The number of arms that mate with the lens mount.\n*   **`mount_arm_radius`**: The radius of the mount arms.\n*   **`mount_arm_thickness`**: The thickness of the mount arms.\n\nEssentially, I want to specify the dimensions of the negative holder, the length and diameter of the tube, and then define the mounting structure parameters. I would like to be able to change these values and have the entire model updated.\n\nCould you please create a parametric OpenSCAD file that does this? I don't need any special libraries like MCAD or BOSL for this. I'd also like some comments in the code explaining each step.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Moire Coaster",
    "scad": "outer_diam = 80;\nthickness = 3;\nlip_width = 1;\ninset_thickness = 1;\nmoire_count = 10;\nmoire_diam = 70;\nmoire_thickness = 3;\nmoire_join_angle = 40;\ncenter_diam = 10;\nmoire_mirror_angle = 66;\ndifference()\n{\n  linear_extrude(height=thickness)\n    circle(outer_diam/2);\n  translate([0, 0, thickness - inset_thickness])\n    linear_extrude(height=inset_thickness+0.1)\n    {\n      moire_scythe();\n      rotate(moire_mirror_angle) mirror() moire_scythe();\n    }\n}\nlinear_extrude(height=thickness)\ndifference()\n{\n  circle(outer_diam/2);\n  circle(outer_diam/2 - lip_width);\n}\nmodule moire_scythe()\n{\n  spacing_angle = 360 / moire_count;\n  join_angle = 180 + moire_join_angle;\n  center_off = center_diam/2;\n  inner_radius = moire_diam/4;\n  outer_radius = moire_diam/3;\n  circle(center_diam/2);\n  for (c = [0 : moire_count-1])\n  {\n    rotate([0, 0, spacing_angle * c])\n    union()\n    {\n      intersection()\n      {\n        translate([inner_radius-center_off, 0, 0])\n          circle_trace(inner_radius);\n        rotate([0, 0, join_angle])\n          translate([outer_radius-center_off, 0, 0])\n            circle(outer_radius);\n        translate([0, -moire_diam, 0])\n          square(moire_diam*2, center=true);\n      }\n      difference()\n      {\n        rotate([0, 0, join_angle])\n          translate([outer_radius-center_off, 0, 0])\n            difference()\n            {\n              circle_trace(outer_radius);\n              translate([0,-moire_diam,0])\n                square(moire_diam*2, center=true);\n            }\n        translate([inner_radius-center_off, 0, 0])\n          circle(inner_radius);\n      }\n    }\n  }\n}\nmodule circle_trace(rad)\n{\n  difference()\n  {\n    circle(rad);\n    circle(rad - moire_thickness);\n  }\n}",
    "description": "Okay, I'm looking to design a coaster with a moire pattern inset into the top surface. I want to be able to customize all the dimensions so I can easily tweak it.\n\nHere's a breakdown of what I'm envisioning:\n\n**Overall Coaster:**\n\n*   **Outer Diameter:** I need a parameter to control the overall diameter of the coaster.\n*   **Thickness:** I need a parameter to specify the total thickness of the coaster.\n*   **Lip:** I want a small lip around the edge. I need a parameter for the width of this lip.\n*   **Inset:**  The moire pattern should be inset into the top surface of the coaster, not cut all the way through. I need a parameter for the depth of this inset.\n\n**Moire Pattern:**\n\n*   **Moire Count:** I need to be able to specify the number of \"curves\" that make up the moire pattern.\n*   **Moire Diameter:** The diameter of the area that the moire pattern covers.\n*   **Moire Thickness:** The thickness of each \"curve\" in the moire pattern.\n*   **Moire Join Angle:** Each moire curve is formed by two circles of differing diameters, joined to look like a curving line. This is the angle where the line transitions from one circle to the other.\n*   **Center Diameter:** The center of the moire pattern is offset from the center of the coaster, using a circle of this diameter.\n*   **Mirror Angle:** The pattern is mirrored and rotated by this angle to create the moire effect.\n\nI'd like the code to be parametric, so I can easily change these values and the design will adjust accordingly. It should be a clean design using standard OpenSCAD primitives. I'd like to avoid using external libraries for this design.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Parametric Handle with Grip and Guard",
    "scad": "use <utils/build_plate.scad>\nHandle_Height = 100;\nHandle_Top_Diameter = 30;\nHandle_Neck_Diameter = 25;\nGuard_Diameter=35;\nNeck_Height = 5;\nGuard_Edge_Thickness = 5;\nHole_Shape=30;\nHole_Diameter = 7.2;\nHole_Depth = 10;\nGrip_Elements = 12;\nGrip_Radius = 3.0;\nPercent_Grip_Depth = 50;\nGrip_Smoothness = 20;\nbuild_plate_selector = 3;\nbuild_plate_manual_x = 200;\nbuild_plate_manual_y = 200;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nHandle_Top_Radius = Handle_Top_Diameter/2;\nHandle_Neck_Radius = Handle_Neck_Diameter/2;\nGuard_Radius = Guard_Diameter/2;\nHole_Radius = Hole_Diameter/2;\nGrip_Offset = Grip_Radius*(1-Percent_Grip_Depth/100);\nGrip_Angle = atan2(Handle_Top_Radius-Handle_Neck_Radius , Handle_Height);\nGrip_Height = Handle_Height+Handle_Top_Radius-Neck_Height-Guard_Edge_Thickness ;\n$fn = 50 / 1 ;\nmodule handle() {\n\tunion() {\n\t\ttranslate([0,0,Handle_Height]) sphere(r=Handle_Top_Radius,center=true);\n\t\tcylinder(h=Handle_Height,r1=Handle_Neck_Radius,r2=Handle_Top_Radius);\n\t\ttranslate([0,0,Guard_Edge_Thickness])cylinder(h=Neck_Height,r1=Guard_Radius,r2=Handle_Neck_Radius);\n\t\tcylinder(h=Guard_Edge_Thickness,r=Guard_Radius);\n\t}\n}\ndifference() {\n\thandle();\n\tunion() {\n\t\tcylinder(r=Hole_Radius,h=Hole_Depth,$fn=Hole_Shape);\n\t\tgrip();\n\t}\n}\nmodule grip() {\n\tfor ( i = [0 : Grip_Elements] )\n\t{\n\t    rotate([-Grip_Angle, 0,  i * 360 / (Grip_Elements)])\n\t    translate([0, Handle_Neck_Radius+Grip_Offset, Neck_Height+Guard_Edge_Thickness])\n\t    cylinder(r=Grip_Radius,h=Grip_Height,$fn=Grip_Smoothness);\n\t}\n}",
    "description": "Okay, I'd like to get a parametric design for a handle, and I'm looking for something that's very flexible in terms of customization. I've seen a design that uses a lot of the features I'm looking for but I want a new design from the ground up. I've got a few core requirements:\n\n1. **Handle Body:**\n    *   I need to be able to control the overall height of the handle, not including any domed top.\n    *   I need to control the top diameter of the handle.\n    *   The handle will have a neck, so I need to be able to control the neck diameter as well.\n    *   I want the handle to have a domed top, and the radius should be automatically calculated from the top diameter.\n    *   I would like the overall shape to transition smoothly from the dome, to a cylinder. There should not be abrupt changes unless explicitly defined by settings.\n\n2.  **Handle Guard:**\n    *   I need an optional guard at the base of the handle, that can be fully removed if needed.\n    *   I need to be able to control the diameter of the guard.\n    *   I need to control the height of the neck section that leads from the guard into the main handle cylinder.\n    *   I need to control the thickness/height of the guard's edge. \n    * The neck section should smoothly taper between the guard diameter and handle neck diameter.\n\n3.  **Internal Hole:**\n    *   I need a central hole through the bottom of the handle. \n    *   I need to choose the shape of the hole. I'd like to be able to select from Circle, Triangle, Square, Hexagon and Octogon.\n    *   I need to control the diameter of the hole.\n    *   I also need to control the depth of the hole.\n\n4.  **Grip:**\n    *   I want the handle to have a textured grip on the main cylindrical section.\n    *   I need to control the number of grip furrows/elements.\n    *   I need to control the radius of the grip furrows.\n    *   I want to control the depth of the grip furrows relative to their radius, so I can go from a smooth handle to a deeply textured one.\n    *   I want to control the smoothness of the furrows, I'd like to have a value that roughly corresponds to the `$fn` used to render the grip.\n\n5.  **Build Plate Preview:**\n     * I need a simple build plate preview to assist in layout. I should be able to select a couple of common printer sizes or specify a custom width and height.\n\n6.  **General Requirements:**\n    *   All dimensions should be in millimeters.\n    *   The design should be parametric using OpenSCAD and well commented.\n    *   The code should be written in a way that it's easy to modify and extend the functionality.\n    *   I do not need you to create any specific libraries for this, I am only looking for a single .scad file.\n\nI'm looking for a well-structured, customizable design that can be easily adapted for different projects. Please make sure the final output uses the most recent OpenSCAD syntax and methods where possible.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Keyboard Foot",
    "scad": "Length=46;\nDepth=24;\nThickness=2.1;\nCorner_Radius=4;\nLeg_Length=11;\nLeg_Width=4;\nTotal_Height=5.3;\nPin_Diameter=3.5;\nPin_Length=3.5;\nPin_Height=1.8;\nPin_Support_Gap=1;\ndifference(){\n\tunion(){\n\t\tcube([Length,Depth-Pin_Diameter/2-Pin_Height,Thickness]);\n\t\ttranslate([-Pin_Length,Depth-Pin_Length,Pin_Height+Pin_Diameter/2])rotate(a=[0,90-0])cylinder(r=Pin_Diameter/2,h=Length+Pin_Length*2,$fn=30);\n\t\ttranslate([0,Depth-Pin_Length,Pin_Height+Pin_Diameter/2])rotate(a=[0,90-0])cylinder(r=Pin_Diameter/2+Pin_Height,h=Length,$fn=30);\n\t}\n\tdifference(){\n\t\ttranslate([-Thickness,-Thickness,-Thickness/2])cube([Corner_Radius+Thickness,Corner_Radius+Thickness,Thickness*2]);\n\t\ttranslate([Corner_Radius,Corner_Radius,-Thickness])cylinder(r=Corner_Radius,h=Thickness*3,$fn=30);\n\t}\n\ttranslate([Length,0,0]){\n\t\tmirror([1,0,0]){\n\t\t\tdifference(){\n\t\t\t\ttranslate([-Thickness,-Thickness,-Thickness/2])cube([Corner_Radius+Thickness,Corner_Radius+Thickness,Thickness*2]);\n\t\t\t\ttranslate([Corner_Radius,Corner_Radius,-Thickness])cylinder(r=Corner_Radius,h=Thickness*3,$fn=30);\n\t\t\t}\n\t\t}\n\t}\n\ttranslate([Leg_Width,Depth-Leg_Length,-Total_Height])cube([Leg_Width/2,Leg_Length*2,Total_Height*2+Pin_Diameter+Pin_Height*2]);\n\ttranslate([Length-Leg_Width*1.5,Depth-Leg_Length,-Total_Height])cube([Leg_Width/2,Leg_Length*2,Total_Height*2+Pin_Diameter+Pin_Height*2]);\n\ttranslate([Leg_Width,Leg_Width,Thickness*1.1])cube([Length-Leg_Width*2,Depth,Pin_Diameter+Pin_Height*2]);\n}\ntranslate([-Pin_Length,Depth-Pin_Diameter*.75-Pin_Height,0])cube([Pin_Length-Pin_Support_Gap,Pin_Diameter/2,Pin_Diameter/2+Pin_Height]);\ntranslate([Length+Pin_Support_Gap,Depth-Pin_Diameter*.75-Pin_Height,0])cube([Pin_Length-Pin_Support_Gap,Pin_Diameter/2,Pin_Diameter/2+Pin_Height]);",
    "description": "Okay, so I need a parametric OpenSCAD file for a replacement keyboard leg. I have a Microsoft Digital Media Keyboard 3000 and one of the plastic legs broke during a move. I've already created a basic model, but it's not very flexible and doesn't use any useful libraries. \n\nHere's the breakdown of what I need, based on my existing code, which I'm including, but I'm looking for something more elegant and parameterizable:\n\n```\n//Length of Leg\nLength=46;\n//Depth of Leg\nDepth=24;\n//Thickness at narrow side\nThickness=2.1;\n//Corner radius\nCorner_Radius=4;\n//Length of cut away section\nLeg_Length=11;\n//Width of cut away section\nLeg_Width=4;\n// Complete height of leg\nTotal_Height=5.3;\n//Diameter of pin\nPin_Diameter=3.5;\n//Length of pin\nPin_Length=3.5;\n//Height of pinn from bottom of foot\nPin_Height=1.8;\n//Gap for pin support structure\nPin_Support_Gap=1;\n\ndifference(){\n\tunion(){\n\t\tcube([Length,Depth-Pin_Diameter/2-Pin_Height,Thickness]);\n\t\ttranslate([-Pin_Length,Depth-Pin_Length,Pin_Height+Pin_Diameter/2])rotate(a=[0,90-0])cylinder(r=Pin_Diameter/2,h=Length+Pin_Length*2,$fn=30);\n\t\ttranslate([0,Depth-Pin_Length,Pin_Height+Pin_Diameter/2])rotate(a=[0,90-0])cylinder(r=Pin_Diameter/2+Pin_Height,h=Length,$fn=30);\n\t}\n\tdifference(){\n\t\ttranslate([-Thickness,-Thickness,-Thickness/2])cube([Corner_Radius+Thickness,Corner_Radius+Thickness,Thickness*2]);\n\t\ttranslate([Corner_Radius,Corner_Radius,-Thickness])cylinder(r=Corner_Radius,h=Thickness*3,$fn=30);\n\t}\n\ttranslate([Length,0,0]){\n\t\tmirror([1,0,0]){\n\t\t\tdifference(){\n\t\t\t\ttranslate([-Thickness,-Thickness,-Thickness/2])cube([Corner_Radius+Thickness,Corner_Radius+Thickness,Thickness*2]);\n\t\t\t\ttranslate([Corner_Radius,Corner_Radius,-Thickness])cylinder(r=Corner_Radius,h=Thickness*3,$fn=30);\n\t\t\t}\n\t\t}\n\t}\n\ttranslate([Leg_Width,Depth-Leg_Length,-Total_Height])cube([Leg_Width/2,Leg_Length*2,Total_Height*2+Pin_Diameter+Pin_Height*2]);\n\ttranslate([Length-Leg_Width*1.5,Depth-Leg_Length,-Total_Height])cube([Leg_Width/2,Leg_Length*2,Total_Height*2+Pin_Diameter+Pin_Height*2]);\n\ttranslate([Leg_Width,Leg_Width,Thickness*1.1])cube([Length-Leg_Width*2,Depth,Pin_Diameter+Pin_Height*2]);\n}\ntranslate([-Pin_Length,Depth-Pin_Diameter*.75-Pin_Height,0])cube([Pin_Length-Pin_Support_Gap,Pin_Diameter/2,Pin_Diameter/2+Pin_Height]);\ntranslate([Length+Pin_Support_Gap,Depth-Pin_Diameter*.75-Pin_Height,0])cube([Pin_Length-Pin_Support_Gap,Pin_Diameter/2,Pin_Diameter/2+Pin_Height]);\n```\n\nHere are the parameters that I need to be able to adjust:\n\n*   **`Length`**: Overall length of the leg.\n*   **`Depth`**: Overall depth of the leg.\n*   **`Thickness`**: The thickness of the leg at its narrowest point.\n*   **`Corner_Radius`**: Radius of the rounded corners.\n*   **`Leg_Length`**: Length of the cut-out section on the leg.\n*   **`Leg_Width`**: Width of the cut-out section on the leg.\n*  **`Total_Height`**: The overall height of the leg including the pin.\n*   **`Pin_Diameter`**: Diameter of the pin that inserts into the keyboard.\n*   **`Pin_Length`**: Length of the pin.\n*   **`Pin_Height`**: Height of the pin from the bottom of the leg's main body.\n*   **`Pin_Support_Gap`**: The gap between the pin support structure and the main leg.\n\n**Key Features Required:**\n\n*   **Rounded Corners:** The corners of the main body should be rounded.\n*   **Cut-out Sections:** There should be two identical cut-out sections, one at each end of the leg on the depth side, positioned with the `Leg_Length` and `Leg_Width` parameters.\n*   **Pin:** The leg needs to have a cylindrical pin protruding from the back at a defined `Pin_Height` and  `Pin_Length` to go into the keyboard. This needs to be joined to the leg and have a small structural support at the base of the pin and along its axis. The size and shape of the support should be derived from the pin parameters.\n*   **Parametric:** All dimensions need to be easily adjustable through parameters.\n*   **Clean Code:** Use a more organized structure than my version, hopefully using libraries for easier editing.\n\nI'd like the code to be well-commented and use a proper parametric design approach using libraries like BOSL2 if that makes sense (especially for rounding and potentially some of the translation/rotation logic). I'm open to using other suitable libraries if it helps. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Pen mount for CNC",
    "scad": "pencil_hole_diameter = 6;\nadapter_size_diameter = 7.85;\nInsert_length = 7.5;\ncollar_diameter = 10;\ncollar_height = 2;\ndifference() {\n\tunion() {\n\t\tcylinder(h = collar_height, r1 = collar_diameter/2, r2 = collar_diameter/2, center = false);\n\t\ttranslate([0, 0, collar_height]) cylinder(h = Insert_length, r1 = adapter_size_diameter/2, r2 = adapter_size_diameter/2, center = false);\n\t}\n\ttranslate([0, 0, -1]) cylinder(h = (Insert_length+collar_height)+2, r1 = pencil_hole_diameter/2, r2 = pencil_hole_diameter/2, center = false);\n}",
    "description": "Okay, I'm looking to design a pen mount for my CNC machine, something that lets me quickly swap out different pens. I've already got a basic design that works well, but it's hardcoded for a specific pen diameter, and I'd really like to make it parametric so I can use different sizes without having to adjust the code manually every time.\n\nHere's the breakdown of what I'm looking for:\n\nThe mount will have a cylindrical collar at the top that will fit into the existing tool holder on my CNC. This collar needs to have a diameter and height that I can define. Then, below the collar, there's a cylindrical plug that goes into the mount; this also needs its own length and diameter, which should be a press fit into the main mount. Finally, there's a hole that goes all the way through the part for the pen to go through, with a diameter slightly larger than the pen itself. The pen hole needs to extend all the way through the adapter.\n\nI'd like the OpenSCAD design to use parameters to control all of the following:\n\n*   **`pencil_hole_diameter`**: The diameter of the hole for the pen. This should be a little bigger than the pen itself to provide some clearance.\n*   **`adapter_size_diameter`**: The diameter of the plug that goes into the CNC mount. This should be slightly larger than the hole it goes into to ensure a press fit.\n*   **`Insert_length`**: The length of the plug, how far it goes into the mount.\n*   **`collar_diameter`**: The diameter of the collar that sits above the plug. This should match the dimensions of the existing tool mount on the CNC.\n*   **`collar_height`**: The height of the collar.\n\nThe code should be in standard OpenSCAD. I don't need any external libraries for this, as it is pretty straightforward.\n\nCould you generate the OpenSCAD code for this parametric design?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Randomized Circular Gallifreyan Coin ",
    "scad": "$fn=64;\nword = \"thingiverse\";\nouter_radius = 42;\ncoin_thickness = 2;\npendant_radius = 30;\nletter_radius = 10;\nline_thickness = 1;\nline_height = 1;\nseed=70;\nrandom_vect=rands(-30,30,20,seed);\necho(random_vect);\nlarge_circle_radius = letter_radius;\nsmall_circle_radius = letter_radius/4;\nlarge_dot_radius = letter_radius/7;\nsmall_dot_radius = letter_radius/8;\ndot_offset = large_circle_radius/4*3;\nchars_in_word = lenWord(word, 0, len(word));\nspacing_angle = 360 / chars_in_word;\nif (len(word) > 0 && isValidWord(word))\n{\n  difference()\n  {\n    linear_extrude(height=coin_thickness)\n      circle(outer_radius);\n    translate([0,0,coin_thickness-line_height])\n      linear_extrude(height=line_height+0.1)\n      rotate([0,0,-90])\n      write_circle();\n  }\n}\nelse\n{\n  echo(\"invalid input\");\n}\nfunction isVowel(t,p,l) = (l - p > 0)\n                       && (t[p] == \"a\" || t[p] == \"e\" || t[p] == \"i\" || t[p] == \"o\" || t[p] == \"u\");\nfunction isConsWithH(t,p,l) = (l - p > 1)\n                           && (t[p+1] == \"h\")\n                           && (t[p] == \"t\" || t[p] == \"s\" || t[p] == \"c\");\nfunction isConsNG(t,p,l) = (l - p > 1)\n                        && t[p] == \"n\"\n                        && t[p+1] == \"g\";\nfunction isConsQU(t,p,l) = (l - p > 1)\n                        && t[p] == \"q\"\n                        && t[p+1] == \"u\";\nfunction isCons2(t,p,l) = isConsWithH(t,p,l) || isConsNG(t,p,l) || isConsQU(t,p,l);\nfunction isCons1(t,p,l) = (l - p > 0)\n                       && (t[p] == \"b\" || t[p] == \"d\" || t[p] == \"f\" || t[p] == \"g\" || t[p] == \"h\" ||\n                           t[p] == \"j\" || t[p] == \"k\" || t[p] == \"l\" || t[p] == \"m\" || t[p] == \"n\" ||\n                           t[p] == \"p\" || t[p] == \"t\" || t[p] == \"r\" || t[p] == \"s\" || t[p] == \"v\" ||\n                           t[p] == \"w\" || t[p] == \"y\" || t[p] == \"z\" || t[p] == \"x\");\nfunction isCons2WithVowel(t,p,l) = isVowel(t,p+2,l) && isCons2(t,p,l);\nfunction isCons1WithVowel(t,p,l) = isVowel(t,p+1,l) && isCons1(t,p,l);\nfunction isValid(t,p,l) = l == p ? true\n                        : isVowel(t,p,l) ? isValid(t,p+1,l)\n                        : isCons2(t,p,l) ? isValid(t,p+2,l)\n                        : isCons1(t,p,l) ? isValid(t,p+1,l) : false;\nfunction lenWord(t,p,l) = isVowel(t,p,l) ? 1 + lenWord(t,p+1,l)\n                        : isCons2WithVowel(t,p,l) ? 1 + lenWord(t,p+3,l)\n                        : isCons1WithVowel(t,p,l) ? 1 + lenWord(t,p+2,l)\n                        : isCons2(t,p,l) ? 1 + lenWord(t,p+2,l)\n                        : isCons1(t,p,l) ? 1 + lenWord(t,p+1,l)\n                        : 0;\nfunction isValidWord(txt) = isValid(txt,0,len(txt));\nfunction isLetterStart(s,t,p,l) = s == p ? true\n                                : s < p ? false\n                                : isVowel(t,p,l) ? isLetterStart(s,t,p+1,l)\n                                : isCons2WithVowel(t,p,l) ? isLetterStart(s,t,p+3,l)\n                                : isCons1WithVowel(t,p,l) ? isLetterStart(s,t,p+2,l)\n                                : isCons2(t,p,l) ? isLetterStart(s,t,p+2,l)\n                                : isCons1(t,p,l) ? isLetterStart(s,t,p+1,l)\n                                : false;\nfunction whichLetter(s,t,p,l) = s <= p ? 0\n                                : isVowel(t,p,l) ? 1 + whichLetter(s,t,p+1,l)\n                                : isCons2WithVowel(t,p,l) ? 1 + whichLetter(s,t,p+3,l)\n                                : isCons1WithVowel(t,p,l) ? 1 + whichLetter(s,t,p+2,l)\n                                : isCons2(t,p,l) ? 1 + whichLetter(s,t,p+2,l)\n                                : isCons1(t,p,l) ? 1 + whichLetter(s,t,p+1,l)\n                                : 0;\nmodule write_circle()\n{\n  for (letter = [0 : len(word)-1])\n  {\n    if (isLetterStart(letter, word, 0, len(word)))\n    {\n      rotate([0, 0, spacing_angle * whichLetter(letter, word, 0, len(word))])\n        translate([pendant_radius, 0, 0])\n        write_circle_letter(word, letter, len(word));\n    }\n  }\n}\nmodule write_circle_letter(t,p,l)\n{\n  if (p < l)\n  {\n    if (isVowel(t,p,l))\n    {\n      translate([-pendant_radius, 0, 0])\n        arc_segment(spacing_angle, pendant_radius);\n      write_vowel(t[p]);\n    }\n    else if (isCons2(t,p,l))\n    {\n      write_consonant(str(t[p],t[p+1]), isCons2WithVowel(t,p,l) ? t[p+2] : undef);\n    }\n    else if (isCons1(t,p,l))\n    {\n      write_consonant(t[p], isCons1WithVowel(t,p,l) ? t[p+1] : undef);\n    }\n    else\n    {\n      echo(\"wha? invalid character\");\n    }\n  }\n}\nmodule write_vowel(c)\n{\n  if (c == \"a\")\n  {\n    translate([letter_radius/2,0,0])\n      circle_line(small_circle_radius);\n  }\n  else if (c == \"e\")\n  {\n    circle_line(small_circle_radius);\n  }\n  else if (c == \"i\")\n  {\n    circle_line(small_circle_radius);\n    rotate([0,0,180])\n      rotate([0,0,random_vect[0]]) translate([small_circle_radius,0,0])\n        line(letter_radius - small_circle_radius+2*outer_radius);\n  }\n  else if (c == \"o\")\n  {\n    translate([-letter_radius/2,0,0])\n    circle_line(small_circle_radius);\n  }\n  else if (c == \"u\")\n  {\n    circle_line(small_circle_radius);\n    rotate([0,0,random_vect[7]]) translate([small_circle_radius,0,0])\n      line(letter_radius - small_circle_radius+2*outer_radius);\n  }\n  else\n  {\n    echo(\"wha? invalid vowel\");\n  }\n}\nmodule write_consonant(c,v)\n{\n  if (c == \"b\" || c == \"ch\" || c == \"d\" || c == \"f\" || c == \"g\" || c == \"h\")\n  {\n    difference()\n    {\n      union()\n      {\n        translate([-pendant_radius, 0, 0])\n          arc_segment(spacing_angle, pendant_radius);\n        translate([-large_circle_radius,0,0])\n          circle_line(large_circle_radius);\n      }\n      square(small_circle_radius*2, center=true);\n    }\n    translate([-large_circle_radius,0,0])\n    {\n      if (c == \"ch\")     write_circle_modifier(1);\n      else if (c == \"d\") write_circle_modifier(2);\n      else if (c == \"f\") write_circle_modifier(3);\n      else if (c == \"g\") write_circle_modifier(4);\n      else if (c == \"h\") write_circle_modifier(5);\n      if (v) write_vowel(v);\n    }\n  }\n  else if (c == \"j\" || c == \"k\" || c == \"l\" || c == \"m\" || c == \"n\" || c == \"p\")\n  {\n    translate([-pendant_radius, 0, 0])\n      arc_segment(spacing_angle, pendant_radius);\n    translate([-large_circle_radius-large_dot_radius,0,0])\n    {\n      circle_line(large_circle_radius);\n      if (c == \"k\")      write_circle_modifier(1);\n      else if (c == \"l\") write_circle_modifier(2);\n      else if (c == \"m\") write_circle_modifier(3);\n      else if (c == \"n\") write_circle_modifier(4);\n      else if (c == \"p\") write_circle_modifier(5);\n      if (v) write_vowel(v);\n    }\n  }\n  else if (c == \"t\" || c == \"sh\" || c == \"r\" || c == \"s\" || c == \"v\" || c == \"w\")\n  {\n    difference()\n    {\n      translate([-pendant_radius, 0, 0])\n        arc_segment(spacing_angle, pendant_radius);\n      circle(large_circle_radius - line_thickness/2);\n    }\n    difference()\n    {\n      rotate(180) arc_segment(180, large_circle_radius);\n      difference()\n      {\n        translate([-pendant_radius,0,0]) circle(pendant_radius+large_circle_radius);\n        translate([-pendant_radius,0,0]) circle(pendant_radius);\n      }\n    }\n    if (c == \"sh\")     write_circle_modifier(1);\n    else if (c == \"r\") write_circle_modifier(2);\n    else if (c == \"s\") write_circle_modifier(3);\n    else if (c == \"v\") write_circle_modifier(4);\n    else if (c == \"w\") write_circle_modifier(5);\n    if (v) write_vowel(v);\n  }\n  else if (c == \"th\" || c == \"y\" || c == \"z\" || c == \"ng\" || c == \"qu\" || c == \"x\")\n  {\n    translate([-pendant_radius, 0, 0])\n      arc_segment(spacing_angle, pendant_radius);\n    circle_line(large_circle_radius);\n    if (c == \"y\")       write_circle_modifier(1);\n    else if (c == \"z\")  write_circle_modifier(2);\n    else if (c == \"ng\") write_circle_modifier(3);\n    else if (c == \"qu\") write_circle_modifier(4);\n    else if (c == \"x\")  write_circle_modifier(5);\n    if (v) write_vowel(v);\n  }\n  else\n  {\n    echo(\"wha? invalid consonant\");\n  }\n}\nmodule write_circle_modifier(y)\n{\n  if (y == 1)\n  {\n    rotate(-45) translate([-dot_offset,0,0]) circle(large_dot_radius);\n    rotate(-70) translate([-dot_offset,0,0]) circle(small_dot_radius);\n  }\n  else if (y == 2)\n  {\n    rotate(-40) translate([-dot_offset,0,0]) circle(small_dot_radius);\n    rotate(-65) translate([-dot_offset,0,0]) circle(large_dot_radius);\n    rotate(-90) translate([-dot_offset,0,0]) circle(small_dot_radius);\n  }\n  else if (y == 3)\n  {\n    rotate(180+15+random_vect[1]) translate([large_circle_radius,0,0]) line(letter_radius+2*outer_radius);\n    rotate(180+random_vect[2]   ) translate([large_circle_radius,0,0]) line(letter_radius+2*outer_radius);\n    rotate(180-random_vect[3]) translate([large_circle_radius,0,0]) line(letter_radius+2*outer_radius);\n  }\n  else if (y == 4)\n  {\n    rotate(180   ) translate([large_circle_radius,0,0]) line(letter_radius+2*outer_radius);\n  }\n  else if (y == 5)\n  {\n    rotate(180+15+random_vect[4]) translate([large_circle_radius,0,0]) line(letter_radius+2*outer_radius);\n    rotate(180-15+random_vect[5]) translate([large_circle_radius,0,0]) line(letter_radius+2*outer_radius);\n  }\n}\nmodule arc_segment(angle, radius, thick)\n{\n  pos_x = cos(angle/2) * radius * 1.5;\n  pos_y = sin(angle/2) * radius * 1.5;\n  intersection()\n  {\n    if (angle < 360)\n      polygon([ [0,0], [pos_x,-pos_y], [radius * 1.5,0], [pos_x,+pos_y] ]);\n    circle_line(radius);\n  }\n}\nmodule circle_line(radius)\n{\n  difference()\n  {\n    circle(radius + line_thickness/2);\n    circle(radius - line_thickness/2);\n  }\n}\nmodule line(length)\n{\n  translate([0,-line_thickness/2,0])\n    square([length, line_thickness]);\n}",
    "description": "Okay, I'm looking to create a customizable coin with a circular Gallifreyan-inspired inscription, similar to the \"Gali-tweaked.scad\" example I've been playing with, but I need more control over the text and overall design, and want it to be more parametric and easier to adjust.\n\nHere's what I'd like the design to be:\n\n**Core Design:**\n*   **Coin Shape:** A flat, circular coin with a specified `outer_radius` and `coin_thickness`.\n*   **Inscription:** The coin will feature a circular Gallifreyan-style inscription using a user-defined `word`. This inscription will follow a circular path at a set `pendant_radius`.\n*   **Letter Structure:** The inscription will be formed using circular elements and lines. Each letter will have a defined `letter_radius` and `line_thickness`. The letters themselves are generated based on rules for breaking down the word (vowels, consonants, etc.) that need to be duplicated, but in a more flexible and parametric way if possible.\n*   **Random Lines:** Lines should cross over the letters, each letter could have random angle lines going past its borders that cross the entire face of the coin.\n*   **Text Input:** The `word` should be easily customizable. I'm assuming only lower-case, no punctuation, just like the Gali-tweaked.scad example.\n*   **Smooth Curves:** I'd prefer the final result to have smooth curves, meaning the `$fn` variable should be settable in the design.\n*   **Seed:** I need a way to control the random number generation for those crossing lines (using a `seed` value).\n\n**Specific Customization Parameters:**\n*   `outer_radius`: The radius of the coin.\n*   `coin_thickness`: The thickness of the coin.\n*   `pendant_radius`: The radius of the circular path for the inscription.\n*   `letter_radius`: The radius of the large circles in each letter.\n*   `line_thickness`: The thickness of the lines used for the inscription and the random crossing lines.\n*  `line_height`: The height of the letters, relative to the coin thickness.\n*   `word`: The word to be inscribed (lower case letters only).\n*   `seed`: The seed value for random line generation.\n*  `$fn`: The number of fragments for circles (for smooth curves).\n\n**Functionality Requests**\n* **Parametric letter generation:** Instead of having a function that depends on specific combinations of letters, can we try making a version that lets the user describe the letter by adding or subtracting from a basic set of circles/lines/arcs?\n*   **Error Handling:**  I'd like a simple message if the input `word` isn't valid. Ideally, this could include more descriptive error messages, if possible\n*   **Clean Code:**  It'd be great if the code was organized well, making it easy to modify and add functionality later on.\n\n**Libraries**\nI don't think I need any external libraries for this, as it's mostly circles and lines, but I'm also open to suggestions if they might simplify the design process.\n\nBasically, I'm looking for a more flexible and parametric way to design these circular Gallifreyan-style coins, making it easier to experiment with different letter configurations and layouts, using the same basic principles as the provided example. Can you help me with this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Toy train track (customizer)",
    "scad": "track_length=25;\ntrack_option=2;\nmodule track(){\n\ttranslate([-20,0,0])\n\trotate (a=[90,0,0]) linear_extrude(height =track_length, center = true) polygon(points = [ [0,0], [0,9], [1,12],[4,12],[5,9],[10,9],[11,12],[29,12],[30,9],[35,9],[36,12], [39,12],[40,9], [40,0]], path = [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]]);\n}\nmodule peg(){\n\ttranslate ([0,-12,0])\n\tunion(){\n\t\tcylinder(12,5.9,5.9);\n\t\ttranslate ([-3,5,0]) cube(size=[6,8,12]);\n\t}\n}\nmodule peg_cut(){\n\ttranslate ([0,-11.9,-1])\n\tunion(){\n\t\tcylinder(14,6.6,6.6);\n\t\ttranslate ([-3,5,0]) cube(size=[7,8,14]);\n\t}\n}\nmodule mm_track (){\ntranslate ([0,-track_length/2,0]) peg();\ntranslate ([0,track_length/2,0]) rotate(a=[0,0,180]) peg();\ntrack ();\n}\nmodule mf_track (){\n\ttranslate ([0,track_length/2,0]) rotate(a=[0,0,180]) peg();\n\tdifference() {\n\t\ttrack();\n\t\ttranslate ([0,-track_length/2,0]) rotate(a=[0,0,180]) peg_cut();\n\t}\n}\nmodule ff_track (){\n\tdifference() {\n\t\ttrack();\n\t\ttranslate ([0,-track_length/2,0]) rotate(a=[0,0,180]) peg_cut();\n\t\ttranslate ([0,track_length/2,0])  peg_cut();\n\t}\n}\nif (track_option==1) {\n\tmm_track();\n}\nif (track_option==2) {\n\tmf_track();\n}\nelse\n{\n\tff_track();\n}",
    "description": "Okay, I'm looking to design some train track pieces for a Thomas-style toy train. I need a straight track section with the ability to choose the connector types on each end. I've already started with some basic code but I'm hoping for a more robust and parametric version that's easier to customize.\n\nHere's a breakdown of what I'm looking for:\n\n**Core Features:**\n\n*   **Straight Track Section:** This is the primary piece.\n*   **Connector Types:** The track should have either male (peg) or female (cutout) connectors on each end.\n*   **Customizable Length:** The track length should be a customizable parameter.\n*   **Parametric Design:** I would like to be able to easily adjust the dimensions of the track profile and connectors through parameters.\n*   **Connector Choice:** I'd like to select which end is male and female from a dropdown. Options will be male-male, male-female, and female-female.\n*   **Ease of Modification:** The code should be as clean and easy to understand as possible so I can modify it if needed.\n*   **No external libraries needed**: Should not use any external OpenSCAD libraries.\n\n**Specific Dimensions (that should become parameters):**\n\n*   **Track Profile:** I'm currently using a polygon with these points, which should have parameters to adjust: `[ [0,0], [0,9], [1,12],[4,12],[5,9],[10,9],[11,12],[29,12],[30,9],[35,9],[36,12], [39,12],[40,9], [40,0]]`.  The thickness of the track (currently set by the `linear_extrude` `height` parameter) also needs to be adjustable.\n*   **Peg (Male) Connector:**\n    *   Cylinder Radius: Currently 5.9mm\n    *   Cylinder Height: Currently 12mm\n    *   Cube Dimensions: Currently 6x8x12mm, with a -3mm offset on the X axis and 5mm offset on the Y axis\n*  **Cutout (Female) Connector:**\n    *   Cylinder Radius: Currently 6.6mm\n    *   Cylinder Height: Currently 14mm\n    *   Cube Dimensions: Currently 7x8x14mm, with a -3mm offset on the X axis and 5mm offset on the Y axis\n    *   Cutout Z offset: Currently -1mm\n\n**Desired Parametric Controls:**\n\n*   `track_length`: Overall length of the track.\n*   `track_thickness`: Height of the track extrusion.\n*   `track_profile_points`: A list of points that define the shape of the track cross-section.\n*    `peg_radius`: Radius of the peg cylinder.\n*   `peg_height`: Height of the peg cylinder.\n    `peg_cube_x`: Width of the peg cube\n    `peg_cube_y`: Height of the peg cube\n   `peg_cube_z`: Thickness of the peg cube\n   `peg_cube_offset_x`: x offset of the peg cube\n    `peg_cube_offset_y`: y offset of the peg cube\n*   `cutout_radius`: Radius of the cutout cylinder.\n*   `cutout_height`: Height of the cutout cylinder.\n    `cutout_cube_x`: Width of the cutout cube\n    `cutout_cube_y`: Height of the cutout cube\n   `cutout_cube_z`: Thickness of the cutout cube\n   `cutout_cube_offset_x`: x offset of the cutout cube\n    `cutout_cube_offset_y`: y offset of the cutout cube\n    `cutout_offset_z`: z offset of the cutout\n*   `end_connector`: A dropdown menu to select `male-male`, `male-female`, or `female-female`.\n\nI'm basically looking to replace my current modules (track, peg, peg_cut, mm_track, mf_track, ff_track) with a more flexible system using parameters. Can you help me design this in OpenSCAD?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Whistle Magic - create your own whistle - Your Whistle your Music",
    "scad": "rad = 30;\nhoehe  =  20;\nlaenge =  35;\nmake_holder =  1;\ntextshow = \"Love\";\ntextsize =  10;\nuse <write/Write.scad>\ndicke  =   2+0;\nbreite =   6+0;\nball   =   3+0;\nbuffer =   0+0;\ntexth  =   1+0;\ndostay =   false+0;\npfeife(textshow, textsize);\nmodule pfeife(name,sizename)\n{\n  if (make_holder) rotate([90,0,0]) translate([-rad/2+0.1,hoehe/2,0]) scale([15/hoehe,1,1]) halter(dicke);\n  if (rad < 40) rotate([0,0,0])  translate([0,0,hoehe]) texter(name, sizename);\n  if (rad > 39)\n  {\n    color(\"yellow\") writecylinder(name,[0,0,0],t=3,h=9,font=\"write/Letters.dxf\",\n      space=1.2, rad/2+1,hoehe,face=\"top\");\n  }\n  difference()\n  {\n    union()\n    {\n      color(\"red\") translate([0,0,0]) cylinder(hoehe, r=rad/2, $fn = 35);\n      color(\"red\") translate([0,rad/2-breite,0]) cube([laenge,breite,hoehe]);\n      color(\"red\") translate([0,0,0]) cube([rad/2,rad/2,hoehe]);\n\t}\n    translate([0,0,dicke]) cylinder(hoehe-dicke*2+buffer, r=rad/2-dicke, $fn = 25);\n    translate([0,rad/2-breite+dicke,dicke])\n      cube([laenge+dicke,breite-dicke*2,hoehe-dicke*2+buffer]);\n    if (rad > 39)\n      translate([0,0,0]) cylinder(hoehe, r=(rad-25)/2-dicke, $fn = 25);\n    color(\"blue\") translate([dicke*5,rad/2-dicke/3,dicke]) rotate([0,0,150])\n      cube([dicke*5,dicke*2,hoehe-2*dicke]);\n    color(\"blue\") translate([4,rad/2-7.5,dicke]) rotate([0,0,0])\n      cube([rad/8,10,hoehe-2*dicke]);\n  }\n  if (dostay)\n    color(\"black\") translate([-rad/6,-rad/2,0]) cube([rad/3,dicke,hoehe]);\n  if (rad > 39)\n  {\n    difference() {\n      translate([0,0,dicke]) cylinder(hoehe-dicke*2, r=(rad-25)/2, $fn = 35);\n      translate([0,0,dicke]) cylinder(hoehe-dicke*2, r=(rad-25)/2-dicke, $fn = 25);\n    }\n  }\n  if (true)\n  {\n    color(\"red\") translate([0,rad/2-7.5,dicke]) cylinder(1, r=1, $fn = 10);\n    difference()\n    {\n      color(\"red\") translate([0,rad/2-7.5,dicke+ball+1+1]) sphere(ball+1, $fn=25);\n      color(\"red\") translate([0,rad/2-7.5,dicke+ball+1+1]) sphere(ball, $fn=25);\n    }\n  }\n}\nmodule texter(gotname=\"NIS\", sizename=11)\n{\n  color(\"yellow\")   translate([0.5,2,0]) rotate([0,0,40])\n    write(gotname,t=3,h=sizename,font=\"write/Letters.dxf\", space=0.90, center=true);\n}\nmodule halter(dicke=1)\n{\n  difference()\n  {\n    union()\n    {\n      color(\"blue\") translate([0,0,-dicke]) cylinder(dicke*2, r=hoehe/2, $fn = 25);\n\t}\n    translate([0,0,-dicke]) cylinder(hoehe-dicke*2, r=hoehe/2-dicke*hoehe/15, $fn = 25);\n    translate([0,-hoehe,-dicke]) cube([hoehe,hoehe*2,dicke*2]);\n  }\n}",
    "description": "Okay, I'd like to design a custom whistle, and I'd like to use OpenSCAD to do it parametrically. I've seen a design that's pretty close to what I want, and I'll describe it along with my desired modifications.\n\nThe basic shape of the whistle is a cylinder with a blowing element that sticks out the side. The core of the whistle is hollowed out, and there's also a smaller channel that cuts into the main cylindrical cavity, creating the \"whistle\" part. Inside there is also a sphere that bounces around to create the whistle sound.\n\nHere are the parameters I need to control, and some ranges I'd like:\n\n*   **`rad`**: The radius of the main cylindrical body of the whistle, in millimeters. I'd like a range of 20 to 50 mm for this.\n*   **`hoehe`**: The height of the whistle, in millimeters. I'd like a range of 15 to 30 mm.\n*   **`laenge`**: The length of the blowing element that sticks out, in millimeters. I'd like a range of 20 to 50 mm.\n*   **`make_holder`**: A boolean (0 or 1) to decide whether or not to include a handle on the whistle.\n*  **`textshow`**: A string that determines the text printed on the whistle.\n*   **`textsize`**: An integer determining the size of the text on the whistle, ranging from 8-14 mm.\n*   **`dicke`**: The thickness of the walls, should be able to set this to at least 2mm. \n*   **`breite`**: The width of the blowing element, around 6mm.\n*   **`ball`**: The radius of the internal sphere that makes the whistle sound. I'd like the ability to change this in the final design.\n* **`buffer`**: An integer offset for the hollowed out space of the whistle.\n*   **`dostay`**: A boolean (0 or 1) that will add a small cube to the bottom of the whistle that allows it to sit on the table without rolling.\n\nHere are the design elements to create:\n\n1.  **Main Cylinder:** A cylinder with radius `rad/2` and height `hoehe`. This forms the main body of the whistle.\n2.  **Blowing Element:** A rectangular prism (or cube) that extends outwards from the main cylinder. Its dimensions are `laenge` x `breite` x `hoehe`, and its positioned such that it connects to the cylinder on its side.\n3.  **Hollow Core:** The interior of the whistle needs to be hollow. This is created by subtracting a smaller cylinder (radius `rad/2 - dicke`, height `hoehe - 2*dicke + buffer`) from the main cylinder and a rectangular prism (`laenge + dicke` x `breite - dicke*2` x `hoehe - 2*dicke + buffer`) from the blowing element.\n4.  **Whistle Channel:** A channel needs to be cut into the side of the whistle to produce sound. This will be done using a few smaller rectangular prisms.\n5. **Text on whistle**: The text specified by `textshow` with the size specified by `textsize` needs to be displayed on the top of the whistle.  If the radius is larger than 39mm it should use `writecylinder` from the write library, and use write in other cases.\n6. **Internal sphere:**  A sphere of radius `ball` needs to be created, positioned near the whistle channel.\n7.  **Handle:** If `make_holder` is true, create a handle on the side of the whistle that could be used as a keychain loop.\n8.  **Support Ring (for larger whistles):** If the radius `rad` is greater than 39, add a support cylinder to the inside to help with printing.\n\nThe original design uses a few things I'd like to mimic:\n\n*   It uses the `write/Write.scad` library for text. Please be sure to use this library for my text as well.\n\nI think that's everything. Let me know if you have any questions!\n"
  },
  {
    "object": "Hey cadmonkey, make me a nice parametric dentelle ceiling lamp shade",
    "scad": "$fn=90;\nSCALE =1.5;\nHEIGHT   = 50*SCALE;\nDIAMETER = 50*SCALE;\nFLOOR    = 18*SCALE;\nWEIGHT_CENTER = 32*SCALE;\nWEIGHT_RADIUS = 12*SCALE;\nTOP_RADIUS = 22*SCALE;\nTOP_EXCENTER = 0*SCALE;\nKABELOEFFNUNG = 7;\nWANDDICKE = 1.8;\nLOECHER_ANZAHL = 8;\nschirm();\nmodule innen()\n{\n   translate([-0.01,-0.01,0])\n   difference()\n   {\n      union()\n      {\n         hull()\n         {\n \t       translate([0,HEIGHT-WANDDICKE-1,0]) square(1);\n  \t       translate([DIAMETER/2-13-WANDDICKE-1,WEIGHT_CENTER-5,0])  rotate([0,0,95])  circle(r=13, $fn=30);\n            square(FLOOR-WANDDICKE);\n         }\n      }\n      translate([-HEIGHT,0,0])\n      {\n        square(HEIGHT);\n      }\n   }\n}\nmodule schirm()\n{\n   difference(){\n        rotate_extrude(convexity = 30)\n        difference()\n        {\n           grundkoerper();\n           innen();\n           kabeloeffnung();\n        }\n      for(i=[1:LOECHER_ANZAHL]){\n         rotate([0,0,(360/LOECHER_ANZAHL)*i])\n         translate([0,-12,HEIGHT-10])\n         rotate([20,0,0])\n         cylinder(h=20,r=3);\n     }\n   }\n}\nmodule grundkoerper()\n{\n   difference()\n   {\n      hull()\n      {\n\t     translate([TOP_EXCENTER,HEIGHT-TOP_RADIUS-0.5,0]) circle(r=TOP_RADIUS);\n\t     square(FLOOR);\n\t     translate([(DIAMETER/2)-WEIGHT_RADIUS,WEIGHT_CENTER,0]) circle(r=WEIGHT_RADIUS);\n      }\n\t translate([-HEIGHT*2,0,0])\n      {\n        square(HEIGHT*2);\n      }\n   }\n}\nmodule kabeloeffnung()\n{\n\t translate([-KABELOEFFNUNG/2,HEIGHT-KABELOEFFNUNG/2,0])\n      {\n        square(KABELOEFFNUNG);\n      }\n}",
    "description": "Okay, I'm looking to create a parametric lampshade in OpenSCAD. I have an existing design I've been tinkering with, but I want to make it more easily adjustable. \n\nThe lampshade should be a rotationally extruded shape, primarily defined by a few key circles/points, which get hulled together.\n\nHere's the basic structure:\n1.  **Base:** The bottom should be a flat circular opening (represented by a square in the 2D profile). It will have a diameter of `FLOOR`, and a wall thickness, `WANDDICKE`.\n2.  **Waist:** At a given height (`WEIGHT_CENTER`) there should be a bulge that's generated by another circle. This circle's radius is specified by `WEIGHT_RADIUS`.\n3.  **Top:** The very top of the lampshade has a circular opening (again, represented by a square in the 2D profile). Its radius is given by `TOP_RADIUS`. The center of the top circle can be offset horizontally using `TOP_EXCENTER`, but for the time being, we can assume it's `0`. \n4.  **Overall Height:** The lampshade should have a total height of `HEIGHT`.\n5.  **Kabelffnung:** There's a rectangular cable opening at the top, which should be sized according to parameter `KABELOEFFNUNG`.\n\nThe lampshade will have a thickness, defined by `WANDDICKE`.\n\nI'd also like to add some decorative holes around the upper part of the lampshade. These holes should be created using `cylinder` primitives, rotated outwards a bit. They should be located near the top of the lampshade, at the height `HEIGHT-10`. Their number should be configurable via the `LOECHER_ANZAHL` parameter, currently 8. They should be rotated 20 degrees on the x-axis and be of radius 3 and height 20.\n\nI would like the final design to be based on the difference of two solids, the first defined by the hull of the three defining points (base, waist, top) and the second defined by the same geometry of the first, but scaled inwards to represent the wall thickness. The cable opening will also be cut from the solid.\n\nI need all these parameters to be easily adjusted to quickly change the lampshade's dimensions. Please generate a parametric OpenSCAD file based on the described design. I don't need any special libraries for this.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Power Stick - Good for Dremels, Fans, Blenders and More!",
    "scad": "depth_motor = 40;\ndia_motor = 30;\nwidth_button = 12.5;\nlength_button = 20;\nwidth_battery = 33;\nlength_battery = 33;\ndepth_battery = 60;\noverall_length = depth_battery+depth_motor+width_button+10;\ndifference(){\nhull(){\nrotate([0,90,0])translate([-15,-15,0])cylinder(r = 5, h = overall_length, center = false);\nrotate([0,90,0])translate([+15,-15,0])cylinder(r = 5, h = overall_length, center = false);\nrotate([0,90,0])translate([-15,+15,0])cylinder(r = 5, h = overall_length, center = false);\nrotate([0,90,0])translate([+15,+15,0])cylinder(r = 5, h = overall_length, center = false);\n}\ntranslate([-1,-width_battery/2,-length_battery/2])cube([depth_battery+width_button+6,width_battery,length_battery]);\nrotate([0,90,0])translate([0,0,overall_length-depth_motor+1])cylinder(r = dia_motor/2, h = depth_motor, center = false);\ntranslate([depth_battery+5,-width_battery/8,-length_battery/2])cube([depth_battery+5,width_battery/4,length_battery]);\ntranslate([depth_battery+5,-length_button/2,1])cube([width_button,length_button,20]);\ntranslate([2,-17.5,-17.5])cube([3,35,40]);\ntranslate([overall_length-6,-25,-5])cube([3,50,10]);\ntranslate([overall_length-16,-25,-5])cube([3,50,10]);\ntranslate([overall_length-26,-25,-5])cube([3,50,10]);\ntranslate([overall_length-36,-25,-5])cube([3,50,10]);\ntranslate([overall_length-6,-5,-25])cube([3,10,50]);\ntranslate([overall_length-16,-5,-25])cube([3,10,50]);\ntranslate([overall_length-26,-5,-25])cube([3,10,50]);\ntranslate([overall_length-36,-5,-25])cube([3,10,50]);\nrotate([0,90,0])translate([15,15,overall_length-9])cylinder(r = 2.5, h = 10, center = false);\nrotate([0,90,0])translate([15,-15,overall_length-9])cylinder(r = 2.5, h = 10, center = false);\nrotate([0,90,0])translate([-15,15,overall_length-9])cylinder(r = 2.5, h = 10, center = false);\nrotate([0,90,0])translate([-15,-15,overall_length-9])cylinder(r = 2.5, h = 10, center = false);\n}",
    "description": "Okay, I have a design concept for a \"Power Stick\" which is essentially a housing for a motor, battery, and switch that can be easily plugged into other 3D printed designs to add motion. I've already started a basic OpenSCAD file, but I need help making it truly parametric and user-friendly.\n\nHere's what I'm looking for:\n\n**Core Functionality:**\n\n*   The design needs to enclose a cylindrical motor, a battery pack, and a switch.\n*   It should be primarily a cylindrical shape, but include a rectangular area for the battery pack and switch.\n*   The design should have a section where the motor's shaft can protrude for driving other things.\n*   It should allow users to easily modify the dimensions of the motor, battery, and switch.\n*   The overall length of the power stick should be automatically calculated based on the component dimensions.\n*  The housing should be made using a hull for ease of printing.\n*  I would prefer that the internal components be subtracted from the hull.\n*  I need holes/recesses to be subtracted from the main body to secure the motor, switch, and battery.\n* I would also like to have holes for wires to come out the back\n\n**Parametric Needs:**\n\nI need to be able to easily change the following variables in the OpenSCAD file:\n\n*   `depth_motor`:  The length (depth) of the motor in mm.\n*   `dia_motor`: The diameter of the motor in mm.\n*   `width_button`: The width of the switch in mm.\n*   `length_button`: The length of the switch in mm.\n*   `width_battery`: The width of the battery holder in mm.\n*   `length_battery`: The length of the battery holder in mm.\n*   `depth_battery`: The depth (how long it is) of the battery holder in mm.\n*   `clearance`: An adjustment that can be made to add clearance to the internal spaces.\n\n**Additional Considerations:**\n\n*   I'd like the code to be well-commented, making it easy for other users (with varying levels of OpenSCAD experience) to understand and modify.\n*   It would be beneficial to have an easy way to adjust clearance for the components (for example, adding `clearance` to the dimensions when subtracting to create space for the internal components).\n*   If there's a better way to handle the cylindrical shape other than using a hull, that is also acceptable.\n\n**Current OpenSCAD Code (for reference):**\n\n```openscad\n//How long is your motor (mm)?\ndepth_motor = 40;\n//What is the diameter of your motor(mm)?\ndia_motor = 30;\n\n//What is the width of your switch(mm)?\nwidth_button = 12.5;\n//What is the length of your switch(mm)?\nlength_button = 20;\n\n//What is the width of your battery holder(mm)?\nwidth_battery = 33;\n//What is the length of your battery holder(mm)?\nlength_battery = 33;\n//What is the height of your battery holder (how long is it)(mm)?\ndepth_battery = 60;\n\n\noverall_length = depth_battery+depth_motor+width_button+10;\n\ndifference(){\n\nhull(){\nrotate([0,90,0])translate([-15,-15,0])cylinder(r = 5, h = overall_length, center = false);\nrotate([0,90,0])translate([+15,-15,0])cylinder(r = 5, h = overall_length, center = false);\nrotate([0,90,0])translate([-15,+15,0])cylinder(r = 5, h = overall_length, center = false);\nrotate([0,90,0])translate([+15,+15,0])cylinder(r = 5, h = overall_length, center = false);\n}\n\n//minus\ntranslate([-1,-width_battery/2,-length_battery/2])cube([depth_battery+width_button+6,width_battery,length_battery]);\n\nrotate([0,90,0])translate([0,0,overall_length-depth_motor+1])cylinder(r = dia_motor/2, h = depth_motor, center = false);\n\ntranslate([depth_battery+5,-width_battery/8,-length_battery/2])cube([depth_battery+5,width_battery/4,length_battery]);\n\ntranslate([depth_battery+5,-length_button/2,1])cube([width_button,length_button,20]);\n\ntranslate([2,-17.5,-17.5])cube([3,35,40]);\n\ntranslate([overall_length-6,-25,-5])cube([3,50,10]);\ntranslate([overall_length-16,-25,-5])cube([3,50,10]);\ntranslate([overall_length-26,-25,-5])cube([3,50,10]);\ntranslate([overall_length-36,-25,-5])cube([3,50,10]);\n\ntranslate([overall_length-6,-5,-25])cube([3,10,50]);\ntranslate([overall_length-16,-5,-25])cube([3,10,50]);\ntranslate([overall_length-26,-5,-25])cube([3,10,50]);\ntranslate([overall_length-36,-5,-25])cube([3,10,50]);\n\nrotate([0,90,0])translate([15,15,overall_length-9])cylinder(r = 2.5, h = 10, center = false);\nrotate([0,90,0])translate([15,-15,overall_length-9])cylinder(r = 2.5, h = 10, center = false);\nrotate([0,90,0])translate([-15,15,overall_length-9])cylinder(r = 2.5, h = 10, center = false);\nrotate([0,90,0])translate([-15,-15,overall_length-9])cylinder(r = 2.5, h = 10, center = false);\n}\n```\nI don't have any particular library preferences, so please use whatever you think is best for this kind of design. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Bracelet",
    "scad": "chain = true;\nlinkLength = 15;\ndiameter = 62;\neyeletSize = 2;\nlinkAdjust = 4;\nlinkWidth = 4;\nconnectType = \"A\";\nconnectCombine = false;\nuseRandomLinks = false;\nnumConnectorsA = 2;\nnumberOfSidesB = 5;\nrandomSpinB = true;\ndensityB = 2;\nthicknessB = 1;\nrandomRotateOnB = 1;\nrandomSkewOnB = 1;\nrandomScaleSkewB = 15;\ncenterExpandC = 2;\ntwistC = 360;\nmodule ring(height, thickness, eyeletSize, res=40){\n\tdifference(){\n\t\tcylinder(h=height, r1=eyeletSize, r2=eyeletSize, center=true, $fn=res);\n\t\tcylinder(h=height*2, r1=eyeletSize-thickness, r2=eyeletSize-thickness, center=true, $fn=res);\n\t}\n}\nmodule link(linkLength, linkType = 0){\n\tunion(){\n\t\trotate([90, 0, 45]) translate([ 0, linkLength/2+eyeletSize, 0]) {\n\t\t\tring(1, 0.5, eyeletSize);\n\t\t}\n\t\trotate([-90, 0, -45]) translate([ 0, linkLength/2+eyeletSize, 0]) {\n\t\t\tring(1, 0.5, eyeletSize);\n\t\t}\n\t\ttranslate([0, 0, (linkLength)/2]) cube(size=[linkWidth, 1, 1], center=true);\n\t\ttranslate([0, 0, -(linkLength)/2]) cube(size=[linkWidth, 1, 1], center=true);\n\t\tif (connectCombine == false){\n\t\t\tif(linkType == \"A\"){\n\t\t\t\tconnectA();\n\t\t\t}\n\t\t\tif(linkType == \"B\"){\n\t\t\t\tconnectB();\n\t\t\t}\n\t\t\tif(linkType == \"C\"){\n\t\t\t\tconnectC();\n\t\t\t}\n\t\t}else{\n\t\t\tconnectA();\n\t\t\tconnectB();\n\t\t}\n\t}\n}\nmodule connectA(){\n\t\tfor (i = [0: numConnectorsA-1]){\n\t\t\ttranslate([((linkWidth/(numConnectorsA-1))*i) - linkWidth/2, 0, 0]) cylinder(h=(linkLength)+1, r1=0.5, r2=0.5, center=true, $fn=20);\n\t\t}\n}\nmodule connectB(){\n\trandom_vect = rands(0,360,linkLength);\n\trandom_vect2 = rands(-45,45,linkLength);\n\tdifference(){\n\t\tunion(){\n\t\t\tfor(i = [0 : densityB : linkLength ]){\n\t\t\t\tif (randomSpinB == true){\n\t\t\t\t\trotate([90, 0, 0]) translate([0,i-((linkLength)/2) , 0]) rotate([random_vect2[i]*randomSkewOnB*(randomScaleSkewB/100), random_vect2[i]*randomSkewOnB*(randomScaleSkewB/100), random_vect[i]*randomRotateOnB]) ring(1, thicknessB, linkWidth/2, numberOfSidesB);\n\t\t\t\t} else {\n\t\t\t\t\trotate([90, 0, 0]) translate([0, i-(linkLength/2), 0]) ring(1, thicknessB, linkWidth/2, numberOfSidesB);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\ttranslate([0, 0, linkLength/2+5]) cube(size=[linkWidth, 10, 10], center=true);\n\ttranslate([0, 0, -linkLength/2-5]) cube(size=[linkWidth, 10, 10], center=true);\n\t}\n}\nmodule connectC(){\n\t\tfunction getLookUp(p) = lookup(p, [[0, 1], [linkLength/2, centerExpandC], [linkLength, 1]]);\n\t\tfor(i = [0 : linkLength]){\n\t\t\ttranslate([0, 0, (i-((linkLength)/2))]) rotate([0, 0, twistC*(i/(linkLength*2))]) cube(size=[linkWidth*getLookUp(i), 1 , 1], center=true);\n\t\t}\n}\nnumOfLinks = ceil((diameter*PI)/(linkLength+eyeletSize)/2)+linkAdjust;\nrandomLinks = rands(0, 1, ceil((diameter*PI)/(linkLength+eyeletSize)/2)+linkAdjust);\nif (chain){\nfor (i = [0 : numOfLinks]){\n\trotate([0, 0, 360/numOfLinks*i]){\n\t\tif(useRandomLinks == false){\n\t\t\trotate([90, 0, 0]) translate([diameter/2, 0, 0]) link(linkLength, connectType);\n\t\t} else {\n\t\t\trotate([90, 0, 0]) translate([diameter/2, 0, 0]) link(linkLength, round(randomLinks[i]));\n\t\t}\n\t}\n}\n}else{\n\trotate([90, 0, 0]) link(linkLength, connectType);\n}",
    "description": "Okay, I'd like to design a customizable bracelet using OpenSCAD. I've got some ideas for how I want it to work.\n\nBasically, I want a bracelet made of interconnected links. I should be able to choose whether I want a full chain bracelet or just a single link. If it's a chain, I need to be able to set the diameter of the bracelet, and the links will be generated around that circle. I also need to control the length of each individual link. There should also be small \"eyelet\" connectors at the ends of each link. I'll need to control the size of these too.\n\nFor the links themselves, I'd like to choose the width. And I'd like to have a few different styles for how the links are connected. I'm thinking I'll call them styles A, B, and C. Style A should be fairly simple, it'll be a bunch of cylinders connecting the top and bottom \"rails\" of each link. I'll want to set how many cylinders there are. Style B will be more complex. It will consist of a series of rings at different points along the link, I'll want to be able to control the shape of the rings (number of sides), the density of the rings along the link and how thick each ring is. I should also be able to add some random spin to the individual rings to make it more organic. I will also need to be able to control the random spin on each of the three axes of the rotation. I'd like to be able to skew each ring along each axis as well, and control the scale of randomness for this. Finally style C should be a bit like a twisted bar, that bulges in the center. I should be able to control the bulge and the total amount of twist.\n\nI'd also like to include an option to randomly choose between these styles, if I make a chain of links.\n\nIt would also be great if I could add or remove a few links to make sure it all connects properly. The links should all be the same length and the eyelets should be located in the same place. I also want the ability to combine connector types if I choose.\n\nSo to summarize, here are the parameters I'd like to control in OpenSCAD:\n\n*   **`chain`**: Boolean, to generate a full bracelet or single link.\n*   **`linkLength`**: Length of each link.\n*   **`diameter`**: Diameter of the bracelet (if chain is true).\n*   **`eyeletSize`**: Size of the eyelet connectors.\n*   **`linkAdjust`**: Number of links to add/remove for fit.\n*   **`linkWidth`**: Width of the links.\n*   **`connectType`**: String, \"A\", \"B\", or \"C\", for the connector style.\n*   **`connectCombine`**: Boolean, for if the different connector styles should combine\n*    **`useRandomLinks`**: Boolean, for if the link type should be randomly selected\n*   **`numConnectorsA`**: Number of cylinders for connector type A.\n*   **`numberOfSidesB`**: Number of sides for the shape used in connector type B.\n*   **`randomSpinB`**: Boolean, to add random spin to shapes in connector type B.\n*   **`densityB`**: Number of sections for the rings in connector type B, less if more.\n*   **`thicknessB`**: Thickness of the sections in connector type B.\n*    **`randomRotateOnB`**: Boolean, for if there should be random rotation.\n*    **`randomSkewOnB`**: Boolean, for if there should be skew on an axis.\n*    **`randomScaleSkewB`**: The scale of the skew\n*   **`centerExpandC`**: Amount of bulge for connector type C.\n*   **`twistC`**: Total twist for connector type C.\n\nI think that should be everything. Let me know if you have any questions. I'm not planning to use any special OpenSCAD libraries.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable USB stick and SD card holder",
    "scad": "use <MCAD/boxes.scad>\nuse <utils/build_plate.scad>\nuse <write/Write.scad>\nDevice_Type = 3;\nDevice_Order = 1;\nUSB_Extra = 1;\nSign_FONT = \"orbitron\";\nSign_TEXT = \"USB sticks\";\nSign_HEIGHT = 6;\nSign_TYPE = 1;\nConnector_Type = 3;\nUSB_sticks = 5;\nUSB_gap = 4;\nSD_cards = 8;\nSD_gap = 2;\nMicroSD_gap = 3;\nPencil_radius = 4;\nPencil_gap = 3;\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nmodule HOLDER() {\n\tdifference() {\n\t\tunion() {\n\t\t\tif ((Device_Type == 1) || (Device_Type == 3))\n\t\t\t\ttranslate([Device_Order*(USB_Holder_Length-.001)/2,0,0]) USB_MicroSD();\n\t\t\tif ((Device_Type == 2) || (Device_Type == 3))\n\t\t\t\ttranslate([-Device_Order*(SD_Holder_Length-.001)/2,0,0]) SD();\n\t\t\tCONNECTORS(1);\n\t\t}\n\t\tCONNECTORS(-1);\n\t\ttranslate([0,0,-50])\n\t\t\tcube([300,300,100],true);\n\t}\n}\nUSB_width = 5;\nUSB_length = 13;\nUSB_depth = 13;\nUSB_Holder_Height = 18;\nUSB_Holder_Width = 32;\nUSB_Holder_Length = USB_sticks*(USB_width + USB_gap)+6-USB_gap;\nMicroSD_width = 1;\nMicroSD_length = 9;\nMicroSD_depth = 15;\nMicroSD_cards = (USB_Holder_Length-3)/(MicroSD_width+MicroSD_gap);\nPencil_holes = (USB_Holder_Length-3)/(2*Pencil_radius+Pencil_gap);\nPencil_depth = 18;\nSign_FONT_dxf = str(\"write/\",Sign_FONT,\".dxf\");\nmodule USB_MicroSD() {\n\tdifference() {\n\t\trotate([0,90,0])\n\t\t\troundedBox([USB_Holder_Height*2,USB_Holder_Width,USB_Holder_Length],3,true,$fn=60);\n\t\tfor (i=[1:USB_sticks])\n\t\t\ttranslate([5-USB_Holder_Length/2+(i-1)*(USB_width+USB_gap),6,USB_Holder_Height-USB_depth/2])\n\t\t\t\tcube([USB_width,USB_length,USB_depth+1], true);\n\t\ttranslate([0,-USB_Holder_Width/2,2*USB_Holder_Height/3+USB_Holder_Width/2])\n\t\t\trotate([45,0,0])\n\t\t\t\tcube([USB_Holder_Length+1,USB_Holder_Width,USB_Holder_Width],true);\n\t\tif (USB_Extra == 1)\n\t\t{\n\t\t\tfor (i=[1:MicroSD_cards])\n\t\t\t\ttranslate([3-USB_Holder_Length/2+(i-1)*(MicroSD_width+MicroSD_gap),-11,USB_Holder_Height-MicroSD_depth/2])\n\t\t\t\t\tcube([MicroSD_width,MicroSD_length,MicroSD_depth], true);\n\t\t}\n\t\tif (USB_Extra == 2)\n\t\t{\n\t\t\tfor (i=[1:Pencil_holes])\n\t\t\t\ttranslate([3*Pencil_radius/2-USB_Holder_Length/2+(i-1)*(2*Pencil_radius+MicroSD_gap),-11.4,USB_Holder_Height-MicroSD_depth/2])\n\t\t\t\t\trotate([30,0,0])\n\t\t\t\t\t\tcylinder(h=Pencil_depth, r=Pencil_radius, center=true, $fn=40);\n\t\t}\n\t\tif (USB_Extra == 4)\n\t\t{\n\t\t\ttranslate([0,-8.5,8])\n\t\t\t\trotate([0,90,0])\n\t\t\t\t\tcylinder(h=USB_Holder_Length-USB_gap, r=6.5, center=true, $fn=60);\n\t\t}\n\t\tif ((USB_Extra == 8)  && (Sign_TYPE == -1))\n\t\t{\n\t\t\ttranslate([0,-11,10])\n\t\t\t\trotate([45,0,0])\n\t\t\t\t\twrite(Sign_TEXT,t=2,h=Sign_HEIGHT,center=true,font=Sign_FONT_dxf);\n\t\t}\n\t}\n\tif ((USB_Extra == 8)  && (Sign_TYPE == 1))\n\t{\n\t\ttranslate([0,-11,10])\n\t\t\trotate([45,0,0])\n\t\t\t\twrite(Sign_TEXT,t=2,h=Sign_HEIGHT,center=true,font=Sign_FONT_dxf);\n\t}\n\ttranslate([0,-3.2,14.21]) {\n\t\trotate([0,90,0]) {\n\t\t\tdifference() {\n\t\t\t\tcylinder(h=USB_Holder_Length, r=3.8, center=true, $fn=60);\n\t\t\t\ttranslate([0,5/2,0])\n\t\t\t\t\tcube([10,5,USB_Holder_Length+1], true);\n\t\t\t}\n\t\t}\n\t}\n}\nSD_width = 2.64;\nSD_length = 26.15;\nSD_depth = 15;\nSD_Holder_Height = 18;\nSD_Holder_Width = 32;\nSD_Holder_Length = SD_gap+SD_cards*(SD_width + SD_gap)+SD_gap/2;\nmodule SD() {\n\tdifference() {\n\t\trotate([0,90,0]) {\n\t\t\troundedBox([SD_Holder_Height*2,SD_Holder_Width,SD_Holder_Length],3,true,$fn=60);\n\t\t}\n\t\tfor (i=[1:SD_cards])\n\t\t\ttranslate([SD_gap+1.5-SD_Holder_Length/2+(i-1)*(SD_width+SD_gap),0,SD_Holder_Height-SD_depth/2])\n\t\t\t\tcube([SD_width,SD_length,SD_depth+1], true);\n\t}\n}\ntabHeight = 8;\ntabSeperation = 16;\ntabLeft = 2.44;\ntabRight = 4.44;\ntabWidth = 2;\ntabX = tabWidth/2;\ntabYa = tabLeft/2;\ntabYb = tabRight/2;\npos_OK = (Device_Type == 3) || ((Device_Type == 2) && (Device_Order ==  1)) || ((Device_Type == 1) && (Device_Order == -1));\nneg_OK = (Device_Type == 3) || ((Device_Type == 2) && (Device_Order == -1)) || ((Device_Type == 1) && (Device_Order ==  1));\nmodule TAB(x,y) {\n\ttranslate([x,y,slotHeight/2])\n\t\tlinear_extrude(height = tabHeight, center = true, convexity = 10, twist = 0)\n\t\t\tpolygon(points=[[-tabX,-tabYa],[-tabX,tabYa],[tabX,tabYb],[tabX,-tabYb]], paths=[[0,1,2,3]]);\n}\nmodule TABS(d) {\n\tif (Connector_Type == 4)\n\t{\n\t\tif (pos_OK)\n\t\t{\n\t\t\ttranslate([0,SD_Holder_Width/2+slotX-.001,0])\n\t\t\t\trotate([0,0,90])\n\t\t\t\t\tTAB(0,tabSeperation/2);\n\t\t}\n\t\tif (neg_OK)\n\t\t{\n\t\t\ttranslate([0,SD_Holder_Width/2+slotX-.001,0])\n\t\t\t\trotate([0,0,90])\n\t\t\t\t\tTAB(0,-tabSeperation/2);\n\t\t}\n\t}\n\telse if ((Connector_Type == 1) || (Connector_Type == 3))\n\t{\n\t\tif (!neg_OK)\n\t\t{\n\t\t\tTAB(slotX-.001,tabSeperation/2);\n\t\t\tTAB(slotX-.001,-tabSeperation/2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTAB(d+slotX-.001,tabSeperation/2);\n\t\t\tTAB(d+slotX-.001,-tabSeperation/2);\n\t\t}\n\t}\n}\nslotHeight = tabHeight;\nslotSeperation = tabSeperation;\nslotLeft = 3;\nslotRight = 5;\nslotWidth = 2;\nslotX = slotWidth/2;\nslotYa = slotLeft/2;\nslotYb = slotRight/2;\nmodule SLOT(x,y) {\n\ttranslate([x,y,slotHeight/2])\n\t\tlinear_extrude(height = slotHeight, center = true, convexity = 10, twist = 0)\n\t\t\tpolygon(points=[[-slotX,-slotYa],[-slotX,slotYa],[slotX,slotYb],[slotX,-slotYb]], paths=[[0,1,2,3]]);\n}\nmodule SLOTS(d) {\n\tif (Connector_Type == 8)\n\t{\n\t\tif (neg_OK)\n\t\t{\n\t\t\ttranslate([0,SD_Holder_Width/2-slotX+.001,0])\n\t\t\t\trotate([0,0,-90])\n\t\t\t\t\tSLOT(0,tabSeperation/2);\n\t\t}\n\t\tif (pos_OK)\n\t\t{\n\t\t\ttranslate([0,SD_Holder_Width/2-slotX+.001,0])\n\t\t\t\trotate([0,0,-90])\n\t\t\t\t\tSLOT(0,-tabSeperation/2);\n\t\t}\n\t}\n\telse if ((Connector_Type == 2) || (Connector_Type == 3))\n\t{\n\t\tif (pos_OK)\n\t\t{\n\t\t\tSLOT(d+slotX-.001,tabSeperation/2);\n\t\t\tSLOT(d+slotX-.001,-tabSeperation/2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSLOT(slotX-.001,tabSeperation/2);\n\t\t\tSLOT(slotX-.001,-tabSeperation/2);\n\t\t}\n\t}\n}\nmodule CONNECTORS(cType) {\n\tif (cType > 0)\n\t{\n\t\tif (Connector_Type == 4)\n\t\t\tTABS(USB_Holder_Width);\n\t\telse if (Device_Order > 0)\n\t\t\tTABS(USB_Holder_Length);\n\t\telse\n\t\t\tTABS(SD_Holder_Length);\n\t}\n\telse\n\t{\n\t\tif (Connector_Type == 5)\n\t\t\tSLOTS(USB_Holder_Width);\n\t\telse if (Device_Order > 0)\n\t\t\tSLOTS(-SD_Holder_Length);\n\t\telse\n\t\t\tSLOTS(-USB_Holder_Length);\n\t}\n}\nHOLDER();",
    "description": "Okay, I'd like to request a parametric OpenSCAD design for a storage holder, similar to the \"UsbStickSdCardHolderV2.scad\" I found. I'm looking for something that can hold USB sticks, SD cards, and optionally, other things like micro SD cards, pencils, or even a small tray. The key is that I want it to be highly customizable.\n\nHere's a breakdown of what I'm looking for:\n\n**General Layout & Device Types:**\n\n*   The holder should be able to be configured to hold USB sticks, SD cards, or both. I'd like a parameter that lets me select which type of storage to support, with an option for both.\n*   When both USB and SD are selected, I need a parameter to control the order they appear in the holder (either SD-USB or USB-SD).\n*   There needs to be an \"extra\" area in the design that can be customized.\n\n**Customizable \"Extra\" Area:**\n   *   I'd like a parameter to control what goes in the \"extra\" area. Options should be:\n        *   None\n        *   Micro SD card slots\n        *   Pencil holes\n        *   A small tray\n        *   Text sign\n\n   *   If I select text, I want to be able to:\n        *   Specify the font (ideally, a selection from a list similar to the \"write\" module fonts. Assume that a library with write fonts similar to the included Write.scad is available.)\n        *   Specify the text itself\n        *   Specify the text's height\n        *   Choose if the sign is embossed or raised\n\n**USB Stick Configuration:**\n    *   I need a parameter for the number of USB sticks the holder should accommodate.\n    *   I need a parameter to control the gap between USB sticks.\n\n**SD Card Configuration:**\n    *   I need a parameter for the number of SD cards the holder should accommodate.\n    *   I need a parameter to control the gap between SD cards.\n\n**Micro SD Card Configuration:** (If selected as \"extra\")\n    *   I need a parameter to control the gap between Micro SD card slots.\n\n**Pencil Hole Configuration:** (If selected as \"extra\")\n    *   I need a parameter for the radius of the pencil holes.\n    *   I need a parameter for the gap between the pencil holes.\n\n**Connectors:**\n   *   I'd like to add connectors that allow the holder to be attached to other objects. These should be configurable with a parameter\n        *   None\n        *   Tabs on the right\n        *   Slots on the left\n        *   Slots on the left and Tabs on the right\n        *   Tabs on the back\n        *   Slots on the back\n\n**Build Plate Dimensions:**\n*   I want to include the `build_plate()` from the utils library to visualize the build plate size. I want a parameter to choose one of a few preset build plates, with an option for manual size setting. The presets should be \"Replicator 2\", \"Replicator\", \"Thingomatic\".\n*   If \"manual\" is chosen as a build plate selector, I want to configure two parameters to manually specify the X and Y dimensions of the plate.\n\n**Libraries:**\n*   I'd like this to use the `MCAD` library for the `boxes.scad` module, the `utils` library for the `build_plate.scad` module, and some \"write\" library with similar functionality to the included `Write.scad`, specifically for the fonts available.\n\nThe goal is to generate a single, parametric .scad file that can be customized as I described. I am not interested in a solution that is simply a conversion of the attached file without the requested customizations. Please let me know if any of this is unclear or if you need more information.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Preassembled Secret Heart Box",
    "scad": "assembly();\nword1=\"\";\nword2=\"\";\nfontsize=6;\nFont = \"write/Letters.dxf\";\nL=40;\nW=35;\nH=25;\nx_hinge=23;\nT=0.8;\nnub=2;\ntol=0.4;\nquality=1;\nuse <utils/build_plate.scad>\nuse <write/Write.scad>\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\n$fa=12/quality;\n$fs=2/quality;\nphi=atan(W/L);\nR=H/2-2*nub-3*T;\nR1=H/2-2*nub;\nt1=1-2*abs($t-0.5);\nmodule animation()\nassign(phi= t1<0.5 ? 0 : (t1-0.5)*2*90,psi= t1<0.5 ? (t1-0.5)*2*180 : 0){\n\tLowerLeft();\n\ttranslate([0,R1*sqrt(2)+H/2+nub,-H/2+nub])rotate([-phi,0,0])\n\t\ttranslate(-[0,R1*sqrt(2)+H/2+nub,-H/2+nub])UpperLeft();\n\trotate([psi,0,0]){\n\t\ttranslate([0,R1*sqrt(2)+H/2+nub,-H/2+nub])rotate([-phi,0,0])\n\t\t\ttranslate(-[0,R1*sqrt(2)+H/2+nub,-H/2+nub])UpperRight();\n\t\tLowerRight();\n\t}\n}\nmodule assembly()\ntranslate([0,0,H/2]){\n\tLowerLeft();\n\tUpperLeft();\n\tLowerRight();\n\tUpperRight();\n}\nmodule UpperLeft()\nrender()\nunion(){\n\tdifference(){\n\t\tcleave(lower=false)Left();\n\t\ttranslate([-3/2*tol-nub-T,0,0])hingeGap();\n\t\ttranslate([-x_hinge,0,0])mirror([1,0,0])hingeGap();\n\t}\n\ttranslate([-L/2*sin(phi),L/2*cos(phi),H/2+0.49])write(word1,t=1,h=fontsize,center=true,font=Font);\n}\nmodule LowerLeft()\nrender()\nunion(){\n\tcleave(lower=true)Left();\n\tdifference(){\n\t\tclasp(inside=1);\n\t\ttranslate([0,0,-R+T])rotate([0,-45,0])translate([0,0,-H])cube(2*H,center=true);\n\t}\n\ttranslate([-3/2*tol-nub-T,0,0])hinge();\n\ttranslate([-x_hinge,0,0])mirror([1,0,0])hinge();\n\tbrace();\n}\nmodule UpperRight()\nrender()\nunion(){\n\tdifference(){\n\t\tcleave(lower=false)Right();\n\t\ttranslate([3/2*tol+nub+T,0,0])mirror([1,0,0])hingeGap();\n\t\ttranslate([x_hinge,0,0])hingeGap();\n\t\tclasp(inside=0);\n\t}\n\ttranslate([L/2*sin(phi),L/2*cos(phi),H/2+0.49])write(word2,t=1,h=fontsize,center=true,font=Font);\n}\nmodule LowerRight()\nrender()\ndifference(){\n\tunion(){\n\t\tcleave(lower=true)Right();\n\t\ttranslate([nub+T,0,T+0.5-H/2])translate([6,5,0])monogram(h=1.01);\n\t\ttranslate([3/2*tol+nub+T,0,0])mirror([1,0,0])hinge();\n\t\ttranslate([x_hinge,0,0])hinge();\n\t\tmirror([1,0,0])brace();\n\t}\n\ttranslate([nub+T+tol/2,0,0])rotate([0,90,0])cylinder(r=R+nub+T,h=tol);\n\tclasp(inside=0);\n}\nmodule brace()\nintersection(){\n\trotate([45,0,0])translate([0,R1,0])difference(){\n\t\tcylinder(r=nub+2*T+tol*3/2,h=3*H,center=true);\n\t\ttranslate([L-nub-T,0,0])cube(2*L,center=true);\n\t\ttranslate([L-nub-T-tol*3/2,L,0])cube(2*L,center=true);\n\t}\n\tdifference(){\n\t\ttranslate([0,0,0])cube([L,2*(R1*sqrt(2)+H/2+nub),H-T],center=true);\n\t\tdifference(){\n\t\t\ttranslate([0,0,L+H/2-2*T])cube(2*L,center=true);\n\t\t\trotate([-45,0,0])cube([2*L,2*L,2*R1],center=true);\n\t\t}\n\t}\n}\nmodule cleave(lower=true)\nassign(y = lower==true ? L+R1 : -L+R1+tol)\ndifference(){\n\tchild(0);\n\trotate([45,0,0])translate([0,y,0])cube(2*L,center=true);\n}\nmodule Right()\ndifference(){\n\tunion(){\n\t\tmirror([1,0,0])hollowbase();\n\t\trotate([-45,0,0])translate([tol/2+.01,0,H/2-nub])point();\n\t}\n\trotate([45,0,0])rotate([0,90,0])track();\n}\nmodule Left()\ndifference(){\n\tunion(){\n\t\thollowbase();\n\t\trotate([-45,0,0])translate([-tol/2-.01,0,H/2-nub])rotate([0,180,0])point();\n\t}\n\trotate([45,0,0])rotate([0,-90,0])track();\n}\nmodule clasp(inside=0)\nrotate([0,90,0])translate([0,0,-tol/2-.01])\n\tcylinder(r1=R-tol-tol*inside,r2=R+nub+T-tol*inside,h=nub+T+tol+.02);\nmodule point()\nrotate([0,-90,0])cylinder(r1=nub,r2=0,h=nub);\nmodule track()\nunion(){\n\tdifference(){\n\t\tunion(){\n\t\t\trotate_extrude()translate([H/2-nub,-tol/2])rotate(45)square(nub*sqrt(2),center=true);\n\t\t\ttranslate(-[0,nub-H/2,0])cylinder(r1=nub,r2=0,h=nub);\n\t\t}\n\t\ttranslate([H+tol/2,0,0])cube(2*H,center=true);\n\t}\n\ttranslate([0,nub-H/2,0])cylinder(r1=nub,r2=0,h=nub);\n}\nmodule hollowbase()\ndifference(){\n\tbase(inside=0);\n\tdifference(){\n\t\tbase(inside=1);\n\t\ttranslate([-nub-T,0,0])hinge();\n\t\ttranslate([-L-x_hinge,R1*sqrt(2)+H/2,-H/2])cube([L,2*nub,nub]);\n\t\ttranslate([-L-x_hinge,R1*sqrt(2)+H/2+nub,-H/2+nub])\n\t\t\trotate([0,90,0])cylinder(r=nub,h=L);\n\t}\n}\nmodule hinge()\ntranslate([-nub/2,R1*sqrt(2)+H/2,-H/2+nub])\ndifference(){\n\tunion(){\n\t\ttranslate([0,-2*nub,0])cube([nub,6*nub,2*nub],center=true);\n\t\ttranslate([0,nub,0])rotate([0,90,0])cylinder(r=nub,h=nub,center=true);\n\t\ttranslate([nub/2-.01,nub,0])rotate([0,90,0])cylinder(r1=nub,r2=0,h=nub);\n\t}\n\ttranslate([0,-6*nub,2*nub])rotate([45,0,0])cube(6*nub,center=true);\n}\nmodule hingeGap()\ntranslate([-nub/2,R1*sqrt(2)+H/2,-H/2+nub])\nunion(){\n\ttranslate([0,tol-nub,0])cube([nub+2*tol,6*nub,2*nub+2*tol],center=true);\n\ttranslate([nub/2+tol-.01,nub,0])rotate([0,90,0])cylinder(r1=nub,r2=0,h=nub);\n}\nmodule base(inside=0)\nassign(W=W-2*T*inside)\nintersection(){\n\trotate([0,0,90+phi])union(){\n\t\tcube([L,W,2*H],center=true);\n\t\ttranslate([L/2,0,0])cylinder(r=W/2,h=2*H,center=true);\n\t\ttranslate([0,W/2-H/2,0])rotate([0,90,0])cylinder(r=H/sqrt(2),h=L,center=true);\n\t\tfor(i=[-1,1])translate([i*L/2,0,0])\n\t\t\trotate_extrude(convexity=2)difference(){\n\t\t\t\ttranslate([W/2-H/2,0])circle(r=H/sqrt(2));\n\t\t\t\ttranslate([-H,0])square(2*H,center=true);\n\t\t\t}\n\t}\n\ttranslate([-L-(nub+T)*inside-tol/2,0,0])cube([2*L,2*L,H-2*T*inside],center=true);\n}\nmodule monogram(h=1)\nlinear_extrude(height=h,center=true)\ntranslate(-[3,2.5])union(){\n\tdifference(){\n\t\tsquare([4,5]);\n\t\ttranslate([1,1])square([2,3]);\n\t}\n\tsquare([6,1]);\n\ttranslate([0,2])square([2,1]);\n}",
    "description": "Okay, I'm looking to create a customized version of a 3D-printable heart-shaped box with a locking mechanism, similar to the one described here. It seems like a complex design, but I'd like to be able to control its dimensions and add custom text.\n\nSpecifically, I want a parametric OpenSCAD design that allows me to:\n\n1.  **Set the Words:**  I need to be able to specify two different text strings that will be printed on the top faces of the heart halves.\n2.  **Font Choice:** The code should allow me to choose a font from a DXF file. The existing design uses \"write/Letters.dxf\", \"write/orbitron.dxf\", and \"write/BlackRose.dxf\" as examples, so I'd like to use the same approach.\n3.  **Word Height:** I need a parameter to control the height of the letters in the words.\n4.  **Midsection Length:** I want to specify the length of the straight, parallel section in the middle of the heart (parameter \"L\").\n5.  **Flat Face Width:** I want to set the width of the flat faces of the heart (parameter \"W\").\n6.  **Box Height:** I need to control the overall height of the box (parameter \"H\").\n7.  **Hinge Spacing:** I want to control the distance between the hinges (parameter \"x_hinge\").\n8.  **Wall Thickness:** I need a parameter to set the wall thickness of the box (parameter \"T\").\n9.  **Nub Depth:** I want to set the depth of the sliding nubs used in the locking mechanism (parameter \"nub\").\n10. **Tolerance:** I need a tolerance parameter for moving parts, to avoid binding and ensure a smooth opening (parameter \"tol\").\n11. **Render Quality:** I'd like to be able to control the rendering quality, potentially with some speed-vs-quality parameter (parameter \"quality\", with 1 being Draft, 2 being Medium, and 4 being Fine, as mentioned).\n12. **Animation (Optional):** If possible, it would be nice to have a built-in animation option that could show the box opening and closing.\n\nThe design makes use of the `build_plate.scad` and `write/Write.scad` library files, so please keep that in mind when creating the new code. I want to be able to specify different build plates (Replicator 2, Replicator, Thingomatic, or Manual) as well as the manual dimensions if the manual build plate is selected. The base code seems to have variables `build_plate_selector`, `build_plate_manual_x` and `build_plate_manual_y` to control this, so please include that functionality.\n\nBasically, I'd like a fully parametric version of this heart box that I can easily customize with my own words and dimensions. I want to be able to print it fully assembled.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Wrench",
    "scad": "include <MCAD/shapes.scad>\ninclude <write/Write.scad>\nmessage = \"ROB`s 10mm\";\nFont = \"write/Letters.dxf\";\nNut_Size = 10;\nTool_Height = 5;\nTool_Length = 10;\nkerf = 0.4 + 0;\nD = Nut_Size + kerf;\nM = D/2;\nH = Tool_Height;\nLtot = D * Tool_Length;\nText_Height = Nut_Size*0.8 ;\nL = Ltot-2*(D/2+M);\nrotate([0, 0, -45])\ndifference() {\n\tunion() {\n\t\ttranslate([0,L/2,H/2]) {\n\t\t\tcylinder(r = (D/2+M), h = H,center = true);\n\t\t}\n\t\ttranslate([0,-L/2,H/2]) {\n\t\t\tcylinder(r = (D/2+M), h = H,center = true);\n\t\t}\n\t\ttranslate([-1*D/2,-L/2,0]) {\n\t\t\tcube([D,L,H], center=false);\n\t\t}\n\t}\n\ttranslate([0,-L/2 - D / 4,H/2 - 0.5]) {\n\t\trotate([0,0,30]) {\n\t\t\thexagon(D, H + 2);\n\t\t}\n\t}\n\ttranslate([0,-L/2 - D - D / 4,H/2 - 0.5]) {\n\t\tcube([D,2*D,H + 2], center = true);\n\t}\n\ttranslate([0,L/2,H/2 - 0.5]) {\n\t\trotate([0,0,30]) {\n\t\t\thexagon(D, H + 2);\n\t\t}\n\t}\n\ttranslate([0, 0, H - .1]){\n\t\trotate([0,0,90]) {\n\t\twrite(message,t=.5,h=Text_Height,center=true,font=Font);\n\t\t}\n\t}\n}",
    "description": "Okay, I'd like to create a customizable wrench, and I'd like an OpenSCAD file that lets me easily adjust the key parameters. I have a basic design in mind that I'll describe, but I need it to be parametric so I can change the dimensions and the text on the wrench.\n\nThe wrench design is essentially a modified dogbone shape, composed of three main parts: two cylinders at either end connected by a rectangular prism. I'll need to specify the nut size this wrench will fit, which will define the diameter of the wrench's jaws.\n\nSpecifically, the design should allow for these things to be changed:\n*   **Nut Size:** The wrench will be designed to fit a specific nut size. This should directly affect the opening size of the wrench as well as the size of the jaws.\n*   **Tool Height:** This is the thickness of the wrench itself.\n*   **Tool Length Adjust:** A multiplier to adjust how long the overall length is. It should adjust the length of the rectangular section of the wrench, effectively spacing the jaws further apart\n*   **Message:** The text engraved on the wrench.\n*   **Font:** Which font to use for the engraving.\n\nHere's the breakdown of how it should work and some of the design specifics I want:\n\n1.  **Basic Shape:**\n    *   Two cylinders will form the wrench's jaws, positioned at either end of a central rectangular prism.\n    *   The cylinders should have a diameter slightly larger than the specified nut size, with a configurable margin that I will define (kerf). The cylinders should be centered on the length of the wrench.\n    *   The rectangular prism connects these cylinders, effectively forming the \"handle\" of the wrench and the body of the dogbone.\n2.  **Wrench Jaw Cutout:**\n    *   Each jaw will have a hexagon cut out from it which fits the nut. The hexagon needs to be sized using the nut size defined earlier, and have a margin.\n    *   There should be an additional clearance cut, also based on the nut size that is used to clear the base of the nut..\n3.  **Engraving:**\n    *   The specified text should be engraved onto the body of the wrench.\n    *   I should be able to select the font from a list of available .dxf fonts (such as the ones found in the `write/` directory of the MCAD library).\n    *   The text should be centered on the rectangular prism section, and the height of the text should be scaled using a multiplier that is dependent on the nut size. The text should not be flush with the surface of the part and should be set below by a reasonable amount.\n4.  **Libraries:**\n    *   I will need the `shapes.scad` and `Write.scad` files from the `MCAD` library in OpenSCAD to create the basic shapes and do the text engraving. I do not need the files included, just that the code will use them.\n\nSo, to summarize, I need a parametric OpenSCAD file that allows me to customize the wrench dimensions, text, and font. The design should include two cylinders connected by a rectangular prism, with hexagonal cutouts to fit the nut, and engraved text on the body. I need to use the `shapes.scad` and `Write.scad` files in the MCAD library for this.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Greeble",
    "scad": "SizeX=100;\nSizeY=100;\nSizeZ=100;\nGreebleSize=50;\nNumberOfGreebles=200;\nRandom=rands(0,1,NumberOfGreebles+10);\nunion() {\nfor (i = [0:NumberOfGreebles])\n{\ntranslate([(Random[i]-0.5)*SizeX,(Random[i+1]-0.5)*SizeY,(Random[i+3]-0.5)*SizeZ]) cube([Random[i+4]*GreebleSize,Random[i+5]*GreebleSize,Random[i+6]*GreebleSize],center = true);\n}\n}",
    "description": "Okay, I'm trying to make some cool greebles, like sci-fi cityscapes or detailed spaceship hulls, and I've got a basic OpenSCAD script that generates a bunch of random cubes. It works, but it's really basic, and I'd love something much more flexible and interesting.\n\nHere's what I'm hoping for:\n\n**Core Idea:** I want to generate a bunch of randomly placed and sized geometric shapes within a defined volume. Instead of just cubes, I want to be able to choose from a variety of primitive shapes and combine them randomly.\n\n**Specific Parameters I'd Like to Control:**\n\n*   **Overall Volume:** I need to set the overall size of the volume where the greebles are generated. Let's say parameters for `VolumeX`, `VolumeY`, and `VolumeZ`.\n*   **Greeble Shape Selection:** Instead of just cubes, I want to be able to choose from a variety of basic shapes, things like cubes, spheres, cylinders, and maybe even a simple cone. Maybe even have the ability to specify how frequently each shape is used, like a weight or probability.\n*   **Greeble Size:** I want to set a maximum greeble size. Let's call it `MaxGreebleSize`. The actual size of each individual greeble would be some random fraction of that maximum size. I'd also like some control over whether the sizing is uniform across dimensions (like a cube) or whether each dimension can be scaled independently.\n*   **Number of Greebles:** I want to be able to set the number of greebles to generate - `NumberOfGreebles`.\n*   **Seed Value:** It would be *great* if I could set a seed value for the random number generator so I could get reproducible results.\n*   **Positioning:** I'd like the greebles to be randomly positioned within the defined volume. I'm happy with the center point of each greeble being within the volume, so they can potentially extend beyond it slightly depending on their individual size.\n*   **Shape Randomization Options:** For each shape, I'd like some degree of random variation beyond just size. For example, cylinders could have random height/radius ratios, spheres could be slightly scaled differently on each axis, or a cube could be elongated or compressed on one axis.\n\n**Output:** The final output should be a single OpenSCAD `union()` of all the generated greebles.\n\n**Libraries:**\n\nI'm not using any specific libraries right now, but Im open to using them if it simplifies things. I know that BOSL or BOSL2 might have some useful functions. I'm especially interested in BOSL2 if it has functions to generate random parameters that are easy to use.\n\n**Example starting code for reference:**\n\n```openscad\nSizeX=100;\nSizeY=100;\nSizeZ=100;\nGreebleSize=50;\nNumberOfGreebles=200;\n\nRandom=rands(0,1,NumberOfGreebles+10);\n\n\nunion() {\nfor (i = [0:NumberOfGreebles])\n{\ntranslate([(Random[i]-0.5)*SizeX,(Random[i+1]-0.5)*SizeY,(Random[i+3]-0.5)*SizeZ]) cube([Random[i+4]*GreebleSize,Random[i+5]*GreebleSize,Random[i+6]*GreebleSize],center = true);\n}\n}\n```\n\nBasically, I want a tool that can create much more interesting and varied greebles than I can now with this really basic script. Please, can you generate a parametric OpenSCAD file that implements all of these requirements?\n"
  },
  {
    "object": "Hey cadmonkey, make me a WALLY - Wall Plate Customizer",
    "scad": "plate_width = 1;\nplate_size = 0;\n1st_plate = \"none\";\n1st_plate_bottom_hole = \"none\";\n2nd_plate = \"none\";\n2nd_plate_bottom_hole = \"none\";\n3rd_plate = \"none\";\n3rd_plate_bottom_hole = \"none\";\n4th_plate = \"none\";\n4th_plate_bottom_hole = \"none\";\n5th_plate = \"none\";\n5th_plate_bottom_hole = \"none\";\nmodule GoAwayCustomizer() {\n}\nl_offset = [34.925,39.6875,44.45];\nr_offset = [34.925,39.6875,44.45];\nspacer = [0,0,46.0375,92.075,138.1125,184.15];\nsolid_plate_width = l_offset[plate_size] + spacer[plate_width] + r_offset[plate_size];\nheight_sizes = [114.3,123.825,133.35];\nheight = 114.3;\ngang_width=[0,69.86,115.824,161.925,206.375,254];\nedgewidth = solid_plate_width + 10;\nrightbevel = solid_plate_width - 4;\nleft_offset = 34.925;\nswitch_offset = 46.0375;\nthinner_offset=[0,0.92,0.95,0.96,0.97,0.973];\npositions=[height_sizes[plate_size]/2,height_sizes[plate_size]/2 - 14.25,height_sizes[plate_size]/2 + 14.25];\nmodule plate1(){\n\tif (1st_plate == \"toggle\" || 1st_plate_bottom_hole == \"toggle\"){\n\t\ttranslate([0,l_offset[plate_size],0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size],0]) hole(\"toggle\");\n\t\t}\n\telse if (1st_plate == \"long_toggle\" || 1st_plate_bottom_hole == \"long_toggle\"){\n\t\ttranslate([0,l_offset[plate_size],0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size],0]) hole(\"long_toggle\");\n\t\t}\n\telse if (1st_plate == \"rocker\" || 1st_plate_bottom_hole == \"rocker\"){\n\t\ttranslate([0,l_offset[plate_size],0]) rocker_screws();\n\t\ttranslate([0,l_offset[plate_size],0]) hole(\"rocker\");\n\t\t}\n\telse if (1st_plate == \"outlet\" || 1st_plate_bottom_hole == \"outlet\") {\n\ttranslate([0,l_offset[plate_size],0]) hole(\"outlet\");\n\t}\n\telse if (1st_plate_bottom_hole == \"none\") {\n\t\ttranslate([0,l_offset[plate_size],0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size],0]) hole(1st_plate);\n\t\t\t}\n\telse if (1st_plate == \"none\") {\n\t\ttranslate([0,l_offset[plate_size],0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size],0]) hole(1st_plate_bottom_hole);\n\t\t\t}\n\telse {\n\ttranslate([0,l_offset[plate_size],0]) box_screws();\n\ttranslate([positions[1],l_offset[plate_size],0]) hole(1st_plate);\n\ttranslate([positions[2],l_offset[plate_size],0]) hole(1st_plate_bottom_hole);\n\t}\n}\nmodule plate2(){\n\tif (2nd_plate == \"toggle\" || 2nd_plate_bottom_hole == \"toggle\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset,0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset,0]) hole(\"toggle\");\n\t\t}\n\telse if (2nd_plate == \"long_toggle\" || 2nd_plate_bottom_hole == \"long_toggle\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset,0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset,0]) hole(\"long_toggle\");\n\t\t}\n\telse if (2nd_plate == \"rocker\" || 2nd_plate_bottom_hole == \"rocker\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset,0]) rocker_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset,0]) hole(\"rocker\");\n\t\t}\n\telse if (2nd_plate == \"outlet\" || 2nd_plate_bottom_hole == \"outlet\") {\n\ttranslate([0,l_offset[plate_size] + switch_offset,0]) hole(\"outlet\");\n\t}\n\telse if (2nd_plate_bottom_hole == \"none\") {\n\t\ttranslate([0,l_offset[plate_size] + switch_offset,0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size] + switch_offset,0]) hole(2nd_plate);\n\t\t\t}\n\telse if (2nd_plate == \"none\") {\n\t\ttranslate([0,l_offset[plate_size] + switch_offset,0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size] + switch_offset,0]) hole(2nd_plate_bottom_hole);\n\t\t\t}\n\telse {\n\ttranslate([0,l_offset[plate_size] + switch_offset,0]) box_screws();\n\ttranslate([positions[1],l_offset[plate_size] + switch_offset,0]) hole(2nd_plate);\n\ttranslate([positions[2],l_offset[plate_size] + switch_offset,0]) hole(2nd_plate_bottom_hole);\n\t}\n}\nmodule plate3(){\n\tif (3rd_plate == \"toggle\" || 3rd_plate_bottom_hole == \"toggle\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) hole(\"toggle\");\n\t\t}\n\telse if (3rd_plate == \"long_toggle\" || 3rd_plate_bottom_hole == \"long_toggle\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) hole(\"long_toggle\");\n\t\t}\n\telse if (3rd_plate == \"rocker\" || 3rd_plate_bottom_hole == \"rocker\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) rocker_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) hole(\"rocker\");\n\t\t}\n\telse if (3rd_plate == \"outlet\" || 3rd_plate_bottom_hole == \"outlet\") {\n\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) hole(\"outlet\");\n\t}\n\telse if (3rd_plate_bottom_hole == \"none\") {\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size] + switch_offset * 2,0]) hole(3rd_plate);\n\t\t\t}\n\telse if (3rd_plate == \"none\") {\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size] + switch_offset * 2,0]) hole(3rd_plate_bottom_hole);\n\t\t\t}\n\telse {\n\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) box_screws();\n\ttranslate([positions[1],l_offset[plate_size] + switch_offset * 2,0]) hole(3rd_plate);\n\ttranslate([positions[2],l_offset[plate_size] + switch_offset * 2,0]) hole(3rd_plate_bottom_hole);\n\t}\n}\nmodule plate4(){\n\tif (4th_plate == \"toggle\" || 4th_plate_bottom_hole == \"toggle\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) hole(\"toggle\");\n\t\t}\n\telse if (4th_plate == \"long_toggle\" || 4th_plate_bottom_hole == \"long_toggle\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) hole(\"long_toggle\");\n\t\t}\n\telse if (4th_plate == \"rocker\" || 4th_plate_bottom_hole == \"rocker\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) rocker_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) hole(\"rocker\");\n\t\t}\n\telse if (4th_plate == \"outlet\" || 4th_plate_bottom_hole == \"outlet\") {\n\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) hole(\"outlet\");\n\t}\n\telse if (4th_plate_bottom_hole == \"none\") {\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size] + switch_offset * 3,0]) hole(4th_plate);\n\t\t\t}\n\telse if (4th_plate == \"none\") {\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size] + switch_offset * 3,0]) hole(4th_plate_bottom_hole);\n\t\t\t}\n\telse {\n\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) box_screws();\n\ttranslate([positions[1],l_offset[plate_size] + switch_offset * 3,0]) hole(4th_plate);\n\ttranslate([positions[2],l_offset[plate_size] + switch_offset * 3,0]) hole(4th_plate_bottom_hole);\n\t}\n}\nmodule plate5(){\n\tif (5th_plate == \"toggle\" || 5th_plate_bottom_hole == \"toggle\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) hole(\"toggle\");\n\t\t}\n\telse if (5th_plate == \"long_toggle\" || 5th_plate_bottom_hole == \"long_toggle\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) hole(\"long_toggle\");\n\t\t}\n\telse if (5th_plate == \"rocker\" || 5th_plate_bottom_hole == \"rocker\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) rocker_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) hole(\"rocker\");\n\t\t}\n\telse if (5th_plate == \"outlet\" || 5th_plate_bottom_hole == \"outlet\") {\n\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) hole(\"outlet\");\n\t}\n\telse if (5th_plate_bottom_hole == \"none\") {\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size] + switch_offset * 4,0]) hole(5th_plate);\n\t\t\t}\n\telse if (5th_plate == \"none\") {\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size] + switch_offset * 4,0]) hole(5th_plate_bottom_hole);\n\t\t\t}\n\telse {\n\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) box_screws();\n\ttranslate([positions[1],l_offset[plate_size] + switch_offset * 4,0]) hole(5th_plate);\n\ttranslate([positions[2],l_offset[plate_size] + switch_offset * 4,0]) hole(5th_plate_bottom_hole);\n\t}\n}\nmodule plate1_solid(){\nif (1st_plate == \"keystone1\" && 1st_plate_bottom_hole == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (1st_plate == \"keystone1\" && 1st_plate_bottom_hole != \"outlet\" && 1st_plate_bottom_hole != \"toggle\" && 1st_plate_bottom_hole != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2,l_offset[plate_size] - 11.5,-3.9]) hole(\"keystone_solid\");\n\t}\nif (1st_plate_bottom_hole == \"keystone1\" && 1st_plate == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (1st_plate_bottom_hole == \"keystone1\" && 1st_plate != \"outlet\" && 1st_plate != \"toggle\" && 1st_plate != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2 + 28.5,l_offset[plate_size] - 11.5,-3.9]) hole(\"keystone_solid\");\n\t}\n}\nmodule plate2_solid(){\nif (2nd_plate == \"keystone1\" && 2nd_plate_bottom_hole == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5 + switch_offset,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (2nd_plate == \"keystone1\" && 2nd_plate_bottom_hole != \"outlet\" && 2nd_plate_bottom_hole != \"toggle\" && 2nd_plate_bottom_hole != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2,l_offset[plate_size] - 11.5 + switch_offset,-3.9]) hole(\"keystone_solid\");\n\t}\nif (2nd_plate_bottom_hole == \"keystone1\" && 2nd_plate == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5 + switch_offset,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (2nd_plate_bottom_hole == \"keystone1\" && 2nd_plate != \"outlet\" && 2nd_plate != \"toggle\" && 2nd_plate != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2 + 28.5,l_offset[plate_size] - 11.5 + switch_offset,-3.9]) hole(\"keystone_solid\");\n\t}\n}\nmodule plate3_solid(){\nif (3rd_plate == \"keystone1\" && 3rd_plate_bottom_hole == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5 + switch_offset * 2,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (3rd_plate == \"keystone1\" && 3rd_plate_bottom_hole != \"outlet\" && 3rd_plate_bottom_hole != \"toggle\" && 3rd_plate_bottom_hole != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2,l_offset[plate_size] - 11.5 + switch_offset * 2,-3.9]) hole(\"keystone_solid\");\n\t}\nif (3rd_plate_bottom_hole == \"keystone1\" && 3rd_plate == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5 + switch_offset * 2,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (3rd_plate_bottom_hole == \"keystone1\" && 3rd_plate != \"outlet\" && 3rd_plate != \"toggle\" && 3rd_plate != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2 + 28.5,l_offset[plate_size] - 11.5 + switch_offset * 2,-3.9]) hole(\"keystone_solid\");\n\t}\n}\nmodule plate4_solid(){\nif (4th_plate == \"keystone1\" && 4th_plate_bottom_hole == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5 + switch_offset * 3,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (4th_plate == \"keystone1\" && 4th_plate_bottom_hole != \"outlet\" && 4th_plate_bottom_hole != \"toggle\" && 4th_plate_bottom_hole != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2,l_offset[plate_size] - 11.5 + switch_offset * 3,-3.9]) hole(\"keystone_solid\");\n\t}\nif (4th_plate_bottom_hole == \"keystone1\" && 4th_plate == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5 + switch_offset * 3,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (4th_plate_bottom_hole == \"keystone1\" && 4th_plate != \"outlet\" && 4th_plate != \"toggle\" && 4th_plate != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2 + 28.5,l_offset[plate_size] - 11.5 + switch_offset * 3,-3.9]) hole(\"keystone_solid\");\n\t}\n}\nmodule plate5_solid(){\nif (5th_plate == \"keystone1\" && 5th_plate_bottom_hole == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5 + switch_offset * 4,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (5th_plate == \"keystone1\" && 5th_plate_bottom_hole != \"outlet\" && 5th_plate_bottom_hole != \"toggle\" && 5th_plate_bottom_hole != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2,l_offset[plate_size] - 11.5 + switch_offset * 4,-3.9]) hole(\"keystone_solid\");\n\t}\nif (5th_plate_bottom_hole == \"keystone1\" && 5th_plate == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5 + switch_offset * 4,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (5th_plate_bottom_hole == \"keystone1\" && 5th_plate != \"outlet\" && 5th_plate != \"toggle\" && 5th_plate != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2 + 28.5,l_offset[plate_size] - 11.5 + switch_offset * 4,-3.9]) hole(\"keystone_solid\");\n\t}\n}\nmodule plate() {\n\tdifference() {\n\t\tcube([height_sizes[plate_size],solid_plate_width,6]);\n\t\ttranslate([-4.3,-5,6.2]) rotate([0,45,0]) cube([6,edgewidth,6]);\n\t\ttranslate([height_sizes[plate_size]-4.2,-5,6.25]) rotate([0,45,0]) cube([6,edgewidth,6]);\n\t\ttranslate([height_sizes[plate_size]+10,-4.4,6.1]) rotate([0,45,90]) cube([6,height_sizes[plate_size]+20,6]);\n\t\ttranslate([height_sizes[plate_size]+10,rightbevel,6]) rotate([0,45,90]) cube([6,height_sizes[plate_size]+10,6]);\n\t\t\t\t}\n\t\t\t}\nmodule plate_inner() {\n\tscale([0.95,thinner_offset[plate_width],1]){\n\ttranslate([3,3,0]){\n\tdifference() {\n\t\tcube([height_sizes[plate_size],solid_plate_width,6]);\n\t\ttranslate([-4.3,-5,6.2]) rotate([0,45,0]) cube([6,edgewidth,6]);\n\t\ttranslate([height_sizes[plate_size]-4.2,-5,6.25]) rotate([0,45,0]) cube([6,edgewidth,6]);\n\t\ttranslate([height_sizes[plate_size]+10,-4.4,6.1]) rotate([0,45,90]) cube([6,height_sizes[plate_size]+20,6]);\n\t\ttranslate([height_sizes[plate_size]+10,rightbevel,6]) rotate([0,45,90]) cube([6,height_sizes[plate_size]+10,6]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nmodule box_screws(){\n\t translate([height_sizes[plate_size]/2 + 41.67125,0,-1]) cylinder(r=2, h=10, $fn=12);\n\t translate([height_sizes[plate_size]/2 + 41.67125,0,3.5]) cylinder(r1=2, r2=3.3, h=3);\n\t translate([height_sizes[plate_size]/2 - 41.67125,0,-1]) cylinder(r=2, h=10, $fn=12);\n\t translate([height_sizes[plate_size]/2 - 41.67125,0,3.5]) cylinder(r1=2, r2=3.3, h=3);\n}\nmodule rocker_screws(){\n\t translate([height_sizes[plate_size]/2 + 48.41875,0,-1]) cylinder(r=2, h=10, $fn=12);\n\t translate([height_sizes[plate_size]/2 + 48.41875,0,3.5]) cylinder(r1=2, r2=3.3, h=3);\n\t translate([height_sizes[plate_size]/2 - 48.41875,0,-1]) cylinder(r=2, h=10, $fn=12);\n\t translate([height_sizes[plate_size]/2 - 48.41875,0,3.5]) cylinder(r1=2, r2=3.3, h=3);\n}\nmodule toggle_screws(){\n\t translate([height_sizes[plate_size]/2 + 30.1625,0,-1]) cylinder(r=2, h=10, $fn=12);\n\t translate([height_sizes[plate_size]/2 + 30.1625,0,3.5]) cylinder(r1=2, r2=3.3, h=3);\n\t translate([height_sizes[plate_size]/2 - 30.1625,0,-1]) cylinder(r=2, h=10, $fn=12);\n\t translate([height_sizes[plate_size]/2 - 30.1625,0,3.5]) cylinder(r1=2, r2=3.3, h=3);\n}\nmodule hole(hole_type) {\n\tif (hole_type == \"toggle\") {\n\t\ttranslate([height_sizes[plate_size]/2,0,0]) cube([23.8125,10.3188,15], center = true);\n\t\t \t\t\t\t\t\t}\n\tif (hole_type == \"long_toggle\") {\n\t\ttranslate([height_sizes[plate_size]/2,0,0]) cube([43.6563,11.9063,15], center = true);\n\t\t \t\t\t\t\t\t}\n\tif (hole_type == \"rocker\") {\n\t\ttranslate([height_sizes[plate_size]/2,0,0]) cube([67.1,33.3,15], center = true);\n\t\t \t\t\t\t\t\t}\n\tif (hole_type == \"outlet\" || hole_type == \"dualsidetoggle\") {\n\t\ttranslate([height_sizes[plate_size]/2 + 19.3915,0,0]) {\n\t\t\tdifference() {\n\t\t\t\tcylinder(r=17.4625, h=15, center = true);\n\t\t\t\ttranslate([-24.2875,-15,-2]) cube([10,37,15], center = false);\n\t\t\t\ttranslate([14.2875,-15,-2]) cube([10,37,15], center = false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\ttranslate([height_sizes[plate_size]/2 - 19.3915,0,0]){\n\t\t\tdifference(){\n\t\t\t\tcylinder(r=17.4625, h=15, center = true);\n\t\t\t\ttranslate([-24.2875,-15,-2]) cube([10,37,15], center = false);\n\t\t\t\ttranslate([14.2875,-15,-2]) cube([10,37,15], center = false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\ttranslate([height_sizes[plate_size]/2,0,-1]) cylinder(r=2, h=10);\n\t\ttranslate([height_sizes[plate_size]/2,0,3.5]) cylinder(r1=2, r2=3.3, h=3);\n\t\t\t\t\t\t\t}\n\tif (hole_type == \"blank\") { }\n\tif (hole_type == \"vga\" || hole_type == \"db09\") {\n\t\t\ttranslate([0,-12.5,3]) cylinder(r=1.75, h=10, center = true);\n\t\t\ttranslate([0,12.5,3]) cylinder(r=1.75, h=10, center = true);\n\t\t\t\tdifference(){\n\t\t\t\t\tcube([10,19,13], center=true);\n\t\t\t\t\ttranslate([-5,-9.2,1]) rotate([0,0,-35.6]) cube([4.4,2.4,15], center=true);\n\t\t\t\t\ttranslate([.9,-11.2,0]) rotate([0,0,9.6]) cube([10,4.8,15], center=true);\n\t\t\t\t\ttranslate([4.6,-8.5,0]) rotate([0,0,37.2]) cube([4.4,2.4,15], center=true);\n\t\t\t\t\ttranslate([-5,9.2,1]) rotate([0,0,35.6]) cube([4.4,2.4,15], center=true);\n\t\t\t\t\ttranslate([0.9,11.2,0]) rotate([0,0,-9.6]) cube([10,4.8,15], center=true);\n\t\t\t\t\ttranslate([4.6,8.5,0]) rotate([0,0,-37.2]) cube([4.4,2.4,15], center=true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\tif (hole_type == \"hdmi\") {\n\t\ttranslate([0,-13,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,13,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,0,3]) cube([6,16,10], center=true);\n\t\t\t\t\t\t\t}\n\tif (hole_type == \"dvi\") {\n\t\ttranslate([0,-16,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,16,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,0,3]) cube([10,26,10], center=true);\n\t\t\t\t\t\t\t}\n\tif (hole_type == \"displayport\") {\n\t\ttranslate([0,-13.5,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,13.5,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,0,0]){\n\t\t\tdifference(){\n\t\t\t\ttranslate([0,0,3]) cube([7,19,10], center=true);\n\t\t\t\ttranslate([2.47,-9.37,3]) rotate([0,0,-54.6]) cube([3,5,14], center=true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\tif (hole_type == \"usb-a\") {\n\t\ttranslate([0,-15,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,15,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,0,3]) cube([8,16,10], center=true);\n\t\t\t\t\t\t\t}\n\tif (hole_type == \"usb-b\") {\n\t\ttranslate([0,-13,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,13,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,0,3]) cube([11,12,10], center=true);\n\t\t\t\t\t\t\t}\n\tif (hole_type == \"firewire\") {\n\t\ttranslate([0,-13.5,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,13.5,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,0,3]) cube([7,12,10], center=true);\n\t\t\t\t\t\t\t}\n\tif (hole_type == \"f-type\") {\n\t\ttranslate([0,0,3]) cylinder(r=4.7625, h=10, center=true);\n\t\t\t\t\t\t\t}\n\tif (hole_type == \"cat5e\" || hole_type == \"cat6\") {\n\t\ttranslate([0,-12.5,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,12.5,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,0,3]) cube([15,15,10], center=true);\n\t\t}\n\tif (hole_type == \"svideo\" || hole_type == \"ps2\") {\n\t\ttranslate([0,-10,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,10,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,0,3]) cylinder(r=5, h=10, center=true);\n\t\t}\n\tif (hole_type == \"stereo\") {\n\t\ttranslate([0,0,3]) cylinder(r=2.985, h=10, center=true);\n\t\t}\n\tif (hole_type == \"keystone1\") {\n\t\ttranslate([0,0,5]) cube([16.5,15,10], center = true);\n\t}\n\tif (hole_type == \"keystone_solid\") {\n\t\trotate([0,0,90]) {\n\t\t\tdifference(){\n\t\t\t\ttranslate([0,0,.1]) cube([23,30.5,9.8]);\n\t\t\t\t\ttranslate([4,4,0]){\n\t\t\t\t\t\tdifference(){\n\t\t\t\t\t\t\tcube([15,22.5,10]);\n\t\t\t\t\t\t\ttranslate([-1,-0.001,3.501]) cube([17,2,6.5]);\n\t\t\t\t\t\t\ttranslate([-1,2.5,-3.40970]) rotate([45,0,0]) cube([17,2,6.5]);\n\t\t\t\t\t\t\ttranslate([-1,18.501,6.001]) cube([17,4,4]);\n\t\t\t\t\t\t\ttranslate([-1,20.5,0]) rotate([-45,0,0]) cube([17,2,6.5]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\nrotate([0,180,90]){\ntranslate([-height_sizes[plate_size]/2,-solid_plate_width/2,-6]){\nif (plate_width == 1) {\n\tdifference() {\n\t\tplate();\n\t\ttranslate([0,0,-3]) plate_inner();\n\t\tplate1();\n\t\t\t}\n\t\tunion() {\n\t\tplate1_solid();\n\t\t}\n\t\t\t}\nelse if (plate_width == 2) {\ndifference()\n{\nplate();\ntranslate([0,0,-3]) plate_inner();\nplate1();\nplate2();\n}\nunion() {\n\t\tplate1_solid();\n\t\tplate2_solid();\n\t\t}\n}\nelse if (plate_width == 3) {\ndifference()\n{\nplate();\ntranslate([0,0,-3]) plate_inner();\nplate1();\nplate2();\nplate3();\n}\nunion() {\n\t\tplate1_solid();\n\t\tplate2_solid();\n\t\tplate3_solid();\n\t\t}\n}\nelse if (plate_width == 4) {\ndifference()\n{\nplate();\ntranslate([0,0,-3]) plate_inner();\nplate1();\nplate2();\nplate3();\nplate4();\n}\nunion() {\n\t\tplate1_solid();\n\t\tplate2_solid();\n\t\tplate3_solid();\n\t\tplate4_solid();\n\t\t}\n}\nelse if (plate_width == 5) {\ndifference()\n{\nplate();\ntranslate([0,0,-3]) plate_inner();\nplate1();\nplate2();\nplate3();\nplate4();\nplate5();\n}\nunion() {\n\t\tplate1_solid();\n\t\tplate2_solid();\n\t\tplate3_solid();\n\t\tplate4_solid();\n\t\tplate5_solid();\n\t\t}\n}\n}\n}",
    "description": "Okay, I'd like to create a custom wall plate generator in OpenSCAD. I need it to be parametric, so I can easily change the size and what kinds of connectors it supports. I want to be able to specify:\n\n*   **Plate Width:** The number of \"gangs\" or sections the wall plate should have, from 1 to 5. This corresponds to the width of standard electrical boxes, and I want screw holes to match.\n*   **Plate Size:** The overall size of the plate itself, and specifically I need to choose from: \"Standard\", \"Junior-Jumbo\", and \"Jumbo\" sizes.\n*   **Connector Types:** For each plate position (up to 5), I need to be able to select a different connector type. I need to be able to select from the following connector types:\n    *   \"None\": No connector at this position.\n    *   \"Blank\": A blank space, but keeps the location.\n    *    \"Toggle\": A full plate with a toggle switch cutout. (This will force selection to a plate without a hole)\n    *   \"Long_Toggle\": A full plate with a long toggle switch cutout. (This will force selection to a plate without a hole)\n    *   \"Outlet\": A full plate with a standard duplex outlet cutout. (This will force selection to a plate without a hole)\n    *   \"Rocker\": A full plate with a rocker/designer style cutout. (This will force selection to a plate without a hole)\n    *   \"Keystone1\": A single keystone jack cutout.\n    *   \"VGA\": VGA port cutout.\n    *   \"HDMI\": HDMI port cutout.\n    *   \"DVI\": DVI-I port cutout.\n    *   \"Displayport\": DisplayPort cutout.\n    *   \"Cat5e\": Cat5e/Cat6 port cutout.\n    *   \"USB-A\": USB-A port cutout.\n    *   \"USB-B\": USB-B port cutout.\n    *   \"Firewire\": Firewire IEEE 1394 port cutout.\n    *   \"DB09\": DB-09 port cutout.\n    *   \"PS2\": PS2 port cutout.\n    *   \"F-Type\": F-Type/Coaxial port cutout.\n    *    \"Svideo\": S-Video port cutout.\n    *    \"Stereo\": Stereo headphone jack cutout.\n\n* **Bottom Connector Types**: For each of the 5 plate positions, I need to be able to independently specify a bottom connector type. This allows for a top and bottom connector or a centered one. I need the same options as above, except \"none\", \"blank\", \"keystone1\", \"VGA\", \"HDMI\", \"DVI\", \"Displayport\", \"Cat5e\", \"USB-A\", \"USB-B\", \"Firewire\", \"DB09\", \"PS2\", \"F-Type\", \"Svideo\", and \"Stereo\". The full plate connector types should not be options.\n\nThe full plate options, \"Toggle\", \"Long_Toggle\", \"Outlet\", and \"Rocker\" when selected in either \"top\" or \"bottom\" hole settings for a plate should take the entire plate; any other selection should be ignored.\n\nIf \"none\" is selected for one of the top/bottom holes, the other selection should be centered in that plate position. if \"blank\" is selected for one of the holes, that port will remain blank, but the other selection will not be centered.\n\nI want the generated plate to have a bevel on all edges.\n\nThe code should be organized using modules to separate the different functionalities. I will not be attaching code or external libraries, but I don't want to use any external libraries. The code should calculate the spacing of all the ports, and center them correctly based on how many \"plates\" wide it is. I want the code to be well-documented so I can easily understand and modify it in the future.\n\nI need the final output to be a 3D model that can be directly printed.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Belfry mods to USB stick and SD card holder",
    "scad": "use <MCAD/boxes.scad>\nuse <utils/build_plate.scad>\nuse <write/Write.scad>\nDevice_Type = 5;\nDevice_Order = 1;\nUSB_Extra = 8;\nSign_FONT = \"orbitron\";\nSign_TEXT = \"Belfry\";\nSign_HEIGHT = 6;\nSign_TYPE = 1;\nConnector_Type = 0;\nUSB_sticks = 4;\nUSB_gap = 6;\nUSB_Cap_Height = 1.25;\nSD_cards = 4;\nSD_gap = 2;\nMicroSD_gap = 3;\nPencil_radius = 4;\nPencil_gap = 3;\nbuild_plate_selector = 2;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nmodule HOLDER() {\n\tdifference() {\n\t\tunion() {\n\t\t\tif ( Device_Type != 2 )\n\t\t\t\ttranslate([Device_Order*((USB_Holder_Length-.001)/2),0,0]) USB_MicroSD();\n\t\t\tif ((Device_Type == 2) || (Device_Type == 3) || (Device_Type == 5) )\n\t\t\t\ttranslate([-Device_Order*((SD_Holder_Length-.001)/2),0,0]) SD();\n\t\t\tif ((Device_Type == 4) || (Device_Type == 5))\n\t\t\t\ttranslate([Device_Order*(((USB_Holder_Length-.001)/2)+(USB_Holder_Length-.001)),0,0]) USB_Caps();\n\t\t\tCONNECTORS(1);\n\t\t}\n\t\tCONNECTORS(-1);\n\t\ttranslate([0,0,-50])\n\t\t\tcube([1000,300,100],true);\n\t}\n}\nmodule USB_MicroSD() {\n\tdifference() {\n\t\trotate([0,90,0])\n\t\t\troundedBox([USB_Holder_Height*2,USB_Holder_Width,USB_Holder_Length],3,true,$fn=60);\n\t\tfor (i=[1:USB_sticks])\n\t\t\ttranslate([5-USB_Holder_Length/2+(i-1)*(USB_width+USB_gap),6,USB_Holder_Height-USB_depth/2])\n\t\t\t\tcube([USB_width,USB_length,USB_depth+1], true);\n\t\ttranslate([0,-USB_Holder_Width/2,2*USB_Holder_Height/3+USB_Holder_Width/2])\n\t\t\trotate([45,0,0])\n\t\t\t\tcube([USB_Holder_Length+1,USB_Holder_Width,USB_Holder_Width],true);\n\t\tif (USB_Extra == 1)\n\t\t{\n\t\t\tfor (i=[1:MicroSD_cards])\n\t\t\t\ttranslate([3-USB_Holder_Length/2+(i-1)*(MicroSD_width+MicroSD_gap),-11,USB_Holder_Height-MicroSD_depth/2])\n\t\t\t\t\tcube([MicroSD_width,MicroSD_length,MicroSD_depth], true);\n\t\t}\n\t\tif (USB_Extra == 2)\n\t\t{\n\t\t\tfor (i=[1:Pencil_holes])\n\t\t\t\ttranslate([3*Pencil_radius/2-USB_Holder_Length/2+(i-1)*(2*Pencil_radius+MicroSD_gap),-11.4,USB_Holder_Height-MicroSD_depth/2])\n\t\t\t\t\trotate([30,0,0])\n\t\t\t\t\t\tcylinder(h=Pencil_depth, r=Pencil_radius, center=true, $fn=40);\n\t\t}\n\t\tif (USB_Extra == 4)\n\t\t{\n\t\t\ttranslate([0,-8.5,8])\n\t\t\t\trotate([0,90,0])\n\t\t\t\t\tcylinder(h=USB_Holder_Length-USB_gap, r=6.5, center=true, $fn=60);\n\t\t}\n\t\tif ((USB_Extra == 8)  && (Sign_TYPE == -1))\n\t\t{\n\t\t\ttranslate([0,-11,10])\n\t\t\t\trotate([45,0,0])\n\t\t\t\t\twrite(Sign_TEXT,t=2,h=Sign_HEIGHT,center=true,font=Sign_FONT_dxf);\n\t\t}\n\t}\n\tif ((USB_Extra == 8)  && (Sign_TYPE == 1))\n\t{\n\t\ttranslate([0,-11,10])\n\t\t\trotate([45,0,0])\n\t\t\t\twrite(Sign_TEXT,t=2,h=Sign_HEIGHT,center=true,font=Sign_FONT_dxf);\n\t}\n\ttranslate([0,-3.2,14.21]) {\n\t\trotate([0,90,0]) {\n\t\t\tdifference() {\n\t\t\t\tcylinder(h=USB_Holder_Length, r=3.8, center=true, $fn=60);\n\t\t\t\ttranslate([0,5/2,0])\n\t\t\t\t\tcube([10,5,USB_Holder_Length+1], true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule USB_Caps() {\n\t\trotate([0,90,0]) {\n\t\t\troundedBox([USB_Holder_Height*2,USB_Holder_Width,USB_Holder_Length],3,true,$fn=60);\n\t\t}\n\t\tfor (i=[1:USB_sticks])\n\t\t\ttranslate([(USB_gap/2)-(USB_Holder_Length/2)+((i-1)*(USB_width+USB_gap)),-(USB_length/2),USB_Holder_Height])\n\t\t\t\tcube([USB_width,USB_length,USB_depth*USB_Cap_Height]);\n\t}\nmodule SD() {\n\tdifference() {\n\t\trotate([0,90,0]) {\n\t\t\troundedBox([SD_Holder_Height*2,SD_Holder_Width,SD_Holder_Length],3,true,$fn=60);\n\t\t}\n\t\tfor (i=[1:SD_cards])\n\t\t\ttranslate([SD_gap+1.5-SD_Holder_Length/2+(i-1)*(SD_width+SD_gap),0,SD_Holder_Height-SD_depth/2])\n\t\t\t\tcube([SD_width,SD_length,SD_depth+1], true);\n\t}\n}\nmodule TAB(x,y) {\n\ttranslate([x,y,slotHeight/2])\n\t\tlinear_extrude(height = tabHeight, center = true, convexity = 10, twist = 0)\n\t\t\tpolygon(points=[[-tabX,-tabYa],[-tabX,tabYa],[tabX,tabYb],[tabX,-tabYb]], paths=[[0,1,2,3]]);\n}\nmodule TABS(d) {\n\tif (Connector_Type == 4)\n\t{\n\t\tif (pos_OK)\n\t\t{\n\t\t\ttranslate([0,SD_Holder_Width/2+slotX-.001,0])\n\t\t\t\trotate([0,0,90])\n\t\t\t\t\tTAB(0,tabSeperation/2);\n\t\t}\n\t\tif (neg_OK)\n\t\t{\n\t\t\ttranslate([0,SD_Holder_Width/2+slotX-.001,0])\n\t\t\t\trotate([0,0,90])\n\t\t\t\t\tTAB(0,-tabSeperation/2);\n\t\t}\n\t}\n\telse if ((Connector_Type == 1) || (Connector_Type == 3))\n\t{\n\t\tif (!neg_OK)\n\t\t{\n\t\t\tTAB(slotX-.001,tabSeperation/2);\n\t\t\tTAB(slotX-.001,-tabSeperation/2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTAB(d+slotX-.001,tabSeperation/2);\n\t\t\tTAB(d+slotX-.001,-tabSeperation/2);\n\t\t}\n\t}\n}\nmodule SLOT(x,y) {\n\ttranslate([x,y,slotHeight/2])\n\t\tlinear_extrude(height = slotHeight, center = true, convexity = 10, twist = 0)\n\t\t\tpolygon(points=[[-slotX,-slotYa],[-slotX,slotYa],[slotX,slotYb],[slotX,-slotYb]], paths=[[0,1,2,3]]);\n}\nmodule SLOTS(d) {\n\tif (Connector_Type == 8)\n\t{\n\t\tif (neg_OK)\n\t\t{\n\t\t\ttranslate([0,SD_Holder_Width/2-slotX+.001,0])\n\t\t\t\trotate([0,0,-90])\n\t\t\t\t\tSLOT(0,tabSeperation/2);\n\t\t}\n\t\tif (pos_OK)\n\t\t{\n\t\t\ttranslate([0,SD_Holder_Width/2-slotX+.001,0])\n\t\t\t\trotate([0,0,-90])\n\t\t\t\t\tSLOT(0,-tabSeperation/2);\n\t\t}\n\t}\n\telse if ((Connector_Type == 2) || (Connector_Type == 3))\n\t{\n\t\tif (pos_OK)\n\t\t{\n\t\t\tSLOT(d+slotX-.001,tabSeperation/2);\n\t\t\tSLOT(d+slotX-.001,-tabSeperation/2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSLOT(slotX-.001,tabSeperation/2);\n\t\t\tSLOT(slotX-.001,-tabSeperation/2);\n\t\t}\n\t}\n}\nmodule CONNECTORS(cType) {\n\tif (cType > 0)\n\t{\n\t\tif (Connector_Type == 4)\n\t\t\tTABS(USB_Holder_Width);\n\t\telse if (Device_Order > 0)\n\t\t\tTABS(USB_Holder_Length);\n\t\telse\n\t\t\tTABS(SD_Holder_Length);\n\t}\n\telse\n\t{\n\t\tif (Connector_Type == 5)\n\t\t\tSLOTS(USB_Holder_Width);\n\t\telse if (Device_Order > 0)\n\t\t\tSLOTS(-SD_Holder_Length);\n\t\telse\n\t\t\tSLOTS(-USB_Holder_Length);\n\t}\n}\nUSB_width = 5;\nUSB_length = 13;\nUSB_depth = 13;\nUSB_Holder_Height = 18;\nUSB_Holder_Width = 32;\nUSB_Holder_Length = USB_sticks*(USB_width + USB_gap)+6-USB_gap;\nMicroSD_width = 1;\nMicroSD_length = 9;\nMicroSD_depth = 15;\nMicroSD_cards = (USB_Holder_Length-3)/(MicroSD_width+MicroSD_gap);\nPencil_holes = (USB_Holder_Length-3)/(2*Pencil_radius+Pencil_gap);\nPencil_depth = 18;\nSign_FONT_dxf = str(\"write/\",Sign_FONT,\".dxf\");\ntabHeight = 8;\ntabSeperation = 16;\ntabLeft = 2.44;\ntabRight = 4.44;\ntabWidth = 2;\ntabX = tabWidth/2;\ntabYa = tabLeft/2;\ntabYb = tabRight/2;\npos_OK = (Device_Type == 3) || ((Device_Type == 2) && (Device_Order ==  1)) || ((Device_Type == 1) && (Device_Order == -1));\nneg_OK = (Device_Type == 3) || ((Device_Type == 2) && (Device_Order == -1)) || ((Device_Type == 1) && (Device_Order ==  1));\nSD_width = 2.64;\nSD_length = 26.15;\nSD_depth = 15;\nSD_Holder_Height = 18;\nSD_Holder_Width = 32;\nSD_Holder_Length = SD_gap+SD_cards*(SD_width + SD_gap)+SD_gap/2;\nslotHeight = tabHeight;\nslotSeperation = tabSeperation;\nslotLeft = 3;\nslotRight = 5;\nslotWidth = 2;\nslotX = slotWidth/2;\nslotYa = slotLeft/2;\nslotYb = slotRight/2;\nHOLDER();",
    "description": "Okay, I'm looking to design a parametric holder for USB sticks, SD cards, and optionally, USB caps, and some extra features. I've got a starting point with an existing OpenSCAD file, but it's a bit clunky and I want something more flexible and easier to customize.\n\nHere's what I'm envisioning:\n\n**Core Functionality:**\n\n*   **Device Support:** The holder needs to be able to accommodate USB sticks and SD cards, either separately or in combination. I'd also like to optionally include storage for USB stick caps.\n*   **Device Order:** The order of the devices should be configurable (e.g., SD cards then USB sticks, or USB sticks then SD cards)\n*   **Parametric Design:** Everything should be easily adjustable through parameters, such as the number of USB sticks, the number of SD cards, the spacing between them, and overall dimensions.\n*   **Extra Features:** I'd like an option to add extra features such as micro SD slots, pencil holes, a small tray, or a text sign.\n\n**Specific Parameters & Options:**\n\n*   **Device Type:** A menu selector to choose between USB sticks only, SD cards only, USB sticks and SD cards, USB sticks and caps, or USB sticks, caps, and SD cards.\n*   **Device Order:** A menu selector to choose between SD cards then USB sticks, or USB sticks then SD cards.\n*   **USB Sticks:**\n    *   Number of USB sticks (integer, menu selectable).\n    *   Gap between USB sticks (float, menu selectable).\n    *   Whether to include storage for USB stick caps (boolean, controlled by Device Type)\n    *   Height of USB Caps (float, menu selectable)\n*   **SD Cards:**\n    *   Number of SD cards (integer, menu selectable).\n    *   Gap between SD cards (float, menu selectable).\n*   **Extra Features:**\n    *   A menu selector to choose between: none, micro SD slots, pencil holes, a tray, or a text sign.\n    *   If Micro SD slots are chosen:\n        *   Gap between Micro SD cards (float, menu selectable).\n    *   If Pencil holes are chosen:\n        *   Radius of the holes (float, menu selectable).\n        *   Gap between the holes (float, menu selectable).\n    *   If a Text sign is chosen:\n        *   Sign text (string input)\n        *   Sign height (integer, menu selectable).\n        *   Sign font (menu selectable from a list of fonts)\n        *  Sign Type ( menu selector to choose between Raised and Embossed.)\n*  **Connectors:**\n   *   Connector Type: A menu selector to choose between none, tabs right, slots left, slots left and tabs right, tabs back, or slots back. This will allow for a modular setup with interlocking parts.\n\n**General Design:**\n\n*   **Rounded Edges:** The basic shape should have rounded edges for a nicer aesthetic.\n*   **Clearance:** The design should include a small amount of clearance for inserting and removing the devices.\n*   **Build Plate Awareness:** It would be helpful to include a build plate visualization based on printer model selection (Replicator 2, Replicator, Thingomatic, or manual dimensions) from the user interface, just for visual representation; it doesn't need to impact the final code.\n\n**Libraries:**\n\nI'd like the design to use the following libraries:\n\n*   **MCAD/boxes.scad**\n*   **utils/build\\_plate.scad**\n*   **write/Write.scad**\n\nEssentially, I'm trying to create a flexible, parametric design that allows me to easily customize a holder for my various memory devices and add other features, all controlled by a simple menu.\n\nCan you help me generate this OpenSCAD code?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Note-Generator",
    "scad": "show_lines_of_staff = \"yes with endbars\";\nshow_clef = \"violin\";\nnotestring=\"1:c1,2:d1,bar,4:e1,8:f1,6:g1,3:a1,3:b1,6:c2,bar,8:d2,4:e2,2:f2,1:g2,bar,#:a2,4:a2,4:br\";\nstr=notestring;\nline_distance =10;\nzeilenhoehe = line_distance;\nline_thickness = 1;\nlinienbreite = line_thickness;\nline_lenght = 400;\nlinienlaenge = line_lenght;\ncutline_height = 5;\nz_height = 15;\nmodule fake(){\n}\n$fn=12;\ntontable=[[\"br\",-1], [\"c1\",0],[\"d1\",1],[\"e1\",2],[\"f1\",3],[\"g1\",4],[\"a1\",5],[\"b1\",6],[\"c2\",7],[\"d2\",8],[\"e2\",9],[\"f2\",10],[\"g2\",11],[\"a2\",12] ];\nif(show_lines_of_staff == \"yes\" || show_lines_of_staff == \"yes with endbars\"){\n\tlines(5);\n\tall();\n}\nif(show_lines_of_staff == \"no\"){\n\tall();\n}\nif(show_lines_of_staff == \"cut lines\"){\n\tdifference(){\n\t\tall();\n\t\ttranslate([0,-5*zeilenhoehe,0])\n\t\t\tlines(15);\n\t}\n}\nif(show_lines_of_staff == \"cut all lines\"){\n\tdifference(){\n\t\tall();\n\t\ttranslate([0,-5*zeilenhoehe,0])\n\t\t\tlines(15);\n\t\ttranslate([0,-5.5*zeilenhoehe,0])\n\t\t\tlines(15);\n\t}\n}\nmodule lines(anz){\ntranslate([linienlaenge/2 - 4*zeilenhoehe,0,-(z_height-cutline_height)]){\n\tunion(){\n\tlinear_extrude(height = z_height){\n\t\tnotenlinien(zeilenhoehe,linienlaenge,linienbreite, anz);\nif(show_lines_of_staff == \"yes with endbars\"){\ntranslate([-linienlaenge/2,-linienbreite/2,0])\n\tsquare(size = [linienbreite,zeilenhoehe*4 + linienbreite]);\ntranslate([linienlaenge/2,-linienbreite/2,0])\n\tsquare(size = [linienbreite,zeilenhoehe*4 + linienbreite]);\n}\n\t}\n}\n}\n}\nmodule all(){\nclef();\nl=search(\",\",str,10000)[0];\nfor(i=[0:len(l)]){\n\ttranslate([i*zeilenhoehe*2,0,0])\n\tfor(j=[l[i-1]+1 == undef ? 0 : l[i-1]+1   :  l[i-1]+1 == undef ? 0 : l[i-1]+1]){\n\t\tnavigate(str[j],str[j+1],str[j+2],str[j+3]);\n\t}\n}\nmodule navigate(a,b,c,d){\n\tif(a != undef && b != undef && c != undef && d != undef ){\n\t\tif(str(a,b,c) == \"bar\"){\n\t\t\tbar();\n\t\t}else if(a == \"#\" || a == \"b\" || a == \"n\"){\n\t\t\ttranslate([zeilenhoehe/2,0,0])\n\t\t\taccidental(a,tontable[search([str(c,d)],tontable)[0]][1]);\n\t\t}else{\n\t\t\tnoten(str(\"1/\",a),tontable[search([str(c,d)],tontable)[0]][1]);\n\t\t}\n\t}\n}\nmodule clef(){\nlinear_extrude(height = z_height){\nif(show_clef != \"no\")\ntranslate([-zeilenhoehe*2,0,0]){\n\tif(show_clef == \"alt\")\n\t\taltschluessel(zeilenhoehe);\n\tif(show_clef == \"bass\")\n\t\tbassschluessel(zeilenhoehe);\n\tif(show_clef == \"violin\")\n\t\tviolinschluessel(zeilenhoehe);\n}\n}\n}\nmodule accidental(vz,th){\nlinear_extrude(height = z_height){\n\ttranslate([0,th == -1 ? zeilenhoehe*3 : -zeilenhoehe + th*(zeilenhoehe/2),0])\n\t\t\tvorzeichen(vz, zeilenhoehe);\n}\n}\nmodule noten(nw,th){\nif(th != -1)\nlinear_extrude(height = z_height){\n\ttranslate([0,-zeilenhoehe + th*(zeilenhoehe/2),0])\n\t\trotate([0,0,th >= 6 ? 180 : 0]){\n\t\t\tnote(zeilenhoehe,nw,th);\n\t\t}\n\tif(th == 0){\n\t\ttranslate([-zeilenhoehe,-zeilenhoehe,0])\n\t\t\tsquare(size = [zeilenhoehe*2,linienbreite]);\n\t}\n\tif(th == 12){\n\t\ttranslate([-zeilenhoehe,zeilenhoehe*5,0])\n\t\t\tsquare(size = [zeilenhoehe*2,linienbreite]);\n\t}\n}\nif(th == -1)\nlinear_extrude(height = z_height){\n\t\tbreak(zeilenhoehe,nw);\n}\n}\nmodule bar(){\nlinear_extrude(height = z_height){\n\t\t\tsquare(size = [linienbreite,zeilenhoehe*4]);\n}\n}\n}\nmodule notenlinien(z,ll,lb, anz){\n\tfor(i=[0:(anz-1)]){\n\t\ttranslate([0,i*z,0])\n\t\t\tsquare(size = [ll,lb], center=true);\n\t}\n}\nmodule note(zh,nw,tonhoehe){\n\tnotenradius = zh/2;\n\tzweidrittel=notenradius*2/3;\n\tif(nw != \"1/1\"){\n\tdifference(){\n\tunion(){\n\t\t\ttranslate([zh/2-zweidrittel/4,0,0])\n\t\t\t\tsquare(size = [zweidrittel/2,zh*3.5]);\n\t\trotate([0,0,30])\n\t\t\thull(){\n\t\t\t\tcircle(r = zh/2);\n\t\t\t\ttranslate([zweidrittel,0,0])\n\t\t\t\t\tcircle(r = zweidrittel);\n\t\t\t\ttranslate([-zweidrittel,0,0])\n\t\t\t\t\tcircle(r = zweidrittel);\n\t\t\t}\n\t}\n\t\tif(nw == \"1/2\"){\n\t\t\trotate([0,0,30])\n\t\t\t\thull(){\n\t\t\t\t\ttranslate([zh/4,0,0])\n\t\t\t\t\t\tcircle(r = zh/4);\n\t\t\t\t\ttranslate([-zh/4,0,0])\n\t\t\t\t\t\tcircle(r = zh/4);\n\t\t\t\t}\n\t\t}\n\t}\n\tif(nw == \"1/8\"){\n\t\ttranslate([tonhoehe >= 6 ? zh/2.5 : zh/2 + (zweidrittel/4.1),zh*2.85,0])\n\t\t\tif(tonhoehe >= 6)\n\t\t\t\tmirror(0,1,0)\n\t\t\t\t\tfahne(zh);\n\t\t\telse\n\t\t\t\tfahne(zh);\n\t}\n\tif(nw == \"1/6\"){\n\t\tfor(i=[0:1])\n\t\ttranslate([tonhoehe >= 6 ? zh/2.5 : zh/2 + (zweidrittel/4.1),zh*2.85 - (i*zh),0])\n\t\t\tif(tonhoehe >= 6)\n\t\t\t\tmirror(0,1,0)\n\t\t\t\t\tfahne(zh);\n\t\t\telse\n\t\t\t\tfahne(zh);\n\t}\n\tif(nw == \"1/3\"){\n\t\tfor(i=[-1:1])\n\t\ttranslate([tonhoehe >= 6 ? zh/2.5 : zh/2 + (zweidrittel/4.1),zh*2.85 - (i*zh),0])\n\t\t\tif(tonhoehe >= 6)\n\t\t\t\tmirror(0,1,0)\n\t\t\t\t\tfahne(zh);\n\t\t\telse\n\t\t\t\tfahne(zh);\n\t\ttranslate([zh/2-zweidrittel/4,zh,0])\n\t\t\t\tsquare(size = [zweidrittel/2,zh*3.5]);\n\t}\n\t}else{\ndifference(){\n\tunion(){\n\t\t\thull(){\n\t\t\t\tcircle(r = zh/2);\n\t\t\t\ttranslate([zweidrittel,0,0])\n\t\t\t\t\tcircle(r = zweidrittel);\n\t\t\t\ttranslate([-zweidrittel,0,0])\n\t\t\t\t\tcircle(r = zweidrittel);\n\t\t\t}\n\t}\n\t\t\trotate([0,0,-30])\n\t\t\t\thull(){\n\t\t\t\t\ttranslate([zh/8,0,0])\n\t\t\t\t\t\tcircle(r = zh/4);\n\t\t\t\t\ttranslate([-zh/8,0,0])\n\t\t\t\t\t\tcircle(r = zh/4);\n\t\t\t\t}\n}\n\t}\n}\nmodule fahne(zh){\nscale(v = [zh/4, zh/4, zh/4])\ntranslate([1.5,-2.5,0])\n  polygon(points=\n    [[-1.608, 1.379], [-0.236, 0.839], [0.625, 0.102], [1.070, -0.770], [1.193, -1.716], [0.857, -3.582], [0.377, -5.000], [1.337, -3.268], [1.607, -1.766], [1.360, -0.448], [0.766, 0.733], [-0.765, 2.866], [-1.359, 3.910], [-1.608, 5.000]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0]]\n    );\n}\nmodule vorzeichen(vz, zh){\n\tif(vz == \"#\")\n\t\tvorzeichen_sharp(zh);\n\tif(vz == \"b\")\n\t\tvorzeichen_b(zh);\n\tif(vz == \"n\")\n\t\tvorzeichen_natural(zh);\n}\nmodule vorzeichen_sharp(zh) {\nscale(v = [zh/5, zh/5, zh/5])\n  polygon(points=\n    [[0.676, 6.500], [0.676, 3.768], [-0.620, 3.194], [-0.620, 5.880], [-1.259, 5.880], [-1.259, 2.907], [-1.935, 2.611], [-1.935, 0.444], [-1.259, 0.741], [-1.259, -1.852], [-1.935, -2.148], [-1.935, -4.315], [-1.259, -4.018], [-1.259, -6.500], [-0.620, -6.500], [-0.620, -3.731], [0.676, -3.167], [0.676, -5.843], [1.315, -5.843], [1.315, -2.880], [1.935, -2.611], [1.935, -0.435], [1.315, -0.713], [1.315, 1.880], [1.935, 2.157], [1.935, 4.324], [1.315, 4.046], [1.315, 6.500], [0.676, 1.602], [0.676, -0.991], [-0.620, -1.565], [-0.620, 1.028]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 0, 0], [28, 29, 30, 31, 28, 28]]\n    );\n}\nmodule vorzeichen_b(zh) {\nscale(v = [zh/5, zh/5, zh/5])\ntranslate([0,3,0])\n  polygon(points=\n    [[-3.276, 7.500], [-3.276, -7.500], [-3.093, -7.500], [-0.500, -6.648], [1.446, -5.288], [2.710, -3.675], [3.256, -2.064], [3.049, -0.712], [2.054, 0.127], [0.236, 0.197], [-2.440, -0.758], [-2.440, 7.500], [-3.276, 7.500], [-0.009, -0.627], [0.711, -0.811], [1.005, -1.301], [0.585, -2.862], [-0.741, -4.638], [-2.440, -5.958], [-2.440, -1.280]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0], [13, 14, 15, 16, 17, 18, 19, 13, 13]]\n    );\n}\nmodule vorzeichen_natural(zh) {\nscale(v = [zh/5, zh/5, zh/5])\n  polygon(points=\n    [[-1.915, 6.500], [-1.915, -3.955], [1.295, -1.911], [1.295, -6.500], [1.915, -6.500], [1.915, 3.955], [-1.268, 1.929], [-1.268, 6.500], [1.295, 1.837], [1.295, -0.190], [-1.268, -1.818], [-1.268, 0.208]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 0], [8, 9, 10, 11, 8]]\n    );\n}\nmodule break(zh,nw){\n\tif(nw == \"1/1\")\n\t\tpause_1_1(zh);\n\tif(nw == \"1/2\")\n\t\tpause_1_2(zh);\n\tif(nw == \"1/4\")\n\t\tpause_1_4(zh);\n\tif(nw == \"1/8\")\n\t\tpause_1_8(zh);\n\tif(nw == \"1/6\")\n\t\tpause_1_16(zh);\n\tif(nw == \"1/3\")\n\t\tpause_1_32(zh);\n}\nmodule pause_1_1(zh) {\ntranslate([0,2.5*zh,0])\n\tsquare(size = [zh*2,zh*0.5]);\n}\nmodule pause_1_2(zh) {\ntranslate([0,2*zh,0])\n\tsquare(size = [zh*2,zh*0.5]);\n}\nmodule pause_1_4(zh) {\ntranslate([0,2*zh,0])\nscale(v = [zh/5.5, zh/5.5, zh/5.5])\n  polygon(points=\n    [[-0.983, 7.462], [-1.147, 7.044], [-0.707, 6.498], [-0.039, 5.578], [0.121, 4.196], [-0.584, 2.939], [-1.172, 2.439], [-2.362, 1.138], [-2.407, 0.846], [-1.545, -0.471], [0.527, -2.922], [0.589, -2.983], [0.507, -2.942], [-1.205, -2.433], [-2.382, -2.442], [-2.677, -2.733], [-2.550, -4.386], [-1.402, -6.689], [-0.815, -7.465], [-0.605, -7.465], [-0.666, -7.174], [-1.124, -5.887], [-1.065, -4.554], [-0.605, -3.968], [0.668, -3.969], [1.907, -4.595], [2.075, -4.744], [2.494, -4.575], [2.346, -4.095], [0.778, -2.231], [0.191, -0.849], [0.372, 0.150], [0.946, 0.994], [1.530, 1.494], [2.744, 2.837], [2.600, 3.588], [0.946, 5.578], [-0.707, 7.483], [-0.983, 7.462]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 0]]\n    );\n}\nmodule pause_1_8(zh) {\ntranslate([0,2*zh,0])\nscale(v = [zh/5.5, zh/5.5, zh/5.5])\n  polygon(points=\n    [[-1.481, 4.970], [-2.212, 4.617], [-2.667, 3.941], [-2.709, 3.489], [-2.537, 2.735], [-2.058, 2.169], [-1.355, 1.832], [-0.302, 1.807], [1.121, 2.152], [1.378, 2.241], [0.108, -1.269], [-1.140, -4.775], [-1.030, -4.843], [-0.536, -4.991], [0.088, -4.712], [1.421, -0.193], [2.711, 4.262], [2.669, 4.324], [2.218, 4.392], [2.066, 4.198], [1.121, 3.080], [0.539, 2.949], [0.150, 3.747], [-0.452, 4.802], [-1.481, 4.970]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 0]]\n    );\n}\nmodule pause_1_16(zh) {\ntranslate([0,1.5*zh,0])\nscale(v = [zh/5.5, zh/5.5, zh/5.5])\n  polygon(points=\n    [[-0.573, 7.468], [-1.285, 7.123], [-1.724, 6.464], [-1.769, 6.024], [-1.601, 5.288], [-1.134, 4.737], [-0.445, 4.408], [0.557, 4.374], [1.924, 4.700], [2.194, 4.786], [1.212, 1.595], [0.434, 0.506], [-0.235, 0.254], [-0.614, 1.032], [-0.971, 1.846], [-1.808, 2.254], [-2.753, 2.014], [-3.361, 1.216], [-3.406, 0.777], [-3.238, 0.044], [-2.771, -0.507], [-2.082, -0.836], [-0.865, -0.836], [0.266, -0.543], [0.583, -0.461], [-1.515, -7.255], [-1.182, -7.444], [-0.676, -7.444], [-0.343, -7.235], [1.545, -0.206], [3.413, 6.777], [3.371, 6.838], [2.972, 6.924], [2.639, 6.505], [1.965, 5.646], [1.401, 5.498], [1.023, 6.275], [0.434, 7.303], [-0.573, 7.468]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 0]]\n    );\n}\nmodule pause_1_32(zh) {\ntranslate([0,2*zh,0])\nscale(v = [zh/5.5, zh/5.5, zh/5.5])\n  polygon(points=\n    [[0.122, 9.959], [-0.580, 9.615], [-1.016, 8.963], [-1.061, 8.528], [-1.016, 8.093], [-0.689, 7.491], [-0.126, 7.078], [0.764, 6.891], [2.488, 7.200], [2.817, 7.306], [2.402, 5.708], [1.926, 3.969], [1.179, 2.973], [0.642, 2.826], [0.269, 3.594], [-0.085, 4.404], [-0.912, 4.803], [-1.846, 4.566], [-2.447, 3.782], [-2.492, 3.347], [-2.324, 2.619], [-1.863, 2.074], [-1.183, 1.749], [0.020, 1.749], [1.138, 2.038], [1.471, 2.144], [0.597, -1.092], [-0.147, -2.129], [-0.789, -2.357], [-1.162, -1.588], [-1.516, -0.783], [-2.343, -0.380], [-3.276, -0.617], [-3.878, -1.405], [-3.923, -1.839], [-3.878, -2.274], [-3.550, -2.876], [-2.987, -3.291], [-2.077, -3.478], [-1.370, -3.433], [-0.166, -3.124], [0.102, -3.018], [0.102, -3.084], [-1.682, -9.758], [-1.102, -10.005], [-0.520, -9.758], [1.740, -0.222], [3.919, 9.317], [3.625, 9.439], [3.272, 9.110], [2.467, 8.029], [2.073, 8.008], [1.699, 8.777], [1.118, 9.793], [0.122, 9.959]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 0]]\n    );\n}\nmodule altschluessel(zh) {\nscale(v = [zh/6.2, zh/6.2, zh/6.2])\ntranslate([0,12.5,0])\n  polygon(points=\n    [[-8.123, -12.484], [-8.123, 11.892], [-8.123, 12.431], [-5.302, 12.431], [-5.302, -11.945], [-5.302, -12.484], [-3.880, -12.484], [-3.880, 11.892], [-3.880, 12.431], [-2.979, 12.431], [-2.979, 0.222], [-1.632, 1.681], [-0.497, 4.038], [-0.019, 5.888], [0.638, 3.753], [1.657, 2.611], [2.792, 2.273], [3.946, 2.591], [4.584, 3.552], [4.966, 6.692], [4.924, 8.203], [4.711, 9.556], [4.171, 10.782], [3.142, 11.522], [2.007, 11.681], [1.158, 11.501], [0.776, 10.994], [1.179, 10.317], [1.635, 9.736], [1.763, 9.186], [1.317, 8.097], [0.129, 7.643], [-1.059, 8.171], [-1.536, 9.429], [-1.331, 10.332], [-0.847, 11.100], [0.723, 12.135], [2.611, 12.484], [4.680, 12.104], [6.451, 10.983], [7.681, 9.165], [8.127, 6.744], [7.953, 5.033], [7.438, 3.647], [6.642, 2.572], [5.656, 1.829], [3.333, 1.216], [1.211, 1.787], [0.087, -0.031], [1.211, -1.839], [3.492, -1.363], [4.815, -1.567], [5.963, -2.167], [6.893, -3.089], [7.575, -4.249], [8.127, -6.892], [7.960, -8.333], [7.459, -9.672], [6.655, -10.824], [5.581, -11.723], [4.274, -12.293], [2.792, -12.484], [1.113, -12.229], [-0.263, -11.617], [-1.179, -10.644], [-1.483, -9.291], [-0.942, -8.129], [0.087, -7.653], [1.285, -8.129], [1.816, -9.291], [1.688, -9.799], [1.317, -10.338], [0.967, -10.782], [0.829, -11.152], [1.190, -11.628], [2.102, -11.860], [3.559, -11.450], [4.436, -10.391], [4.865, -8.816], [5.008, -6.892], [4.595, -3.699], [3.940, -2.668], [2.792, -2.325], [1.694, -2.590], [0.882, -3.393], [0.023, -5.898], [-0.635, -3.551], [-1.706, -1.554], [-2.979, -0.222], [-2.979, -12.484], [-3.880, -12.484]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 0, 0], [6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 6]]\n    );}\nmodule bassschluessel(zh) {\ntranslate([0,zh*1.3,0])\nscale(v = [zh/6.2, zh/6.2, zh/6.2])\ntranslate([0,7.5,0])\n  polygon(points=\n    [[-6.497, -7.077], [-3.725, -5.161], [-1.850, -3.543], [-0.220, -1.360], [0.670, 0.713], [1.064, 2.959], [0.796, 4.860], [-0.102, 6.360], [-0.835, 6.802], [-1.763, 6.949], [-3.630, 6.556], [-4.367, 6.036], [-4.843, 5.268], [-4.922, 5.040], [-4.725, 4.750], [-4.410, 4.648], [-4.024, 4.718], [-3.496, 4.797], [-2.370, 4.357], [-1.874, 3.297], [-2.126, 2.457], [-2.811, 1.836], [-3.772, 1.609], [-4.646, 1.751], [-5.379, 2.182], [-5.868, 2.850], [-6.032, 3.690], [-5.850, 4.798], [-5.308, 5.747], [-3.449, 7.051], [-1.173, 7.491], [0.060, 7.331], [1.222, 6.847], [2.234, 6.090], [3.010, 5.103], [3.510, 3.959], [3.679, 2.732], [3.301, 0.551], [2.167, -1.470], [0.476, -3.285], [-1.574, -4.847], [-6.387, -7.486], [4.443, 5.072], [4.750, 5.779], [5.483, 6.069], [6.184, 5.747], [6.499, 5.033], [6.184, 4.310], [5.443, 4.027], [4.727, 4.334], [4.443, 0.957], [4.735, 1.671], [5.483, 1.962], [6.184, 1.648], [6.499, 0.957], [6.200, 0.211], [5.483, -0.088], [4.735, 0.203]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 0, 0], [42, 43, 44, 45, 46, 47, 48, 49, 42, 42], [50, 51, 52, 53, 54, 55, 56, 57, 50, 50]]\n    );}\nmodule violinschluessel(zh) {\nscale(v = [zh/5.2, zh/5.2, zh/5.2])\ntranslate([0,9.5,0])\n  polygon(points=\n    [[0.832, -1.806], [-0.578, -2.778], [-1.061, -3.577], [-1.220, -4.447], [-0.848, -5.711], [0.249, -6.726], [0.485, -6.967], [0.283, -7.088], [-0.767, -6.625], [-1.608, -5.840], [-2.165, -4.819], [-2.368, -3.656], [-2.153, -2.373], [-1.583, -1.187], [-0.715, -0.206], [0.367, 0.439], [-0.215, 3.492], [-1.983, 1.806], [-3.390, 0.043], [-4.321, -1.828], [-4.664, -3.854], [-4.284, -5.677], [-3.221, -7.294], [-1.577, -8.405], [0.485, -8.825], [2.140, -8.541], [1.439, -1.720], [2.756, -8.335], [3.610, -7.818], [4.219, -7.066], [4.706, -4.869], [4.175, -3.269], [3.052, -2.133], [-0.291, 7.225], [0.654, 8.120], [1.659, 9.574], [2.444, 11.277], [2.731, 12.885], [2.672, 13.505], [2.385, 14.218], [1.769, 14.459], [1.047, 14.221], [0.401, 13.505], [-0.359, 11.561], [-0.680, 9.324], [-0.823, 6.726], [-1.456, 10.984], [-1.178, 13.591], [-0.443, 15.698], [0.637, 17.066], [1.406, 17.487], [1.693, 17.367], [2.022, 16.988], [3.154, 14.583], [3.533, 11.733], [3.153, 8.868], [2.064, 6.202], [0.333, 4.000], [1.017, 0.611], [1.786, 0.688], [3.533, 0.275], [4.892, -0.843], [5.753, -2.443], [6.057, -4.327], [5.861, -5.784], [5.272, -7.105], [4.290, -8.190], [2.908, -8.946], [3.271, -10.761], [3.651, -12.644], [3.769, -13.995], [3.288, -15.810], [1.963, -17.048], [0.148, -17.487], [-1.157, -17.288], [-2.284, -16.696], [-3.079, -15.758], [-3.381, -14.537], [-3.094, -13.393], [-2.402, -12.515], [-1.372, -12.137], [-0.435, -12.412], [0.266, -13.169], [0.528, -14.218], [0.021, -15.509], [-1.262, -16.042], [-1.456, -16.042], [-0.804, -16.627], [0.165, -16.825], [1.321, -16.584], [2.326, -15.930], [2.866, -15.053], [3.077, -13.599], [2.959, -12.361], [2.604, -10.743], [2.258, -9.212], [0.680, -9.410], [-0.663, -9.267], [-1.929, -8.834], [-4.090, -7.225], [-5.534, -4.886], [-6.057, -2.159], [-5.559, 0.353], [-4.386, 2.615], [-2.891, 4.542]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0], [26, 27, 28, 29, 30, 31, 32, 26, 26], [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 33, 33], [45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 45, 45]]\n    );}",
    "description": "Okay, I'd like to design a parametric OpenSCAD file for generating musical notation. I've got some basic functionality already working, but it's a bit clunky and I'd like to make it much more flexible and easier to use.\n\nHere's what I'm aiming for:\n\n**Core Functionality:**\n\n1.  **Staff Lines:** Generate the standard five-line staff.\n    *   Should be able to turn the lines on/off or display them with end bars.\n    *   Should allow for \"cut lines\" functionality.  This means being able to remove parts of staff lines behind notes so notes are more visible.\n    *   Line thickness, line length, and line spacing (distance between lines) should be adjustable.\n    *   The total height above the plane of the staff lines should also be adjustable.\n2.  **Clefs:** Generate clefs (treble, alto, and bass).\n    *   Should allow selection of which clef to display, or none at all.\n    *   Clef height needs to scale to line distance\n3. **Notes:** Generate notes.\n   * Accept a note string (e.g. \"1:c1,2:d1,bar,4:e1,8:f1,6:g1,3:a1,3:b1,6:c2,bar,8:d2,4:e2,2:f2,1:g2,bar,#:a2,4:a2,4:br\") to specify the sequence of notes.\n    *   The note string should specify note duration (1 = whole, 2=half, 4=quarter, 8=eighth, 6= sixteenth, 3=triplet eighth) note, pitch (c1 to b1 in the first octave, and c2 to a2 in the second octave, \"br\" for break/rest), accidentals (sharp, flat, natural, marked with #,b, and n respectively, preceding a note), and bars (\"bar\" for bar line).\n\t* Notes should be able to placed above and below the staff.\n    *   Note head size, stem length, and flag appearance should scale appropriately with line spacing.\n\t* A way to also display rests. \n4.  **Accidentals:** Generate sharp, flat, and natural symbols.\n   *  Should be placed correctly before the notes.\n   *   Should scale appropriately with the staff.\n5.  **Bar Lines:** Generate vertical bar lines.\n   *  Bar lines should span the staff.\n6.  **Breaks/Rests:** Generate rests based on duration.\n    * All normal durations should be included in the breaks/rests options\n\n**Parametric Design Goals:**\n\n*   All dimensions should be parametric and driven by variables.  I want to be able to adjust the scale of the music notation easily.\n*   I want to use a library to keep the code organized\n\n**Specific Requests:**\n\n*   **Use BOSL2:** I'd like you to use the BOSL2 library for organization. It helps keep the code more modular and easier to read.\n*   **Clear Variable Names:** Please use clear and descriptive variable names.\n*   **Comments:** Add comments to the code explaining the purpose of each module and the logic behind the calculations.\n*   **Maintain Current Functionality:** Please make sure you maintain the functionality of the current code. This includes the note string format, the ability to render accidentals, bars, and rests.\n\n**Specific Examples of Parameters to Control:**\n*   `line_distance`: Space between staff lines.\n*   `line_thickness`: Thickness of staff lines.\n*   `line_lenght`: Length of staff lines.\n*   `cutline_height`: Height of cut line feature.\n*  `z_height`: Height of extrusion.\n* `notestring`: The string that defines the notes for the song.\n* `show_lines_of_staff`: Defines if, and what, staff lines to display.\n* `show_clef`: Defines which clef to show.\n\n**Essentially, I want a well-structured and flexible system that I can reuse to generate different musical scores, making it easy to adjust the overall appearance and scale as needed.**\n\nI have attached my current clunky code as a reference, so you can see what I'm trying to achieve.  Please let me know if you have any questions. I'm excited to see what you come up with!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Button",
    "scad": "$fn = 64*1;\ndiameter = 20;\nheight = 2;\nnumber_of_holes = 4;\nhole_diameter = 2;\nhole_offset = 2;\nlip_ratio = 60;\nedge_ratio = 90;\nmain();\nmodule main(){\n\tdifference(){\n\t\tcylinder(h = height, r = diameter/2);\n\t\tif (number_of_holes == 1) {\n\t\t\toneHole();\n\t\t} else if (number_of_holes == 2) {\n\t\t\ttwoHoles();\n\t\t} else if (number_of_holes == 3) {\n\t\t\tthreeHoles();\n\t\t} else if (number_of_holes == 4){\n\t\t\tfourHoles();\n\t\t} else {\n\t\t\tfiveHoles();\n\t\t}\n\t\ttranslate(v=[0,0,height*lip_ratio*.01])\n\t\tcylinder(h = 25, r = diameter/2*edge_ratio*.01);\n\t}\n}\nmodule oneHole() {\n\tcylinder(h=25, r = hole_diameter/2);\n}\nmodule twoHoles() {\n\ttranslate(v=[hole_offset, 0, 0])\n\tcylinder(h = 25, r = hole_diameter/2);\n\ttranslate(v=[-hole_offset, 0, 0])\n\tcylinder(h = 25, r = hole_diameter/2);\n}\nmodule threeHoles() {\n\ttranslate(v=[0, hole_offset, 0])\n\tcylinder(h = 25, r = hole_diameter/2);\n\ttranslate(v=[.87*hole_offset, -.5*hole_offset, 0])\n\tcylinder(h = 25, r = hole_diameter/2);\n\ttranslate(v=[-.87*hole_offset, -.5*hole_offset, 0])\n\tcylinder(h = 25, r = hole_diameter/2);\n}\nmodule fourHoles() {\n\ttranslate(v=[hole_offset, hole_offset, 0])\n\tcylinder(h = 25, r = hole_diameter/2);\n\ttranslate(v=[-hole_offset, hole_offset, 0])\n\tcylinder(h = 25, r = hole_diameter/2);\n\ttranslate(v=[hole_offset, -hole_offset, 0])\n\tcylinder(h = 25, r = hole_diameter/2);\n\ttranslate(v=[-hole_offset,-hole_offset,0])\n\tcylinder(h = 25, r = hole_diameter/2);\n}\nmodule fiveHoles() {\n\ttranslate(v=[0, hole_offset, 0])\n\tcylinder(h = 25, r = hole_diameter/2);\n\ttranslate(v=[hole_offset*.95, hole_offset*.31, 0])\n\tcylinder(h = 25, r = hole_diameter/2);\n\ttranslate(v=[hole_offset*.59, -hole_offset*.81, 0])\n\tcylinder(h = 25, r = hole_diameter/2);\n\ttranslate(v=[-hole_offset*.59,-hole_offset*.81,0])\n\tcylinder(h = 25, r = hole_diameter/2);\n\ttranslate(v=[-hole_offset*.95,hole_offset*.31,0])\n\tcylinder(h = 25, r = hole_diameter/2);\n}",
    "description": "Okay, I'm trying to design a customizable button using OpenSCAD. I've seen some great tutorials that got me started, but I need help making it a bit more robust and user-friendly with parameters.\n\nBasically, I want a cylindrical button with some options for holes and an optional lip and edge. Here's a breakdown of what I'm looking for:\n\n**Overall Shape:**\n\n*   The base of the button should be a cylinder.\n*   I need to be able to control the **diameter** and **height** of this cylinder.\n\n**Holes:**\n\n*   I want to be able to choose the **number of holes** in the button  between 1 and 5.\n*   All holes will be cylindrical, and I need to be able to control their **diameter**.\n*   I also need to be able to adjust their **offset** from the center. For multiple holes, they should be arranged in a pattern.\n    *   **1 Hole**: Centered.\n    *   **2 Holes**: Symmetrically placed along the x-axis on either side of the center.\n    *   **3 Holes**: Placed in a triangle shape centered on the origin.\n    *   **4 Holes**: Placed in a square shape centered on the origin.\n    *   **5 Holes**: Placed in a pentagon shape centered on the origin.\n\n**Lip and Edge:**\n\n*   I'd like to optionally add a slight lip or raised edge to the top of the button.\n*   The **lip** should be a cylinder extending from the top surface of the main cylinder. I need to be able to adjust the lip height as a percentage of the base cylinder height (e.g. 60% of the main cylinder height for the base of the lip). It should extend above the main cylinder by a set constant value, not a proportion.\n*   The **edge** should be a cylinder with a slightly larger diameter than the main button. The diameter of this edge should also be controlled as a percentage of the main button diameter (e.g. 90% of the main button diameter). I think it should start from the top of the lip, if a lip is included, otherwise from the top of the button.\n\n**Parameters:**\n\nI need to be able to adjust all of these through parameters:\n\n*   `diameter`:  The diameter of the main button cylinder.\n*   `height`: The height of the main button cylinder.\n*   `number_of_holes`: The number of holes (1-5).\n*   `hole_diameter`: The diameter of the holes.\n*   `hole_offset`: The offset of the holes from the center.\n*   `lip_ratio`: The height of the lip's base as a percentage of the main cylinder height.\n*   `edge_ratio`: The diameter of the edge cylinder as a percentage of the main cylinder diameter.\n\n**Other:**\n\n*   I'm not too concerned about the *depth* of the holes. They can just go right through the button.\n*   I'd prefer to have the button centered at the origin.\n\nCould you please generate the OpenSCAD code for me? I'm not using any libraries beyond standard OpenSCAD features.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Game Card Holder",
    "scad": "card_x = 54;\ncard_y = 80;\nshow_logo = \"yes\";\nconnectors = \"yes\";\ncard_space = 2;\nwall_thickness = 3;\nplate_height = 3;\nwall_height = 12;\nshortwall_cut = card_x/(card_y/card_x);\nshortwall = (card_x-shortwall_cut)/2+wall_thickness+card_space/2;\nfemale_con_x = 10+1-1;\nfemale_con_y1 = 21+1-2;\nfemale_con_y2 = 12.5+1-1;\nmale_con_x = 11.4+1-1;\nmale_con_y1 = 19.8+1-1;\nmale_con_y2 = 10.46+1-1;\nangle = atan( ((female_con_y1-female_con_y2)/2) / female_con_x );\nunion() {\n\tdifference() {\n\t\tcube(size = [card_x+card_space+wall_thickness*2, card_y+card_space+wall_thickness*2,plate_height], center = true);\n\t\ttranslate([0,card_y/1.27,-card_x/4])\n\t\tcylinder(card_x/2, card_x/2, card_x/2, $fa=2);\n\t\ttranslate([0,-card_y/1.27,-card_x/4])\n\t\tcylinder(card_x/2, card_x/2, card_x/2, $fa=2);\n\t\tif (show_logo == \"yes\") {\n\t\t\tunion() {\n\t\t\t\ttranslate([0, -4.5, 0])\n\t\t\t\tcube(size = [19,9,10], center = true);\n\t\t\t\tdifference() {\n\t\t\t\t\ttranslate([-4.5, 0.5 ,0])\n\t\t\t\t\tcube(size = [10,19,10], center = true);\n\t\t\t\t\ttranslate([0.5, 12 ,0])\n\t\t\t\t\trotate([0, 0, 45])\n\t\t\t\t\tcube(size = [10,12,11], center = true);\n\t\t\t\t\ttranslate([-9.5, 12 ,0])\n\t\t\t\t\trotate([0, 0, 45])\n\t\t\t\t\tcube(size = [12,10,11], center = true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (connectors == \"yes\") {\n\t\t\ttranslate( [ (card_x/2) - female_con_x + card_space/2 + wall_thickness +0.01 , -female_con_y1/2, -plate_height ] )\n\t\t\tdifference() {\n\t\t\t\tcube(size = [female_con_x, female_con_y1, plate_height*2], center = false);\n\t\t\t\ttranslate( [ 0,female_con_y1,-1 ] )\n\t\t\t\trotate([0, 0, -angle])\n\t\t\t\tcube(female_con_x*2);\n\t\t\t\ttranslate( [ 0,0,-1 ] )\n\t\t\t\trotate([0, 0, angle-90])\n\t\t\t\tcube(female_con_x*2);\n\t\t\t}\n\t\t}\n\t}\n\tif (connectors == \"yes\") {\n\t\ttranslate( [ -(card_x/2) - card_space/2 - wall_thickness - male_con_x, -male_con_y1/2, -plate_height/2 ] )\n\t\tdifference() {\n\t\t\tcube(size = [male_con_x, male_con_y1, plate_height], center = false);\n\t\t\ttranslate( [ 0,male_con_y1,-1 ] )\n\t\t\trotate([0, 0, -angle])\n\t\t\tcube(male_con_x*2);\n\t\t\ttranslate( [ 0,0,-1 ] )\n\t\t\trotate([0, 0, angle-90])\n\t\t\tcube(male_con_x*2);\n\t\t}\n\t}\n\ttranslate([  (card_x+card_space+wall_thickness*2)/2 , (card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\trotate([0,0,180])\n\tcube(size = [wall_thickness,(card_y-card_x)/2+wall_thickness+card_space/2,wall_height] ,center = false);\n\ttranslate([  -(card_x+card_space+wall_thickness*2)/2 +wall_thickness , (card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\trotate([0,0,180])\n\tcube(size = [wall_thickness,(card_y-card_x)/2+wall_thickness+card_space/2,wall_height] ,center = false);\n\ttranslate([  (card_x+card_space+wall_thickness*2)/2 -wall_thickness, -(card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\trotate([0,0,0])\n\tcube(size = [wall_thickness,(card_y-card_x)/2+wall_thickness+card_space/2,wall_height] ,center = false);\n\ttranslate([  -(card_x+card_space+wall_thickness*2)/2 , -(card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\trotate([0,0,0])\n\tcube(size = [wall_thickness,(card_y-card_x)/2+wall_thickness+card_space/2,wall_height] ,center = false);\n\ttranslate([  -(card_x+card_space+wall_thickness*2)/2  , (card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\trotate([0,0,270])\n\tcube(size = [wall_thickness, shortwall , wall_height] ,center = false);\n\ttranslate([  (card_x+card_space+wall_thickness*2)/2 , -(card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\trotate([0,0,90])\n\tcube(size = [wall_thickness, shortwall , wall_height] ,center = false);\n\ttranslate([  -(card_x+card_space+wall_thickness*2)/2 , -(card_y+card_space+wall_thickness*2)/2 +wall_thickness ,plate_height/2])\n\trotate([0,0,270])\n\tcube(size = [wall_thickness, shortwall , wall_height] ,center = false);\n\ttranslate([  (card_x+card_space+wall_thickness*2)/2 , (card_y+card_space+wall_thickness*2)/2 -wall_thickness ,plate_height/2])\n\trotate([0,0,90])\n\tcube(size = [wall_thickness, shortwall , wall_height] ,center = false);\n}",
    "description": "Okay, I've got this OpenSCAD file for a card holder, but it's a bit clunky and I'd really like to make it more flexible and easier to customize. It's for holding game cards, like Settlers of Catan cards, but I want to be able to adjust it for any card size.\n\nRight now, I have a bunch of variables defined at the top, like `card_x`, `card_y`, `wall_thickness`, `plate_height`, etc. These are all fine, but the way the short walls are calculated using `shortwall_cut` and `shortwall` is kind of confusing. It works, but it's not very intuitive to change. Also, the code for the connectors, the male and female parts, is also a bit awkward because of the way I've calculated the angles. I'd like to simplify these parts.\n\nHere's what I'm looking for in a new version:\n\n1.  **Fully Parametric Card Dimensions:** I need to be able to specify the card's width and height (like my existing `card_x` and `card_y`) and have all other dimensions scale accordingly. I want to be able to change card dimensions and have all the walls and spaces correctly adjusted.\n2.  **Simplified Wall Calculations:** Instead of using the calculation based on `shortwall_cut`, can we calculate the short wall length directly using the card dimensions? I want it to be clear how the short walls are derived.  It should be calculated using `card_x` and `card_y`, `wall_thickness` and `card_space`.\n3. **Simplified Connector Design:** The male and female connector pieces are too messy with lots of random numbers. I'd like to have them parameterized more clearly for the key dimensions (width, height, depth) and have the angles be more reliably defined. I would like to use a simple trapezoid approach with `con_width`, `con_height` and `con_depth` as the main parameters.\n4.  **Clearer Overall Structure:** The current code has a big `union()` with a `difference()` inside, followed by more unions, and it's kind of hard to follow. It would be great if the code was better organized and commented to show how the base, walls, and connectors are built up step-by-step.\n5.  **Option for No Connectors:** I have `connectors = \"yes\";  // [yes,no]` for turning connectors on or off. This is fine.\n6.  **Logo Option:** I have `show_logo = \"yes\"; // [yes,no]` for showing/hiding the logo. That is also fine.\n\nEssentially, I want the code to be as simple and readable as possible, with clear parameters for all important dimensions.  I'd like the AI to produce a single `.scad` file with this improved and more easily parameterized card holder. I don't need to use any libraries for this design.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Round Thing",
    "scad": "0base_diameter=75;\n1top_diameter=75;\n2side=3;\n3base=2;\n4wall=2;\nuse <utils/build_plate.scad>;\nbuild_plate(3,230,200);\nmodule thing(base_diameter,top_diameter,side, base,wall)\n{\n\t$fa=0.01;\n\tlinear_extrude(height=base) circle(base_diameter/2+wall);\n\ttranslate([0,0,base]) difference() {\n\t\tcylinder(side,base_diameter/2+wall,top_diameter/2+wall);\n\t\tcylinder(side,base_diameter/2,top_diameter/2);\n\t}\n}\nthing(0base_diameter,1top_diameter,2side,3base,4wall);",
    "description": "Okay, I need a parametric OpenSCAD design for making round things with angled sides, like lids, dishes, cups, and even frisbees. \n\nBasically, I want to be able to specify:\n\n*   **The internal diameter at the base (bottom):**  This will let me set how big the bottom opening is. Let's call this `base_diameter`.\n*   **The internal diameter at the top:** This will let me control the size of the opening at the top, which can be different than the base for angled sides. Let's call this `top_diameter`.\n*   **The height of the sides:** This will be the distance between the top of the base and the top edge of the object.  Let's call this `side_height`.\n*   **The thickness of the base:** This sets how thick the flat bottom part is. Let's call this `base_thickness`.\n*   **The thickness of the wall:** This will be the thickness of the sides.  Let's call this `wall_thickness`.\n\nI'd like to be able to adjust these parameters to create different kinds of objects, like a lid with straight sides, a cup that tapers, a vase, or a flat dish.\n\nThe design should use a `linear_extrude` for the base and a `cylinder` for the sides with a difference() to hollow it out, like in the example I saw.\n\nAlso, I'd like it if you can include a function to show the build plate for my printer. It's a Type A Machines Series 1, which has a build plate of 230mm x 200mm. I'd like to use the `build_plate` function from `utils/build_plate.scad` so that I don't have to define the build plate size every time I want to see it. Please make sure it shows the build plate by default.\n\nCould you generate the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Curvy Flat Spring ",
    "scad": "length = 150;\nnumber_of_wiggles = 6;\nangle = 240;\nwidth = 10;\nheight = 10;\nresolution = 100;\nmodule ring(outer, inner, h) {\n  difference() {\n    cylinder(h=h, r=outer);\n    cylinder(h=h, r=inner);\n  }\n}\nmodule arc_of_cylinder(r, h, angle ) {\n  half_angle = 90 - (angle / 2);\n  difference() {\n    cylinder(h=h, r=r);\n    rotate(half_angle) translate([-r,0,0]) cube(size=r*2);\n    rotate(-half_angle) translate([-r,0,0]) cube(size=r*2);\n  }\n}\nmodule arc_of_ring(outer, inner, h, angle ) {\n  difference() {\n    ring(outer, inner, h);\n    arc_of_cylinder(r=2*outer, h=h, angle=360 - angle);\n  }\n}\nmodule spring4(length, n, angle , width, height) {\n  useful_intermediate_angle = 180 - angle / 2;\n  echo(useful_intermediate_angle);\n  path_radius = length / (2 * n * sin(useful_intermediate_angle));\n  echo(path_radius);\n  half_width = width / 2;\n  inner = path_radius - half_width;\n  outer = path_radius + half_width;\n  x_spacing = length / n;\n  y_offset = length / (2 * n * tan(useful_intermediate_angle));\n  epsilon = y_offset / 10000;\n  adjusted_y_offset = y_offset - epsilon;\n  union() for (i = [0 : n-1]) {\n    translate([x_spacing * i, 0, 0])\n      rotate([0,0,180 * i])\n      translate([0, adjusted_y_offset, 0])\n      arc_of_ring(outer, inner, height, angle);\n  }\n}\nspring4(length, number_of_wiggles, angle, width, height, $fn=resolution);",
    "description": "Okay, I'm looking to create a spring-like object using OpenSCAD, and I have a pretty good idea of what I want, but need a little help making it fully parametric. I want the spring to be made up of sections of rings, arranged in a kind of wavy or helical pattern, like a flat, squiggly spring.\n\nHere's what I'm picturing, and the parameters I'd like to control:\n\n*   **Overall Length:**  The total length of the spring when laid flat.\n*   **Number of Wiggles:** How many \"wiggles\" or curves the spring has along its length.\n*   **Angle of Arc:** The angle of the circle that makes up each wiggle. For example, a 240-degree arc would mean that each section looks like a C-shape rather than a full circle or a semi-circle. It must be between 180 and 360 degrees.\n*   **Width:** The width of the \"band\" that makes up the spring (how thick is each ring segment).\n*   **Height:** The thickness of the spring (the height of the ring segments).\n*   **Resolution:** A parameter to control the smoothness of curves (like `$fn`).\n\nBasically, I imagine each wiggle as being an arc of a ring (a section of a circle), and I'm going to want to lay these arcs end-to-end along a line. The number of wiggles determines how many of these arc sections there will be. The `Angle of Arc` determines how much of each circle is used. I need to space them out in a way that creates that squiggly shape along the length of the overall spring. Each arc will also be rotated such that they create an S-shaped path, with the total width being controlled by the length parameter, and number of wiggles.\n\nTo make this a little more clear, each 'wiggle' should not start immediately where the last one stops, but will have some straight section that moves from the previous wiggle to the next.\n\nThe core modules I think I'll need are modules for:\n\n*   **ring:** To create a basic ring shape.\n*   **arc\\_of\\_cylinder:** To create an arc of a cylinder (I suppose that can be a partial cylinder).\n*   **arc\\_of\\_ring:** To create an arc of a ring.\n*   **spring4**: The main module, that brings all of the above together to form the final spring.\n\nI'm going to want to be able to set all of the parameters mentioned above. The code I wrote below calculates the necessary radius for the circles based on the length and number of wiggles, but I would like this to be handled with parameters and math inside the code itself as needed.\n\nI am including an example below of what I have so far, in OpenSCAD format. Can you create a parametric OpenSCAD file that does this? I'm not using any special libraries.\n```\n/* Begin customizer.makerbot.com section. */\n\nlength = 150;\nnumber_of_wiggles = 6;\n// The portion of the circle that appears in each wiggle\nangle = 240; // [180:360]\n// The width of the band of material\nwidth = 10;\nheight = 10;\n// Circles are n-gons.  Choose n\nresolution = 100;\n\n/* End customizer.makerbot.com section. */\n\n\n\n\nmodule ring(outer, inner, h) {\n  difference() {\n    cylinder(h=h, r=outer);\n    cylinder(h=h, r=inner);\n  }\n}\n\nmodule arc_of_cylinder(r, h, angle /* angle must be <= 180 */) {\n  half_angle = 90 - (angle / 2);\n  difference() {\n    cylinder(h=h, r=r);\n    rotate(half_angle) translate([-r,0,0]) cube(size=r*2);\n    rotate(-half_angle) translate([-r,0,0]) cube(size=r*2);\n  }\n}\n\nmodule arc_of_ring(outer, inner, h, angle /* must be 180 <= angle <= 360 */) {\n  difference() {\n    ring(outer, inner, h);\n    arc_of_cylinder(r=2*outer, h=h, angle=360 - angle);\n  }\n}\n\nmodule spring4(length, n, angle /* must be 180 <= angle <= 360 */, width, height) {\n  useful_intermediate_angle = 180 - angle / 2;\n  echo(useful_intermediate_angle);\n  path_radius = length / (2 * n * sin(useful_intermediate_angle));\n  echo(path_radius);\n  half_width = width / 2;\n  inner = path_radius - half_width;\n  outer = path_radius + half_width;  \n  x_spacing = length / n;\n  y_offset = length / (2 * n * tan(useful_intermediate_angle));\n  epsilon = y_offset / 10000;   // Grr.\n  adjusted_y_offset = y_offset - epsilon;\n  union() for (i = [0 : n-1]) {\n    translate([x_spacing * i, 0, 0])\n      rotate([0,0,180 * i])   // mirror() works better\n      translate([0, adjusted_y_offset, 0])\n      arc_of_ring(outer, inner, height, angle);\n  }\n}\n\n// With args from customizer.makerbot.com section above\nspring4(length, number_of_wiggles, angle, width, height, $fn=resolution);\n```\n"
  },
  {
    "object": "Hey cadmonkey, make me a Note-Jewlery",
    "scad": "theitem = \"1/8\";\nnote_body_height =10;\nzeilenhoehe = note_body_height;\nring_x = 5;\nring_y = 35;\nring_inner_radius = 3;\nring_wallthickness = 2;\nz_height = 2;\n$fn=11+1;\nlinear_extrude(height=z_height)\ndifference(){\n\tunion(){\n\t\titem(theitem);\n\t\ttranslate([ring_x,ring_y,0])\n\t\t\tcircle(r=ring_inner_radius+ring_wallthickness);\n\t}\n\ttranslate([ring_x,ring_y,0])\n\t\tcircle(r=ring_inner_radius);\n}\nmodule item(item){\nif(item == \"violin\"){\n\tviolinschluessel(zeilenhoehe);\n}else if(item == \"bass\"){\n\tbassschluessel(zeilenhoehe);\n}else if(item == \"alt\"){\n\taltschluessel(zeilenhoehe);\n}else if(item == \"#\"){\n\ttranslate([0,-zeilenhoehe + 5*(zeilenhoehe/2),0])\n\t\t\tvorzeichen(\"#\", zeilenhoehe);\n}else if(item == \"b\"){\n\ttranslate([0,-zeilenhoehe + 5*(zeilenhoehe/2),0])\n\t\t\tvorzeichen(\"b\", zeilenhoehe);\n}else if(item == \"natural\"){\n\ttranslate([0,-zeilenhoehe + 5*(zeilenhoehe/2),0])\n\t\t\tvorzeichen(\"n\", zeilenhoehe);\n}else if(item == \"1/1\"){\n\tnote(zeilenhoehe,\"1/1\",5);\n}else if(item == \"1/2\"){\n\tnote(zeilenhoehe,\"1/2\",5);\n}else if(item == \"1/4\"){\n\tnote(zeilenhoehe,\"1/4\",5);\n}else if(item == \"1/8\"){\n\tnote(zeilenhoehe,\"1/8\",5);\n}else if(item == \"1/16\"){\n\tnote(zeilenhoehe,\"1/6\",5);\n}else if(item == \"1/32\"){\n\tnote(zeilenhoehe,\"1/3\",5);\n}else if(item == \"1/32\"){\n\tnote(zeilenhoehe,\"1/3\",5);\n}else if(item == \"1/1 break\"){\n\tbreak(zeilenhoehe,\"1/1\");\n}else if(item == \"1/2 break\"){\n\tbreak(zeilenhoehe,\"1/2\");\n}else if(item == \"1/4 break\"){\n\tbreak(zeilenhoehe,\"1/4\");\n}else if(item == \"1/8 break\"){\n\tbreak(zeilenhoehe,\"1/8\");\n}else if(item == \"1/16 break\"){\n\tbreak(zeilenhoehe,\"1/6\");\n}else if(item == \"1/32 break\"){\n\tbreak(zeilenhoehe,\"1/3\");\n}\n}\nmodule note(zh,nw,tonhoehe){\n\tnotenradius = zh/2;\n\tzweidrittel=notenradius*2/3;\n\tif(nw != \"1/1\"){\n\tdifference(){\n\tunion(){\n\t\t\ttranslate([zh/2-zweidrittel/4,0,0])\n\t\t\t\tsquare(size = [zweidrittel/2,zh*3.5]);\n\t\trotate([0,0,30])\n\t\t\thull(){\n\t\t\t\tcircle(r = zh/2);\n\t\t\t\ttranslate([zweidrittel,0,0])\n\t\t\t\t\tcircle(r = zweidrittel);\n\t\t\t\ttranslate([-zweidrittel,0,0])\n\t\t\t\t\tcircle(r = zweidrittel);\n\t\t\t}\n\t}\n\t\tif(nw == \"1/2\"){\n\t\t\trotate([0,0,30])\n\t\t\t\thull(){\n\t\t\t\t\ttranslate([zh/4,0,0])\n\t\t\t\t\t\tcircle(r = zh/4);\n\t\t\t\t\ttranslate([-zh/4,0,0])\n\t\t\t\t\t\tcircle(r = zh/4);\n\t\t\t\t}\n\t\t}\n\t}\n\tif(nw == \"1/8\"){\n\t\ttranslate([tonhoehe >= 6 ? zh/2.5 : zh/2 + (zweidrittel/4.1),zh*2.85,0])\n\t\t\tif(tonhoehe >= 6)\n\t\t\t\tmirror(0,1,0)\n\t\t\t\t\tfahne(zh);\n\t\t\telse\n\t\t\t\tfahne(zh);\n\t}\n\tif(nw == \"1/6\"){\n\t\tfor(i=[0:1])\n\t\ttranslate([tonhoehe >= 6 ? zh/2.5 : zh/2 + (zweidrittel/4.1),zh*2.85 - (i*zh),0])\n\t\t\tif(tonhoehe >= 6)\n\t\t\t\tmirror(0,1,0)\n\t\t\t\t\tfahne(zh);\n\t\t\telse\n\t\t\t\tfahne(zh);\n\t}\n\tif(nw == \"1/3\"){\n\t\tfor(i=[-1:1])\n\t\ttranslate([tonhoehe >= 6 ? zh/2.5 : zh/2 + (zweidrittel/4.1),zh*2.85 - (i*zh),0])\n\t\t\tif(tonhoehe >= 6)\n\t\t\t\tmirror(0,1,0)\n\t\t\t\t\tfahne(zh);\n\t\t\telse\n\t\t\t\tfahne(zh);\n\t\ttranslate([zh/2-zweidrittel/4,zh,0])\n\t\t\t\tsquare(size = [zweidrittel/2,zh*3.5]);\n\t}\n\t}else{\ndifference(){\n\tunion(){\n\t\t\thull(){\n\t\t\t\tcircle(r = zh/2);\n\t\t\t\ttranslate([zweidrittel,0,0])\n\t\t\t\t\tcircle(r = zweidrittel);\n\t\t\t\ttranslate([-zweidrittel,0,0])\n\t\t\t\t\tcircle(r = zweidrittel);\n\t\t\t}\n\t}\n\t\t\trotate([0,0,-30])\n\t\t\t\thull(){\n\t\t\t\t\ttranslate([zh/8,0,0])\n\t\t\t\t\t\tcircle(r = zh/4);\n\t\t\t\t\ttranslate([-zh/8,0,0])\n\t\t\t\t\t\tcircle(r = zh/4);\n\t\t\t\t}\n}\n\t}\n}\nmodule fahne(zh){\nscale(v = [zh/4, zh/4, zh/4])\ntranslate([1.5,-2.5,0])\n  polygon(points=\n    [[-1.608, 1.379], [-0.236, 0.839], [0.625, 0.102], [1.070, -0.770], [1.193, -1.716], [0.857, -3.582], [0.377, -5.000], [1.337, -3.268], [1.607, -1.766], [1.360, -0.448], [0.766, 0.733], [-0.765, 2.866], [-1.359, 3.910], [-1.608, 5.000]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0]]\n    );\n}\nmodule vorzeichen(vz, zh){\n\tif(vz == \"#\")\n\t\tvorzeichen_sharp(zh);\n\tif(vz == \"b\")\n\t\tvorzeichen_b(zh);\n\tif(vz == \"n\")\n\t\tvorzeichen_natural(zh);\n}\nmodule vorzeichen_sharp(zh) {\nscale(v = [zh/5, zh/5, zh/5])\n  polygon(points=\n    [[0.676, 6.500], [0.676, 3.768], [-0.620, 3.194], [-0.620, 5.880], [-1.259, 5.880], [-1.259, 2.907], [-1.935, 2.611], [-1.935, 0.444], [-1.259, 0.741], [-1.259, -1.852], [-1.935, -2.148], [-1.935, -4.315], [-1.259, -4.018], [-1.259, -6.500], [-0.620, -6.500], [-0.620, -3.731], [0.676, -3.167], [0.676, -5.843], [1.315, -5.843], [1.315, -2.880], [1.935, -2.611], [1.935, -0.435], [1.315, -0.713], [1.315, 1.880], [1.935, 2.157], [1.935, 4.324], [1.315, 4.046], [1.315, 6.500], [0.676, 1.602], [0.676, -0.991], [-0.620, -1.565], [-0.620, 1.028]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 0, 0], [28, 29, 30, 31, 28, 28]]\n    );\n}\nmodule vorzeichen_b(zh) {\nscale(v = [zh/5, zh/5, zh/5])\ntranslate([0,3,0])\n  polygon(points=\n    [[-3.276, 7.500], [-3.276, -7.500], [-3.093, -7.500], [-0.500, -6.648], [1.446, -5.288], [2.710, -3.675], [3.256, -2.064], [3.049, -0.712], [2.054, 0.127], [0.236, 0.197], [-2.440, -0.758], [-2.440, 7.500], [-3.276, 7.500], [-0.009, -0.627], [0.711, -0.811], [1.005, -1.301], [0.585, -2.862], [-0.741, -4.638], [-2.440, -5.958], [-2.440, -1.280]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0], [13, 14, 15, 16, 17, 18, 19, 13, 13]]\n    );\n}\nmodule vorzeichen_natural(zh) {\nscale(v = [zh/5, zh/5, zh/5])\n  polygon(points=\n    [[-1.915, 6.500], [-1.915, -3.955], [1.295, -1.911], [1.295, -6.500], [1.915, -6.500], [1.915, 3.955], [-1.268, 1.929], [-1.268, 6.500], [1.295, 1.837], [1.295, -0.190], [-1.268, -1.818], [-1.268, 0.208]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 0], [8, 9, 10, 11, 8]]\n    );\n}\nmodule break(zh,nw){\n\tif(nw == \"1/1\")\n\t\tpause_1_1(zh);\n\tif(nw == \"1/2\")\n\t\tpause_1_2(zh);\n\tif(nw == \"1/4\")\n\t\tpause_1_4(zh);\n\tif(nw == \"1/8\")\n\t\tpause_1_8(zh);\n\tif(nw == \"1/6\")\n\t\tpause_1_16(zh);\n\tif(nw == \"1/3\")\n\t\tpause_1_32(zh);\n}\nmodule pause_1_1(zh) {\ntranslate([0,2.5*zh,0])\n\tsquare(size = [zh*2,zh*0.5]);\n}\nmodule pause_1_2(zh) {\ntranslate([0,2*zh,0])\n\tsquare(size = [zh*2,zh*0.5]);\n}\nmodule pause_1_4(zh) {\ntranslate([0,2*zh,0])\nscale(v = [zh/5.5, zh/5.5, zh/5.5])\n  polygon(points=\n    [[-0.983, 7.462], [-1.147, 7.044], [-0.707, 6.498], [-0.039, 5.578], [0.121, 4.196], [-0.584, 2.939], [-1.172, 2.439], [-2.362, 1.138], [-2.407, 0.846], [-1.545, -0.471], [0.527, -2.922], [0.589, -2.983], [0.507, -2.942], [-1.205, -2.433], [-2.382, -2.442], [-2.677, -2.733], [-2.550, -4.386], [-1.402, -6.689], [-0.815, -7.465], [-0.605, -7.465], [-0.666, -7.174], [-1.124, -5.887], [-1.065, -4.554], [-0.605, -3.968], [0.668, -3.969], [1.907, -4.595], [2.075, -4.744], [2.494, -4.575], [2.346, -4.095], [0.778, -2.231], [0.191, -0.849], [0.372, 0.150], [0.946, 0.994], [1.530, 1.494], [2.744, 2.837], [2.600, 3.588], [0.946, 5.578], [-0.707, 7.483], [-0.983, 7.462]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 0]]\n    );\n}\nmodule pause_1_8(zh) {\ntranslate([0,2*zh,0])\nscale(v = [zh/5.5, zh/5.5, zh/5.5])\n  polygon(points=\n    [[-1.481, 4.970], [-2.212, 4.617], [-2.667, 3.941], [-2.709, 3.489], [-2.537, 2.735], [-2.058, 2.169], [-1.355, 1.832], [-0.302, 1.807], [1.121, 2.152], [1.378, 2.241], [0.108, -1.269], [-1.140, -4.775], [-1.030, -4.843], [-0.536, -4.991], [0.088, -4.712], [1.421, -0.193], [2.711, 4.262], [2.669, 4.324], [2.218, 4.392], [2.066, 4.198], [1.121, 3.080], [0.539, 2.949], [0.150, 3.747], [-0.452, 4.802], [-1.481, 4.970]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 0]]\n    );\n}\nmodule pause_1_16(zh) {\ntranslate([0,1.5*zh,0])\nscale(v = [zh/5.5, zh/5.5, zh/5.5])\n  polygon(points=\n    [[-0.573, 7.468], [-1.285, 7.123], [-1.724, 6.464], [-1.769, 6.024], [-1.601, 5.288], [-1.134, 4.737], [-0.445, 4.408], [0.557, 4.374], [1.924, 4.700], [2.194, 4.786], [1.212, 1.595], [0.434, 0.506], [-0.235, 0.254], [-0.614, 1.032], [-0.971, 1.846], [-1.808, 2.254], [-2.753, 2.014], [-3.361, 1.216], [-3.406, 0.777], [-3.238, 0.044], [-2.771, -0.507], [-2.082, -0.836], [-0.865, -0.836], [0.266, -0.543], [0.583, -0.461], [-1.515, -7.255], [-1.182, -7.444], [-0.676, -7.444], [-0.343, -7.235], [1.545, -0.206], [3.413, 6.777], [3.371, 6.838], [2.972, 6.924], [2.639, 6.505], [1.965, 5.646], [1.401, 5.498], [1.023, 6.275], [0.434, 7.303], [-0.573, 7.468]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 0]]\n    );\n}\nmodule pause_1_32(zh) {\ntranslate([0,2*zh,0])\nscale(v = [zh/5.5, zh/5.5, zh/5.5])\n  polygon(points=\n    [[0.122, 9.959], [-0.580, 9.615], [-1.016, 8.963], [-1.061, 8.528], [-1.016, 8.093], [-0.689, 7.491], [-0.126, 7.078], [0.764, 6.891], [2.488, 7.200], [2.817, 7.306], [2.402, 5.708], [1.926, 3.969], [1.179, 2.973], [0.642, 2.826], [0.269, 3.594], [-0.085, 4.404], [-0.912, 4.803], [-1.846, 4.566], [-2.447, 3.782], [-2.492, 3.347], [-2.324, 2.619], [-1.863, 2.074], [-1.183, 1.749], [0.020, 1.749], [1.138, 2.038], [1.471, 2.144], [0.597, -1.092], [-0.147, -2.129], [-0.789, -2.357], [-1.162, -1.588], [-1.516, -0.783], [-2.343, -0.380], [-3.276, -0.617], [-3.878, -1.405], [-3.923, -1.839], [-3.878, -2.274], [-3.550, -2.876], [-2.987, -3.291], [-2.077, -3.478], [-1.370, -3.433], [-0.166, -3.124], [0.102, -3.018], [0.102, -3.084], [-1.682, -9.758], [-1.102, -10.005], [-0.520, -9.758], [1.740, -0.222], [3.919, 9.317], [3.625, 9.439], [3.272, 9.110], [2.467, 8.029], [2.073, 8.008], [1.699, 8.777], [1.118, 9.793], [0.122, 9.959]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 0]]\n    );\n}\nmodule altschluessel(zh) {\nscale(v = [zh/6.2, zh/6.2, zh/6.2])\ntranslate([0,12.5,0])\n  polygon(points=\n    [[-8.123, -12.484], [-8.123, 11.892], [-8.123, 12.431], [-5.302, 12.431], [-5.302, -11.945], [-5.302, -12.484], [-3.880, -12.484], [-3.880, 11.892], [-3.880, 12.431], [-2.979, 12.431], [-2.979, 0.222], [-1.632, 1.681], [-0.497, 4.038], [-0.019, 5.888], [0.638, 3.753], [1.657, 2.611], [2.792, 2.273], [3.946, 2.591], [4.584, 3.552], [4.966, 6.692], [4.924, 8.203], [4.711, 9.556], [4.171, 10.782], [3.142, 11.522], [2.007, 11.681], [1.158, 11.501], [0.776, 10.994], [1.179, 10.317], [1.635, 9.736], [1.763, 9.186], [1.317, 8.097], [0.129, 7.643], [-1.059, 8.171], [-1.536, 9.429], [-1.331, 10.332], [-0.847, 11.100], [0.723, 12.135], [2.611, 12.484], [4.680, 12.104], [6.451, 10.983], [7.681, 9.165], [8.127, 6.744], [7.953, 5.033], [7.438, 3.647], [6.642, 2.572], [5.656, 1.829], [3.333, 1.216], [1.211, 1.787], [0.087, -0.031], [1.211, -1.839], [3.492, -1.363], [4.815, -1.567], [5.963, -2.167], [6.893, -3.089], [7.575, -4.249], [8.127, -6.892], [7.960, -8.333], [7.459, -9.672], [6.655, -10.824], [5.581, -11.723], [4.274, -12.293], [2.792, -12.484], [1.113, -12.229], [-0.263, -11.617], [-1.179, -10.644], [-1.483, -9.291], [-0.942, -8.129], [0.087, -7.653], [1.285, -8.129], [1.816, -9.291], [1.688, -9.799], [1.317, -10.338], [0.967, -10.782], [0.829, -11.152], [1.190, -11.628], [2.102, -11.860], [3.559, -11.450], [4.436, -10.391], [4.865, -8.816], [5.008, -6.892], [4.595, -3.699], [3.940, -2.668], [2.792, -2.325], [1.694, -2.590], [0.882, -3.393], [0.023, -5.898], [-0.635, -3.551], [-1.706, -1.554], [-2.979, -0.222], [-2.979, -12.484], [-3.880, -12.484]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 0, 0], [6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 6]]\n    );}\nmodule bassschluessel(zh) {\ntranslate([0,zh*1.3,0])\nscale(v = [zh/6.2, zh/6.2, zh/6.2])\ntranslate([0,7.5,0])\n  polygon(points=\n    [[-6.497, -7.077], [-3.725, -5.161], [-1.850, -3.543], [-0.220, -1.360], [0.670, 0.713], [1.064, 2.959], [0.796, 4.860], [-0.102, 6.360], [-0.835, 6.802], [-1.763, 6.949], [-3.630, 6.556], [-4.367, 6.036], [-4.843, 5.268], [-4.922, 5.040], [-4.725, 4.750], [-4.410, 4.648], [-4.024, 4.718], [-3.496, 4.797], [-2.370, 4.357], [-1.874, 3.297], [-2.126, 2.457], [-2.811, 1.836], [-3.772, 1.609], [-4.646, 1.751], [-5.379, 2.182], [-5.868, 2.850], [-6.032, 3.690], [-5.850, 4.798], [-5.308, 5.747], [-3.449, 7.051], [-1.173, 7.491], [0.060, 7.331], [1.222, 6.847], [2.234, 6.090], [3.010, 5.103], [3.510, 3.959], [3.679, 2.732], [3.301, 0.551], [2.167, -1.470], [0.476, -3.285], [-1.574, -4.847], [-6.387, -7.486], [4.443, 5.072], [4.750, 5.779], [5.483, 6.069], [6.184, 5.747], [6.499, 5.033], [6.184, 4.310], [5.443, 4.027], [4.727, 4.334], [4.443, 0.957], [4.735, 1.671], [5.483, 1.962], [6.184, 1.648], [6.499, 0.957], [6.200, 0.211], [5.483, -0.088], [4.735, 0.203]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 0, 0], [42, 43, 44, 45, 46, 47, 48, 49, 42, 42], [50, 51, 52, 53, 54, 55, 56, 57, 50, 50]]\n    );}\nmodule violinschluessel(zh) {\nscale(v = [zh/5.2, zh/5.2, zh/5.2])\ntranslate([0,9.5,0])\n  polygon(points=\n    [[0.832, -1.806], [-0.578, -2.778], [-1.061, -3.577], [-1.220, -4.447], [-0.848, -5.711], [0.249, -6.726], [0.485, -6.967], [0.283, -7.088], [-0.767, -6.625], [-1.608, -5.840], [-2.165, -4.819], [-2.368, -3.656], [-2.153, -2.373], [-1.583, -1.187], [-0.715, -0.206], [0.367, 0.439], [-0.215, 3.492], [-1.983, 1.806], [-3.390, 0.043], [-4.321, -1.828], [-4.664, -3.854], [-4.284, -5.677], [-3.221, -7.294], [-1.577, -8.405], [0.485, -8.825], [2.140, -8.541], [1.439, -1.720], [2.756, -8.335], [3.610, -7.818], [4.219, -7.066], [4.706, -4.869], [4.175, -3.269], [3.052, -2.133], [-0.291, 7.225], [0.654, 8.120], [1.659, 9.574], [2.444, 11.277], [2.731, 12.885], [2.672, 13.505], [2.385, 14.218], [1.769, 14.459], [1.047, 14.221], [0.401, 13.505], [-0.359, 11.561], [-0.680, 9.324], [-0.823, 6.726], [-1.456, 10.984], [-1.178, 13.591], [-0.443, 15.698], [0.637, 17.066], [1.406, 17.487], [1.693, 17.367], [2.022, 16.988], [3.154, 14.583], [3.533, 11.733], [3.153, 8.868], [2.064, 6.202], [0.333, 4.000], [1.017, 0.611], [1.786, 0.688], [3.533, 0.275], [4.892, -0.843], [5.753, -2.443], [6.057, -4.327], [5.861, -5.784], [5.272, -7.105], [4.290, -8.190], [2.908, -8.946], [3.271, -10.761], [3.651, -12.644], [3.769, -13.995], [3.288, -15.810], [1.963, -17.048], [0.148, -17.487], [-1.157, -17.288], [-2.284, -16.696], [-3.079, -15.758], [-3.381, -14.537], [-3.094, -13.393], [-2.402, -12.515], [-1.372, -12.137], [-0.435, -12.412], [0.266, -13.169], [0.528, -14.218], [0.021, -15.509], [-1.262, -16.042], [-1.456, -16.042], [-0.804, -16.627], [0.165, -16.825], [1.321, -16.584], [2.326, -15.930], [2.866, -15.053], [3.077, -13.599], [2.959, -12.361], [2.604, -10.743], [2.258, -9.212], [0.680, -9.410], [-0.663, -9.267], [-1.929, -8.834], [-4.090, -7.225], [-5.534, -4.886], [-6.057, -2.159], [-5.559, 0.353], [-4.386, 2.615], [-2.891, 4.542]]\n    , paths=\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0], [26, 27, 28, 29, 30, 31, 32, 26, 26], [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 33, 33], [45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 45, 45]]\n    );}",
    "description": "Okay, I'd like to design some jewelry pieces based on musical notation. I'm envisioning pendants or charms that can be customized with different musical symbols.\n\nHere's what I'd like the design to be:\n\n**Overall Structure:**\n\n*   The jewelry piece will consist of a flat, extruded shape of a musical symbol with a ring attached for a chain or clasp.\n*   I want the main shape of the musical symbol to be extruded to a certain thickness, let's say initially 2mm.\n*   The ring should be a circle attached to the main musical symbol. It should have an inner radius for the chain, and an outer radius. The ring should also be extruded to the same thickness as the symbol.\n*   I'd like the position of the ring (specifically, its center) to be adjustable relative to the symbol.\n\n**Musical Symbols:**\n\n*   I need to be able to select from several different musical symbols, including:\n    *   Treble clef (violin clef)\n    *   Bass clef\n    *   Alto clef\n    *   Sharp sign (#)\n    *   Flat sign (b)\n    *   Natural sign\n    *   Various note durations (whole, half, quarter, eighth, sixteenth, and thirty-second notes)\n    *   Various rest durations (whole, half, quarter, eighth, sixteenth, and thirty-second rests)\n*   Each of the musical symbols needs to be generated with a consistent visual style (like how all the symbols in my provided example are).\n\n**Parameters:**\n\nI'd like to have several customizable parameters:\n\n*   `symbol_type`:  A dropdown list or similar selector to choose the specific musical symbol.\n*   `note_body_height`: The base height of the note symbols. All other symbols should scale from this (like my example code does).\n*   `ring_x`: The X-coordinate of the center of the ring, relative to the musical symbol's origin (which will be somewhere close to the center).\n*   `ring_y`: The Y-coordinate of the center of the ring, relative to the musical symbol's origin.\n*  `ring_inner_radius`: The inner radius of the ring.\n*   `ring_wallthickness`: The thickness of the ring's wall.\n*   `z_height`: The extrusion height of the entire piece.\n\n**OpenSCAD Details:**\n\n*   I want this all to be in one parametric OpenSCAD file.\n*   I'd like the file to be well-commented and easy to understand.\n*   I will use the standard OpenSCAD libraries; no external libraries are needed for this design (like MCAD, BOSL, etc). I'll handle any additional libraries or .scad files myself if I decide to further extend the design.\n\nCan you generate the OpenSCAD code for this jewelry design?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Stamp Handle 02",
    "scad": "WIDTH \t= 18;\nLENGTH \t= 61;\ntranslate([-WIDTH/2,-LENGTH/2,0]) {\n\tdifference() {\n\t\tpyramid(WIDTH,LENGTH,200);\n\t   translate([0,0,5]) cube([WIDTH,LENGTH,200]);\n\t}\n\ttranslate([WIDTH/2,LENGTH/2,5]) {\n\t\trotate_extrude($fn=200) polygon(points=[[0,0],[3.5,0],[4.5,3],[3.5,6],[5.5,25],[0,27]]);\n\t\ttranslate([5,0,22]) sphere(r=1, $fn=20);\n\t}\n}\nmodule pyramid(w, l, h) {\n\tmw = w/2;\n\tml = l/2;\n\tpolyhedron(points = [\n\t\t[0, 0, 0],\n\t\t[w, 0, 0],\n\t\t[0, l, 0],\n\t\t[w, l, 0],\n\t\t[mw, ml, h]\n\t], triangles = [\n\t\t[4, 1, 0],\n\t\t[4, 3, 1],\n\t\t[4, 2, 3],\n\t\t[4, 0, 2],\n\t\t[0, 1, 2],\n\t\t[2, 1, 3]\n\t]);\n}",
    "description": "Okay, I'd like a parametric OpenSCAD file for a stamp handle.\n\nThe handle should have a tapered, pyramid-like base, and a curved, ergonomic top that incorporates a small sphere. I want to be able to adjust the overall width and length of the base, as well as the height. \n\nSpecifically:\n\n**Base:**\n*   The base should be a truncated pyramid, with a rectangular base.\n*   I want to be able to control `WIDTH` and `LENGTH` of the base rectangle.\n*   The overall height of the pyramid should also be adjustable. The pyramid should not be a full pyramid but should be cut off at a certain height.\n*   I want to control the height at which the pyramid is truncated (i.e., where the taper stops and becomes a cylinder).\n\n**Top/Handle:**\n*   The top should have a curved profile.\n*   I want a single extrusion to create a curved handle shape on the center of the top of the base. I would like to control the specific shape of the 2D profile being extruded. The profile should start and end on the X axis.\n*   I want to also be able to adjust the Z position of the extrusion.\n*   The handle should also have a small sphere on top, slightly inset. I want the sphere radius to be adjustable, and to have control over its X and Z position relative to the top of the curved handle.\n\n**Parameters:**\n*   `WIDTH`: Width of the base rectangle.\n*   `LENGTH`: Length of the base rectangle.\n*   `PYRAMID_HEIGHT`: Total height of the pyramid base.\n*   `TRUNCATION_HEIGHT`: Height at which the pyramid is truncated/becomes cylindrical.\n*   `PROFILE_POINTS`: An array of points defining the 2D profile of the curved handle.\n*   `HANDLE_Z_OFFSET`: Z offset of the curved handle from the top of the truncated pyramid.\n*   `SPHERE_RADIUS`: Radius of the sphere on top of the handle.\n*   `SPHERE_X_OFFSET`: X offset of the sphere from the center of the handle.\n*   `SPHERE_Z_OFFSET`: Z offset of the sphere from the top of the handle extrusion.\n\nI'd like the design to use the standard OpenSCAD library functions for creating the pyramid, extrusion, and sphere. I don't need any external libraries for this design.\n\nCould you provide the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Stamp Handle 01",
    "scad": "WIDTH \t= 61;\nLENGTH \t= 18;\ntranslate([0,0,1.25]) cube(size = [LENGTH,WIDTH,2.5], center = true);\ntranslate([0,0,7.25]) {\n\tdifference() {\n\t\tcolor(\"green\") cube(size = [6,WIDTH-WIDTH*0.3,10], center = true);\n\t\ttranslate([101,0,0]) cylinder(h = 10.1, r = 100, $fn=700, center = true);\n\t\ttranslate([-101,0,0]) cylinder(h = 10.1, r = 100, $fn=700, center = true);\n\t}\n}\ntranslate([5.7,-1.25,3.25]) rotate([0,0,45]){\n\tcolor(\"red\") cube([5, 1.5, 1.5], center = true);\n\ttranslate ([1.75,1.75,0]) color(\"red\") cube([1.5, 5, 1.5], center = true);\n}",
    "description": "Okay, I need a parametric OpenSCAD file for a stamp handle.\n\nThe basic design has a rectangular base, a raised grip area, and a small angled brace connecting the base and grip.\n\nThe base should be a rectangular prism, centered on the origin in x and y, with its bottom face at z=0. The base needs parameters for `WIDTH`, `LENGTH` and a thickness of 2.5, with the top of the base at 2.5.\n\nThe grip is centered on the origin, like the base, but it's taller (top at z=10+2.5=12.5) and slightly smaller than the base. The grip should also be a rectangular prism, with a length of 6 and parameters for a width offset from the base. The width of the grip should always be a fraction (e.g. 0.3) smaller than the width of the base, e.g. if the base is 60 wide and the offset is 0.3, the grip should be 60-0.3*60 = 42 wide.  The grip needs to be created with a `difference()` using the same logic described below for the brace, with a centered cylinder subtraction at each end, for a radius at least 10 times the `LENGTH` and `WIDTH` to be outside the shape. \n\nThe brace is a smaller prism, oriented diagonally. It should attach to the base at the specified point (5.7, -1.25, 3.25) and then angled up at 45 degrees to the grip. It is composed of a `cube`, and a second `cube` which is perpendicular to the first and translates up in y, both created using `rotate()`. This second `cube` should be joined to the angled `cube` at one point along the edge. It should have parameters to control the `BRACE_X`, `BRACE_Y`, and `BRACE_Z` as the location of the center of rotation and the `BRACE_WIDTH` , `BRACE_DEPTH`, and `BRACE_HEIGHT` of the angled portion of the brace and the straight portion of the brace.\n\nPlease make all dimensions parametric so I can easily adjust the overall size and proportions of the stamp handle. I'd like to be able to control the base dimensions (`WIDTH` and `LENGTH`), the grip offset factor, and the brace dimensions (`BRACE_X`, `BRACE_Y`, `BRACE_Z`, `BRACE_WIDTH`, `BRACE_DEPTH`, and `BRACE_HEIGHT`). The height of the grip should remain constant, as it's important to fit inside a stamp body.\n\nUse comments to clearly identify each part of the design (base, grip, brace). Also, it would be helpful if the final code uses the `color()` function to use the same green for the grip and red for the brace, like the example file.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Text Ring/Bracelet/Crown Thing",
    "scad": "use <write/Write.scad>\ntext = \"TEXT\";\nrounded_text = \"yes\";\nletters_inside = \"no\";\ntext_font = \"write/Letters.dxf\";\nfont_Width = 3;\ntext_percent_of_height = 70;\nletter_spacing = 22;\ninside_diameter = 20;\nWidth = 5;\nHeight = 10;\nband_OD_percent = 70;\nband_ID_percent = 100;\nband_type = \"rounded\";\nsplit_band = \"no\";\nsplit_angle = 70;\nID = inside_diameter;\nband_OD_scalar = band_OD_percent/100;\nband_ID_scalar = band_ID_percent/100;\nText_Height_Scalar = text_percent_of_height/100;\nSpacing = letter_spacing/20;\nOD = ID+(2*Width);\nText_Width = 10*Height/font_Width;\nrotate([0,0,-225])\nif (split_band == \"yes\")\n{\n\tdifference()\n\t{\n\t\tring();\n\t\tdifference()\n\t\t{\n\t\t\tdifference()\n\t\t\t{\n\t\t\tlinear_extrude(height = Height*2,center = true,convexity = 10)\n\t\t\tpolygon(points=[[0,0],\n\t\t\t\t\t\t \t    [(ID+Width)*sin(split_angle),-(ID+Width)*cos(split_angle)],\n\t\t\t\t\t  \t \t\t [(ID+Width),-(ID+Width)],\n\t\t\t\t\t\t \t\t [-(ID+Width),-(ID+Width)],\n\t                \t\t [-(ID+Width)*sin(split_angle),-(ID+Width)*cos(split_angle)]],\n\t              paths = [[0,1,2,3,4]]);\n\t\t\trotate([0,0,-split_angle])\n\t\t\ttranslate([0,-((OD+ID)/2-(OD-ID)/2*band_ID_scalar+(OD+ID)/2+(OD-ID)/2*band_OD_scalar)/4,0])\n\t\t\tscale([(Width+Height)/1,Width,Height])\n\t\t\tsphere(r=band_type==\"sharp\" ? 0.7:0.55,$fn = 30);\n\t\t\t}\n\t\trotate([0,0,split_angle])\n\t\ttranslate([0,-((OD+ID)/2-(OD-ID)/2*band_ID_scalar+(OD+ID)/2+(OD-ID)/2*band_OD_scalar)/4,0])\n\t\tscale([(Width+Height)/1,Width,Height])\n\t\tsphere(r=band_type==\"sharp\" ? 0.7:0.55,$fn = 30);\n\t\t}\n\t}\n}\nelse\n{\n\tring();\n}\nmodule ring()\n{\n\tunion()\n\t{\n\t\tcolor(\"MediumBlue\")\n\t\tdifference()\n\t\t{\n\t\t\tdifference()\n\t\t\t{\n\t\t\t\tscale([OD/Text_Width/2,OD/Text_Width/2,1*Text_Height_Scalar])\n\t\t\t\twritecylinder(text,[0,0,0],Text_Width,0,space=Spacing,rotate=0,east=180,h=Height*0.9,t=Text_Width*2,font = text_font);\n\t\t\t\tif (letters_inside == \"yes\")\n\t\t\t\t{\n\t\t\t\t\tcylinder(r=ID/2,h=Height*2,center=true,$fn=50);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcylinder(r=(ID+OD)/4,h=Height*2,center=true,$fn=50);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rounded_text == \"yes\")\n\t\t\t{\n\t\t   \tdifference()\n\t\t\t\t{\n\t\t\t\t\tdifference()\n\t\t\t\t\t{\n\t\t\t\t\t\tcylinder(r=OD*2,h=Height*2,center = true,$fn = 50);\n\t\t\t\t\t\tcylinder(r=(ID+OD)/4,h=Height*3,center=true,$fn = 50);\n\t\t\t\t\t}\n\t\t\t\t\tdonut(ID,OD,Height);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdifference()\n\t\t\t\t{\n\t\t\t\t\tcylinder(r=OD*2,h=2*Height,center = true,$fn=50);\n\t\t\t\t\tcylinder(r=OD/2,h=3*Height,center = true,$fn=50);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (band_type == \"rounded\")\n\t\t{\n\t\t\tdonut((OD+ID)/2-(OD-ID)/2*band_ID_scalar,(OD+ID)/2+(OD-ID)/2*band_OD_scalar,Height);\n\t\t}\n\t\tif (band_type == \"sharp\")\n\t\t{\n\t\t\ttube((OD+ID)/2-(OD-ID)/2*band_ID_scalar,(OD+ID)/2+(OD-ID)/2*band_OD_scalar,Height);\n\t\t}\n\t\tif (band_type == \"tube\")\n\t\t{\n\t\t\tdonut((OD+ID)/2-(OD-ID)/2*band_ID_scalar,(OD+ID)/2+(OD-ID)/2*band_OD_scalar,(OD-ID)/4*(band_ID_scalar+band_OD_scalar));\n\t\t}\n\t}\n}\nmodule donut(ID,OD,height)\n{\n\tscale([1,1,height/((OD-ID)/2)])\n\trotate_extrude(convexity = 10,$fn = 50)\n\ttranslate([(ID+OD)/4,0,0])\n\trotate(r=[0,90,0])\n\tcircle(r=((OD-ID)/2)*0.5,$fn = 20);\n}\nmodule tube(ID,OD,height)\n{\n\tdifference()\n\t{\n\t\tcylinder(r=OD/2,h=height,center = true,$fn=50);\n\t\tcylinder(r=ID/2,h=height+1,center=true,$fn=50);\n\t}\n}",
    "description": "Okay, I'm looking to create a custom ring with some text on it using OpenSCAD. I've seen a design before that gets pretty close to what I want, but I'd like something a little more tailored.\n\nHere are the key features and parameters I'd like to be able to control:\n\n**Text:**\n\n*   **Text Content:** I need to be able to specify the text that appears on the ring. It should be a string.\n*   **Text Appearance:**\n    *   I want the option to make the text have rounded edges, or keep them sharp.\n    *   I need to choose whether the text is engraved *into* the ring or is raised *from* the ring. I would like to refer to these options as 'inside' and 'outside'.\n*   **Font:** I need to be able to choose from different font styles. The available styles should include, at minimum: 'Letters.dxf', 'orbitron.dxf', 'knewave.dxf', 'braille.dxf', and 'Blackrose.dxf'. These all seem to come from the `Write.scad` library.\n*   **Font Size:** I need to adjust the text height as a percentage of the total ring height. Also, I'll need to control the width of the font characters as well as the spacing between letters. I should be able to specify an actual number for font width and letter spacing.\n\n**Ring Size & Shape:**\n\n*   **Inner Diameter:** I need to be able to specify the inner diameter of the ring.\n*   **Width:**  I need to specify the radial width of the ring.\n*   **Height:** I need to specify the height or thickness of the ring.\n*   **Band Dimensions:**\n    *   I need to control how much the band extrudes outwards. I'd like to be able to set the percentage that this band protrudes from the inner diameter of the ring and the outside diameter of the ring. These should be independent values.\n*   **Band Style:**\n    *   I want to choose the cross-sectional style of the ring band. The options should be 'tube', 'rounded' and 'sharp'. The first should create a cylindrical band, the second a rounded band and the third a sharp edged band.\n\n**Ring Customization:**\n\n*   **Split Band:** I would like to be able to optionally split the ring into two pieces.\n    *   If the ring is split, I'd like to set the angle of the split.\n\nEssentially, I'm looking for a parametric ring generator that uses the `Write.scad` library to inscribe text on a customizable band.\n\nI'd like the code to be as clear and well-commented as possible. I prefer to name the variables something readable, and have them match the descriptions above.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Android Figure Customizable",
    "scad": "$fn=50;\nbody_height = 39;\nbody_r = 22.5;\nneck_height = 4;\nneck_r = 20;\nsholder_r = 2.5;\nleg_spacing = 7;\neye_r = 4;\neye_height_addition = 0;\nantenna_lengte = 7;\nantenna_angle = 25;\nantenna_thick_r = 2;\nprint_mode = 0;\nsholder_width = 60/1;\nsholder_length = 15/1;\nsholder_height = 30.5/1;\narm_afstand_body = 2/1;\narm_thick_r = 5/1;\narm_lengte = 30/1;\narm_height_vanaf_bottom_body = 11/1;\narm_height_vanaf_bottom_body_wave = 21/1;\nwave = 10/1;\nleg_thick = 9/1;\nleg_thick_r = 4.5/1;\nleg_height = 9;\nleg_depth = 32/1;\nstart();\nmodule start(){\n\tif (print_mode == 0){\n\t\tandroid();\n\t} else {\n\t\tprint1();\n\t\tprint2();\n\t\tprint3();\n\t}\n}\nmodule print1(){\n\ttranslate([-50,0,-body_height]) neck();\n\ttranslate([-30,45,-body_height-neck_height]) head();\n}\nmodule print2(){\n\ttranslate([0,0,body_height])\n\trotate(180,[1,0,0]){\n\t\tbody();\n\t\tlegs();\n \t}\n}\nmodule print3(){\n\ttranslate([-20,-30,arm_thick_r]){\n\t\trotate(90,[0,1,0]) rotate(90,[1,0,0]) arm_sholder(0,1);\n\t}\n\ttranslate([20,-20,arm_thick_r]){\n\t\trotate(-90,[0,1,0]) rotate(90,[1,0,0]) arm_sholder(1,1);\n\t}\n}\nmodule android(){\n\tbody();\n\tneck();\n\thead();\n\ttranslate([body_r + arm_afstand_body + arm_thick_r,0,arm_height_vanaf_bottom_body]) {\n\t\tarm_sholder(0,0);\n\t}\n\ttranslate([-(body_r + arm_afstand_body + arm_thick_r),0,arm_height_vanaf_bottom_body]){\n\t\tarm_sholder(1,0);\n\t}\n\tlegs();\n}\nmodule body(print){\n\tdifference(){\n\t\tcolor(\"lime\") cylinder(body_height,body_r,body_r);\n\t\tsholders_diff();\n\t}\n}\nmodule neck(){\n  \ttranslate([0,0,body_height])\n  \tcolor(\"white\") cylinder(neck_height, neck_r, neck_r);\n}\nmodule head(){\n  translate([0,0,body_height + neck_height]){\n     difference(){\n  \tscale([1,1,0.8]){\n      \tcolor(\"lime\") sphere(body_r);\n      }\n        translate([0,0,-(body_height + neck_height + 1)])\n    \tcylinder((body_height + neck_height + 1),body_r + 1,body_r + 1);\n    }\n  }\n  antennas();\n  eyes();\n}\nmodule arm_sholder(isLeft,isPrint){\n\tif (isLeft == 1){\n\t\ttranslate([0,0,wave]) {color(\"lime\") cylinder(arm_lengte, arm_thick_r, arm_thick_r);}\n\t\ttranslate([sholder_length,0,-arm_height_vanaf_bottom_body + sholder_height]){\n\t\trotate(-90,[0,1,0])\n  \t\tcolor(\"white\") cylinder(sholder_length,sholder_r,sholder_r);}\n\t} else {\n  \t\tcolor(\"lime\") cylinder(arm_lengte, arm_thick_r, arm_thick_r);\n\t\ttranslate([-sholder_length,0,-arm_height_vanaf_bottom_body + sholder_height])\n\t  \trotate(90,[0,1,0])\n  \t\tcolor(\"white\") cylinder(sholder_length,sholder_r,sholder_r);\n\t}\n}\nmodule sholders_diff(){\n\tdifference(){\n\t\ttranslate([-(sholder_width/2),0,sholder_height])\n\t  \trotate(90,[0,1,0])\n  \t\tcolor(\"white\") cylinder(sholder_width,sholder_r,sholder_r);\n\t\ttranslate([-(sholder_width/6),-5,sholder_height-5]) cube([sholder_width/3,10,10]);\n\t}\n}\nmodule antennas(){\n  translate([10,0,15 + neck_height + body_height])\n  rotate([0,antenna_angle,0])\n  color(\"lime\") cylinder(antenna_lengte, antenna_thick_r, antenna_thick_r);\n  translate([-10,0,15+ neck_height + body_height])\n  rotate([0,-antenna_angle,0])\n  color(\"lime\") cylinder(antenna_lengte, antenna_thick_r, antenna_thick_r);\n}\nmodule eyes(){\n  translate([9,-15,9 + neck_height + body_height + eye_height_addition])\n  color(\"white\") sphere(eye_r);\n  translate([-9,-15,9 + neck_height + body_height + eye_height_addition])\n  color(\"white\") sphere(eye_r);\n}\nmodule legs(){\n  translate([(leg_spacing/2) + leg_thick_r, (leg_depth/2), -leg_height])\n  rotate(90,[1,0,0])\n  color(\"lime\") cylinder(32, leg_thick_r, leg_thick_r);\n  translate([-((leg_spacing/2) + leg_thick_r), (leg_depth/2), -leg_height])\n  rotate(90,[1,0,0])\n  color(\"lime\") cylinder(32, leg_thick_r, leg_thick_r);\n  translate([(leg_spacing/2), -(leg_depth/2),-leg_height])\n  color(\"lime\") cube([leg_thick,leg_depth,leg_height]);\n  translate([-(leg_spacing/2 + leg_thick), -(leg_depth/2),-leg_height])\n  color(\"lime\") cube([leg_thick,leg_depth,leg_height]);\n}",
    "description": "Okay, I'd like to design a customizable Android figure for 3D printing, similar to the one I've seen online. I need an OpenSCAD file that allows me to adjust various dimensions. Here are the features I'd like to be able to control with parameters:\n\n*   **Body:**\n    *   Body height\n    *   Body radius (think of it as thickness or fatness)\n*   **Neck:**\n    *   Neck height\n    *   Neck radius\n*   **Shoulders:**\n    *   Shoulder radius\n*   **Legs:**\n    *   Spacing between the legs\n*   **Eyes:**\n    *   Eye radius\n    *   Vertical adjustment of the eyes' height relative to the head\n*   **Antennas:**\n    *   Antenna length\n    *   Antenna angle (relative to vertical)\n    *   Antenna thickness (radius)\n\nAdditionally, I'd like the design to include:\n\n*   **Arms:**\n    *   The arms should be attached to a kind of rounded \"shoulder\" piece.\n    *   I need to control the height of the arms relative to the bottom of the body.\n    *   There should be two arm positions to choose from: down (resting) and a waving position (raised up a little).\n    *   The arm itself should be a cylinder.\n    *   I need to adjust the length and radius of the arm and the size and length of the rounded shoulder attachment.\n*   **Legs:**\n    *   The legs should have a kind of \"foot\" at the bottom. The depth of this foot needs to be a parameter I can adjust, as well as the overall height of the legs. The thickness of the leg pieces should also be a parameter.\n\nThe main figure should be constructed from basic shapes - cylinders, spheres, cubes, etc., and I need to be able to specify the \"starting height\" for the shoulders relative to the bottom of the body.\n\nFinally, I'd like to have a \"print mode\" option. In print mode, the design should output each part separately (body, head, arms, legs), translated to different positions so I can print them easily, rather than as a single assembled object.\n\nI'm not looking for anything overly complex, but I do need all of the dimensions to be controlled with parameters. I'd like the default values to be reasonable for a classic android design. I'm not using any external libraries, so everything should be made with standard OpenSCAD functions.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Custom Letter Earings or bracelet bangles",
    "scad": "LETTER=\"A\";\nmodule EARINGMOUNT(h){\n\tdifference(){\n\t\tcylinder(r=2.5,h=h,$fn=50);\n\t\ttranslate([0,0,-h]) cylinder(r=1.75,h=h*3,$fn=50);\n\t}\n}\nmodule bA(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    difference()\n    {\n       linear_extrude(height=h)\n         polygon([[-3.581547,-3.787202],[-3.316699,-5.149251],[-2.597507,-6.208336],[-1.569399,-6.924548],[-0.377804,-7.257982],[0.831850,-7.168728],[1.914135,-6.616881],[2.723622,-5.562531],[3.114883,-3.965772],[3.274426,-1.560141],[3.123115,0.907052],[2.246278,6.033457],[1.201067,11.428105],[0.704173,17.105658],[1.136402,20.081183],[1.954821,22.286651],[3.086347,23.830295],[4.457900,24.820344],[5.996397,25.365031],[7.628758,25.572587],[10.882743,25.409228],[14.217704,24.924179],[16.074546,24.374559],[17.782808,23.357593],[19.136375,21.676323],[19.929130,19.133787],[19.954958,15.533025],[19.007743,10.677078],[16.913079,5.691028],[14.568896,1.056543],[12.747706,-3.477495],[12.274644,-5.785320],[12.222023,-8.162202],[12.215560,-12.243413],[13.204173,-16.108632],[14.375943,-18.104151],[14.984510,-19.945312],[15.040445,-21.598007],[14.554318,-23.028131],[13.536701,-24.201575],[11.998162,-25.084235],[9.949273,-25.642003],[7.400603,-25.840772],[-5.724397,-25.572922],[-9.296519,-25.280764],[-11.893601,-24.689135],[-13.631571,-23.841229],[-14.626359,-22.780241],[-14.993893,-21.549364],[-14.850101,-20.191792],[-13.492257,-17.269342],[-12.107471,-14.636115],[-11.322635,-12.258951],[-11.051543,-10.071901],[-11.207993,-8.009012],[-12.458698,-3.991918],[-14.385117,0.319938],[-17.807924,8.418888],[-19.171507,12.642927],[-19.954958,16.658596],[-19.897090,20.222334],[-19.471039,21.758617],[-18.736714,23.090582],[-17.661464,24.187785],[-16.212642,25.019780],[-14.357599,25.556123],[-12.063687,25.766368],[-9.084989,25.840772],[-6.649212,25.488721],[-4.714315,24.759752],[-3.238255,23.703402],[-2.178991,22.369208],[-1.494479,20.806709],[-1.142678,19.065439],[-1.081547,17.194938],[-1.498585,11.022693],[-2.448633,5.476654],[-3.340137,0.544222],[-3.581547,-3.787202]]);\n       translate([0, 0, -fudge])\n         linear_extrude(height=h+2*fudge)\n           polygon([[-2.599397,-15.215772],[-2.368184,-17.233394],[-1.729682,-18.624941],[-0.831280,-19.416814],[0.179633,-19.635412],[1.155668,-19.307136],[1.949434,-18.458388],[2.413542,-17.115566],[2.400603,-15.305072]]);\n    }\n  }\n}\nmodule bB(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    difference()\n    {\n       linear_extrude(height=h)\n         polygon([[-14.447872,9.187377],[-15.975552,13.591909],[-16.459739,17.264197],[-16.017398,20.239297],[-14.765490,22.552259],[-12.820979,24.238139],[-10.300827,25.331988],[-7.321997,25.868859],[-4.001452,25.883807],[2.093654,25.216844],[6.900749,23.927787],[10.558224,22.153510],[13.204469,20.030892],[14.977876,17.696807],[16.016835,15.288132],[16.459739,12.941743],[16.444978,10.794517],[16.271725,6.898909],[15.786514,3.408879],[15.023391,0.277963],[14.016401,-2.540306],[11.407007,-7.424757],[8.230698,-11.616193],[9.847088,-14.444549],[10.782933,-17.068992],[11.000909,-19.440935],[10.463693,-21.511792],[9.133958,-23.232975],[6.974382,-24.555900],[3.947640,-25.431978],[0.016408,-25.812623],[-4.025570,-25.883807],[-8.733592,-25.455483],[-11.883466,-24.621341],[-12.831110,-24.036992],[-13.409061,-23.354058],[-13.653695,-22.582240],[-13.601387,-21.731238],[-12.751452,-19.830483],[-10.975380,-16.721890],[-9.881460,-13.435345],[-9.412634,-9.985732],[-9.511844,-6.387937],[-10.122031,-2.656843],[-11.186137,1.192663],[-14.447872,9.187377]]);\n       translate([0, 0, -fudge])\n         linear_extrude(height=h+2*fudge)\n           polygon([[0.194978,-15.098343],[1.387611,-15.899823],[1.962564,-16.951023],[2.035978,-18.063605],[1.723996,-19.049234],[1.142763,-19.719573],[0.408420,-19.886285],[-0.362890,-19.361034],[-1.055022,-17.955483]]);\n       translate([0, 0, -fudge])\n         linear_extrude(height=h+2*fudge)\n           polygon([[0.016408,-8.134053],[1.779266,-8.063768],[3.012323,-7.130061],[3.717481,-5.655104],[3.896644,-3.961071],[3.551715,-2.370133],[2.684597,-1.204464],[1.297193,-0.786236],[-0.608592,-1.437623]]);\n    }\n  }\n}\nmodule bC(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[2.725136,-25.671364],[1.404672,-25.757206],[0.093542,-25.542053],[-2.472097,-24.285467],[-4.914553,-22.055023],[-7.176597,-19.004138],[-9.201000,-15.286228],[-10.930532,-11.054710],[-12.307967,-6.463001],[-13.276075,-1.664517],[-13.777627,3.187323],[-13.755395,7.939105],[-13.152149,12.437410],[-11.910662,16.528822],[-9.973705,20.059925],[-7.284048,22.877301],[-5.639074,23.970399],[-3.784464,24.827534],[-1.713065,25.429528],[0.582276,25.757206],[3.179533,25.731771],[5.462907,25.264829],[7.443627,24.394000],[9.132922,23.156901],[10.542023,21.591151],[11.682158,19.734369],[12.564556,17.624172],[13.200448,15.298179],[13.777627,10.149278],[13.503530,4.588613],[12.467992,-1.082870],[10.760846,-6.564224],[10.332907,-7.184717],[9.804651,-7.215322],[8.554346,-6.134372],[7.224257,-4.576384],[6.596269,-4.010690],[6.028706,-3.796364],[2.610699,-4.161141],[0.260588,-5.243646],[-1.186866,-6.875250],[-1.896905,-8.887326],[-2.034769,-11.111246],[-1.765700,-13.378382],[-0.667724,-17.367794],[0.529445,-19.094714],[2.152669,-19.807512],[2.947823,-19.705373],[3.638017,-19.255810],[4.152759,-18.427526],[4.421556,-17.189224],[4.944169,-15.012232],[5.907963,-13.737195],[7.148429,-13.224133],[8.501056,-13.333069],[9.801336,-13.924024],[10.884757,-14.857020],[11.586811,-15.992079],[11.742986,-17.189224],[11.545042,-19.853490],[11.193989,-21.106489],[10.535123,-22.276440],[9.463624,-23.340623],[7.874672,-24.276317],[5.663450,-25.060804],[2.725136,-25.671364]]);\n  }\n}\nmodule bD(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    difference()\n    {\n       linear_extrude(height=h)\n         polygon([[-15.610292,18.035715],[-12.696101,11.369670],[-10.934518,5.237119],[-10.136852,-0.318930],[-10.114415,-5.255471],[-10.678516,-9.529499],[-11.640466,-13.098006],[-12.811574,-15.917987],[-14.003152,-17.946435],[-15.050575,-20.434356],[-14.922335,-22.314640],[-13.887628,-23.671211],[-12.215646,-24.587992],[-10.175585,-25.148909],[-8.036638,-25.437886],[-4.538862,-25.535715],[-0.411328,-25.033303],[2.953471,-23.961710],[5.669322,-22.395094],[7.850010,-20.407610],[9.609321,-18.073416],[11.061040,-15.466670],[13.496848,-9.732145],[15.259517,-2.017028],[15.779198,4.840236],[15.591286,7.933595],[15.114668,10.796196],[14.356693,13.422610],[13.324708,15.807404],[12.026059,17.945147],[10.468095,19.830409],[8.658163,21.457757],[6.603610,22.821762],[4.311783,23.916991],[1.790031,24.738014],[-0.954300,25.279399],[-3.913862,25.535715],[-6.205186,25.299136],[-8.488629,24.767171],[-12.573767,23.007326],[-14.146408,21.874571],[-15.253061,20.636676],[-15.779198,19.341203],[-15.610292,18.035715]]);\n       translate([0, 0, -fudge])\n         linear_extrude(height=h+2*fudge)\n           polygon([[-1.592432,-17.142865],[-0.649983,-17.178869],[0.205844,-16.898898],[1.633737,-15.562727],[2.643457,-13.477743],[3.187215,-10.987335],[3.217222,-8.434895],[2.685689,-6.163813],[1.544828,-4.517479],[0.730964,-4.035903],[-0.253152,-3.839285],[-1.115731,-7.014394],[-1.536082,-10.315853],[-1.592432,-17.142865]]);\n    }\n  }\n}\nmodule bE(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[5.929162,-11.753980],[6.018462,-13.718270],[5.929165,-14.477196],[5.572022,-15.057552],[4.054162,-15.682550],[1.732732,-16.307550],[0.686605,-16.991158],[0.343089,-17.747162],[0.560911,-18.471999],[1.198800,-19.062107],[2.115485,-19.413922],[3.169693,-19.423881],[4.220152,-18.988421],[5.125592,-18.003980],[6.021808,-16.985798],[7.010202,-16.328613],[8.018693,-16.021296],[8.975204,-16.052720],[9.807657,-16.411757],[10.443973,-17.087279],[10.812074,-18.068159],[10.839882,-19.343270],[10.283775,-21.450308],[9.095289,-23.408777],[7.529099,-24.896992],[5.839882,-25.593270],[-1.077835,-25.771118],[-7.463688,-25.414690],[-9.814011,-24.771794],[-10.753499,-24.148713],[-11.458306,-23.306253],[-11.870260,-22.230697],[-11.931187,-20.908326],[-11.582914,-19.325423],[-10.767268,-17.468270],[-9.587275,-14.862864],[-8.755645,-12.243717],[-8.282712,-9.561011],[-8.178807,-6.764925],[-8.454263,-3.805641],[-9.119412,-0.633339],[-11.660118,6.549590],[-13.682986,12.208211],[-14.299489,15.194170],[-14.298976,18.083439],[-13.416151,20.725174],[-12.560966,21.906077],[-11.385717,22.968531],[-9.857242,23.893679],[-7.942378,24.662667],[-2.820838,25.656740],[2.451908,25.771118],[5.031406,25.572394],[7.447907,25.017749],[9.607600,23.968202],[11.416675,22.284768],[12.781322,19.828465],[13.607732,16.460310],[14.299489,10.315807],[13.875592,2.353160],[12.714882,-4.611120],[12.058367,-6.754642],[10.853852,-8.698936],[10.089602,-9.326829],[9.240564,-9.581464],[8.324139,-9.355023],[7.357732,-8.539690],[6.296763,-7.104410],[5.083023,-5.828451],[3.466459,-5.171506],[2.428978,-5.218818],[1.197022,-5.593270],[0.433104,-6.617996],[0.449593,-8.271538],[0.832661,-9.095804],[1.509438,-9.791301],[2.512792,-10.262705],[3.875592,-10.414690],[5.436849,-10.549866],[5.837696,-10.997233],[5.929162,-11.753980]]);\n  }\n}\nmodule bF(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[-5.644681,24.910715],[1.766039,25.267855],[3.999898,25.233611],[5.872731,24.905151],[7.410512,24.315569],[8.639215,23.497960],[9.584815,22.485415],[10.273287,21.311028],[10.982742,18.609104],[10.975378,15.656934],[10.458988,12.719266],[9.641370,10.060847],[8.730319,7.946425],[4.927931,0.198891],[3.491090,-3.623209],[3.102767,-5.433401],[3.016039,-7.142855],[3.192414,-8.193046],[3.860648,-8.989056],[4.954789,-9.486965],[6.408889,-9.642855],[8.060328,-10.000270],[8.429702,-10.504917],[8.462469,-11.250005],[8.462469,-12.857145],[8.305451,-13.924973],[7.932504,-14.596643],[6.587469,-15.267855],[4.884934,-15.912737],[3.927031,-16.688058],[3.610172,-17.461982],[3.830773,-18.102675],[4.485245,-18.478301],[5.470005,-18.457025],[6.681465,-17.907011],[8.016039,-16.696425],[9.623179,-15.089285],[10.564320,-14.434575],[11.414465,-14.208233],[12.154817,-14.337435],[12.766576,-14.749361],[13.529131,-16.130094],[13.551749,-17.767855],[12.549028,-20.366459],[11.313972,-22.687319],[10.361934,-23.647661],[9.054948,-24.423446],[7.294061,-24.976302],[4.980319,-25.267855],[-2.608961,-25.267855],[-5.904874,-24.662860],[-7.093540,-24.036382],[-7.963060,-23.227135],[-8.503720,-22.260032],[-8.705805,-21.159985],[-8.559600,-19.951908],[-8.055391,-18.660715],[-6.953127,-16.050660],[-6.375588,-13.350761],[-6.252956,-10.570642],[-6.515410,-7.719926],[-7.916295,-1.845201],[-10.019681,4.196425],[-11.793259,9.036822],[-12.852183,12.205954],[-13.551749,15.520035],[-13.536368,18.713308],[-13.149452,20.181592],[-12.450455,21.520016],[-11.394927,22.695360],[-9.938421,23.674404],[-8.036489,24.423929],[-5.644681,24.910715]]);\n  }\n}\nmodule bG(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[12.901421,-9.762988],[12.674411,-2.374596],[12.864042,5.013797],[14.062131,19.790582],[14.178239,21.695689],[13.748425,22.993124],[12.919050,23.757614],[11.836476,24.063884],[10.647064,23.986661],[9.497176,23.600672],[8.533174,22.980644],[7.901421,22.201302],[5.171227,23.784615],[2.663307,24.879117],[0.369932,25.530286],[-1.716631,25.783599],[-3.604110,25.684531],[-5.300238,25.278562],[-8.149358,23.727822],[-10.325837,21.495195],[-11.891519,18.944497],[-12.908248,16.439544],[-13.437869,14.344152],[-14.137246,6.105445],[-14.178239,-0.867862],[-13.675336,-6.686806],[-12.743018,-11.462420],[-11.495771,-15.305739],[-10.048080,-18.327799],[-8.514428,-20.639634],[-7.009299,-22.352278],[-3.570024,-24.704675],[-0.290148,-25.767932],[2.726421,-25.783599],[5.375773,-24.993223],[7.554001,-23.638355],[9.157195,-21.960542],[10.081448,-20.201334],[10.222851,-18.602278],[9.865701,-15.923698],[9.408635,-15.059873],[8.519441,-14.422511],[6.059901,-13.855111],[3.717548,-14.277362],[2.974838,-14.877064],[2.722851,-15.745128],[2.633551,-17.530848],[2.188501,-18.899565],[1.149162,-19.396667],[-0.107803,-18.983185],[-1.205729,-17.620148],[-2.499811,-14.145777],[-3.241838,-11.230974],[-3.487892,-8.849947],[-3.294054,-6.976903],[-2.716408,-5.586050],[-1.811036,-4.651593],[-0.634019,-4.147740],[0.758561,-4.048698],[1.824025,-4.238711],[2.593855,-4.669140],[3.324708,-5.929691],[3.107310,-7.187246],[2.691826,-7.613929],[2.097851,-7.798698],[0.764958,-7.931030],[-0.031997,-8.422936],[-0.376948,-9.153850],[-0.353828,-10.003205],[0.460893,-11.574970],[1.084627,-12.056248],[1.740701,-12.173698],[8.883561,-12.173698],[10.733248,-11.915540],[12.000158,-11.460332],[12.713235,-10.759130],[12.901421,-9.762988]]);\n  }\n}\nmodule bH(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[-3.471558,-6.651775],[-3.092443,-7.960791],[-2.397341,-8.948058],[-1.480419,-9.589043],[-0.435847,-9.859213],[0.642208,-9.734034],[1.659577,-9.188973],[2.522091,-8.199498],[3.135582,-6.741075],[3.372195,-4.316973],[3.144593,-1.196549],[2.153442,5.848225],[1.490526,11.504657],[1.310926,14.697496],[1.400676,17.836546],[1.885861,20.699154],[2.892565,23.062667],[4.546874,24.704432],[5.656282,25.185079],[6.974872,25.401795],[12.332012,25.669655],[15.704904,25.170207],[17.971095,23.953752],[19.302541,22.150397],[19.871196,19.890252],[19.849015,17.303426],[19.407954,14.520025],[17.957012,8.883935],[16.450515,2.786370],[15.035432,-3.353853],[14.720346,-6.607109],[14.857924,-10.071609],[15.591436,-13.814211],[17.064152,-17.901775],[17.779400,-20.427800],[17.894887,-21.759970],[17.736889,-23.023486],[17.221362,-24.132280],[16.264260,-25.000282],[14.781538,-25.541423],[12.689152,-25.669635],[6.885582,-25.312495],[5.055472,-24.937346],[3.986181,-24.105705],[3.585340,-22.872994],[3.760582,-21.294635],[4.296302,-17.812495],[4.226888,-16.315917],[3.331457,-15.464734],[0.635582,-14.776775],[-1.048377,-14.685901],[-2.669152,-15.003528],[-3.301022,-15.417509],[-3.731310,-16.055993],[-3.898084,-16.959771],[-3.739418,-18.169635],[-3.203698,-21.294635],[-3.024057,-22.662495],[-3.337542,-23.995986],[-4.700177,-25.072552],[-7.667988,-25.669635],[-12.221558,-25.758935],[-14.479671,-25.411963],[-16.180657,-24.528888],[-17.397628,-23.077796],[-18.203698,-21.026775],[-18.134166,-19.036824],[-17.559740,-16.813333],[-15.869198,-11.426812],[-15.239576,-8.144325],[-15.078049,-4.389381],[-15.627864,-0.102250],[-17.132268,4.776795],[-18.896934,10.250308],[-19.573465,13.601643],[-19.871196,16.995597],[-19.608927,20.156844],[-18.605458,22.810058],[-17.769150,23.860114],[-16.679592,24.679914],[-15.314135,25.235043],[-13.650128,25.491085],[-8.382268,25.758935],[-5.593834,25.315298],[-3.581502,24.031756],[-2.242367,22.052032],[-1.473526,19.519853],[-1.172072,16.578943],[-1.235101,13.373028],[-2.042988,6.741085],[-3.355499,0.044655],[-3.663828,-3.303559],[-3.471558,-6.651775]]);\n  }\n}\nmodule bI(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[1.392301,26.112013],[3.694860,26.017900],[5.615264,25.573543],[7.182211,24.817942],[8.424402,23.790093],[9.370534,22.528993],[10.049305,21.073639],[10.719560,17.736162],[10.664756,14.089639],[10.114481,10.446049],[8.445871,4.415583],[6.205797,-2.255526],[5.662737,-4.785820],[5.483379,-6.997837],[5.652010,-9.055498],[6.152919,-11.122726],[8.088721,-15.941567],[9.243094,-20.141750],[9.309061,-21.694712],[9.090447,-22.933151],[8.629431,-23.894740],[7.968187,-24.617152],[6.213721,-25.495137],[0.948572,-26.112013],[-1.569601,-26.077250],[-3.964849,-25.673707],[-5.482687,-25.174349],[-6.768504,-24.423794],[-7.788443,-23.465915],[-8.508641,-22.344587],[-8.895241,-21.103685],[-8.914382,-19.787082],[-8.532204,-18.438655],[-7.714849,-17.102277],[-5.900824,-13.566049],[-4.924009,-10.385637],[-4.636105,-7.499276],[-4.888816,-4.845206],[-5.533844,-2.361662],[-6.422890,0.013117],[-8.339849,4.683433],[-10.132715,11.195649],[-10.719560,16.217053],[-10.273482,19.945388],[-8.967580,22.578396],[-6.974952,24.313819],[-4.468697,25.349402],[-1.621913,25.882886],[1.392301,26.112013]]);\n  }\n}\nmodule bJ(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[12.031990,-17.008935],[10.175635,-12.171787],[9.261821,-8.166294],[9.089255,-4.814843],[9.456643,-1.939821],[11.006103,3.091382],[11.785587,5.602789],[12.299850,8.348215],[13.168295,14.164515],[12.856108,18.565704],[11.631837,21.752097],[9.764030,23.924011],[7.521237,25.281764],[5.172005,26.025670],[1.228420,26.473215],[-1.960546,26.187803],[-4.673485,25.390245],[-6.943132,24.139927],[-8.802224,22.496235],[-10.283496,20.518556],[-11.419683,18.266276],[-12.243521,15.798781],[-12.787745,13.175456],[-13.168295,7.698865],[-12.823218,2.311591],[-12.014398,-2.511275],[-11.003720,-6.294645],[-10.373142,-7.174839],[-9.173366,-7.577680],[-7.906624,-7.539896],[-7.075150,-7.098215],[-4.843010,-4.955355],[-3.358724,-4.189448],[-2.103059,-4.182391],[-1.092432,-4.831586],[-0.343259,-6.034432],[0.128044,-7.688332],[0.305059,-9.690685],[0.171370,-11.938893],[-0.289440,-14.330355],[-1.197246,-18.014363],[-1.820294,-21.534848],[-1.686487,-23.072951],[-1.075234,-24.377193],[0.148882,-25.383246],[2.121280,-26.026785],[6.049850,-26.473215],[8.293092,-26.382550],[10.079699,-25.876830],[11.424350,-25.007530],[12.341723,-23.826124],[12.846495,-22.384086],[12.953345,-20.732893],[12.676951,-18.924017],[12.031990,-17.008935]]);\n  }\n}\nmodule bK(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[-14.446754,7.326595],[-12.131813,2.140316],[-11.291534,-0.761353],[-10.757564,-3.804322],[-10.601036,-6.940302],[-10.893087,-10.121002],[-11.704851,-13.298133],[-13.107464,-16.423405],[-14.289730,-18.804347],[-14.933590,-20.738380],[-15.115436,-22.277829],[-14.911660,-23.475018],[-14.398653,-24.382275],[-13.652809,-25.051923],[-11.768174,-25.887695],[-7.394322,-26.331828],[-5.393211,-26.182269],[-3.553894,-25.709125],[-2.219774,-24.987826],[-1.348228,-24.103453],[-0.866670,-23.084335],[-0.702514,-21.958803],[-1.036059,-19.501815],[-1.768174,-16.959125],[-2.293804,-14.978022],[-2.118585,-13.520437],[-1.449292,-12.606031],[-0.492701,-12.254466],[0.544410,-12.485402],[1.455266,-13.318500],[2.033090,-14.773420],[2.071106,-16.869825],[1.672780,-19.218293],[1.564561,-21.494236],[1.796069,-22.560803],[2.312295,-23.556190],[3.183971,-24.462715],[4.481826,-25.262695],[7.024140,-26.053067],[9.009412,-26.356030],[12.160396,-26.244835],[14.046139,-25.948189],[15.259836,-25.173926],[15.864930,-24.026255],[15.924863,-22.609386],[15.503076,-21.027529],[14.663014,-19.384893],[13.468116,-17.785688],[11.981826,-16.334125],[8.946111,-14.053507],[5.910396,-11.423405],[4.573981,-9.637247],[4.635445,-8.239390],[5.445992,-7.049613],[6.356826,-5.887695],[10.822540,-0.845857],[12.668980,1.842374],[14.231564,4.678287],[15.490609,7.688987],[16.426431,10.901582],[17.019348,14.343176],[17.249676,18.040875],[17.078749,20.240319],[16.420716,22.246728],[15.264248,23.940263],[13.598016,25.201085],[11.914984,25.857557],[10.104162,26.148945],[8.262446,26.042527],[6.486733,25.505579],[4.873918,24.505378],[3.520898,23.009201],[2.524568,20.984325],[1.981826,18.398025],[1.907044,15.117558],[2.077096,10.224210],[2.177188,4.998125],[1.892526,0.719445],[1.462308,-1.868842],[0.664631,-3.359937],[-0.350978,-3.915143],[-1.434995,-3.695762],[-2.437892,-2.863096],[-3.210143,-1.578446],[-3.602223,-0.003115],[-3.464604,1.701595],[-1.036130,10.841464],[-0.357260,15.322169],[-0.339407,17.508923],[-0.607464,19.648025],[-1.264283,21.942469],[-2.492438,23.766001],[-4.156961,25.113112],[-6.122887,25.978292],[-8.255252,26.356030],[-10.419088,26.240816],[-12.479431,25.627142],[-14.301314,24.509495],[-15.540004,23.158032],[-16.451453,21.458353],[-17.024923,19.470794],[-17.249676,17.255693],[-17.114974,14.873385],[-16.610078,12.384209],[-15.724251,9.848500],[-14.446754,7.326595]]);\n  }\n}\nmodule bL(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[-11.743680,7.564126],[-9.987351,1.758136],[-8.562089,-4.038115],[-8.318445,-6.922446],[-8.571373,-9.792173],[-9.458806,-12.643237],[-11.118680,-15.471584],[-12.606617,-18.928318],[-12.821505,-20.441748],[-12.681149,-21.810859],[-12.183653,-23.034882],[-11.327124,-24.113049],[-10.109668,-25.044589],[-8.529390,-25.828734],[-5.591710,-26.581986],[0.131320,-26.453734],[2.023578,-26.104626],[3.709945,-25.259813],[4.308946,-24.630251],[4.656106,-23.851245],[4.684637,-22.914288],[4.327750,-21.810874],[1.470610,-14.489444],[0.990028,-11.651638],[1.031723,-8.894465],[1.739289,-6.680317],[2.387647,-5.921374],[3.256320,-5.471584],[4.415978,-5.465552],[5.263846,-5.875241],[5.844558,-6.641139],[6.202750,-7.703734],[7.464147,-9.446934],[8.157547,-9.744995],[8.893502,-9.653800],[10.495339,-8.282953],[12.274180,-5.293014],[13.328638,-0.133025],[13.787636,5.514158],[13.757764,11.561324],[13.345610,17.921266],[12.834741,20.502309],[11.780222,22.856828],[10.891590,23.883514],[9.678039,24.774818],[8.076570,25.504489],[6.024180,26.046276],[-3.350820,26.581986],[-7.786259,26.165751],[-10.841145,24.950048],[-11.915417,24.079768],[-12.721993,23.054468],[-13.635319,20.598604],[-13.787636,17.702046],[-13.385459,14.484386],[-11.743680,7.564126]]);\n  }\n}\nmodule bM(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[-6.388413,26.401581],[-5.117102,26.000668],[-4.015047,25.152978],[-3.105895,23.955817],[-2.413291,22.506494],[-1.772311,19.240591],[-1.871226,17.618627],[-2.281273,16.133731],[-5.146878,8.552906],[-6.370856,4.553670],[-7.191983,0.151581],[-7.451533,-3.171370],[-7.366224,-5.703968],[-7.012415,-7.454373],[-6.466463,-8.430746],[-5.804729,-8.641247],[-5.103570,-8.094038],[-4.439345,-6.797279],[-3.888413,-4.759129],[-3.717751,-3.176610],[-3.832284,-1.348406],[-4.227231,2.491226],[-4.162791,4.225739],[-3.693839,5.652107],[-2.647949,6.631873],[-0.852693,7.026581],[0.804765,6.678418],[1.972998,5.741063],[2.728399,4.334041],[3.147357,2.576877],[3.281510,-1.509777],[2.986587,-5.562699],[3.000675,-7.464801],[3.505212,-8.701782],[4.310360,-9.224462],[5.226278,-8.983659],[6.063128,-7.930192],[6.631071,-6.014879],[6.740267,-3.188539],[6.200877,0.598011],[1.468727,15.240871],[0.986406,18.625061],[1.039441,20.550030],[1.431130,22.447681],[2.268369,24.181087],[3.658048,25.613323],[5.707063,26.607463],[8.522307,27.026581],[14.593727,26.758731],[16.200317,26.314623],[17.570847,25.473698],[18.705441,24.295321],[19.604223,22.838858],[20.694851,19.329132],[20.843727,15.419441],[14.950877,-4.401989],[14.660545,-7.657223],[15.155279,-10.781611],[16.172812,-13.818865],[17.450877,-16.812699],[18.650466,-20.207387],[18.873024,-22.709291],[18.333655,-24.452042],[17.247464,-25.569271],[15.829557,-26.194606],[14.295038,-26.461680],[11.736587,-26.455559],[8.173265,-25.715237],[5.481763,-24.857666],[3.516786,-23.902142],[2.133039,-22.867959],[1.185227,-21.774415],[0.528054,-20.640803],[-0.495553,-18.330559],[-2.204446,-22.304486],[-3.253478,-23.749011],[-4.422031,-24.880044],[-7.087091,-26.346038],[-10.138413,-26.991269],[-12.532701,-27.026581],[-14.769706,-26.766225],[-16.727928,-26.161666],[-18.285870,-25.164364],[-19.322031,-23.725784],[-19.714913,-21.797386],[-19.343016,-19.330634],[-18.084843,-16.276989],[-16.815047,-13.421792],[-15.975940,-10.580950],[-15.535171,-7.753386],[-15.460390,-4.938021],[-15.719247,-2.133777],[-16.279391,0.660424],[-18.174143,6.223011],[-19.749055,11.091887],[-20.619962,15.168760],[-20.843727,18.517596],[-20.477210,21.202366],[-19.577272,23.287038],[-18.200776,24.835581],[-16.404583,25.911966],[-14.245553,26.580161]]);\n  }\n}\nmodule bN(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[-5.689319,-0.223215],[-0.600039,16.830355],[-0.187405,19.461040],[-0.497402,21.627887],[-1.388697,23.362385],[-2.719953,24.696025],[-4.349837,25.660295],[-6.137012,26.286686],[-9.617899,26.651785],[-13.517587,26.087891],[-15.016913,25.473452],[-16.242959,24.666437],[-17.956409,22.561937],[-18.820331,19.948907],[-18.997118,17.001863],[-18.649165,13.895317],[-17.028609,7.901785],[-15.225543,2.734520],[-14.062805,-1.707764],[-13.466652,-5.508561],[-13.363339,-8.751364],[-13.679123,-11.519665],[-14.340259,-13.896959],[-15.273002,-15.966738],[-16.403609,-17.812495],[-17.519507,-20.315343],[-17.741843,-22.327682],[-17.243187,-23.895061],[-16.196112,-25.063030],[-14.773188,-25.877138],[-13.146988,-26.382933],[-9.975039,-26.651785],[-7.303246,-26.173316],[-5.192593,-25.475707],[-3.565623,-24.588603],[-2.344879,-23.541649],[-0.812246,-21.086766],[0.024961,-18.348215],[4.757101,-2.008925],[6.139037,1.416277],[6.490561,1.577135],[6.657211,0.892852],[6.560152,-2.443068],[6.096391,-7.455355],[5.470335,-10.689333],[4.649851,-13.437235],[2.882101,-18.616075],[2.146795,-21.301705],[2.208636,-23.282088],[2.900051,-24.660113],[4.053467,-25.538673],[5.501310,-26.020657],[7.076009,-26.208959],[9.935681,-26.116075],[13.565045,-25.484818],[15.956239,-24.625186],[17.329444,-23.606025],[17.904847,-22.496176],[17.902630,-21.364484],[17.542977,-20.279793],[16.632101,-18.526785],[15.140488,-15.551435],[14.319199,-13.712277],[13.680774,-11.353921],[13.400105,-8.262709],[13.652081,-4.224982],[14.611593,0.972917],[16.453531,7.544645],[18.205221,14.152622],[18.814584,17.288305],[18.997118,20.154412],[18.565945,22.632916],[17.334186,24.605785],[15.114961,25.954991],[11.721391,26.562505],[8.987651,26.539526],[6.769901,25.984434],[5.014135,24.952921],[3.666352,23.500676],[2.672546,21.683392],[1.978715,19.556760],[1.274961,14.598215],[-2.117899,-1.830355],[-2.805282,-4.187946],[-3.606798,-5.701902],[-4.430958,-6.428542],[-5.186274,-6.424186],[-5.781257,-5.745156],[-6.124418,-4.447770],[-6.124268,-2.588350],[-5.689319,-0.223215]]);\n  }\n}\nmodule bO(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    difference()\n    {\n       linear_extrude(height=h)\n         polygon([[2.523829,-26.716306],[4.867386,-25.639709],[7.022504,-24.003289],[8.965016,-21.735472],[10.670749,-18.764688],[12.115535,-15.019365],[13.275204,-10.427931],[14.125585,-4.918815],[14.642509,1.579554],[14.718931,9.216124],[14.354192,13.159220],[13.542414,16.937314],[12.149793,20.364252],[10.042525,23.253875],[8.679084,24.439020],[7.086805,25.420028],[5.248962,26.173629],[3.148829,26.676554],[-1.209187,27.030786],[-4.261881,26.497984],[-7.038075,24.771967],[-9.355118,22.508681],[-11.232033,19.778525],[-12.687847,16.651899],[-13.741584,13.199202],[-14.412271,9.490831],[-14.718931,5.597185],[-14.680591,1.588664],[-13.920947,-5.832958],[-13.182596,-9.805300],[-12.165318,-13.736701],[-10.839182,-17.465687],[-9.174256,-20.830788],[-7.140609,-23.670532],[-4.708311,-25.823446],[-3.153582,-26.523192],[-1.275308,-26.946027],[0.694499,-27.030786],[2.523829,-26.716306]]);\n       translate([0, 0, -fudge])\n         linear_extrude(height=h+2*fudge)\n           polygon([[-3.369021,-13.144876],[-3.071341,-15.930040],[-2.220132,-17.724509],[-1.141053,-18.702962],[-0.159761,-19.040076],[0.803201,-18.808089],[1.894667,-17.874184],[2.763746,-16.094068],[3.059549,-13.323446],[3.059549,-9.484156],[2.718387,-8.340502],[1.933628,-7.690558],[0.021969,-7.294736],[-1.989778,-7.548888],[-2.886685,-8.185378],[-3.279741,-9.394856]]);\n    }\n  }\n}\nmodule bP(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    difference()\n    {\n       linear_extrude(height=h)\n         polygon([[3.984874,8.182230],[2.024281,4.249594],[1.393182,2.000394],[1.135531,-0.277054],[1.356817,-2.462493],[2.162526,-4.435667],[3.658145,-6.076322],[5.949164,-7.264200],[8.291625,-8.484470],[10.550379,-10.790574],[12.335384,-13.809658],[13.256599,-17.168869],[13.271397,-18.859505],[12.923983,-20.495353],[12.165600,-22.029806],[10.947494,-23.416257],[9.220909,-24.608099],[6.937091,-25.558727],[4.047284,-26.221533],[0.502734,-26.549910],[-4.095481,-26.083254],[-8.693696,-25.299910],[-10.480232,-24.630617],[-11.788226,-23.862970],[-12.660722,-23.015802],[-13.140765,-22.107947],[-13.271397,-21.158240],[-13.095662,-20.185514],[-11.997266,-18.246340],[-10.441707,-15.786010],[-9.393014,-12.870665],[-8.802438,-9.621700],[-8.621231,-6.160507],[-8.800645,-2.608482],[-9.291931,0.912984],[-11.015126,7.378660],[-12.845352,13.938583],[-13.183181,16.564566],[-13.191273,18.797207],[-12.910965,20.668489],[-12.383598,22.210394],[-11.650509,23.454904],[-10.753037,24.434004],[-8.630301,25.723899],[-6.346099,26.335941],[-2.616136,26.549910],[1.271739,26.522995],[3.972772,26.051128],[6.476401,24.909472],[7.489627,24.002119],[8.256026,22.824891],[8.709775,21.343649],[8.785047,19.524248],[8.416018,17.332549],[7.536863,14.734407],[6.081756,11.695681],[3.984874,8.182230]]);\n       translate([0, 0, -fudge])\n         linear_extrude(height=h+2*fudge)\n           polygon([[-0.568696,-12.353480],[1.208306,-13.948175],[2.106013,-15.657557],[1.978865,-17.500617],[0.681304,-19.496340],[-0.356907,-20.042395],[-1.078091,-19.884340],[-1.514767,-19.168670],[-1.699454,-18.041882],[-1.442938,-15.140939],[-0.568696,-12.353480]]);\n    }\n  }\n}\nmodule bQ(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    difference()\n    {\n       linear_extrude(height=h)\n         polygon([[7.691498,20.148547],[9.803175,16.844455],[11.354485,13.261439],[12.410318,9.505159],[13.035559,5.681278],[13.295097,1.895459],[13.253820,-1.746637],[12.528368,-8.177013],[11.428199,-13.185043],[10.064332,-17.647509],[8.479971,-21.507209],[6.718320,-24.706942],[4.822586,-27.189505],[2.835973,-28.897697],[0.801685,-29.774317],[-1.237072,-29.762163],[-4.876994,-28.665617],[-7.849408,-26.758354],[-10.224694,-24.201045],[-12.073233,-21.154358],[-13.465405,-17.778963],[-14.471590,-14.235529],[-15.607522,-7.287223],[-15.811927,0.284742],[-15.454934,4.628340],[-14.694136,9.007766],[-13.456277,13.171080],[-11.668103,16.866346],[-9.256356,19.841624],[-7.793751,20.980537],[-6.147782,21.844977],[-1.549795,22.871563],[0.157767,22.859141],[1.441498,22.469977],[3.570123,25.160021],[5.768590,27.684196],[6.977331,28.686206],[8.303511,29.409296],[9.780458,29.774317],[11.441498,29.702117],[13.153110,29.088475],[14.426942,28.238313],[15.282011,27.237975],[15.737334,26.173805],[15.811927,25.132147],[15.524808,24.199346],[14.894992,23.461744],[13.941498,23.005687],[9.182458,21.832061],[7.839439,21.036646],[7.592455,20.602008],[7.691498,20.148547]]);\n       translate([0, 0, -fudge])\n         linear_extrude(height=h+2*fudge)\n           polygon([[-3.587852,-10.238993],[-0.749748,-11.491848],[0.548265,-11.714818],[1.715448,-11.501683],[2.061996,-16.196196],[1.774880,-19.861002],[1.355542,-21.245260],[0.732001,-22.297688],[-0.111006,-22.993482],[-1.188742,-23.307843],[-2.423905,-22.922737],[-3.420902,-21.805860],[-4.165205,-20.144740],[-4.642287,-18.126905],[-4.736677,-13.771207],[-4.324930,-11.808400],[-3.587852,-10.238993]]);\n    }\n  }\n}\nmodule bR(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    difference()\n    {\n       linear_extrude(height=h)\n         polygon([[-15.399152,9.342945],[-16.635110,14.616931],[-16.851589,18.657070],[-16.275881,21.631795],[-15.135279,23.709539],[-13.657073,25.058734],[-12.068558,25.847813],[-9.469762,26.419355],[-6.547915,26.343607],[-4.657174,25.828736],[-2.818632,24.787958],[-1.286348,23.065340],[-0.314377,20.504952],[-0.156780,16.950861],[-1.067612,12.247135],[-2.644007,4.830200],[-2.826685,0.107539],[-2.214584,-2.402917],[-1.406642,-3.183235],[-0.469350,-2.792953],[0.040075,-2.057322],[0.495983,-0.795735],[1.005135,3.802191],[0.573888,11.994595],[1.143036,16.812687],[2.169906,20.453161],[3.522607,23.075864],[5.069250,24.840643],[6.677945,25.907345],[8.216803,26.435818],[10.557448,26.517465],[12.421011,25.919663],[14.051050,24.769386],[15.396039,23.106928],[16.404453,20.972583],[17.024765,18.406643],[17.205452,15.449403],[16.894988,12.141156],[16.041848,8.522195],[13.807666,2.599152],[10.792610,-3.141009],[7.482201,-7.832007],[5.867963,-9.513359],[4.361958,-10.607565],[6.677413,-13.985166],[7.947708,-17.123212],[8.210191,-19.943070],[7.502206,-22.366110],[5.861101,-24.313701],[3.324222,-25.707211],[-0.071084,-26.468009],[-4.287472,-26.517465],[-8.744709,-26.051325],[-12.108986,-25.410952],[-14.508750,-24.639569],[-16.072451,-23.780399],[-16.928536,-22.876663],[-17.205452,-21.971583],[-17.031648,-21.108383],[-16.535572,-20.330285],[-14.136903,-15.950019],[-12.757304,-11.764391],[-12.209614,-7.771954],[-12.306672,-3.971264],[-12.861317,-0.360874],[-13.686386,3.060660],[-15.399152,9.342945]]);\n       translate([0, 0, -fudge])\n         linear_extrude(height=h+2*fudge)\n           polygon([[-5.613292,-19.383265],[-3.310192,-19.627512],[-1.843181,-19.012206],[-1.099553,-17.803707],[-0.966604,-16.268376],[-1.331627,-14.672573],[-2.081916,-13.282659],[-3.104767,-12.364992],[-4.287472,-12.185935]]);\n    }\n  }\n}\nmodule bS(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[-13.510790,12.317848],[-12.938771,16.339032],[-11.736419,19.532627],[-10.039950,21.976030],[-7.985580,23.746639],[-5.709525,24.921851],[-3.348001,25.579065],[-1.037224,25.795678],[1.086590,25.649088],[2.927209,25.317989],[5.029744,24.691838],[7.222152,23.566185],[9.332390,21.736578],[11.188416,18.998567],[12.618186,15.147702],[13.449658,9.979533],[13.510790,3.289608],[12.975924,0.593321],[12.094200,-1.998017],[10.806550,-4.500064],[9.053901,-6.928477],[6.777185,-9.298916],[3.917331,-11.627037],[0.415270,-13.928500],[-3.788070,-16.218962],[-4.581123,-16.861962],[-4.805610,-17.607033],[-4.587426,-18.396964],[-4.052462,-19.174546],[-2.535773,-20.463822],[-1.262690,-21.017182],[-0.361085,-21.056849],[0.683594,-20.691533],[1.733715,-19.289487],[2.651650,-16.218962],[3.172452,-15.192145],[3.903300,-14.550958],[4.774786,-14.236373],[5.717506,-14.189366],[7.539020,-14.661975],[8.812590,-15.496572],[9.567189,-16.679637],[10.099181,-18.606333],[10.083232,-19.734190],[9.773468,-20.910732],[9.090503,-22.090216],[7.954950,-23.226902],[5.379524,-24.624951],[2.306045,-25.504688],[-0.857051,-25.795678],[-3.701330,-25.427482],[-6.116018,-24.540631],[-8.506174,-22.997841],[-9.518030,-21.909786],[-10.314928,-20.572929],[-10.827257,-18.958995],[-10.985410,-17.039712],[-10.492273,-15.287154],[-9.260831,-13.329435],[-5.754050,-9.524282],[-3.697828,-6.939004],[-2.943133,-4.556950],[-3.085633,-3.627194],[-3.591645,-2.970319],[-4.473881,-2.660350],[-5.745050,-2.771312],[-8.783310,-3.614573],[-10.982965,-3.579665],[-11.784113,-3.114671],[-12.394565,-2.288263],[-13.068660,0.637958],[-13.497189,7.132087],[-13.510600,12.317848]]);\n  }\n}\nmodule bT(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[-11.298117,10.638920],[-11.809083,15.427176],[-11.406902,19.146174],[-10.295896,21.928332],[-8.680385,23.906064],[-6.764689,25.211786],[-4.753129,25.977914],[-1.259697,26.421050],[2.328509,25.872726],[4.479175,25.043184],[6.571449,23.703465],[8.383253,21.748628],[9.692511,19.073731],[10.277146,15.573832],[9.915083,11.143990],[7.713208,1.314756],[4.485513,-9.185330],[3.564082,-13.020180],[3.286595,-16.004651],[3.453817,-17.985332],[3.866513,-18.808810],[4.522600,-18.746827],[5.328673,-17.956020],[6.079275,-16.164323],[6.568953,-13.099670],[6.889361,-11.940636],[7.570016,-11.148065],[9.232783,-10.465280],[9.927076,-10.476919],[10.750056,-10.766365],[11.442700,-11.516514],[11.745983,-12.910260],[11.809083,-19.349990],[11.458705,-22.781388],[10.482146,-25.029980],[8.937941,-26.206342],[6.884623,-26.421050],[-7.762587,-25.979110],[-8.882660,-25.761613],[-9.726680,-25.314072],[-10.773712,-23.884817],[-11.277985,-22.003264],[-11.613797,-19.981330],[-11.676897,-13.036530],[-11.336493,-11.711575],[-10.647111,-10.840930],[-9.181267,-10.167200],[-7.695491,-10.465408],[-7.086285,-11.070614],[-6.752437,-12.089510],[-6.163745,-14.772046],[-5.435794,-16.920501],[-4.710454,-18.344840],[-4.129597,-18.855030],[-3.493152,-18.203203],[-3.160324,-16.241987],[-3.446983,-12.917328],[-4.668997,-8.175170],[-8.148974,0.684536],[-11.298117,10.638920]]);\n  }\n}\nmodule bU(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[-14.918007,9.766650],[-15.008650,12.769943],[-14.811974,15.381444],[-14.358889,17.628455],[-13.680305,19.538280],[-12.807133,21.138220],[-11.770281,22.455578],[-9.329181,24.351761],[-6.604284,25.445250],[-3.842870,25.954465],[0.800393,26.093760],[3.364796,26.013033],[6.085054,25.675130],[8.755943,24.916212],[11.172239,23.572446],[13.128718,21.479995],[14.420156,18.475022],[14.841329,14.393693],[14.187013,9.072170],[13.102064,4.855586],[12.120085,-0.097429],[11.963418,-3.046722],[12.187345,-6.416072],[12.910148,-10.284128],[14.250113,-14.729540],[15.388769,-17.745198],[15.857449,-19.492021],[15.994635,-21.234801],[15.602032,-22.851012],[14.481342,-24.218126],[12.434271,-25.213615],[9.262523,-25.714950],[5.831844,-25.296820],[4.418223,-24.712721],[3.289703,-23.839741],[2.509248,-22.648736],[2.139824,-21.110560],[2.244397,-19.196069],[2.885933,-16.876120],[3.867773,-12.855308],[4.139539,-9.887388],[3.865824,-7.812741],[3.211219,-6.471753],[2.340316,-5.704806],[1.417708,-5.352284],[0.075743,-5.252050],[-1.225667,-5.124020],[-2.020046,-5.273209],[-2.732641,-5.825903],[-3.230279,-6.978126],[-3.379783,-8.925906],[-3.047981,-11.865269],[-2.101697,-15.992240],[-1.565768,-18.882187],[-1.491273,-20.342556],[-1.732897,-21.756370],[-2.430996,-23.081012],[-3.725925,-24.273868],[-5.758037,-25.292323],[-8.667687,-26.093760],[-10.667917,-26.017321],[-12.429797,-25.560968],[-13.898369,-24.788035],[-15.018672,-23.761856],[-15.735748,-22.545765],[-15.994635,-21.203094],[-15.740375,-19.797178],[-14.918007,-18.391350],[-13.722782,-16.325253],[-12.975689,-13.714131],[-12.623408,-10.622831],[-12.612620,-7.116203],[-13.402244,0.883652],[-14.918007,9.766650]]);\n  }\n}\nmodule bV(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[-17.724625,-19.993540],[-18.228123,-21.559141],[-17.952066,-22.856155],[-17.072146,-23.902842],[-15.764058,-24.717460],[-12.566149,-25.723525],[-9.763885,-26.020420],[-7.283452,-25.617782],[-4.337423,-24.368175],[-3.047367,-23.398831],[-2.069982,-22.185433],[-1.548291,-20.717209],[-1.625315,-18.983390],[-2.537794,-13.263010],[-2.801752,-9.033985],[-2.571038,-6.072684],[-1.999498,-4.155478],[-1.240978,-3.058737],[-0.449325,-2.558832],[0.617995,-2.455010],[1.895977,-3.073816],[2.775127,-3.962312],[3.577916,-5.383831],[4.126991,-7.448596],[4.245002,-10.266829],[3.754597,-13.948749],[2.478425,-18.604580],[2.550087,-21.102779],[2.971658,-22.225636],[3.748675,-23.232165],[4.954851,-24.098242],[6.663900,-24.799741],[8.949537,-25.312539],[11.885475,-25.612510],[14.907753,-25.195483],[16.221511,-24.614743],[17.276445,-23.747454],[17.977125,-22.564815],[18.228123,-21.038028],[17.934013,-19.138293],[16.999365,-16.836810],[13.894740,-9.963439],[10.981883,-2.810951],[9.787138,1.146173],[8.868060,5.504530],[8.300556,10.374604],[8.160535,15.866880],[8.053973,18.561854],[7.576570,20.773272],[6.803280,22.539230],[5.809061,23.897821],[4.668867,24.887141],[3.457656,25.545285],[1.122005,26.020420],[-1.066702,25.662242],[-2.348680,25.111595],[-3.649038,24.216504],[-4.887747,22.904414],[-5.984778,21.102771],[-6.860104,18.739021],[-7.433695,15.740610],[-7.622964,8.375139],[-7.707029,4.699358],[-8.107480,0.815429],[-9.066892,-3.436237],[-10.827837,-8.215229],[-13.632891,-13.681133],[-17.724625,-19.993540]]);\n  }\n}\nmodule bW(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[-17.577629,-17.843801],[-18.643320,-20.211159],[-18.860937,-22.049749],[-18.416295,-23.430813],[-17.495203,-24.425596],[-16.283475,-25.105341],[-14.966922,-25.541293],[-12.762589,-25.966791],[-10.383270,-26.229769],[-7.183963,-25.977023],[-5.833878,-25.394303],[-4.947272,-24.367111],[-4.746971,-22.790267],[-5.455799,-20.558591],[-6.500820,-17.031149],[-6.525407,-14.865575],[-6.041010,-13.749653],[-5.559079,-13.371171],[-5.081627,-13.553740],[-4.474811,-14.616147],[-3.847663,-16.916056],[-3.309219,-20.811131],[-2.560074,-23.667783],[-1.353026,-24.991720],[-0.051322,-25.353652],[0.981791,-25.324291],[1.840145,-24.995732],[2.629259,-24.114195],[3.147600,-22.725191],[3.193631,-20.874231],[3.362659,-17.184716],[4.133394,-15.228195],[5.063705,-14.461052],[5.711461,-14.339671],[6.086735,-14.710878],[6.381532,-15.858895],[6.437883,-17.896739],[6.097821,-20.937431],[5.957053,-22.794860],[6.372104,-24.127108],[7.209554,-25.019219],[8.335979,-25.556236],[10.922075,-25.905161],[13.063021,-25.854231],[15.509474,-25.418209],[16.593806,-24.868214],[17.473746,-24.067181],[18.065445,-22.992824],[18.285057,-21.622855],[18.048735,-19.934990],[17.272631,-17.906941],[15.135644,-12.575830],[14.112795,-7.867880],[13.972593,-3.653614],[14.483546,0.196447],[16.532946,7.321868],[17.608410,10.856184],[18.409061,14.544209],[18.860937,18.324107],[18.624613,21.183270],[17.854442,23.250749],[16.704779,24.655599],[15.329979,25.526873],[13.884396,25.993624],[11.398301,26.229769],[8.308075,25.947636],[6.522065,25.401561],[4.762506,24.439062],[3.169685,22.950324],[1.883889,20.825534],[1.045405,17.954877],[0.794521,14.228539],[1.803581,7.970883],[2.192780,3.258354],[2.104235,-0.128714],[1.680066,-2.409987],[1.062391,-3.805129],[0.393329,-4.533807],[-0.530479,-4.870431],[-1.302563,-4.709849],[-1.845107,-4.110530],[-2.343482,-2.828890],[-2.686310,-0.612700],[-2.762212,2.790267],[-2.459811,7.632237],[-1.667729,14.165439],[-1.764964,18.337971],[-2.401113,21.400230],[-3.449561,23.523796],[-4.783693,24.880249],[-6.276892,25.641168],[-7.802541,25.978133],[-10.444729,26.066519],[-13.086235,25.655568],[-14.608581,24.999513],[-16.072831,23.943575],[-17.334616,22.413132],[-18.249570,20.333560],[-18.673324,17.630237],[-18.461509,14.228539],[-15.705825,3.512443],[-14.815627,-1.048599],[-14.328411,-5.143638],[-14.302589,-8.821677],[-14.796576,-12.131715],[-15.868785,-15.122756],[-17.577629,-17.843801]]);\n  }\n}\nmodule bX(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[-1.080917,18.799704],[-2.152584,13.385587],[-2.622304,8.488974],[-2.617564,4.197818],[-2.265855,0.600074],[-1.694664,-2.216305],[-1.031482,-4.163366],[-0.403797,-5.153154],[0.060903,-5.097716],[0.943544,-3.625319],[1.576409,-2.087060],[2.167457,0.160504],[2.589549,3.248323],[2.715550,7.307347],[2.418323,12.468524],[1.570733,18.862804],[1.513773,21.316980],[2.098088,23.141764],[3.171042,24.428302],[4.580000,25.267739],[6.172327,25.751222],[7.795386,25.969899],[10.523163,25.977414],[12.840036,25.632331],[14.152118,25.161358],[15.399268,24.398423],[16.455962,23.273769],[17.196680,21.717642],[17.495897,19.660286],[17.228093,17.031944],[16.116631,9.607610],[15.217614,5.909256],[14.008543,2.196713],[12.428517,-1.547572],[10.416640,-5.341146],[7.912011,-9.201561],[4.853733,-13.146366],[6.701900,-16.130159],[9.904133,-19.361466],[12.762521,-21.579557],[13.843432,-22.524648],[14.482068,-23.382695],[14.520863,-24.170393],[13.802252,-24.904438],[12.168671,-25.601524],[9.462553,-26.278346],[7.813374,-26.332649],[6.362474,-26.032882],[5.079454,-25.433328],[3.933917,-24.588269],[1.933697,-22.378764],[0.118633,-19.838626],[-1.453021,-20.531301],[-2.557954,-21.539482],[-4.228267,-23.935517],[-5.223955,-25.039948],[-6.613533,-25.893037],[-8.612156,-26.353074],[-11.434977,-26.278346],[-14.864282,-25.217102],[-15.726671,-24.487999],[-15.975740,-23.598457],[-15.577629,-22.527390],[-14.498479,-21.253709],[-10.161627,-18.014156],[-7.459192,-15.764174],[-6.225325,-14.198539],[-5.121527,-12.262486],[-9.045380,-6.525239],[-12.658888,-0.012129],[-14.235281,3.820331],[-15.597309,8.188703],[-16.699379,13.206970],[-17.495897,18.989114],[-17.331250,21.248117],[-16.704181,23.012014],[-15.726312,24.337141],[-14.509265,25.279838],[-11.804120,26.243290],[-9.481717,26.353074],[-6.637894,26.044445],[-3.441065,25.104706],[-2.108127,24.200343],[-1.164362,22.900809],[-0.768911,21.126973],[-1.080917,18.799704]]);\n  }\n}\nmodule bY(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[-12.400024,13.743230],[-12.554755,16.594192],[-11.982273,19.075937],[-10.817673,21.189142],[-9.196051,22.934485],[-7.252502,24.312645],[-5.122120,25.324301],[-2.940002,25.970129],[-0.841244,26.250810],[2.644511,26.019103],[4.675284,25.469556],[6.649893,24.488784],[8.382267,22.970216],[9.686336,20.807282],[10.376030,17.893411],[10.265276,14.122030],[9.780307,10.153927],[9.047974,6.810707],[7.424216,2.252740],[5.975507,-1.924582],[5.497404,-5.390820],[5.808520,-8.279053],[6.727465,-10.722360],[8.072853,-12.853821],[9.663294,-14.806515],[12.853786,-18.707920],[13.875920,-20.709243],[14.267717,-22.301396],[14.158808,-23.529179],[13.678818,-24.437390],[12.124107,-25.474289],[10.640606,-25.770480],[8.588074,-25.796507],[5.990065,-25.532719],[3.761025,-24.648108],[3.070631,-23.869555],[2.815396,-22.811670],[3.093696,-18.550298],[2.585279,-15.634079],[2.056440,-14.646614],[1.355388,-13.954892],[0.490279,-13.545399],[-0.530734,-13.404620],[-1.269566,-13.582051],[-1.837291,-14.109435],[-2.582372,-16.084697],[-3.371784,-22.811670],[-3.632664,-23.688607],[-4.179272,-24.423361],[-5.815437,-25.495234],[-7.651814,-26.085109],[-9.059934,-26.250810],[-11.216433,-26.211079],[-12.283492,-26.036890],[-13.212847,-25.612827],[-13.906817,-24.828650],[-14.267718,-23.574114],[-14.197867,-21.738979],[-13.599584,-19.213000],[-12.551162,-17.299416],[-11.122277,-15.319432],[-7.996104,-11.060716],[-6.735309,-8.732210],[-5.967038,-6.237755],[-5.909537,-3.552464],[-6.781054,-0.651450],[-9.892676,6.364607],[-11.272793,9.978053],[-12.400024,13.743230]]);\n  }\n}\nmodule bZ(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[-12.842445,17.346411],[-12.833718,20.376463],[-12.020867,22.580039],[-10.576260,24.095036],[-8.672262,25.059348],[-6.481243,25.610872],[-4.175568,25.887503],[0.090275,26.167671],[4.297869,26.468959],[6.698594,26.338851],[8.986497,25.797110],[10.928494,24.675389],[12.291504,22.805338],[12.842445,20.018608],[12.348235,16.146851],[11.050832,9.915405],[10.244150,4.525750],[9.065235,-5.508299],[8.461040,-7.515475],[7.785032,-8.750450],[7.072620,-9.346405],[6.359215,-9.436526],[5.071069,-8.631996],[4.203875,-7.402329],[3.211315,-5.354423],[2.038042,-4.293205],[0.961497,-3.953384],[0.259125,-4.069669],[-0.387313,-4.656528],[-0.618048,-5.600679],[-0.197407,-7.085999],[1.110285,-9.296369],[5.868384,-14.565421],[10.391065,-18.892819],[11.818789,-20.814950],[11.957381,-22.459335],[11.061426,-23.825545],[9.385507,-24.913151],[7.184207,-25.721724],[4.712112,-26.250836],[-0.026135,-26.468959],[-8.000415,-26.059625],[-10.840234,-25.662678],[-11.700859,-25.314388],[-12.084835,-24.827459],[-12.428795,-18.227536],[-12.074248,-15.961871],[-11.264085,-14.725939],[-10.094326,-14.328067],[-9.048574,-14.345629],[-7.271492,-15.285097],[-5.817642,-16.860436],[-4.571825,-18.387739],[-3.037485,-19.624398],[-1.809488,-20.239269],[-0.871553,-20.355308],[-0.207400,-20.095467],[0.364684,-18.939966],[0.037005,-17.756399],[-6.055167,-12.074027],[-8.542236,-9.181312],[-9.875125,-6.707849],[-11.118093,-0.595721],[-11.699457,5.409086],[-12.110486,11.368992],[-12.842445,17.346411]]);\n  }\n}\nfudge=.1;\nmodule PRINTEARING(){\n\tif (LETTER==\"A\"){\n\t\tbA(4);\n\t\ttranslate([0,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"B\"){\n\t\tbB(4);\n\t\ttranslate([0,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"C\"){\n\t\tbC(4);\n\t\ttranslate([1,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"D\"){\n\t\tbD(4);\n\t\ttranslate([-1.5,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"E\"){\n\t\tbE(4);\n\t\ttranslate([0,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"F\"){\n\t\tbF(4);\n\t\ttranslate([0,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"G\"){\n\t\tbG(4);\n\t\ttranslate([0,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"H\"){\n\t\tbH(4);\n\t\ttranslate([-3,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"I\"){\n\t\tbI(4);\n\t\ttranslate([0,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"J\"){\n\t\tbJ(4);\n\t\ttranslate([1.75,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"K\"){\n\t\tbK(4);\n\t\ttranslate([-2.5,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"L\"){\n\t\tbL(4);\n\t\ttranslate([-1,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"M\"){\n\t\tbM(4);\n\t\ttranslate([-3.5,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"N\"){\n\t\tbN(4);\n\t\ttranslate([-3,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"O\"){\n\t\tbO(4);\n\t\ttranslate([0,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"P\"){\n\t\tbP(4);\n\t\ttranslate([0,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"Q\"){\n\t\tbQ(4);\n\t\ttranslate([0,9.25,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"R\"){\n\t\tbR(4);\n\t\ttranslate([-1.5,9,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"S\"){\n\t\tbS(4);\n\t\ttranslate([0,9,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"T\"){\n\t\tbT(4);\n\t\ttranslate([0,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"U\"){\n\t\tbU(4);\n\t\ttranslate([-2.5,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"V\"){\n\t\tbV(4);\n\t\ttranslate([-2.5,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"W\"){\n\t\tbW(4);\n\t\ttranslate([0,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"X\"){\n\t\tbX(4);\n\t\ttranslate([-3,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"Y\"){\n\t\tbY(4);\n\t\ttranslate([-3,8.75,0]) EARINGMOUNT(1.5);\n\t}else if (LETTER==\"Z\"){\n\t\tbZ(4);\n\t\ttranslate([0,8.75,0]) EARINGMOUNT(1.5);\n\t}\n}\nPRINTEARING();\ntranslate([20,0,0]) PRINTEARING();",
    "description": "Okay, I'd like to design some earrings based on a specific font, \"Bell bottom laser,\" which I've linked below. I've already started prototyping these in OpenSCAD, but I need help making the design fully parametric and easier to customize.\n\nHere's what I want:\n\n*   **Letter Selection:** The earrings should be based on a single letter from the alphabet, A through Z. I want to be able to easily choose which letter is used.\n*   **Font Outlines:** The core of the earring is a 2D outline of the selected letter, taken from the \"Bell bottom laser\" font. I'd like these outlines to be imported from an external data source (maybe a CSV or JSON file), instead of being hardcoded in the OpenSCAD script, and this data source can be managed outside of the OpenSCAD script.\n*   **Extrusion:** This 2D outline should be linearly extruded to a specified height for the earring. I want to parameterize this height as `earring_height`.\n*   **Earing Mount:** An ear wire mount is attached on top of the letter, it is a short cylinder with a thinner cylinder cut out of it's center. I want to parameterize the height of the mount as `mount_height` and have its position be calculated based on the size of the letter outline and have an offset parameter.\n*   **Size Control:** I need a scaling factor (e.g. `scale_factor`) to control the overall size of the earring.\n*   **Thickness Control:**  There are some interior parts of the letters that are cut out of the letter shape. I want the thickness of this cut out to be a parameter `cutout_thickness`.\n*   **Clearance:** Finally, I want to add a small fudge factor (e.g. `fudge`) to the extrusion of the cut out sections to ensure they are clear and don't fuse.\n\nEssentially, I want a parametric OpenSCAD design where I can:\n\n1.  Select a letter (`LETTER`).\n2.  Adjust the overall size of the earring (`scale_factor`).\n3.  Control the thickness of the main earring (`earring_height`).\n4.  Control the thickness of the cutout portions (`cutout_thickness`).\n5. Control the height of the earwire mount (`mount_height`).\n6. Control the offset from the edge of the letter for the mount location\n7. Ensure the cutout portions are clean by applying a fudge factor to their extrusions (`fudge`).\n\nMy current implementation has all the letter outlines hardcoded, which is not ideal. I'd like the new version to use an external file. I'm not too concerned with the file format, but a CSV or JSON where each key is the letter, and the value is a list of points forming the polygon would work.\n\nI do use the basic OpenSCAD language primitives of `linear_extrude`, `polygon`, `translate`, `difference`, `union`, and `scale`.\n\nCould you generate an OpenSCAD file for this? I don't need any other .scad files from external libraries, just the main file using standard OpenSCAD primitives.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Ziggurat",
    "scad": "bottom_radius=5;\ntop_radius=8;\nlayers=6;\nheight=4.3;\nincrease=.01;\nthing();\nmodule thing(){\n$fn=148;\ntranslate([0,0,-height])\nfor ( i = [0 : layers]  ){\ntranslate([0,0,(i-1)*height+increase+(height+(i-1)*increase)])\nif (i>0){\ncylinder(r1=bottom_radius,r2=top_radius,h=height+i*increase);\n}\n}\n}",
    "description": "Okay, I'm trying to design a customizable ziggurat-like structure in OpenSCAD, and I've got a basic concept working, but it's not quite flexible enough for what I need.\n\nHere's what I'm going for: I want a series of truncated cones stacked on top of each other, each with a slightly increasing radius, kind of like a stepped pyramid. I need to control the bottom radius, the top radius of the final cone, the height of each step, and the number of steps (layers). Importantly, each layer should also have a slight height *increase* from the previous layer, starting from the base. I want the increasing height to be a fixed parameter, not a percentage change, for example.\n\nI've tried to implement it using a for loop and `cylinder` but its a bit rigid.  Specifically:\n\n1.  **Bottom Radius:**  I need a parameter to set the radius of the very first cylinder at the bottom of the stack.\n2.  **Top Radius:** I want to control the radius at the top of the *last* cylinder.  This radius should be used at the top of the final cylinder.\n3.  **Number of Layers:** I need a parameter to control the total number of steps in the ziggurat.\n4.  **Height:** I need a parameter to set the base height of each layer.\n5.  **Height Increase:** I want a parameter to control the *additional* height added to each successive layer.\n\nIdeally, the code would use a module to create the ziggurat. The module should handle the stacking and the incremental height adjustment of the steps. It would be helpful if the module could calculate the radius of each layer automatically based on the bottom radius, the final top radius, and the number of layers using a linear interpolation, so that I only have to specify the two ends. I also need the final z-translation to be calculated automatically so that each cylinder stacks nicely.\n\nI am _not_ looking for a spiral staircase ziggurat.\n\nI would like to avoid relying on any libraries, if possible, so just the basic OpenSCAD primitives and features would be preferred. Please generate the OpenSCAD file for this customizable ziggurat.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Word Rings",
    "scad": "total_width=95;\ntotal_height=60;\ndesired_word = \"FAB\";\ntotal_depth = 10;\nfinger_size = 23;\nfinger_spacing = 23;\nuse <MCAD/fonts.scad>\nthisFont=8bit_polyfont();\nx_shift=thisFont[0][0];\ny_shift=thisFont[0][1];\ntheseIndicies=search(desired_word,thisFont[2],1,1);\nword_width = (len(theseIndicies))* x_shift;\nmodule write_word(word_text=\"Fabulous\", word_height=2.0) {\n      for( j=[0:(len(theseIndicies)-1)] ) translate([j*x_shift,-y_shift/2]) {\n\t\tlinear_extrude(height=word_height) polygon(points=thisFont[2][theseIndicies[j]][6][0],paths=thisFont[2][theseIndicies[j]][6][1]);\n      }\n}\nunion() {\n\ttranslate(v=[0,-total_height/2,0]) {\n\t\tscale(v=[1,total_height/total_width,total_depth/(2*total_width)]) {\n\t\t\tcube(total_width);\n\t\t}\n\t}\n\ttranslate(v=[5,0,0]) {\n\t\tscale(v=[(total_width-10)/word_width,(total_height-10)/8,1]) {\n\t\t\twrite_word(desiredWord,total_depth);\n\t\t}\n\t}\n\tdifference() {\n\t\ttranslate(v=[0,-total_height/2,(total_depth-.1)/2]) {\n\t\t\tscale(v=[1,total_height/total_width,(total_depth+.1)/(2*total_width)]) {\n\t\t\t\tcube(total_width);\n\t\t\t}\n\t\t}\n\t\ttranslate(v=[5,5-(total_height/2),total_depth/2]) {\n\t\t\tscale(v=[1,(total_height-5)/total_width,total_depth/total_width]) {\n\t\t\t\tcube(total_width-10);\n\t\t\t}\n\t\t}\n\t}\n\tdifference() {\n\t\ttranslate(v=[((total_width-finger_size-finger_spacing)/2)-3,0,-(finger_size/2)+3]) {\n\t\t\trotate(a=[90,0,0]) {\n\t\t\t\tdifference() {\n\t\t\t\t\tcylinder(h = 10, r1 = (finger_size/2)+3, r2 = (finger_size/2)+3, center = true );\n\t\t\t\t\tcylinder(h = total_depth+finger_size+5, r1 = (finger_size/2), r2 = (finger_size/2), center = true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate(v=[5,5-(total_height/2),total_depth/2]) {\n\t\t\tscale(v=[1,(total_height-5)/total_width,total_depth/total_width]) {\n\t\t\t\tcube(total_width-10);\n\t\t\t}\n\t\t}\n\t}\n\tdifference() {\n\t\ttranslate(v=[((total_width+finger_size+finger_spacing)/2)+3,0,-(finger_size/2)+3]) {\n\t\t\trotate(a=[90,0,0]) {\n\t\t\t\tdifference() {\n\t\t\t\t\tcylinder(h = 10, r1 = (finger_size/2)+3, r2 = (finger_size/2)+3, center = true );\n\t\t\t\t\tcylinder(h = total_depth+finger_size+5, r1 = (finger_size/2), r2 = (finger_size/2), center = true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate(v=[5,5-(total_height/2),total_depth/2]) {\n\t\t\tscale(v=[1,(total_height-5)/total_width,total_depth/total_width]) {\n\t\t\t\tcube(total_width-10);\n\t\t\t}\n\t\t}\n\t}\n}",
    "description": "Okay, I'd like to design some custom word rings, like those described in the provided description. I need an OpenSCAD file that can create these rings with a few key parameters.\n\nHere's what I need:\n\n**Overall Design:**\n\nThe design is essentially a rectangular plate with text extruded from its surface, and two rings attached to the back. The plate has a frame cut out of the top, leaving a thin border around the edges and the text. The rings are positioned to allow it to be worn on two fingers. I want it to be fully parametric so I can adjust all dimensions and the text.\n\n**Specific Parameters I Need to Control:**\n\n*   **`total_width`:** The overall width of the rectangular plate (in millimeters).\n*   **`total_height`:** The overall height of the rectangular plate (in millimeters).\n*   **`desired_word`:** The text to be displayed on the plate. I need to use the `8bit_polyfont()` from the MCAD library for the font.\n*   **`total_depth`:**  The total depth/thickness of the entire piece, specifically the distance from the top surface of the letters to the bottom of the plate (in millimeters).\n*   **`finger_size`:**  The inner diameter of the finger holes/rings, plus some extra for comfort (in millimeters). This is essentially the diameter of your finger with some tolerance.\n*   **`finger_spacing`:** The distance between the edges of the two finger holes/rings (in millimeters).\n\n**Detailed Requirements:**\n\n1.  **Plate:**\n    *   A base rectangular plate with the specified `total_width`, `total_height`, and a thickness derived from `total_depth`. The bottom of the base plate should be at z=0.\n    * The top of the base plate should be slightly less than `total_depth`\n    * The words/text should be extruded to have a total height of `total_depth`.\n    *   The plate should have a frame cut out of the top, leaving a border (a thin wall) around the edges and the text. This should be done by subtracting a smaller rectangle from a slightly larger one.\n\n2.  **Text:**\n    *   The text specified by `desired_word` should be extruded from the surface of the base plate.\n    *   The text should be centered on the plate, with a margin from the edges.\n    *   The font should be `8bit_polyfont()` from the MCAD library. The text's extrusion height should equal total_depth.\n\n3.  **Finger Rings:**\n    *   Two cylindrical finger holes/rings should be attached to the bottom/back of the plate.\n    *   The rings should be placed on the left and right sides of the plate.\n    *   The rings should have a inner diameter equal to `finger_size` and a total diameter of `finger_size + 6`.\n    *   The rings should have a height equal to `total_depth + finger_size + 5`, starting slightly below the bottom of the plate.\n\n4.  **Libraries:**\n    *   Use the MCAD library for the font (`8bit_polyfont()`).\n\nI've included the original SCAD file above, hopefully that gives a good starting point.  I'm mostly just looking for a cleaner more readable version that includes some comments, and maybe uses variables a little better.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Simple S Hook V2",
    "scad": "profile_radius = 5;\ntop_radius = 20;\nbottom_radius = 20;\ntop_closure_angle = 240;\nbottom_closure_angle = 240;\nconnector_length = 15;\n$fn=64;\ntop();\nconnector();\nbottom();\nmodule hex_profile()\n{\n    $fn=6;\n    circle(r=profile_radius);\n}\nmodule oval_profile()\n{\n    oval_height =10;\n    oval_depth = 10;\n    polygon(points=[[-oval_depth/2,-oval_height/2],[oval_depth/2-2,-oval_height/2],[oval_depth/2,-oval_height/2+2],[oval_depth/2,oval_height/2-2],[oval_depth/2-2,oval_height/2],[-oval_depth/2+2,oval_height/2],[-oval_depth/2,oval_height/2-2],[-oval_depth/2,-oval_height/2+2],[-oval_depth/2+2,-oval_height/2]]);\n}\nmodule top()\n{\n    rotate_extrude(angle=top_closure_angle,convexity = 10)translate([top_radius, 0, 0])hex_profile();\n    end_cap_top();\n}\nmodule bottom()\n{\n    translate([top_radius*2-(top_radius-bottom_radius),-connector_length,0])rotate([0,0,180])\n    {\n        rotate_extrude(angle=bottom_closure_angle,convexity = 10)translate([bottom_radius, 0, 0])hex_profile();\n        end_cap_bottom();\n    }\n}\nmodule connector()\n{\n    translate([top_radius,0,0])rotate([90,0,0])linear_extrude(connector_length, convexity = 10)hex_profile();\n}\nmodule end_cap_top()\n{\n    $fn=6;\n    rotate([0,0,top_closure_angle])translate([top_radius,0,0])rotate([-90,0,0])cylinder(r1=profile_radius,r2=profile_radius-2,h=2);\n}\nmodule end_cap_bottom()\n{\n    $fn=6;\n    rotate([0,0,bottom_closure_angle])translate([bottom_radius,0,0])rotate([-90,0,0])cylinder(r1=profile_radius,r2=profile_radius-2,h=2);\n}",
    "description": "Okay, I'm looking to create a parametric S-hook design, and I've got a pretty good idea of what I want, but I need help coding it up in OpenSCAD. I've found a decent starting point, but it's not quite as flexible as I need, and I want to add some more parameters.\n\nThe basic design is an S-shape made of three sections: a top hook, a bottom hook, and a connecting straight section. I want to be able to control the following:\n\n*   **Profile Radius:** This is the radius of the material used to create the hook shape - it should probably be a hexagon, but maybe an oval shape as well. I'd like this to be easily changed.\n*   **Top Hook Radius:**  The radius of the arc of the top hook, measured from the center of the circle to the center of the material.\n*   **Bottom Hook Radius:** The radius of the arc of the bottom hook, same as the top radius. This should be independently adjustable.\n*   **Top Closure Angle:** The angle that the top hook sweeps through.  A larger angle creates a tighter gap for the hook opening.\n*   **Bottom Closure Angle:** Same as the top closure angle, but for the bottom hook.\n*   **Connector Length:** The length of the straight section that connects the top and bottom hooks. This should adjust the overall length of the hook.\n\nHere's what I want to be able to do, beyond the example SCAD file I found. I'd like to have the following:\n\n*   **Profile Shape:**  I want the hook profile to be able to be chosen between a hexagon (like the example), a circle, or an oval profile. So maybe a variable like `profile_type = \"hexagon\", \"circle\", \"oval\"`. For the oval, I'll want to control the height and width of the oval shape, or maybe just a height and the width is calculated proportionally so that it still looks like an oval. If we go with an oval, we should be able to choose a \"rounded rectangle\" that's more like the example oval profile, or a true ellipse.\n*   **End Caps:** The example includes end caps, which is great, but I would like those to follow the selected profile. The current design creates an end cap with a 2mm chamfer, which is a bit excessive, I'd like to set the chamfer amount in a variable like `end_cap_chamfer = 0.5;`.\n*   **Orientation:** Be able to rotate the entire hook around all three axes, so if the connector section is pointed along the x-axis, we can rotate it so the connector points up or down along the Z axis etc.. This would make it easier to place in my larger projects. So the design should start with the connector along the X axis, and we can apply a rotation after the hook is built.\n*   **Extra parameters:** There should be an overall wall thickness for the S-hook, which would be useful for printing the hook hollow. There should also be a `segments_for_circle` variable that we can use to smooth out the S hook segments when doing a circle profile or the end caps if we use a circle end cap.\n*   **Units:** I want everything to be in mm.\n*   **Library:** No libraries are needed.\n\nEssentially, I'm aiming for a highly configurable S-hook that I can easily adapt to different sizes and shapes for various projects. The existing example is a solid start, but needs more flexibility. It'd be great if the OpenSCAD code could be well-commented and easy to read so I can learn as I go. The previous version used `$fn=64;` which I think is a bit much and should be configurable so that the circle can be rendered with an appropriate number of segments based on the size of the circle. It was also using `convexity = 10`, which seems unnecessary.\n\nI think that covers everything! Thanks for the help.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Matching Ring",
    "scad": "ring_type = 1;\nring_size = 18.14;\nring_thickness = 1.6;\nring_width = 6;\nring_top_high = 5;\ninner_radius = ring_size/2;\ntranslate ([0,0,ring_width/2])\nunion () {\nring();\ntranslate ([0,-inner_radius,0])\nrotate(a=90,v=[1,0,0])\nif(ring_type == 0){\n\tringtop1 (ring_width,ring_top_high);\n} else {\n\tringtop2 (ring_width,ring_top_high);\n}\n}\nmodule ring() {\ndifference() {\n\t\t\tcylinder(r=inner_radius+ring_thickness,h=ring_width,$fn = 100,center = true);\n\t\t\tcylinder(r=inner_radius,h=ring_width+1,$fn = 100,center = true);\n}\n}\nmodule heart (w,h) {\nscale (v=[w/171,w/171,1])\ntranslate([0,-78,0])\nrotate (a=45, v=[0,0,1])\nlinear_extrude(height = h,convexity =10, twist =0 ) {\npolygon(points=[[0,0],[100,0],[0,100]], paths=[[0,1,2]]);\ntranslate([100,50,0])\ncircle(r=50);\ntranslate([50,100,0])\ncircle(r=50);\n}\n}\nmodule ringtop1 (w,h) {\ndifference() {\ntranslate ([-w/2,-w/2,0])\ncube (size=[w,w,h]);\ntranslate ([0,0,h*0.5])\nheart (w*0.9+0.3,h*0.5);\n}\n}\nmodule ringtop2 (w,h) {\nunion() {\ntranslate ([-w/2,-w/2,0])\ncube (size=[w,w,h*.5]);\nheart (w*0.9,h);\n}\n}",
    "description": "Okay, I'm looking to create a set of matching rings for Valentine's Day. I want them to have a heart design element, and I'd like to be able to customize them with different ring sizes and widths.\n\nThe basic ring structure should be a cylinder with a specified inner diameter (based on US ring sizes) and a configurable thickness.  I'd like two different \"top\" options: one for a more masculine ring and another for a more feminine ring.\n\nFor the masculine option, I envision a square or rectangular block on top of the ring, with a heart-shaped cutout in the center.  For the feminine option, I'd like a heart shape raised up from the ring, attached to a similar square or rectangular base.\n\nI need to be able to specify the following parameters:\n\n*   **`ring_type`**: A selector for either \"Male\" or \"Female\" style top.\n*   **`ring_size`**: The inner diameter of the ring, based on standard US ring sizes.  I've got a list of ring sizes with their corresponding diameters that I can provide; it includes sizes from 0 to 16 and also quarter sizes such as 0.25, 0.5, 0.75.\n*   **`ring_thickness`**: The thickness of the ring itself, probably 1.6mm for a normal ring and 2.4mm for a thicker ring.\n*   **`ring_width`**: The width (height when printed flat) of the ring band.\n*   **`ring_top_high`**: The height of the top part of the ring (the square base for the heart).\n\nI don't think I need to specify any module specific $fn values, the default should be OK, but it would be good if the program would generate nice smooth circles. It should be able to generate smooth heart shapes as well.\n\nId prefer that the heart is generally proportional to the width of the ring itself. I'd also like the hearts to be positioned so that they feel properly centered on the ring.\n\nCould you provide me with an OpenSCAD file that can do this? It should include parametric variables for all the customizable settings I described above and also include the modules to draw the hearts, the top of the ring, and the ring itself. I don't need any specific libraries, it should be able to do all this with vanilla openscad features.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Kickboard Paperweight",
    "scad": "length=17.5;\nwidth=15;\nthickness=1;\ndifference()\n{\nunion()\n{\nscale(0.1) cylinder(r=width*5,h=thickness*10);\ntranslate([width/-2,0,0]) scale([width,length-(width/2),thickness]) cube(1);\ntranslate([(width/-2)+1.25,length-(width/2),0]) scale([width-2.5,1.25,thickness]) cube(1);\ntranslate([(width/-2)+1.25,length-(width/2),0]) scale(0.1) cylinder(r=12.5,h=thickness*10);\ntranslate([(width/2)-1.25,length-(width/2),0]) scale(0.1) cylinder(r=12.5,h=thickness*10);\n}\n}",
    "description": "Okay, so I was doing my math homework, and I got a little distracted. Instead of calculating the volume of this rectangular prism with a half-cylinder on one end, I decided to make it in OpenSCAD. It's supposed to be a kickboard or something. I have something basic, but I want it to be a bit better.\n\nHere's what I'm thinking:\n\nThe basic shape is a rectangular prism. It's defined by a length, width, and thickness. I already have the basics set up, so I can specify those using variables like `length`, `width`, and `thickness`. I've also added a half-cylinder to one end, kind of like a little bumper, and I'd like to be able to control its radius.\n\nHere's a breakdown of what I need, and what I'd like to be parametric:\n\n*   **Overall Dimensions:**\n    *   `length`: The overall length of the kickboard.\n    *   `width`: The width of the kickboard.\n    *   `thickness`: The thickness of the kickboard.\n\n*   **Rectangular Prism Body:** The core shape of the kickboard, with the specified `length`, `width`, and `thickness`.\n\n*   **Half-Cylinder Bumper:**\n    *   Located at one end of the kickboard's length.\n    *  A parameter to specify the radius, `bumper_radius`.\n    *  Should be centered on the edge of the kickboard.\n    *  I'd like the \"flat\" side of the half-cylinder to be flush with the end of the rectangle, making it a proper half-cylinder. I don't want it to extend out and then use a difference.\n\n*   **Rounding Edges** I would like the corners to be rounded as well. The radius of the rounded corner should be adjustable as well, so I'll add `corner_radius`.\n\n*   **Mounting holes** I'd also like to include some mounting holes through the main body of the board. I want to specify the number of holes `hole_count`, the diameter `hole_diameter` and the offset for the center of the holes from the sides of the rectangle. I can call the offset from the side `hole_offset`.\n\nSo, to summarize, please generate an OpenSCAD file that:\n1. Creates a rectangular prism\n2. Creates a half-cylinder bumper at the end of the board.\n3. Includes a rounded edge on the corners of the rectangular prism\n4. Includes mounting holes that run through the rectangular prism.\n5. Make the `length`, `width`, `thickness`, `bumper_radius`, `corner_radius`, `hole_count`, `hole_diameter` and `hole_offset` all parameters.\n\nI would also like to use the `round` function from the `BOSL` library for the rounded edges. I'd prefer a clean, well-commented implementation so it is easy to understand.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Laser Ring",
    "scad": "fingerWidth = 18;\nbatteryWidth = 11.5;\nbatteryHeight = 5.6;\nbatteryCount = 3;\nlaserWidth = 7.08;\nlaserHeight = 14;\nthickness= 2.5;\nbatterySlot  = batteryHeight *batteryCount;\nringLength = (batterySlot) +( laserHeight+ thickness*2 );\ntranslate([0,0,ringLength ] ) rotate([180, 0, 0]) laserRing();\nmodule laserRing(){\n\tdifference(){\n\t\tlinear_extrude(height = ringLength) {\n\t\t\tface();\n\t\t}\n\t\ttranslate([fingerWidth/2 + batteryWidth/2 +thickness  ,0,thickness]){\n\t\t\tcylinder(r = batteryWidth/2,  h = batterySlot  );\n\t\t}\n\t\ttranslate([fingerWidth/2 +batteryWidth/2 + thickness*2   ,0,thickness+ batterySlot/2]){\n\t\t\t\tcube([batteryWidth/2, batteryWidth*2, batterySlot], center=true);\n\t\t}\n\t\ttranslate([fingerWidth/2 + batteryWidth/4 +thickness*1.5,0 ,thickness*2 +batterySlot  ]){\n\t\t\tcylinder(r=laserWidth/2, h =laserHeight );\n\t\t}\n\t\ttranslate([fingerWidth/2 + batteryWidth/4 +thickness*1.5  ,0,thickness+batterySlot ]){\n\t\t\tcylinder(r=laserWidth/2-1, h =laserHeight +thickness);\n\t\t}\n\t\ttranslate([-(ringLength * .6)/2 - fingerWidth/2, 50, 0] ) rotate([90, 0, 0])\n\t\tcylinder(r = ringLength * .8, h = 100);\n\t}\n\ttranslate([fingerWidth/2 +batteryWidth/2 + thickness*2+ .8, 0, thickness+ batterySlot/2])\n\t\tcube([.9, batteryWidth/2 +thickness*2+.9, batterySlot], center = true) ;\n}\nmodule face(){\n\tdifference(){\n\t\thull(){\n\t\t\tcircle(r = fingerWidth/2 + thickness)  ;\n\t\t\ttranslate([ fingerWidth/2 + thickness/2, -(batteryWidth )/2, 0])\n\t\t\tsquare([batteryWidth/2 +thickness*2, (batteryWidth )]);\n\t\t}\n\t\tcircle(r = fingerWidth/2);\n\t\ttranslate([-fingerWidth/2, 0, 0]){\n\t\t\tsquare([fingerWidth,fingerWidth*.25], center = true);\n\t\t}\n\t}\n}",
    "description": "Okay, I'm trying to design a laser ring, you know, like the kind that shines a little laser beam. I've got a basic idea using OpenSCAD, but I'd really like to make it parametric and a little more robust.\n\nHere's what I'm aiming for: a ring that holds a stack of button cell batteries and a small laser module.  The basic layout is that the batteries are stacked perpendicular to the ring direction, and the laser is mounted pointing lengthwise out from the ring.  Here are the parameters I think I'll need:\n\n*   **fingerWidth:**  This is the inner diameter of the ring, where it fits on your finger.\n*   **batteryWidth:** The diameter of the button cell batteries. I'm using LR44s, which are around 11.5mm.\n*   **batteryHeight:** The height of a single button cell. LR44s are 5.6mm.\n*   **batteryCount:** How many batteries will be stacked. Usually 3 for this kind of laser.\n*   **laserWidth:** The diameter of the laser module itself.  Mine is about 7.08mm\n*   **laserHeight:** The length of the laser module. Mine is around 14mm.\n*   **thickness:** The thickness of the ring walls, all around.  I'm using 2.5mm.\n\nRight now, the design extrudes a 2D shape to create the ring body, then cuts away the battery and laser slots. I also have a support to keep the battery stack in place.  It's a bit rough.  I'd really like this to be more easily adjustable and have smoother transitions and be less likely to have problems with 3D printing.\n\nSpecifically, I'd like:\n\n1.  A cleaner way to create the basic ring shape. Instead of a 2D shape extruded, can we maybe use a series of cylinders and subtract them? I'm thinking a main inner cylinder and a larger outer cylinder for the main ring structure.\n2.  The battery slot should be able to handle different numbers of batteries and I'd like it to be as efficient as possible. Maybe a curved cutout for the battery stack rather than a simple cylinder? It should also have a retaining wall, like my current design, but it should be curved and blend in a bit more.\n3.  The laser mount could use a little more attention. Maybe a tapered cylinder slot that holds the laser, instead of just a straight cylinder subtraction, that would allow more tolerance in the laser module itself and possibly have a slight flare to aid insertion.\n4.  I'd love to have some fillets and chamfers on the outer edges for better comfort and print quality. \n5.  Could we move that support so that it can be printed well, and maybe be more of a small curved wedge instead of a rectangular support?\n6.  Finally, it would be nice if there was a parametric \"gap\" variable that could control the clearance for all the parts. This would allow the user to control how snug the parts fit into the ring.\n\nI'm not super experienced with OpenSCAD, so the more help the better.  I'm okay with the code being reasonably complex; I can try to understand it.  I am aware of libraries available for OpenSCAD. Im happy to use the `MCAD` library, for the fillets and chamfers, specifically `fillet()` and `chamfer()`. I would be glad to use other libraries if they simplify the process, but I am most familiar with `MCAD`.\n\nThanks so much for your help!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable flexible name bracelet",
    "scad": "inner_radius = 28;\nouter_radius = 33;\nlength = 12;\nnozzle = 0.4;\nsections = 25;\ntext = \"Ingegno.be\";\nholes = \"no\";\ntext_thickness = 4;\nfull=\"True\";\nuse <MCAD/fonts.scad>\nmodule test(){\n  echo(\"test\");\n}\nbaseheight = 0.8;\nr1 = inner_radius;\nr2 = outer_radius;\nn = sections;\ngapin=2*nozzle;\ngapout = 3*nozzle;\nalpha = 2*PI/sections;\nalpha_1 = alpha - gapin/r1;\nbeta = 2*PI/sections;\nbeta_1 = alpha - gapout/r2;\nalpha_2 = gapin/r1;\nbeta_2 = gapout/r2;\nalpha_3 = nozzle/r1;\nbeta_3 = nozzle/r2;\nfudge = 0.01;\nthisFont=8bit_polyfont();\nx_shift=thisFont[0][0];\ny_shift=thisFont[0][1];\ntheseIndicies=search(text,thisFont[2],1,1);\nwordlength = (len(theseIndicies));\nfactorygap = 3;\nscale_x = (beta_1-beta_2) * r2 / x_shift;\nscale_y = (length - factorygap*gapout) / y_shift;\nthicknessword = text_thickness * nozzle;\nmodule alltext() {\n    for( j=[0:(len(theseIndicies)-1)] )\n      rotate([0, 0, (3/2*beta_2 + (beta_1-beta_2)/2 + j* beta)*180/PI])\n      translate([r2 -1.5* nozzle, -(beta_1-beta_2) * r2 /2 , factorygap/2*gapout])\n      rotate([90,0,90])\n        {\n        scale([scale_x,scale_y,1]){\n          linear_extrude(height=thicknessword)\n            polygon(points=thisFont[2][theseIndicies[j]][6][0],paths=thisFont[2][theseIndicies[j]][6][1]);\n        }\n      }\n}\nmodule innerholes() {\n  union() {\n    for (i = [0:n-1]){\n      rotate([0,0,(-alpha_1/2 + i* alpha)*180/PI])\n        translate([r1,0,0])\n          cube(size=[3*nozzle,r1*(alpha_2+alpha_3), 3*length], center=true);\n    }\n  }\n}\nmodule spikes() {\n  linear_extrude(height=length) { union(){\n    for (i = [0:n-1]){\n      polygon(points = [ [r1*cos((-alpha_1/2 + i* alpha-alpha_2/2)*180/PI),\n                          r1*sin((-alpha_1/2 + i* alpha-alpha_2/2)*180/PI)],\n                         [r2*cos((2*beta_2/2 + (i-1)* beta)*180/PI),\n                          r2*sin((2*beta_2/2 + (i-1)* beta)*180/PI)],\n                         [r2*cos((2*beta_2/2 + (i-1)* beta-beta_3)*180/PI),\n                          r2*sin((2*beta_2/2 + (i-1)* beta-beta_3)*180/PI)],\n                         [r1*cos((-alpha_1/2 + i* alpha-alpha_2/2-alpha_3)*180/PI),\n                          r1*sin((-alpha_1/2 + i* alpha-alpha_2/2-alpha_3)*180/PI)]\n                         ],\n                   paths = [ [0,1,2,3]]);\n    }\n  }}\n  linear_extrude(height=length) { union(){\n    for (i = [0:n-1]){\n      polygon(points = [ [r1*cos((-alpha_1/2 + i* alpha+alpha_2/2+alpha_3)*180/PI),\n                          r1*sin((-alpha_1/2 + i* alpha+alpha_2/2+alpha_3)*180/PI)],\n                         [r2*cos(((i)* beta+beta_3)*180/PI),\n                          r2*sin(( (i)* beta+beta_3)*180/PI)],\n                         [r2*cos(( (i)* beta)*180/PI),\n                          r2*sin(( (i)* beta)*180/PI)],\n                         [r1*cos((-alpha_1/2 + i* alpha+alpha_2/2)*180/PI),\n                          r1*sin((-alpha_1/2 + i* alpha+alpha_2/2)*180/PI)]\n                         ],\n                   paths = [ [0,1,2,3]]);\n    }\n  }}\n}\nmodule outerholes() {\n  union() {\n    for (i = [0:n-1]){\n      rotate([0,0,(beta_2/2 + i* beta)*180/PI])\n        translate([r2-nozzle,0,0])\n          cube(size=[3*nozzle, gapout, 3*length], center=true);\n    }\n  }\n}\nmodule outercirc(){\n  difference(){\n    cylinder(h=length, r=r2, $fn=100);\n    translate([0,0,-fudge]) cylinder(h=length+2*fudge, r=r2-nozzle, $fn=100);\n    outerholes();\n  }\n}\nmodule innercirc(){\n  difference(){\n    cylinder(h=length, r=r1+nozzle, $fn=100);\n    translate([0,0,-fudge]) cylinder(h=length+2*fudge, r=r1, $fn=100);\n    innerholes();\n  }\n}\nmodule baseform(){\n  union(){\n    outercirc();\n    innercirc();\n    spikes();\n  }\n}\nrotate([0,0,-90])\nif (holes == \"yes\") {\n  difference(){\n  baseform();\n  alltext();\n  }\n} else {\n  union(){\n    baseform();\n    alltext();\n  }\n}",
    "description": "Okay, I'd like to design a flexible bracelet using OpenSCAD. I've seen some designs online, but I want a parametric design that allows me to customize it. Here's what I'm looking for:\n\n**Core Structure:**\n\n*   **Flexible Segments:** The bracelet should be made of connected, repeating segments to achieve flexibility.\n*   **Inner and Outer Radius:** I need to be able to set the inner radius (where the bracelet will sit on my wrist) and the outer radius (the overall width of the bracelet). These should be adjustable parameters.\n*   **Bracelet Length/Height:** I'd like to control the bracelet's thickness (how tall it is when printed).\n*   **Nozzle Diameter:** I need to input my 3D printer's nozzle diameter so the design takes gaps and widths into account.\n*   **Number of Segments:** The number of repeating segments should be customizable, affecting the level of flexibility.\n\n**Text Feature:**\n\n*   **Text Input:** I want to add custom text to the bracelet.\n*   **Text Placement:** The text should be placed on the outer circumference of the bracelet.\n*   **Text Thickness:** The thickness of the text should be an adjustable parameter.\n*   **Text as Holes:** I need a toggle to decide whether the text should be raised (extruded) or cut as holes in the bracelet.\n\n**Other Features:**\n\n*   **Gap Creation:** The segments will need gaps to allow flexibility, and the size of these gaps should be adjustable based on the nozzle size. There should be different gaps on the inner and outer parts of the segments.\n*   **Solid Base Structure:** The underlying structure of the bracelet should be solid, with the flexibility and gaps created between the solid segments.\n*   **Full Boolean:** There should be an option to control whether to use a full Boolean or only part of the bracelet.\n\n**Specific OpenSCAD Requirements:**\n\n*   I need to use the `MCAD/fonts.scad` library to handle the text.\n*   The design should use a combination of `linear_extrude`, `polygon`, `rotate`, `translate`, `difference`, `union`, `cylinder` and `cube` primitives, to create the base structure, and text.\n*   I need all values to be parametric, so I can adjust the bracelet later and generate new designs.\n*   I want the design to be well-commented.\n*   Include some basic unit tests that print some text to the console.\n\nCould you please generate the OpenSCAD code that meets these requirements?\n"
  },
  {
    "object": "Hey cadmonkey, make me a [Parametric] Pyramids (easy to print)",
    "scad": "use<utils/build_plate.scad>;\nuse<solids.scad>;\nPyramid_type = 1;\nBase_side_size = 30;\nPyramid_number = 6;\nheight = Base_side_size;\ndist = height;\nnum = Pyramid_number;\nangle = atan(0.5);\nbuild_plate(3,200,200);\nif(Pyramid_type == 2) translate([0,0,Base_side_size/3]) {\nEquilateral_pyramid(height);\nif(num > 1)\nfor(i=[0:num-2])\nrotate([0,0,i*90])\n  translate([0,dist,0])\n    Equilateral_pyramid(height);\nif(num > 5)\n  for(i=[0:num-6])\n    rotate([0,0,45+i*90])\n      translate([0,dist*1.5,0])\n        Equilateral_pyramid(height);\n} else translate([0,0,Base_side_size/2]) {\nfor(i=[0:num-1])\nrotate([0,0,i*90])\n  translate([0,dist,0])\n    Isosceles_pyramid(height);\nif(num > 4)\n  for(i=[0:num-5])\n    rotate([0,0,45+i*90])\n      translate([0,dist*1.5,0])\n        Isosceles_pyramid(height);\nif(num > 8)\n  translate([0,-dist*1.5,0])\n     Isosceles_pyramid(height);\n}\nmodule Equilateral_pyramid(height) {\n    edge = height;\n    tinyValue = 0.001;\n    rotate([90+45,0,0])\n      hull() {\n          cube(size=[edge, edge, tinyValue], center=true);\n          translate([0, 0, height/2]) cube(size=[tinyValue, tinyValue, tinyValue], center=true);\n      }\n}\nmodule Isosceles_pyramid(height) {\n    edge = height;\n    tinyValue = 0.001;\n    rotate([+90+angle,0,0])\n      hull() {\n          cube(size=[edge, edge, tinyValue], center=true);\n          translate([0, 0, height]) cube(size=[tinyValue, tinyValue, tinyValue], center=true);\n      }\n}",
    "description": "Okay, I'd like to design a parametric pyramid, but I need a bit more flexibility than what I currently have, and also a way to easily arrange them in specific patterns.\n\nHere's what I'm thinking:\n\n**Core Pyramid Design:**\n\n*   I need both isosceles and equilateral pyramids. The base of both pyramid types will be square.\n*   I want to be able to define the base side length of the square.\n*   The *height* of both types of pyramids should also be configurable.\n*  The code needs to use the hull() function, similar to how it is implemented in the provided code.\n*  The code should take advantage of the fact the pyramids are positioned on the side to enable easier printing (no messy vertices).\n\n**Parametric Arrangement:**\n\n*   I want to be able to create a grid of pyramids. I should specify:\n    *   The number of rows and columns.\n    *   The spacing between pyramids in both the X and Y direction.\n\n*   I would also like a polar arrangement option where the pyramids are placed in a circle. I need to specify:\n    *   The number of pyramids in the circle.\n    *   The radius of the circle on which the pyramid bases will be centered.\n\n* I need the ability to rotate each pyramid after it's been arranged, using a global rotational modifier.\n\n**Additional considerations:**\n*   The pyramids should sit \"on their side\" so that they are easier to print, with the base at the bottom and the vertex to the side. (Like in my original file).\n*   I'd like to use units in millimeters, so that its easy to set the right scale for printing.\n*  I need the program to include the `build_plate()` module from the `utils` library, as specified in my attached code.\n*  I need the program to include the `Equilateral_pyramid()` and `Isosceles_pyramid()` modules from the `solids` library, as specified in my attached code.\n\nTo summarize, I need a parametric OpenSCAD file that creates both isosceles and equilateral pyramids, allows me to arrange them in a grid or circle pattern, and be able to globally rotate them. I have attached example code that has the basic functionality and should help to establish the correct shape. The example code uses the `build_plate` and `solids` libraries, and your solution should assume these are available as well.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Weight for Me - Customizeable Weights",
    "scad": "use <write/Write.scad>\nexportMode = 0;\nfillMaterial = 1500;\nweightUnit = 2.20462;\nweight = 10;\nweightType = 2;\nif (exportMode == 0) {\n  if (weightType == 2) {\n    translate([68,0,weightRadius*13.377])\n    rotate(a=-90, v=[0,1,0]) {\n      union() {\n        drawBarbell();\n        drawWeightContainer();\n        translate([0,0,150])\n          rotate(a=180, v=[0,1,0])\n            drawWeightContainer();\n      }\n    }\n  }\n  else {\n    translate([0,0,volumeDepth*10+8]) {\n      drawKettleHandle();\n      drawWeightContainer();\n    }\n  }\n}\nelse if (exportMode == 1) {\n  if (weightType == 2) {\n    translate([68,0,weightRadius*12+7])\n    rotate(a=-90, v=[0,1,0]) {\n      drawBarbell();\n    }\n  }\n  else {\n    drawKettleHandle();\n  }\n}\nelse if (exportMode == 2) {\n    translate([0,0,volumeDepth*10+8]) {\n      drawWeightContainer();\n    }\n}\nmodule drawBarbell() {\n  union() {\n    translate([0,0,150])\n      rotate(a=180,v=[0,1,0])\n        drawBarbellCap();\n    translate([0,0,17])\n      cylinder(h=116, r1=12.5, r2=12.5, center=false, $fn=16);\n    drawBarbellCap();\n  }\n}\nweightRadius = 6.5;\ncollarVolume = 3.14159*(weightRadius*0.9)*(weightRadius*0.9)*4;\ntargetVolume = ((weight/weightUnit/weightType)/fillMaterial)*1000000 - collarVolume;\nvolumeDepth = targetVolume/147.875;\nmodule drawKettleHandle() {\n  difference() {\n    union() {\n      translate([weightRadius*5, 0, 18]) {\n        rotate(a=20, v=[0,1,0])\n        union() {\n          sphere(r=12.5, center=true, $fn=32);\n          cylinder(h=80, r1=12.5, r2=12.5, center=false, $fn=32);\n          translate([0,0,80])\n            sphere(r=12.5, center=true, $fn=32);\n          translate([0,0,80])\n            rotate(a=-110, v=[0,1,0])\n              cylinder(h=122, r1=12.5, r2=12.5, center=false, $fn=32);\n        }\n      }\n      translate([-weightRadius*5, 0, 18]) {\n        rotate(a=-20, v=[0,1,0])\n        union() {\n          sphere(r=12.5, center=true, $fn=32);\n          cylinder(h=80, r1=12.5, r2=12.5, center=false, $fn=32);\n          translate([0,0,80])\n            sphere(r=12.5, center=true, $fn=32);\n        }\n      }\n    }\n    cube(size=[weightRadius*20, weightRadius*20, 30], center=true);\n  }\n  drawBarbellCap();\n}\nmodule drawBarbellCap() {\n  difference() {\n    cylinder(h=18, r1=weightRadius*12+7, r2=weightRadius*12+7, center=false, $fn=32);\n    drawThreads(15, weightRadius*12, 3, 0.15, 1);\n  }\n}\nmodule drawWeightContainer() {\n  text = str(weight/weightType, (weightUnit == 1) ? \" kg\" : \" lbs\");\n  translate([0,0,-volumeDepth*10-5+3])\n  union() {\n    difference() {\n      drawWeight();\n      translate([0,0,-3]) {\n        mirror([1,0,0]) {\n          write(text, t=2, h=weightRadius*3.5, font=\"write/orbitron.dxf\", center=true);\n          translate([0,-weightRadius*4, 0]) {\n            if (fillMaterial == 1000) {\n              write(\"Fill With Water\", t=2, h=weightRadius*1.5, font=\"write/Letters.dxf\", center=true);\n            }\n            else if (fillMaterial == 1500) {\n              write(\"Fill With Sand\", t=2, h=weightRadius*1.5, font=\"write/Letters.dxf\", center=true);\n            }\n            else if (fillMaterial == 7000) {\n              write(\"Fill With Pennies\", t=2, h=weightRadius*1.5, font=\"write/Letters.dxf\", center=true);\n            }\n            else if (fillMaterial == 8400) {\n              write(\"Fill With Shot\", t=2, h=weightRadius*1.5, font=\"write/Letters.dxf\", center=true);\n            }\n          }\n        }\n      }\n    }\n    difference() {\n      translate([0,0,volumeDepth*10+1.5])\n        drawThreads(15, weightRadius*12, 3, 0.15, 1);\n      drawCollar();\n    }\n  }\n}\nmodule drawThreads(length, radius, threadDepth, tpm, leftRight = 0) {\n  if (exportMode > 0) {\n    mirror([leftRight,0,0])\n  \tlinear_extrude(height=length, twist=360*length*tpm, center=false, $fn=32)\n  \t  translate([threadDepth,0,0])\n  \t    circle(r=radius-threadDepth);\n  }\n}\nmodule drawCollar() {\n  if (exportMode > 0) {\n    translate([0,0,volumeDepth*10+1.25])\n      cylinder(h=46,r1=weightRadius*9,r2=weightRadius*9, $fn=32);\n  }\n}\nmodule drawWeight() {\n  polyhedron(\n  points=[\n    [-5.491517066955566*weightRadius,13.255526542663574*weightRadius,-3],\n    [-5.5304107666015625*weightRadius,13.376564979553223*weightRadius,3.9257373809814453],\n    [5.509345054626465*weightRadius,13.248157501220703*weightRadius,-3],\n    [5.548361301422119*weightRadius,13.369129180908203*weightRadius,3.9257373809814453],\n    [13.282904624938965*weightRadius,5.479954719543457*weightRadius,-3],\n    [13.37697982788086*weightRadius,5.529995918273926*weightRadius,3.9257373809814453],\n    [13.275522232055664*weightRadius,-5.498571395874023*weightRadius,-3],\n    [13.36954402923584*weightRadius,-5.548775672912598*weightRadius,3.9257373809814453],\n    [5.491516590118408*weightRadius,-13.256356239318848*weightRadius,-3],\n    [5.530409812927246*weightRadius,-13.377394676208496*weightRadius,3.9257373809814453],\n    [-5.50934362411499*weightRadius,-13.248984336853027*weightRadius,-3],\n    [-5.54836368560791*weightRadius,-13.36995792388916*weightRadius,3.9257373809814453],\n    [-13.282904624938965*weightRadius,-5.4807844161987305*weightRadius,-3],\n    [-13.37697982788086*weightRadius,-5.530825138092041*weightRadius,3.9257373809814453],\n    [-13.275521278381348*weightRadius,5.497743606567383*weightRadius,-3],\n    [-13.369544982910156*weightRadius,5.547945976257324*weightRadius,3.9257373809814453],\n    [-5.5304107666015625*weightRadius,13.376564979553223*weightRadius,8.43543815612793+(volumeDepth-1)*10],\n    [5.548361301422119*weightRadius,13.369129180908203*weightRadius,8.43543815612793+(volumeDepth-1)*10],\n    [13.37697982788086*weightRadius,5.529995918273926*weightRadius,8.43543815612793+(volumeDepth-1)*10],\n    [13.36954402923584*weightRadius,-5.548775672912598*weightRadius,8.43543815612793+(volumeDepth-1)*10],\n    [5.530409812927246*weightRadius,-13.377394676208496*weightRadius,8.43543815612793+(volumeDepth-1)*10],\n    [-5.54836368560791*weightRadius,-13.36995792388916*weightRadius,8.43543815612793+(volumeDepth-1)*10],\n    [-13.37697982788086*weightRadius,-5.530825138092041*weightRadius,8.43543815612793+(volumeDepth-1)*10],\n    [-13.369544982910156*weightRadius,5.547945976257324*weightRadius,8.43543815612793+(volumeDepth-1)*10],\n    [-5.466272354125977*weightRadius,13.194588661193848*weightRadius,12.0+(volumeDepth-1)*10],\n    [5.484016418457031*weightRadius,13.187253952026367*weightRadius,12.0+(volumeDepth-1)*10],\n    [13.221841812133789*weightRadius,5.454761028289795*weightRadius,12.0+(volumeDepth-1)*10],\n    [13.214489936828613*weightRadius,-5.473294734954834*weightRadius,12.0+(volumeDepth-1)*10],\n    [5.46627140045166*weightRadius,-13.195416450500488*weightRadius,12.0+(volumeDepth-1)*10],\n    [-5.484017848968506*weightRadius,-13.188077926635742*weightRadius,12.0+(volumeDepth-1)*10],\n    [-13.221843719482422*weightRadius,-5.455591201782227*weightRadius,12.0+(volumeDepth-1)*10],\n    [-13.214491844177246*weightRadius,5.472464561462402*weightRadius,12.0+(volumeDepth-1)*10],\n    [-4.999999523162842*weightRadius,10.0*weightRadius,12.0+(volumeDepth-1)*10],\n    [5.0*weightRadius,10.0*weightRadius,12.0+(volumeDepth-1)*10],\n    [10.0*weightRadius,4.999999523162842*weightRadius,12.0+(volumeDepth-1)*10],\n    [10.0*weightRadius,-5.0*weightRadius,12.0+(volumeDepth-1)*10],\n    [4.999999046325684*weightRadius,-10.0*weightRadius,12.0+(volumeDepth-1)*10],\n    [-5.0*weightRadius,-10.0*weightRadius,12.0+(volumeDepth-1)*10],\n    [-10.0*weightRadius,-5.0*weightRadius,12.0+(volumeDepth-1)*10],\n    [-10.0*weightRadius,5.0*weightRadius,12.0+(volumeDepth-1)*10],\n    [-4.999999046325684*weightRadius,9.999998092651367*weightRadius,2.0],\n    [5.0*weightRadius,10.0*weightRadius,2.0],\n    [10.0*weightRadius,5.0*weightRadius,2.0],\n    [9.999998092651367*weightRadius,-5.0*weightRadius,1.9999995231628418],\n    [4.999999046325684*weightRadius,-10.0*weightRadius,2.0],\n    [-5.0*weightRadius,-9.999998092651367*weightRadius,2.0],\n    [-10.0*weightRadius,-4.999999523162842*weightRadius,1.9999995231628418],\n    [-10.0*weightRadius,5.0*weightRadius,2.0]\n  ],\n  triangles=[\n    [0,3,1],\n    [2,5,3],\n    [4,6,5],\n    [6,8,7],\n    [8,10,9],\n    [10,12,11],\n    [5,17,3],\n    [14,1,15],\n    [12,15,13],\n    [0,4,2],\n    [19,26,18],\n    [7,18,5],\n    [3,16,1],\n    [9,19,7],\n    [11,20,9],\n    [13,21,11],\n    [15,22,13],\n    [1,23,15],\n    [28,36,27],\n    [22,29,21],\n    [18,26,17],\n    [21,28,20],\n    [16,31,23],\n    [17,24,16],\n    [20,27,19],\n    [23,30,22],\n    [37,44,36],\n    [31,39,30],\n    [27,35,26],\n    [30,38,29],\n    [26,34,25],\n    [29,37,28],\n    [24,32,31],\n    [25,33,24],\n    [41,42,40],\n    [32,47,39],\n    [33,40,32],\n    [36,43,35],\n    [39,46,38],\n    [35,43,34],\n    [38,46,37],\n    [34,41,33],\n    [2,3,0],\n    [4,5,2],\n    [5,6,7],\n    [7,8,9],\n    [9,10,11],\n    [11,12,13],\n    [18,17,5],\n    [0,1,14],\n    [14,15,12],\n    [8,6,4],\n    [12,10,8],\n    [14,12,0],\n    [0,8,4],\n    [12,8,0],\n    [27,26,19],\n    [19,18,7],\n    [17,16,3],\n    [20,19,9],\n    [21,20,11],\n    [22,21,13],\n    [23,22,15],\n    [16,23,1],\n    [27,36,35],\n    [30,29,22],\n    [17,26,25],\n    [29,28,21],\n    [24,31,16],\n    [25,24,17],\n    [28,27,20],\n    [31,30,23],\n    [45,44,37],\n    [30,39,38],\n    [26,35,34],\n    [29,38,37],\n    [25,34,33],\n    [28,37,36],\n    [31,32,39],\n    [24,33,32],\n    [40,42,47],\n    [47,42,46],\n    [46,42,45],\n    [45,42,44],\n    [44,42,43],\n    [40,47,32],\n    [41,40,33],\n    [44,43,36],\n    [47,46,39],\n    [34,43,42],\n    [37,46,45],\n    [42,41,34]\n  ]);\n}",
    "description": "Okay, I'm looking for an OpenSCAD design for customizable, fillable weights, similar to the one I found online, but with more flexibility.  I want to be able to easily adjust the shape, size, and weight of the final product, and I need different export options, too. I need both barbell and kettlebell styles.\n\nHere's what I have in mind:\n\n**General Requirements:**\n\n*   **Parametric Design:** The entire design should be driven by parameters, allowing me to easily adjust things like weight, dimensions, and the type of filler material.\n*   **Fillable:** The weights should be hollow and designed to be filled with different materials (water, sand, pennies, or lead shot).\n*   **Printable:** The design should be printable on a standard 3D printer (at least a 6\"x6\" bed).\n*   **Export Modes:** I need three export options:\n    *   **Preview Mode:**  Displays the complete weight assembly, including the handle and weight container.\n    *   **Handle Only:** Exports only the handle (barbell or kettlebell style).\n    *   **Weight Container Only:** Exports only the fillable container.\n*   **Units:** I'd like to specify the target weight in either kilograms or pounds.\n*   **Material Density:**  The design should account for the density of the filler material when calculating the container's required volume.\n*   **Text Labels:** The design should include text labels on the weight container, indicating the target weight and type of fill material. These should be mirrored on the opposite side of the weight.\n\n**Specific Features:**\n\n*   **Weight Types:**\n    *   **Barbell/Dumbbell:** This should have two fillable containers connected by a bar handle.\n    *   **Kettlebell:** This should have a single fillable container with a loop-style handle.\n*   **Barbell Handle:**\n    *   The handle should have end caps and a textured grip area.\n    *   The end caps should connect to the weight containers with threads (a feature I saw in the example code), and should have a collar to secure the weight.\n*   **Kettlebell Handle:**\n    *   The handle should be a smooth, ergonomic loop, connected to the top of the weight container, ideally using a similar threaded collar connection to the weight container.\n*   **Weight Container Shape:**\n    *   I'd like the weight container to be roughly spherical, but with a faceted look. It doesn't have to use exactly the same polyhedron geometry I saw in the online example - it just needs to look similar to what I saw. This shape should be parametric enough to let me adjust the number of facets in the future.\n\n**Parameters I'd Like to Control:**\n\n*   `exportMode`: (0: Preview, 1: Handle, 2: Weight Container)\n*   `fillMaterial`: (e.g., Water, Sand, Pennies, Lead Shot)  This should ideally use a list that maps to density values.\n*   `weightUnit`: (Kilograms or Pounds)\n*   `weight`: (Target weight)\n*   `weightType`: (Dumbbell or Kettlebell)\n*   `weightRadius`: (Starting radius of the weights, which should affect the size of the handle etc.)\n    *   The `weightRadius` should also be used to scale the text elements.\n\n**Libraries:**\n\n*   I know this will require the `write/Write.scad` library, as the example I have uses that for the text. I can provide this library as needed.\n\n**Output:**\n\nI'm looking for a single `.scad` file that includes all of this, please. Please make sure that your parametric design is well-commented and easy to adjust.  I'd also like to know how to easily add more materials to the `fillMaterial` options in the future.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Universal Stand",
    "scad": "stand_width = 80;\npaper_thickness = 16;\npaper_height = 115;\nholdback_height = 12;\nwall_thickness = 3;\nfuzz = 0.01;\nrotate_angle = 15;\nrotate_a = -rotate_angle;\ntail_length=20;\nprint_mode = \"preview\";\nstart();\nmodule start(){\n\tif (print_mode == \"preview\"){\n\t\tdifference(){\n \t\t\tding();\n\t\t\ttranslate([-300,-300,-600]) cube([600,600,600]);\n\t\t}\n\t} else {\n\t\trotate(-90,[0,1,0]){\n\t\t\tdifference(){\n \t\t\t\tding();\n\t\t\t\ttranslate([-300,-300,-600]) cube([600,600,600]);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule ding(){\n\trotate(rotate_a,[1,0,0]) a();\n\tb();\n\tc();\n}\nmodule a(){\n\tcube([stand_width, wall_thickness,paper_height]);\n\ttranslate([0,-paper_thickness+fuzz,0]) cube([stand_width, paper_thickness, wall_thickness]);\n\ttranslate([0,-paper_thickness+fuzz,0]) cube([stand_width, wall_thickness,holdback_height]);\n}\nmodule b(){\n\tcube([stand_width,sin(rotate_a*-1)*paper_height,wall_thickness]);\n\ttranslate([0,sin(rotate_a*-1)*paper_height,0]) cube([stand_width,wall_thickness,cos(rotate_a*1)*paper_height]);\n}\nmodule c(){\n\tcube([stand_width,sin(rotate_a*-1)*paper_height+tail_length,wall_thickness]);\n}",
    "description": "Okay, I'd like a parametric OpenSCAD design for a simple paper stand, similar to the one I already have, but I want more control over some aspects and a cleaner implementation.\n\nHere's what I'm looking for:\n\n*   **Core Functionality:** It needs to hold papers upright at a slightly tilted angle. Basically, a base with a back support, a little lip to hold the paper at the bottom, and a holdback to keep the papers from falling forward.\n*   **Key Dimensions (Parameters):**\n    *   `stand_width`: The width of the stand (and therefore the paper it can hold). I'd like to set this in mm.\n    *   `paper_thickness`: This defines how deep the paper lip/tray is. I'll probably be using this with stacks of paper, so I'd like it to be a bit larger.\n    *   `paper_height`: The height of the back support for the paper.\n    *   `holdback_height`: The height of the holdback lip.\n    *  `wall_thickness`: The thickness of all the structural parts.\n    *   `paper_angle`: This sets the tilt of the back support and thus how leaned back the paper is, in degrees.\n\n*   **Additional Features:**\n    *   **Tail:** Include a tail at the back of the base to prevent it from tipping backwards, as in my current design. This should be parametric, so I can set its length.  `tail_length`\n     * **Clear preview:** Ensure that in `print_mode=\"preview\"`, the design is viewable normally, but that when `print_mode=\"print\"` the design is automatically rotated for printing on its side (without supports). This should be an easy switch for the user via the parameter `print_mode`\n    *   **Fuzz factor:** Allow a small tolerance value for `paper_thickness`, to deal with manufacturing issues or slight paper variations.\n\n*   **Design:** The design should be mostly box-like, but with the back support tilted. I like the idea that the back of the structure has a support that follows the tilt of the back support and makes it rigid. Also, make sure that the tail is part of the base, so that it also follows the angle of the back support.\n\n*   **OpenSCAD Style:**\n    *  Use modules for the main features to make the code easier to understand and change.\n    *   Use parameters for all important dimensions.\n    *   Keep it as simple as possible, without any fancy libraries for now.\n    * The design should be placed in the origin and be centered in the Y-direction. This way the user can position the object anywhere easily.\n\nI think that covers everything. I'm looking forward to seeing what you can come up with!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizeable Stamp",
    "scad": "use <write/Write.scad>\nunits = 1;\nheadType = 1;\nhandleDiameter = 50;\nhandleLength = 80;\nheadWidth = 120;\nheadHeight = 35;\nmyFont = \"write/Letters.dxf\";\ntext = \"MakerBot\";\ntextRotation = 0;\ntextWidth = headWidth*0.9;\ntextHeight=textWidth/(units*0.55*len(text))*units;\ntranslate([0,0,(headHeight>handleDiameter)?headHeight*units/2:handleDiameter*units/2])\nrotate(a=90, v=[1,0,0])\nunion() {\n  createHandle();\n  createBridge();\n  createHead();\n  createPrint();\n}\nmodule createPrint() {\n  myHeight = (textHeight<headHeight) ? textHeight : headHeight;\n  translate([0,myHeight*0.0625,12.7+2.49999])\n    mirror([1,0,0])\n      write(text, t=5, h=myHeight*units*0.75, rotate=textRotation,font=myFont, center=true);\n}\nmodule createHandle() {\n  translate([0,0,-handleLength*units])\n  rotate_extrude($fn=100)\n  scale([handleDiameter*units/2, handleLength*units*0.8, 0])\n    handlePoly();\n}\nmodule handlePoly() {\n  polygon(points=[[0,0],[0,1],[1,1],[1,0.858],[0.915,0.818],[0.858,0.761],[0.828,0.682],[0.814,0.57],[0.824,0.463],[0.861,0.387],[0.906,0.332],[0.953,0.299],[1,0.277],[1,0.226],[0.923,0.141],[0.707,0.07],[0.317,0.017]]);\n}\nmodule createBridge() {\n  translate([0,0,-handleLength*units*0.2])\n  cylinder(h=handleLength*units*0.2, r1=handleDiameter*units/2, r2=((headWidth<headHeight)?headWidth*units/2:headHeight*units/2), $fn=101);\n}\nmodule createHead() {\n  if (headType == 0) {\n    translate([0,0,6.35])\n    cube(size=[headWidth*units,headHeight*units,12.7], center=true);\n  }\n  else if (headType == 1) {\n    scale([headWidth*units,headHeight*units,1])\n    cylinder(h=12.7, r1=0.5, r2=0.5, $fn=101);\n  }\n}",
    "description": "Okay, I need a custom stamp designed in OpenSCAD. I want it to be parametric so I can easily change the dimensions and text later. \n\nHere's what I'm looking for:\n\n**General Structure:**\n\nThe stamp should have three main parts: a handle, a bridge connecting the handle to the head, and the stamp head itself.\n\n**Handle:**\n\n*   It should be a rounded shape, created by rotating a 2D polygon.\n*   The handle should have a customizable diameter and length.\n*   I'd like to use the same polygon shape used in the example file, from the `handlePoly()` function, as a starting point.\n\n**Bridge:**\n\n*   The bridge will connect the circular handle to the (potentially non-circular) head.\n*   It should be a cylindrical shape that has one diameter that matches the handle's diameter and the other diameter that matches the head's width or height (whichever is smaller).\n*   The bridge should have a customizable length.\n\n**Stamp Head:**\n\n*   The head can be either a rectangle or an ellipse, and I want to be able to choose between these two shapes.\n*   It should have customizable width and height.\n*   It should have a thickness that's consistent with the example file.\n\n**Text:**\n\n*   I need to be able to engrave text onto the head of the stamp.\n*   The text should be centered on the head and automatically resized to fill a significant portion of the stamp head, while not going over the edge. I want the font to be customizable, like in the example file. I specifically want to be able to use any font that is usable by the included `write/Write.scad` library.\n*   I also need to be able to rotate the text if I choose to.\n\n**Parametric Considerations:**\n\n*   I want to be able to set all dimensions in units of millimeters, centimeters, or inches, and I'll provide a single parameter for this scaling.\n*   I need parameters to define the handle's diameter, handle length, bridge length, head width, head height, the head type (rectangle or ellipse), the text, the text rotation, and the font from `write/Write.scad`.\n*   The thickness of the head should be fixed at 12.7 scaled by the chosen unit scale (as in the included file)\n*   The depth of the text should be fixed at 5 scaled by the chosen unit scale (as in the included file)\n*   The text's height should be based on 75% of the head's height, or the height of the space the text is going into, whichever is smaller, as specified in the example file.\n\n**Libraries:**\n* I understand that the included library `write/Write.scad` is already expected in the environment, and I am requesting that it is used. I do not need to see this library, and I also do not need to ask about it.\n\nEssentially, I want a flexible stamp generator that allows me to easily customize its size, shape, and text while using the `write/Write.scad` for the text.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Funnel",
    "scad": "Large_End_Diameter = 60;\nSmall_End_Diameter = 10;\nWall_Thickness = 1;\nFunnel_Height = 40;\nTop_Band = 5;\nBottom_Spout_Length = 10;\nspout_or = Small_End_Diameter/2;\nwall = Wall_Thickness;\nflare_percentage = Large_End_Diameter / Small_End_Diameter * 100;\nheight = Funnel_Height;\nbottom_band=Bottom_Spout_Length;\nres = 100/2;\nplane = 0.01/1;\nspout_ir = spout_or - wall;\ntop_or = spout_or*flare_percentage/100;\ntop_ir = top_or - wall;\nh1 = bottom_band;\nh2 = height - Top_Band;\nfunnel_rise = height - bottom_band - Top_Band;\nhi_adjust_ang = atan((top_or-spout_or)/funnel_rise)/2;\nhi_adjust = wall*tan(hi_adjust_ang);\ntranslate([0,0,height])mirror([0,0,1])difference(){\nunion(){\ncylinder(h=bottom_band,r=spout_or,$fn=res);\ntranslate([0,0,h1])cylinder(h=funnel_rise,r1=spout_or,r2=top_or,$fn=res);\ntranslate([0,0,h2])cylinder(h=Top_Band,r=top_or,$fn=res);\n}\nunion(){\ncylinder(h=bottom_band+plane+hi_adjust,r=spout_ir,$fn=res);\ntranslate([0,0,h1+hi_adjust])cylinder(h=funnel_rise,r1=spout_ir,r2=top_ir,$fn=res);\ntranslate([0,0,h2+hi_adjust-plane])cylinder(h=Top_Band+hi_adjust+plane,r=top_ir,$fn=res);\n}\n}",
    "description": "Okay, I'm looking to design a customizable funnel using OpenSCAD, and I have some specific requirements and parameters I'd like to control.\n\nI need a funnel with a large opening at the top and a smaller opening at the bottom, connected by a tapered section. Here are the key parameters that need to be customizable:\n\n1.  **Large End Diameter:** I need to be able to specify the outer diameter of the large opening at the top of the funnel.\n2.  **Small End Diameter:** I need to specify the outer diameter of the small opening at the bottom of the funnel.\n3.  **Wall Thickness:** I need to be able to define the thickness of the funnel walls.\n4.  **Funnel Height:** The overall height of the tapered part of the funnel, excluding the bands, should be adjustable.\n5.  **Top Band Height:** I'd like to have a straight, cylindrical band at the top of the funnel *before* the tapered section begins. I need to specify the height of this band.\n6.  **Bottom Spout Length:** I need to specify the length of a straight cylindrical spout at the bottom of the funnel *after* the tapered section ends.\n\nI'd like the OpenSCAD file to calculate the inner diameters based on the outer diameters and wall thickness, and then use those values to create the funnel using cylinders. The output should be a single solid funnel object.\n\nThe important thing to me is the parametric design. I need to be able to easily change any of those parameters to make different sized funnels. I don't need any fancy features, just a simple, well-defined funnel with precise dimensions. I don't expect any library usage besides the core OpenSCAD functionality.\n\nCould you please provide an OpenSCAD file that allows me to customize all of these parameters?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Wall bracket",
    "scad": "ClampSize=10;\nThickness=2;\nRimHeight=3;\nCorner=2;\nMakeBracket();\nmodule MakeBracket(){\nWidth=20;\nrotate([0,0,-90]) difference(){\nlinear_extrude(height = Width)\npolygon([[0,0],[0,20+Thickness],[Thickness,20+Thickness],[Thickness,Thickness+Corner],[Thickness+Corner,Thickness],[Thickness+ClampSize-Corner,Thickness],[Thickness+ClampSize,Thickness+Corner],[Thickness+ClampSize,Thickness+RimHeight],[2*Thickness+ClampSize,Thickness+RimHeight],[2*Thickness+ClampSize,Corner],[2*Thickness+ClampSize-Corner,0]]);\n# translate([-0.1,10+Thickness,Width/2]) rotate([0,90,0]) cylinder(r1=2.5,r2=5,h=Thickness+0.2);\n}\n}",
    "description": "Okay, I'm looking to get a customizable wall bracket designed in OpenSCAD. I've used something similar before, and I have a good idea of what I want, but I'd like to have something a little more flexible.\n\nEssentially, I need a bracket that can clamp onto a flat object and be mounted to a wall. I've used a design in the past (attached, for reference) that's a good starting point, but I want to make some improvements. Specifically:\n\n1.  **Parametric Clamp Size:** The original design uses a `ClampSize` variable, which is great, but I'd like it to have more flexibility. I'd like to define the thickness of the object being clamped, but also to have a separate parameter that specifies the *gap* between the clamp and the wall. For example, `ClampSize` should become the thickness of the clamped object, and I'd like a new parameter `ClampGap` to define how far the object sticks out from the wall.\n\n2.  **Parametric Width and Height:** I'd like to be able to easily adjust the width of the bracket (how far it extends along the wall) and the overall height of the bracket. The original `Width` parameter only controls how wide the base of the bracket is, but does not effect the height of the bracket. I'd like to be able to change that using `BracketHeight`.\n\n3.  **Rounded Edges:** Instead of sharp edges on the main clamping section, I would like them to be rounded for a more finished look. Instead of `Corner` being a fixed value, it should be the radius of a curve. The entire bracket should have an option to add a rounded edge, using a global parameter called `Round`. The base of the bracket (where it meets the wall) should have no rounding or beveled edges.\n\n4.  **Mounting Holes:** Instead of the single cylinder mounting hole, I'd like to have two mounting holes, countersunk for flat head screws, with the positions also being parametrically defined. This should be controlled by parameters `MountHole_X_Separation`, `MountHole_Y`, `Screw_Head_Diameter` , `Screw_Head_Angle`, and `Screw_Shank_Diameter`.\n\n5.  **Material Thickness Parameter:** I still want to keep a `Thickness` parameter to control the material thickness.\n\nSo, in summary, I would like the following parameters:\n*   `ClampSize`: Thickness of object being clamped.\n*   `ClampGap`: Distance the object is held out from the wall.\n*   `BracketWidth`: Width of the bracket, along the wall.\n*   `BracketHeight`: Height of the entire bracket.\n*   `Round`: Radius of the round edges of the bracket (excluding the base).\n*   `Thickness`: Material thickness.\n*   `MountHole_X_Separation`: Separation of mounting holes in the x-direction (along the wall).\n*   `MountHole_Y`: Distance of mounting holes from the bottom of the bracket (y-direction).\n*   `Screw_Head_Diameter`: Diameter of countersunk screw head.\n*   `Screw_Head_Angle`: Angle of countersunk screw head.\n*   `Screw_Shank_Diameter`: Diameter of screw shank.\n\nI would like to use the BOSL2 library, if that helps. I'm hoping this will create a versatile bracket I can use for lots of different projects.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Single piece peg-top! easy to print and customizable!",
    "scad": "use <utils/build_plate.scad>\ndiameter = 40;\nside_number = 4;\npole_length_percent = 36;\npole_thickness_percent = 12;\ncorner_bevel_size_percent = 55;\nedge_bevel_size_percent = 10;\nprinting_angle_limit = 55;\nbuild_plate_selector = 3;\nbuild_plate_manual_x = 50;\nbuild_plate_manual_y = 50;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nradius = diameter/2;\nh1 = radius * cos (360 / (2*side_number));\nt = 360/side_number;\nR2 = radius*radius;\ncost = cos(t);\ncosA = cos(180+printing_angle_limit);\nheight = sqrt( (-R2-R2*cost-R2*cosA-R2*cost*cosA) / (2*(cosA+cost)) );\nangle = atan(height/h1);\nrotz = (side_number % 2 == 0) ? 360/(2*side_number) : 0;\npole_length = pole_length_percent*0.01*height*2;\nspindle_rtop = pole_thickness_percent*0.01*diameter/4;\nspindle_rbase_tmp = spindle_rtop+pole_length*tan(180+angle-(90-printing_angle_limit));\nspindle_rbase = (spindle_rbase_tmp > spindle_rtop) ? spindle_rbase_tmp : spindle_rtop;\nmodule spin_top(height) {\n    tinyValue = 0.001;\n    translate([0,0,h1*cos(-90+angle)])\n    rotate([0,180+angle,0])\n    rotate([0,0, rotz])\n    union() {\n      intersection() {\n        hull() {\n          cylinder(r=radius, h=tinyValue, center=false, $fn=side_number);\n          translate([0, 0, height]) cylinder(r=tinyValue, h=tinyValue, center=false, $fn=side_number);\n        }\n        rotate([0,0,360/(side_number*2)]) cylinder(r1=tinyValue, r2=radius*4*(1-0.01*corner_bevel_size_percent), h=height*2, center=true, $fn=side_number);\n\t\t  cylinder(r1=tinyValue, r2=radius*2*(1-0.01*edge_bevel_size_percent), h=height*2, center=true, $fn=side_number);\n      }\n      rotate([180,0,0]) {\n        cylinder(r1=spindle_rbase, r2=spindle_rtop, h=pole_length, center=false, $fn=60);\n        translate([0,0,pole_length]) sphere(r=spindle_rtop, $fn=30);\n      }\n    }\n}\nspin_top(height);",
    "description": "Okay, I'm looking to design a parametric spinning top in OpenSCAD, and I've got some specific ideas about its shape and dimensions. I'd like it to be based on a pyramid shape, but with a few key modifications and parameters to make it customizable.\n\nHere's what I have in mind:\n\n**Basic Shape:**\n\n*   The body of the top should be a truncated pyramid, with a flat top surface for easy printing. This flat surface should actually be the base of the pyramid, making it so the design rests on its flattest face.\n*   The base of the pyramid should be a regular polygon, and I want to be able to control the number of sides it has.\n*   I want to control the diameter of this polygon base.\n*   The height of the pyramid needs to be automatically calculated based on a given maximum printing angle, so that the faces aren't too steep for a 3D printer.\n\n**Pole/Spindle:**\n\n*   The spinning top will have a pole extending from the center of the pyramid's base.\n*   I want to be able to control the pole's length as a percentage of the overall height of the pyramid.\n*   The pole should have a conical shape, getting thinner towards its end, with the top part of the cone capped by a sphere.\n*   I want to control the thickness of the pole at its base and at the tip as a percentage of the diameter of the pyramid base. I want the top of the cone to always have a minimum thickness, though the cone should still transition from a thicker base to this minimum.\n\n**Beveling/Chamfering:**\n\n*   I'd like to bevel both the corners and the edges of the pyramid.\n*   I want to independently control the size of both of these bevels as a percentage of the pyramid's radius.\n\n**Other Parameters:**\n\n*   I'd like a parameter to control the number of sides of the pyramid base.\n*   I need to specify the maximum printing angle.\n*   I'd like the option to use a build plate library for preview and placement purposes. I'm using a library called `build_plate.scad` that allows me to specify common printer dimensions or manual dimensions, that might be useful.\n\n**Specifics:**\n\n*   The code I'm using right now calculates the pyramid height based on the printing angle, which I need to maintain. This is to ensure that the pyramid doesn't have too much of an overhang.\n\n*   The pole's conical shape is currently calculated using a few intermediary variables but it does what I want, namely a pole that starts thicker and tapers to a thinner tip, and that does not fall below a minimum radius.\n\n*   It also uses `atan` to position the top correctly, so that it is printed \"flat\", with a base on the z=0 plane.\n\n**Required Libraries:**\n\n* I'm using a `build_plate.scad` file. I do not need the assistant to include its code.\n\nEssentially, I need a fully parametric version of the current code I have, including the ability to set the diameter, number of sides, pole length/thickness percentages, bevel sizes, and the printing angle limit. I'd like to ensure that the final shape has beveled corners and edges. The critical aspect is having the pyramid rest with a flat base on the print surface (z=0 plane), not resting on the vertex of the pyramid.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Velcro-like Fastener Customizable",
    "scad": "Width=10;\nLength=20;\nNotchSize=145;\nFastener();\nmodule Fastener(){\nNotchDiameter=NotchSize/100;\nPlatformHeight=0.7;\nNotchDistance=2;\nNotchHeight=1.3;\nNotchShape=0.9;\n$fn=12;\ncube([Width,Length,PlatformHeight]);\nfor(i=[1:NotchDistance:NotchDistance*floor(Width/NotchDistance)]){\nfor(j=[1:NotchDistance:NotchDistance*floor(Length/NotchDistance)]){\ntranslate([i,j,PlatformHeight]) cylinder(r1=NotchShape*NotchDiameter/2,r2=NotchDiameter/2,h=NotchHeight);\ntranslate([i,j,PlatformHeight+NotchHeight]) cylinder(r1=NotchDiameter/2,r2=0,h=NotchHeight*0.3);\n}\n}\n}",
    "description": "Okay, I'm looking to create a parametric, printable fastener similar to Velcro, but using interlocking mushroom-shaped posts instead of hooks and loops. I've been experimenting, and I'm mostly happy with the basic design, but I'm hoping an AI assistant can help make it more robust and flexible.\n\nI've attached my current OpenSCAD file (\"Fastener_v1_0.scad\") as a starting point. It defines the basic geometry: a rectangular platform with an array of mushroom-shaped posts on top.\n\nHere are my key requirements for the new design:\n\n1.  **Parametric Control:** I need to be able to adjust all the key dimensions of the fastener, including:\n    *   **Overall Width and Length:**  Like my current `Width` and `Length` parameters, but I also want the option to adjust the size of the platform.\n    *   **Post Spacing:** The horizontal and vertical spacing between the posts should be individually adjustable parameters, rather than just relying on the `NotchDistance` which doesn't clearly indicate what we're spacing.\n    *   **Post Dimensions:**\n        *   **Notch Diameter:**  This is the diameter of the wide part of the mushroom. This is currently calculated as `NotchSize/100` and I would like a variable for `NotchDiameter`.\n        *   **Stem Diameter:** I'd like a separate parameter controlling the stem diameter. This is currently calculated in two parts of the code, once as `NotchShape*NotchDiameter/2` and then as `NotchDiameter/2` again. I would like a single `StemDiameter` parameter.\n        *  **Mushroom Height:** The overall height of the post, i.e., how high the 'mushroom' stands off the platform. This is currently the sum of `NotchHeight` (1.3) and `NotchHeight * 0.3`. I would like a single `MushroomHeight` variable.\n        * **Stem Height:** How tall is the stem itself from the base. This is currently indicated by `NotchHeight`.\n        *   **Post Shape:** Currently, the 'mushroom' shape is a frustum (truncated cone). I'd like an option to choose between a frustum and a rounded mushroom shape (e.g., using a sphere or torus). Perhaps an enum `[\"frustum\", \"rounded\"]`.\n    *   **Platform Height:** The height of the base platform. I want to adjust this.\n\n2.  **Interlocking Behaviour:** I want the ability to easily adjust the design of the posts so they interlock securely with another identical fastener. I need the ability to add a small undercut or a slight angle to the mushroom cap to allow for secure interlocking. I'm open to suggestions on the best way to achieve this - maybe some additional parameters or alternative post shapes.\n\n3.  **Array Handling:** I would prefer to use more modern looping methods (e.g. using `for` with vector ranges) instead of the `for` loops and `floor()` in the original design to be more flexible.\n\n4.  **Libraries:** I would like the design to be compatible with BOSL2. I don't need to use every possible feature of the library, but it should be using BOSL2 for some of the functionality.\n\n5.  **Modularity**: The basic unit should be a single post, the platform, and the array of posts should be their own modules, so that I can re-use them as needed.\n\n6.  **Comments:** Please ensure the generated SCAD file is well-commented, explaining the purpose of each section, parameter, and module.\n\n7. **Units**: Please use millimeters for all units.\n\nEssentially, I'd like a more sophisticated, flexible, and parametric version of my existing design, leveraging best practices. Can you provide an improved version, using BOSL2 to implement the changes described?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Heart Ring",
    "scad": "ring_size = 18.14;\nring_thickness = 1.6;\nring_width = 8;\nnum_of_hearts = 9;\nmodule ring() {\ndifference() {\n\t\t\tcylinder(r=inner_radius+ring_thickness,h=ring_width,$fn = 100,center = true);\n\t\t\tcylinder(r=inner_radius,h=ring_width+1,$fn = 100,center = true);\n}\n}\nmodule heart (w,h) {\nscale (v=[w/171,w/171,1])\ntranslate([0,-78,0])\nrotate (a=45, v=[0,0,1])\nlinear_extrude(height = h,convexity =10, twist =0 )\n{\npolygon(points=[[0,0],[100,0],[100,50],[50,100],[0,100]], paths=[[0,1,2,3,4]]);\ntranslate([100,50,0])\ncircle(r=50);\ntranslate([50,100,0])\ncircle(r=50);\n}\n}\nmodule circleofhearts ()\n{\nfor (i=[0:num_of_hearts]) {\nrotate(a=i*360/num_of_hearts,v=[0,0,1]) {\ntranslate ([0,inner_radius+ring_thickness,0])\nrotate(a=90,v=[1,0,0])\nheart(heart_size,2*ring_thickness);\n}\n}\n}\ninner_radius = ring_size/2;\npi = 3.1415;\nheart_size = min(ring_width*0.8, 2*inner_radius*pi/num_of_hearts);\ntranslate ([0,0,ring_width/2])\ndifference () {\nring();\ncircleofhearts ();\n}",
    "description": "Okay, I'm looking to design a heart-themed ring, and I'd like it to be highly customizable. I've got some ideas based on an existing design, but I need a more robust parametric version.\n\nHere's what I'm thinking:\n\n1.  **Ring Size:** I need to be able to specify the ring size, ideally based on US ring sizes (diameter in mm). I'd like a variable where I can input the US ring size, and the script should automatically calculate the inner radius.\n2.  **Ring Thickness:**  I want to control the thickness of the ring, this should be a variable that affects the cross sectional thickness of the ring. I'd like to start with options for \"Normal\" and \"Thick\", corresponding to something like 1.6mm and 2.4mm, respectively. I should be able to easily set custom values here.\n3.  **Ring Width:** I need to be able to set the overall width of the ring (the dimension parallel to the finger). I'd like a range for this, probably between 6mm and 12mm.\n4. **Heart Count:** I want to be able to change the number of hearts that go around the ring's circumference. I'd like to be able to specify from between 3 and 11 hearts.\n5.  **Heart Size:** The size of each heart should be automatically calculated to fit around the ring without overlapping. It should take into account both the ring width and the circumference, and use the smaller of the two available constraints. They should be scaled appropriately to ensure they fit correctly.\n6. **Heart Shape:** The hearts themselves should be generated using a simple extrusion of a 2D heart shape. It needs to look like a classic heart shape and be a bit more rounded than a simple two triangle connected by a rectangle.\n7.  **Placement:** The hearts should be evenly spaced around the outer edge of the ring.\n8.  **OpenSCAD Structure:** The code should be well-structured, using modules and variables to make it easy to modify the design later. All critical parameters need to be user-modifiable.\n\nI'd like the design to use a difference operation to create the ring and to subtract the hearts. I'd also like the hearts to be rotated 90 degrees so that they stick outwards from the ring face, with each heart's long dimension parallel to the ring axis.\n\nEssentially, I want a parametric ring where I can easily adjust the size, thickness, width, number of hearts, and have the heart size automatically scale. I'm familiar with OpenSCAD's basic modules and operations, so feel free to use standard OpenSCAD commands to achieve this. I am not using any external libraries.\n\nCould you please generate the OpenSCAD file based on these specifications?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable pipe holder",
    "scad": "module pipeholder()\ndefine();\nsth=40;\nshr=18;\nns =3;\nind=280;\nod=343;\nfd=600;\nfth=60;\nch=340;\ntdp=fth*2/3;\noff= 360/ns;\n$fn=48;\n\ttranslate([0, 0, 0]) {\n\t\tdifference() {\n                union(){\n\t\t  translate([0, 0, fth]) cylinder(h = ch-fth, r =od/2);\n          translate([0, 0, 00])cylinder(h = fth, r= fd/2);\n                       }\n\t\tfor (i = [0:(ns-1)]) {\n\t\t\techo(360*i/ns, sin(360*i/ns)*(od/2+70), cos(360*i/ns)*(od/2+70));\n\t\t\ttranslate([sin(360*i/ns)*(od/2+70), cos(360*i/ns)*(od/2+70), fth/2])\n\t\t\t\tcylinder(h =tdp, r2=sth,r1=shr);\n\t\t                      }\n\t\ttranslate([0, 0, 50])\n\t\t\tcylinder(h = ch-fth+25, r=ind/2);\n\t\t       for (i = [0:(ns-1)]) {\n\t\t\techo(360*i/ns+off, sin(360*i/ns+off)*(od/2+70), cos(360*i/ns+off)*(od/2+70));\n\t\t\ttranslate([sin(360*i/ns+off)*(od/2+70), cos(360*i/ns+off)*(od/2+70), -1 ])\n\t\t\t\tcylinder(h=(fth-tdp)+20,r=shr);\n\t\t                             }\n                     }\n                              }\npipeholder();",
    "description": "Okay, I need a customizable pipe holder designed in OpenSCAD. I have a basic design in mind, but I'd like it to be fully parametric so I can adjust it for different pipe sizes and mounting situations.\n\nHere's a breakdown of the features I need:\n\n**Core Structure:**\n\n*   **Cylinder:** The main body of the pipe holder should be a hollow cylinder. I need to be able to control the following:\n    *   `ind`: Inner diameter of the cylinder.\n    *   `od`: Outer diameter of the cylinder.\n    *   `ch`: Height (or length) of the cylinder.\n\n*   **Fringe:** There should be a flange or fringe at the base of the cylinder, which provides a wider base for mounting. I need to control:\n    *   `fd`: Diameter of the fringe.\n    *   `fth`: Thickness of the fringe.\n\n**Mounting Holes (Screws):**\n\n*   **Tapered Holes:** There should be countersunk holes on the fringe for mounting screws. These holes will have a tapered shape, with a larger diameter at the top (for the screw head) and a smaller diameter at the bottom. I need to control:\n    *   `sth`: Radius of the top (larger end) of the tapered screw hole.\n    *   `shr`: Radius of the bottom (smaller end) of the tapered screw hole, which will continue through the fringe as a straight hole.\n    *  `tdp`: Taper depth of the countersunk screw hole.\n    *   `ns`: Number of mounting holes.\n    *   `off`: Rotation offset of the main screw holes.\n\n**Other Features:**\n\n*  The cylinder should extend a short distance below the fringe.\n*   All the holes should be properly aligned with the main cylinder and the fringe.\n*   The number of mounting holes should be easily configurable.\n*   I would like to include a preview of the mounting hole positions in the console, including their x and y values.\n\n**Parametric Requirements:**\n\nI need all of the dimensions listed above to be easily adjustable parameters within the OpenSCAD code. This will allow me to quickly create different sized holders without needing to manually edit the code each time. I would like all the values to be defined at the top of the file.\n\nI'm not using any libraries beyond standard OpenSCAD for this, so please don't assume any libraries are available.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Hex Key T Handle",
    "scad": "part_render=1;\nhex_key_diameter=3;\nhex_key_short_length=23;\nhandle_length=70;\nhandle_thickness=7;\nresolution=55;\n$fn=resolution;\nif (part_render==1)\n{\n   hex_key_t_handle();\ntranslate([handle_thickness+2*hex_key_diameter+10,0,0])hex_key_clip();\n}\nif (part_render==2)\n{\n   hex_key_t_handle();\n}\nif (part_render==3)\n{\nhex_key_clip();\n}\nmodule hex_key_clip(){\nrotate([90,0,0]){\ntranslate([0,(((hex_key_short_length*2)+hex_key_diameter)/-2)+8,0]){\ndifference(){\nhull(){\nrotate([90,0,0])translate([0,(hex_key_diameter+handle_thickness)/2-1,(hex_key_short_length+(hex_key_diameter/2))/-1])cylinder(8,((hex_key_diameter+handle_thickness)/2)+2,((hex_key_diameter+handle_thickness)/2)+2);\ntranslate([0,0,-.5]){\nrotate([90,0,0])translate([0,((hex_key_diameter+handle_thickness)/2)-6,(hex_key_short_length+(hex_key_diameter/2))/-1])cylinder(8,((hex_key_diameter+handle_thickness)/2)+1.75,((hex_key_diameter+handle_thickness)/2)+1.75);\n}\n}\ndifference(){\ntranslate([0,0,-1]){\nhull(){\nrotate([90,0,0])translate([0,(hex_key_diameter+handle_thickness)/2,(hex_key_short_length+(hex_key_diameter/2))/-1])cylinder((hex_key_short_length*2)+hex_key_diameter,(hex_key_diameter+handle_thickness)/2-.5,(hex_key_diameter+handle_thickness)/2-.5);\nrotate([90,0,0])translate([0,((hex_key_diameter+handle_thickness)/2)-4.25,(hex_key_short_length+(hex_key_diameter/2))/-1])cylinder((hex_key_short_length*2)+hex_key_diameter,(hex_key_diameter+handle_thickness)/2-1.25,(hex_key_diameter+handle_thickness)/2-1.25);\n}\ntranslate([0,0,(handle_thickness/-2)-2])cube([(hex_key_short_length*2)+hex_key_diameter+handle_thickness*3,(hex_key_short_length*2)+hex_key_diameter+handle_thickness*3,handle_thickness],center=true);\n}\n}\n}\n}\n}\n}\nmodule hex_key_t_handle(){\nunion(){\ntranslate([0,0,-.5]){\ndifference(){\nrotate([90,0,0])translate([0,(hex_key_diameter+handle_thickness)/2,(hex_key_short_length+(hex_key_diameter/2))/-1])cylinder((hex_key_short_length*2)+hex_key_diameter,(hex_key_diameter+handle_thickness)/2,(hex_key_diameter+handle_thickness)/2);\nrotate([0,0,90])translate([0,0,(hex_key_diameter+handle_thickness)-(.5+hex_key_diameter)/2])hex_key();\nrotate([0,0,-90])translate([0,0,(hex_key_diameter+handle_thickness)-(.5+hex_key_diameter)/2])hex_key();\ncube([(hex_key_short_length*2)+hex_key_diameter+handle_thickness*3,(hex_key_short_length*2)+hex_key_diameter+handle_thickness*3,1],center=true);\n}\n}\ndifference(){\ntranslate([0,(((hex_key_short_length*2)+hex_key_diameter)/-2)+1,-.5])hex_key_t_handle_extension();\ntranslate([0,((hex_key_short_length*2)+hex_key_diameter)/-2,-1])cube([(hex_key_short_length*2)+hex_key_diameter+50,(hex_key_short_length*2)+hex_key_diameter+50,2],center=true);\n}\ndifference(){\ntranslate([0,(((hex_key_short_length*2)+hex_key_diameter)/2)-1,-.5])rotate([0,0,180])hex_key_t_handle_extension();\ntranslate([0,(((hex_key_short_length*2)+hex_key_diameter)/2)+1,-1])cube([(hex_key_short_length*2)+hex_key_diameter+50,(hex_key_short_length*2)+hex_key_diameter+50,2],center=true);\n}\n}\n}\nmodule hex_key(){\nrotate([0,0,360/6]){\nrotate([90,0,360/12])translate([0,0,0])hexagon(hex_key_short_length,(hex_key_diameter+.5)/2);\nrotate([90,0,360/12])translate([0,-1.5,0])cylinder(hex_key_short_length/2,(hex_key_diameter+1)/2,0);\nrotate([0,0,360/12])translate([0,0,(-hex_key_short_length)+(hex_key_diameter/2)+.5])hexagon(hex_key_short_length,(hex_key_diameter+1)/2);\n}\ntranslate([0,(hex_key_diameter+.5)/-2,0])cube([hex_key_short_length,hex_key_diameter+.5, hex_key_diameter]);\n}\nmodule hex_key_t_handle_extension(){\nrotate([90,0,0])translate([0,(hex_key_diameter+handle_thickness)/2,0]){\ntranslate([0,0,.1*handle_length])cylinder(.5*handle_length-(.1*handle_length),(hex_key_diameter+handle_thickness+2)/2,(hex_key_diameter+handle_thickness+2)/2);\ntranslate([0,0,0])cylinder((.1*handle_length), (hex_key_diameter+handle_thickness)/2,(hex_key_diameter+handle_thickness+2)/2);\ntranslate([0,0,(5/10)*handle_length])sphere((hex_key_diameter+handle_thickness+2)/2);\n}\n}\nmodule reg_polygon(sides,radius)\n{\n  function dia(r) = sqrt(pow(r*2,2)/2);\n  if(sides<2) square([radius,0]);\n  if(sides==3) triangle(radius);\n  if(sides==4) square([dia(radius),dia(radius)],center=true);\n  if(sides>4) circle(r=radius,$fn=sides);\n}\nmodule hexagonf(radius)\n{\n  reg_polygon(6,radius);\n}\nmodule hexagon(height,radius)\n{\n  linear_extrude(height=height) hexagonf(radius);\n}",
    "description": "Okay, I'm looking to design a parametric T-handle for hex keys, and I'd like it to also have a clip to store the T-handle itself.  I have some existing code that gives the general shape I'm after, but I think it can be improved, and I want to make sure it's flexible for different hex key sizes.\n\nHeres what Im envisioning:\n\n**Core Functionality:**\n\n*   **Parametric Design:** The design should be driven by parameters to easily adjust for different hex key sizes and handle lengths.\n*   **T-Handle Shape:** The main part should have the typical T-shape with a central stem where the hex key is inserted, and two perpendicular handle arms for grip.\n*   **Hex Key Compatibility:** It should accommodate different hex key diameters. The design needs to securely hold the hex key in place.\n*   **Clip:** A separate clip mechanism should be included to attach the T-handle to a tool board or belt, with a gap the main body can snap into.  This part should also be configurable with parameters, and can be rendered independently if I choose.\n*   **Resolution Control:** I need to be able to control the resolution/smoothness of the curved parts, probably using the `$fn` variable.\n*   **Individual Part Rendering:** I want a way to render just the T-handle, just the clip, or both together. This will make it easier to iterate through design changes.\n\n**Specific Parameters I need to control:**\n\n*   `hex_key_diameter`: The diameter of the hex key that will be inserted into the handle.\n*   `hex_key_short_length`: The length of the short leg of the hex key, which Ill use to determine how deep the insertion hole needs to be.\n*   `handle_length`: The length of each handle arm on the T.  This will be added to the hex_key_short_length times two in the current code.\n*   `handle_thickness`: The thickness of each handle arm, this is added to the diameter of the hex key in the current code.\n*    `resolution`: The resolution of curved features, directly tied to `$fn`\n* `part_render`: A variable to control what part of the model is rendered (1= T-handle & Clip, 2=T-handle only, 3=clip only).\n\n**Specific Design Considerations:**\n\n*   **Hex Key Attachment:** I think there could be a cleaner way to create the hex key attachment hole, rather than overlapping cylinders and cubes. I'd be interested in seeing if a more streamlined design is possible using techniques that better match the shape of the key. I'd like to keep a gap of `0.5`mm around the hex key when inserted.\n\n*   **Handle Arms:** The handle arms should have a comfortable shape. It's possible they could be more ergonomic than just a simple cylinder, but for now a cylinder is acceptable. The current design has a spherical ends, which is a nice touch.\n*   **Clip Mechanism:** The clip should be strong enough to hold the handle securely, but not so tight that it's difficult to remove it, the current clip is too thin and might break. The clip might need to be slightly different depending on the handle size.\n\n**Output:**\n\nI need an OpenSCAD file that implements all of the functionality above.  It should be well-commented and easy to understand.  Id prefer to avoid custom modules unless it really makes sense and to lean on built-in functions whenever possible. I am not asking to include code from external libraries.\n\nCould you generate that for me?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Calipers",
    "scad": "include <write/Write.scad>;\nLength=170;\nWidth=15;\nThickness=2;\nScale=1;\nUnitNumbersEvery=10;\nSubdivisions=10;\nScaleThickness=.7;\nClearance=1.2;\nOffset=0.15;\ncolor([0.8,0.8,0.8]) {\ndifference() {\nunion() {\ncube([Length,Width,Thickness]);\nrotate([45,0,0]) cube([Length,Thickness/sqrt(2),Thickness/sqrt(2)]);\ntranslate([0,Width,0]) rotate([45,0,0]) cube([Length,Thickness/sqrt(2),Thickness/sqrt(2)]);\nlinear_extrude(height = Thickness) polygon([[0,0],[-Offset,0],[-Offset,-40],[-10,-30],[-20,0],[-20,Width],[-15+Offset,Width],[-15+Offset,Width+15],[-10,Width+5],[-10,Width],[0,Width]]);\n}\nfor(i=[0:Scale*UnitNumbersEvery/Subdivisions:Length-Scale*UnitNumbersEvery/Subdivisions]){translate([i+1,-1,Thickness-ScaleThickness]) cube([0.3,Width*StripeLenght(i/Scale),ScaleThickness*2]);}\nfor(i=[0:Scale*UnitNumbersEvery:Length-Scale*UnitNumbersEvery]){\ntranslate([i+2,Width/1.5,Thickness-ScaleThickness]) write(str(floor(i/Scale)),h=Width/4,t=ScaleThickness*2,font=\"write/Letters.dxf\");\necho(i);\n}\n}\ntranslate([30,-30-Width,0]) linear_extrude(height = Thickness) polygon([[Offset,-Thickness],[Offset,-40],[10,-30],[20,-Thickness],[50,-Thickness],[50,Width+Thickness+Clearance],[-15-Offset,Width+Thickness+Clearance],[-15-Offset,Width+15],[-20,Width+10],[-20,-Thickness]]);\ndifference(){\nunion(){\ntranslate([75,-30-Thickness-Width]) cylinder(r=4,h=Thickness);\ntranslate([30,-30-Width,Thickness]) linear_extrude(height = Thickness) polygon([[Offset,-Thickness],[Offset,-40],[10,-30],[20,-Thickness],[50,-Thickness],[50,Width+Thickness+Clearance],[0,Width+Thickness+Clearance]]);\n}\ntranslate([30+1,-30-Width,0]) for(i=[0:Subdivisions]){\ntranslate([i*Scale*UnitNumbersEvery/Subdivisions*1.9,-StripeLenght(i)*4,Thickness*2-ScaleThickness]) cube([0.3,Width,ScaleThickness*2]);}\ntranslate([30,-30-Width,Thickness]) {\ntranslate([-1,0,0]) cube([60,Width+Clearance,Thickness*2]);\nrotate([45,0,0]) cube([60,Thickness/sqrt(2),Thickness/sqrt(2)]);\ntranslate([0,Width+Clearance,0]) rotate([45,0,0]) cube([60,Thickness/sqrt(2),Thickness/sqrt(2)]);\n}\n}\n}\nfunction StripeLenght(Value)=0.4+0.3*floor(1/(((Value)%10)+1))+0.25*floor(1/(((Value)%5)+1))+0.05*floor(1/(((Value)%2)+1));",
    "description": "Okay, I'm looking to create a parametric caliper design in OpenSCAD, and I'd like your help generating the code. I already have an example design, but I need something more customizable.\n\nHere's what I'm aiming for, based on the provided `Caliper_v0_7.scad` file:\n\n**Core Functionality:**\n\n*   It should be a standard sliding caliper with a main body, a sliding jaw, and a thumb grip on the slider.\n*   The design should incorporate a scale on the main body and a corresponding scale on the slider, making it usable for basic measurements.\n\n**Key Parameters I need to be able to adjust:**\n\n*   **Length:** The overall length of the main caliper body.\n*   **Width:** The width of the main caliper body.\n*   **Thickness:** The thickness of the main caliper body.\n*   **Scale:** A scaling factor to adjust the size of the caliper; this will also need to affect the scale spacing and calibration. I'd like it to be something that I can easily use for inch-based or metric-based designs, by changing the scale parameter.\n*   **UnitNumbersEvery:** The spacing of the main numeric labels on the main body, scaled by scale.\n*   **Subdivisions:** The number of tick marks between main unit numbers on both the main body and slider.\n*   **ScaleThickness:** The thickness of the scale markings.\n*   **Clearance:** The gap between the sliding part and the main body. This allows for slight variations in printing and ensures a smooth sliding action.\n*   **Offset:** A small offset, likely for a printer or filament width compensation.\n\n**Specific Design Details:**\n\n*   **Main Body:** The main body is a rectangle with reinforcing diagonal beams. The main scale is marked along one edge. The scale markings and their labels should be generated algorithmically.\n*   **Slider:** The slider should have a jaw that fits around the main body and a thumb grip. The slider should have a scale that lines up with the main body scale. The slider is made of two parts, a top and bottom layer, which when connected should sandwich the main body.\n*   **Scale Markings:** The scale markings should vary in length based on their value in a repeating pattern. The reference file has a function `StripeLenght(Value)` to generate the length; I would like this to remain, or to have a similar easily adjustable functionality.\n*   **Text:** The numbers on the scale should be readable and have a similar feel as the reference file, using the `write` module from the `Write.scad` library.\n*   The slider will need to clear the diagonal reinforcing beams, and all design should account for printer variations by utilizing the `Clearance` parameter.\n\n**Libraries:**\n\n*   I need the `write` module from the `Write.scad` library for text rendering. This is the library that the reference design uses, and I am fine with keeping this library for the new design.\n\n**In summary,** I need a fully parametric version of the caliper, similar to the design described but with all of the above parameters easily adjustable to customize the dimensions, scales, tolerances, etc. Please generate the OpenSCAD code for this design. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable PVC Inner Coupler",
    "scad": "use <utils/build_plate.scad>\npvcDiameter = 20.93;\ncouplerConst = 3;\ncouplerLength = 25.4;\ndoubleRotate = 90;\nxFourRotate = 180;\nyFourRotate = 0;\nfiveRotate = 270;\nsixRotate = 180;\nisWarp = 0;\nisHollow = 0;\nbuildPlateType = 1;\nbuildPlateX = 200;\nbuildPlateY = 200;\npvcWall = 4/1;\nflangeWidth = 5/1;\nflangeThick = 0.2/1;\ngapConstant = 1.25/1;\ndiameter = pvcDiameter - gapConstant;\ncouplerRadius = diameter/2;\nmodule warping(){\n\ttranslate(v = [0,0,-flangeThick/2]){\n\t\tcylinder(r = (couplerRadius + pvcWall + flangeWidth), h = flangeThick, center=true);\n\t}\n\ttranslate(v = [0,-((couplerLength/2) + (flangeWidth/2)),-flangeThick/2]){\n\t\tcube(size = [(diameter + (flangeWidth*2)), (couplerLength + flangeWidth), flangeThick], center=true);\n\t}\n\trotate(doubleRotate,[0,0,1]){\n\t\ttranslate(v = [0,-((couplerLength/2) + (flangeWidth/2)),-flangeThick/2]){\n\t\t\tcube(size = [(diameter + (flangeWidth*2)), (couplerLength + flangeWidth), flangeThick], center=true);\n\t\t}\n\t}\n\tif(couplerConst >= 2){\n\t\trotate(fiveRotate,[0,0,1]){\n\t\t\ttranslate(v = [0,-((couplerLength/2) + (flangeWidth/2)),-flangeThick/2]){\n\t\t\t\tcube(size = [(diameter + (flangeWidth*2)), (couplerLength + flangeWidth), flangeThick], center=true);\n\t\t\t}\n\t\t}\n\t}\n\tif(couplerConst == 3){\n\t\trotate(sixRotate,[0,0,1]){\n\t\t\ttranslate(v = [0,-((couplerLength/2) + (flangeWidth/2)),-flangeThick/2]){\n\t\t\t\tcube(size = [(diameter + (flangeWidth*2)), (couplerLength + flangeWidth), flangeThick], center=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule pvcCoupler(){\n\tmodule rotateCylinder(deg, r, h){\n\t\trotate(90, [1,0,0]) rotate(deg, [0,1,0])\n\t\t\tcylinder(r = r, h = h, center = false);\n\t}\n\tmodule rotateThirdCylinder(degCO, degCT, r, h){\n\t\trotate(degCO, [1,0,0]) rotate(degCT, [0,1,0])\n\t\t\tcylinder(r = r, h = h, center = false);\n\t}\n\trotate(a=[0,180,0]){\n\t\tdifference(){\n\t\t\tunion(){\n\t\t\t\trotateCylinder(0, couplerRadius, couplerLength);\n\t\t\t\trotateCylinder(doubleRotate, couplerRadius, couplerLength);\n\t\t\t\tif(couplerConst >= 1){\n\t\t\t\t\trotateThirdCylinder(xFourRotate, yFourRotate, couplerRadius, couplerLength);\n\t\t\t\t}\n\t\t\t\tif(couplerConst >= 2){\n\t\t\t\t\trotateCylinder(fiveRotate, couplerRadius, couplerLength);\n\t\t\t\t}\n\t\t\t\tif(couplerConst >= 3){\n\t\t\t\t\trotateCylinder(sixRotate, couplerRadius, couplerLength);\n\t\t\t\t}\n\t\t\t\tsphere(r = (couplerRadius + pvcWall));\n\t\t\t\tif(isWarp == 1){\n\t\t\t\t\twarping();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcylinder(r = (couplerLength * 2), h = (couplerRadius + pvcWall * 2), center = false);\n\t\t\tif(isHollow == 1){\n\t\t\t\tdifference(){\n\t\t\t\t\tunion(){\n\t\t\t\t\t\trotateCylinder(0, couplerRadius - 1, couplerLength + 1);\n\t\t\t\t\t\trotateCylinder(doubleRotate, couplerRadius - 1, couplerLength + 1);\n\t\t\t\t\t\tif(couplerConst >= 1){\n\t\t\t\t\t\t\trotateThirdCylinder(xFourRotate, yFourRotate, couplerRadius - 1, couplerLength + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(couplerConst >= 2){\n\t\t\t\t\t\t\trotateCylinder(fiveRotate, couplerRadius - 1, couplerLength + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(couplerConst >= 3){\n\t\t\t\t\t\t\trotateCylinder(sixRotate, couplerRadius - 1, couplerLength + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nif(couplerConst >= 1 || pvcDiameter > 26.64){\n\ttranslate(v = [-(couplerLength + (flangeWidth*4)),0,0]){\n\t\tpvcCoupler();\n\t}\n\ttranslate(v = [(couplerLength + (flangeWidth*4)),0,0]){\n\t\tmirror([1,0,0]) {\n\t\t\tpvcCoupler();\n\t\t}\n\t}\n}else{\n\ttranslate(v = [-(pvcWall + (flangeWidth*4)),0,0]){\n\t\tpvcCoupler();\n\t}\n\ttranslate(v = [(pvcWall + (flangeWidth*4)),0,0]){\n\t\tmirror([1,0,0]) {\n\t\t\tpvcCoupler();\n\t\t}\n\t}\n}\nbuild_plate(buildPlateType, buildPlateX, buildPlateY);",
    "description": "Okay, I'm looking to generate a customizable PVC pipe connector, and I've got a specific design in mind. I want to be able to create a connector that joins multiple PVC pipes at various angles, kind of like a hub. I've previously created a version of this that I'm attaching for reference, but it's a little clunky, and I think an AI could probably make it better.\n\nSpecifically, I need the following features to be parametric:\n\n1.  **PVC Pipe Diameter:**  The connector needs to be able to accommodate different PVC pipe sizes.  I'll want to specify the outer diameter of the PVC pipe as a parameter. I'll want to refer to PVC pipe schedule 40 dimensions, so that should be a starting point. Maybe some sort of lookup table for common PVC sizes like 1/8\", 1/4\", 3/8\", 1/2\", 3/4\", 1\", 1 1/4\", 1 1/2\", 2\", 2 1/2\",  or just a way to input in millimeters if I want to use other sizes.\n\n2.  **Number of Connections:** I need to be able to specify the number of PVC pipe connections on the hub. This should be selectable between 2, 4, 5, or 6 connections.\n\n3.  **Connector Length:** The length of each individual \"arm\" of the connector (the part that goes into the PVC pipe) needs to be configurable via a parameter.\n\n4.  **Connection Angles:**  I need to be able to set the rotation angles for the different connections. The first connection should always be at 0 degrees and the second at a specified rotation angle around the z-axis. Then, for 4, 5, and 6-way connectors, the third and fourth connections will need separate rotation angles around the x and y-axes. Finally, for 5 and 6-way connectors, the fifth and sixth will have z-axis rotations. I need to be able to specify all of those angles (second, fifth, and sixth being rotations around the z-axis, and third and fourth having separate rotations around the x- and y-axes).\n\n5.  **Warping Help:** I'd like to include an option for additional \"flanges\" at the base of the connector that help prevent warping during printing.  I'd like a boolean option to turn these on/off, and the width and thickness of these flanges should also be parameters.\n\n6.  **Hollow Connectors:** I need an option to hollow out the arms of the connector to save on material, controlled by a boolean parameter.\n\n7.  **Build Plate Display:** It would be helpful to see the dimensions of the build plate for reference while designing, so I'd like the option to display a representation of the build plate. I'd like to be able to specify the printer type (Replicator 2, Replicator, Thingomatic, or Manual) and for manual entry I should be able to control the x and y dimensions of the build plate.\n\n8.  **Clearance:** The connector needs a small gap between the PVC pipe and the connector for glue, I need to be able to set that with a parameter.\n\n9.  **Wall Thickness:** I need a parameter to control how thick the coupler part is, that makes contact with the pvc pipe.\n\nI'd like the output to be a single OpenSCAD file. Please make sure it uses the `build_plate()` function from the `utils/build_plate.scad` library.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Gear Generator For Customizer V1.0 **outdated**",
    "scad": "height = 5;\ntype = \"Spur\";\nteeth = 17;\nscale = 100;\nhole = \"Yes\";\nholeSize = 1.5;\nif (type == \"Spur\")\n{\nif(hole == \"Yes\")\n{\nhole();\n}\nelse\n{\nspur();\n}\n}\nelse if(type == \"Cog\")\n{\nif(hole == \"Yes\")\n{\nhole();\n}\nelse\n{\ncog();\n}\n}\nelse if(type == \"Double Helix(beta)\")\n{\nif(hole == \"Yes\")\n{\nhole();\n}\nelse\n{\ndouble_helix();\n}\n}\nelse if (type == \"Single Helix\")\n{\nif(hole == \"Yes\")\n{\nhole();\n}\nelse\n{\nsingle_helix();\n}\n}\nmodule gear(number_of_teeth,\n\t\tcircular_pitch=false, diametral_pitch=false,\n\t\tpressure_angle=20, clearance = 0)\n{\n\tcircular_pitch = (circular_pitch!=false?circular_pitch:180/diametral_pitch);\n\tpitch_diameter  =  number_of_teeth * circular_pitch / 180;\n\tpitch_radius = pitch_diameter/2;\n\tbase_diameter = pitch_diameter*cos(pressure_angle);\n\tbase_radius = base_diameter/2;\n\tpitch_diametrial = number_of_teeth / pitch_diameter;\n\taddendum = 1/pitch_diametrial;\n\touter_radius = pitch_radius+addendum;\n\touter_diameter = outer_radius*2;\n\tdedendum = addendum + clearance;\n\troot_radius = pitch_radius-dedendum;\n\troot_diameter = root_radius * 2;\n\thalf_thick_angle = 360 / (4 * number_of_teeth);\n\tunion()\n\t{\n\t\trotate(half_thick_angle) circle($fn=number_of_teeth*2, r=root_radius*1.001);\n\t\tfor (i= [1:number_of_teeth])\n\t\t{\n\t\t\trotate([0,0,i*360/number_of_teeth])\n\t\t\t{\n\t\t\t\tinvolute_gear_tooth(\n\t\t\t\t\tpitch_radius = pitch_radius,\n\t\t\t\t\troot_radius = root_radius,\n\t\t\t\t\tbase_radius = base_radius,\n\t\t\t\t\touter_radius = outer_radius,\n\t\t\t\t\thalf_thick_angle = half_thick_angle);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule involute_gear_tooth(\n\t\t\t\t\tpitch_radius,\n\t\t\t\t\troot_radius,\n\t\t\t\t\tbase_radius,\n\t\t\t\t\touter_radius,\n\t\t\t\t\thalf_thick_angle\n\t\t\t\t\t)\n{\n\tpitch_to_base_angle  = involute_intersect_angle( base_radius, pitch_radius );\n\touter_to_base_angle = involute_intersect_angle( base_radius/2, outer_radius*1);\n\tbase1 = 0 - pitch_to_base_angle - half_thick_angle;\n\tpitch1 = 0 - half_thick_angle;\n\touter1 = outer_to_base_angle - pitch_to_base_angle - half_thick_angle;\n\tb1 = polar_to_cartesian([ base1, base_radius ]);\n\tp1 = polar_to_cartesian([ pitch1, pitch_radius ]);\n\to1 = polar_to_cartesian([ outer1, outer_radius ]);\n\tb2 = polar_to_cartesian([ -base1, base_radius ]);\n\tp2 = polar_to_cartesian([ -pitch1, pitch_radius ]);\n\to2 = polar_to_cartesian([ -outer1, outer_radius ]);\n\t\tpitch_to_root_angle = pitch_to_base_angle - involute_intersect_angle(base_radius, root_radius );\n\t\troot1 = pitch1 - pitch_to_root_angle;\n\t\troot2 = -pitch1 + pitch_to_root_angle;\n\t\tr1_t =  polar_to_cartesian([ root1, root_radius ]);\n\t\tr2_t =  polar_to_cartesian([ -root1, root_radius ]);\n\t\tr1_f =  polar_to_cartesian([ base1, root_radius ]);\n\t\tr2_f =  polar_to_cartesian([ -base1, root_radius ]);\n\tif (root_radius > base_radius)\n\t{\n\t\tpolygon( points = [\n\t\t\tr1_t,p1,o1,o2,p2,r2_t\n\t\t], convexity = 3);\n\t}\n\telse\n\t{\n\t\tpolygon( points = [\n\t\t\tr1_f, b1,p1,o1,o2,p2,b2,r2_f\n\t\t], convexity = 3);\n\t}\n}\nfunction involute_intersect_angle(base_radius, radius) = sqrt( pow(radius/base_radius,2) - 1);\nfunction polar_to_cartesian(polar) = [\n\tpolar[1]*cos(polar[0]),\n\tpolar[1]*sin(polar[0])\n];\nmodule test_gears()\n{\n\tgear(number_of_teeth=51,circular_pitch=200);\n\ttranslate([0, 50])gear(number_of_teeth=17,circular_pitch=200);\n\ttranslate([-50,0]) gear(number_of_teeth=17,diametral_pitch=1);\n}\nmodule cog()\n{\n\t\tgear(number_of_teeth=teeth,diametral_pitch=scale/100);\n}\nmodule single_helix()\n{\n\ttranslate([50,0]);\n\t{\n\tlinear_extrude(height = height, center = true, convexity = 10, twist = -45)\n\t gear(number_of_teeth=teeth,diametral_pitch=scale/100);\n\t}\n}\nmodule double_helix()\n{\nlinear_extrude(height = height, center = true, convexity = 10, twist = -45)\n\t gear(number_of_teeth=teeth,diametral_pitch=scale/100);\n\ttranslate([0,0,height]) linear_extrude(height = height, center = true, convexity = 10, twist = 45)\n\t gear(number_of_teeth=teeth,diametral_pitch=scale/100);\n}\nmodule spur()\n{\n\t\ttranslate([0,0]) linear_extrude(height = height, center = true, convexity = 10, twist = 0)\n\t gear(number_of_teeth=teeth,diametral_pitch=1);\n}\nmodule demo_3d_gears()\n{\n\ttranslate([50,0])\n\t{\n\tlinear_extrude(height = 10, center = true, convexity = 10, twist = -45)\n\t gear(number_of_teeth=17,diametral_pitch=1);\n\ttranslate([0,0,10]) linear_extrude(height = height, center = true, convexity = 10, twist = 45)\n\t gear(number_of_teeth=17,diametral_pitch=1);\n\t}\n\ttranslate([0,-50]) linear_extrude(height = height, center = true, convexity = 10, twist = 0)\n\t gear(number_of_teeth=17,diametral_pitch=1);\n}\nmodule hole() {\n   difference() {\nif(type == \"Spur\")\n{\ntranslate([0,0]) linear_extrude(height = height, center = true, convexity = 10, twist = 0)\n\t gear(number_of_teeth=teeth,diametral_pitch=1);\n}\nelse if(type == \"Cog\")\n{\ngear(number_of_teeth=teeth,diametral_pitch=scale/100);\n}\nelse if (type == \"Double Helix(beta)\")\n{\nlinear_extrude(height = height, center = true, convexity = 10, twist = -45)\n\t gear(number_of_teeth=teeth,diametral_pitch=scale/100);\n\ttranslate([0,0,height]) linear_extrude(height = height, center = true, convexity = 10, twist = 45)\n\t gear(number_of_teeth=teeth,diametral_pitch=scale/100);\n}\nelse if (type == \"Single Helix\")\n{\nlinear_extrude(height = height, center = true, convexity = 10, twist = -45)\n\t gear(number_of_teeth=teeth,diametral_pitch=scale/100);\n}\n# rotate ([0,0,0]) cylinder (h = height*4, r=holeSize, center = true, $fn=100);\n}\n}\nmodule test_involute_curve()\n{\n\tfor (i=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])\n\t{\n\t\ttranslate(polar_to_cartesian([involute_intersect_angle( 0.1,i) , i ])) circle($fn=15, r=0.5);\n\t}\n}",
    "description": "Okay, so I'm looking to create a gear generator that's a bit more flexible and robust than what I've got so far. I'd like a single OpenSCAD file that allows me to generate various types of gears with a good degree of customizability.\n\nHere's what I'd like the script to do:\n\n**Core Functionality:**\n\n*   **Parametric Gear Generation:**  I need to be able to generate different gear types based on several key parameters. These parameters should be easily adjustable.\n*   **Gear Types:**\n    *   **Spur Gears:** Standard straight-cut gears.\n    *   **Cog Gears:**  (Ideally, the definition of 'cog' should be clarified. If it is the same as a spur gear, this should be clarified)\n    *   **Single Helix Gears:** Gears with angled teeth.\n    *   **Double Helix Gears:** Gears with two sets of angled teeth (herringbone). I understand that it can be tricky but I would like it to try and get these working well.\n*   **Key Parameters:**\n    *   `height`: The thickness/height of the gear.\n    *   `type`: A selection for the type of gear (Spur, Cog, Single Helix, Double Helix).\n    *   `teeth`: The number of teeth on the gear.\n    *   `scale`: A parameter that, along with `teeth`, controls the size.\n    *   `hole`: A boolean or toggle (Yes/No) to specify if the gear should have a center hole or not.\n    *   `holeSize`: If `hole` is yes, this controls the diameter of the hole.\n    *   `circular_pitch` or `diametral_pitch`: Input using either one of these. The other should calculate itself based on this input. If circular pitch is given, the diametral pitch should be calculated. If diametral pitch is given, the circular pitch should be calculated.\n    *    `pressure_angle`: The pressure angle of the gear teeth\n    *    `clearance`: The clearance value between teeth, if necessary.\n\n**Additional Desired Features:**\n\n*   **Error Handling:** Make sure the script handles invalid parameters gracefully (e.g., negative teeth, zero `scale` or `holeSize`).\n*   **Clear Module Structure:**  Break the code into modules to make it more readable.\n*   **Consistent Definitions:** I noticed that the old code has different gear module call based on gear type. I would like to make that more consistent so that it always calls the gear module or a variant.\n*   **Improved Double Helix:** Try to create a more stable and correct double helix geometry in this new implementation.\n*  **No Global Variables:** The code has a number of global variables, these should be localized as much as possible\n* **Libraries:** I do _not_ want the code to depend on any external libraries such as MCAD, BOSL or any other ones.\n\n**Example Usage (Conceptual):**\n\nI should be able to easily adjust all the parameters at the top and, after compilation, get the resulting gear. For example, I might set:\n\n```openscad\nheight = 10;\ntype = \"Double Helix\";\nteeth = 32;\nscale = 150;\nhole = \"Yes\";\nholeSize = 4;\ncircular_pitch = 100;\n```\n\nor\n\n```openscad\nheight = 5;\ntype = \"Spur\";\nteeth = 20;\nscale = 100;\nhole = \"No\";\ndiametral_pitch = 1;\n```\nI would like the code to correctly use the input.\n\n**What I Don't Need:**\n\n*   Example code with hardcoded parameters.\n*   Additional test cases outside of the main functionality.\n*   Usage of external libraries (MCAD, etc).\n\n**In Summary:**\n\nI'm looking for a clean, well-structured, and parametric OpenSCAD gear generator that can handle spur, cog, single, and double helix gears, with customizable parameters like height, tooth count, scale, hole presence, and center hole size, while handling either circular pitch or diametral pitch values, without external libraries. I'd also like the double helix to be as correct as possible, and try to localize the global variables as much as possible.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Heart Clip",
    "scad": "thickness = 1.0;\nlength = 64;\nuse <utils/build_plate.scad>\nbuild_plate_selector = 2;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nmodule heart(scale_x = 1) {\n\thump_radius = 10;\n\ttranslate([0,-(hump_radius - 0.1),0]) cylinder(thickness,hump_radius,hump_radius);\n\ttranslate([0,(hump_radius - 0.1),0]) cylinder(thickness,hump_radius,hump_radius);\n\tscale([scale_x,1,1]) {\n\t\tdifference() {\n\t\t\thull() {\n\t\t\t\ttranslate([1,-17.8,thickness/2]) sphere(thickness/2, $fn = 10);\n\t\t\t\ttranslate([1,17.8,thickness/2]) sphere(thickness/2, $fn = 10);\n\t\t\t\ttranslate([75,0,thickness/2]) sphere(thickness/2, $fn = 10);\n\t\t\t}\n\t\t\ttranslate([56,-10,-4]) cube([30,20,8]);\n\t\t}\n\t}\n\ttranslate([(55.4 * scale_x),0,0]) cylinder(thickness,6.6,6.6, $fn = 60);\n}\nmodule hole(scale_x = 1) {\n\tdepth = thickness + 4;\n\ttranslate([0,0,-2]) {\n\t\ttranslate([1,-12,0]) cylinder(depth,5,5, $fn = 60);\n\t\ttranslate([1,12,0]) cylinder(depth,5,5, $fn = 60);\n\t\tscale([scale_x,1,1]) {\n\t\t\ttranslate([0,16,0]) rotate([0,0,256.3]) cube([4,56,depth]);\n\t\t\ttranslate([0,-12,0]) rotate([0,0,-76.3]) cube([4,56,depth]);\n\t\t}\n\t\ttranslate([(55.4 * scale_x),0,0]) cylinder(depth,4,4, $fn = 60);\n\t}\n}\nmodule heart_clip(scale_x = 1) {\n\ttranslate([-(54 * scale_x / 2),0,0]) difference() {\n\t\theart(scale_x);\n\t\thole(scale_x);\n\t}\n}\nheart_clip(length / 64);",
    "description": "Okay, I'm looking to design a heart-shaped clip, and I'd like to make it parametric so I can easily adjust its size and thickness. I want to use OpenSCAD for this.\n\nI've got a basic idea and some dimensions in mind, inspired by another design, so I'll try to describe it clearly:\n\n**Overall Shape:** The clip is basically a stylized heart shape, with two rounded humps at the top and a stem coming down to a rounded point. It's a 2D shape with a defined thickness.\n\n**Key Features and Dimensions:**\n\n*   **Length:** I want to control the overall length of the clip. Let's set a default of 64mm, and allow the user to adjust that, say from 50mm to 100mm.\n*   **Thickness:** I need to be able to set the thickness of the clip. I'd like options for 0.5mm (really thin), 1.0mm (thin), 2.0mm (thick), 3.0mm (thicker), and 4.0mm (really thick). I'll probably start with 1mm.\n*   **Heart Humps:** The top two rounded parts of the heart should be like two half-cylinders with a shared axis. I'm thinking the radius for these is around 10mm.\n*   **Stem:** This part extends downwards from the humps. It tapers slightly as it goes down, and ends with a rounded tip (a half cylinder).\n*   **Flexibility:** The clip needs to flex a little, so I need a few slots cut into the main body. I'd like these slots to be long, thin rectangles and follow the general shape of the clip.\n*   **Holes:** There should be two small circular holes at the base of the humps, and another circular hole at the rounded tip of the stem.\n\n**Parametric Needs:**\n\n*   **Overall Length:** Should control the entire length of the clip, including both the heart section and stem.\n*   **Thickness:** Adjustable.\n*   **Scale:** The whole thing should ideally scale proportionally to the length adjustment. I can start with scaling the x-axis since that's the most significant, but I think all axes should scale.\n*   **Hole Size and Placement:** The positions of the holes and slots should be relative to the overall scale and shape.\n*   **Rounded edges:** I'd like to have control of how rounded those edges are, but it can be hardcoded to 60 $fn value for now.\n\n**Libraries:** I do not need a library to accomplish this, however, if you use any standard libraries I would like to know that.\n\nCan you provide me with an OpenSCAD file that implements this design with all of these parameters? I also need a preview showing a south-east perspective with the top tilted.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Posable Figurine",
    "scad": "torso_height = 7;\ntorso_width = 4;\ntorso_thickness = 2.5;\narm_length=10;\narm_r=(torso_thickness/2) *0.8;\narm_upper_to_lower_ratio = 0.5;\narm_forarm_to_wrist_ratio = 1.5;\nhand_thickness = 0.3;\nhand_width = 1;\nhand_lenth_width_ratio = 2;\nleft_arm_angle_out =   30;\nleft_arm_angle_front = 60;\nleft_arm_elbow_bend = 70;\nright_arm_angle_out = 50;\nright_arm_angle_front = 40;\nright_arm_elbow_bend = 70;\nshoulders_h = 2*arm_r;\nshoulders_w =2*arm_r;\nhead_side_tilt_angle = 20;\nhead_angle_forward = 40;\nhead_radius = 2;\nneck_length = 1;\nneck_radius = 0.8;\nleg_length = 13;\nleg_u_r=torso_thickness/2;\nknee_r = torso_thickness/2 * 0.80;\nankle_r = knee_r * 0.75;\nleg_upper_to_lower_ratio = 0.5;\nfoot_length  =  3;\nlegs_space_between = torso_width *.9;\nright_leg_angle_out = 23;\nright_leg_angle_front = 30;\nright_leg_knee_bend = 40;\nright_foot_angle = 0;\nleft_leg_angle_out = 3;\nleft_leg_angle_front = 30;\nleft_leg_knee_bend = 60;\nleft_foot_angle = 6;\nrotate ([0,180,130]) {\n\tdraw_torso();\n\tdraw_head();\n\tdraw_arms();\n\tdraw_legs();\n}\nmodule draw_torso() {\n\tcube([torso_width,torso_thickness,torso_height]);\n\ttranslate([-(shoulders_w),0,0])\n\tcube([torso_width+(shoulders_w*2),torso_thickness,shoulders_h]);\n}\nmodule draw_legs() {\n\ttranslate([torso_width-legs_space_between,leg_u_r,torso_height])\n\tcolor(\"red\")\n\tsphere(leg_u_r);\n\ttranslate([legs_space_between,leg_u_r,torso_height])\n\tcolor(\"red\")\n\tsphere(leg_u_r);\n\ttranslate([torso_width-legs_space_between,leg_u_r,torso_height])\n\trotate([right_leg_angle_front,-right_leg_angle_out,0])\n\tcylinder(leg_length*leg_upper_to_lower_ratio,leg_u_r,knee_r);\n\tr_y_off_out = sin(right_leg_angle_front)*leg_length*leg_upper_to_lower_ratio;\n\tr_z_off_out = cos(right_leg_angle_front)*leg_length*leg_upper_to_lower_ratio;\n\tr_x_for = sin((180 - right_leg_angle_out)/2)* sin(right_leg_angle_out/2)*r_z_off_out*2;\n\tr_z_for = cos((180 - right_leg_angle_out)/2)* sin(right_leg_angle_out/2)*r_z_off_out*2;\n\tr_kn_x = torso_width-legs_space_between-r_x_for;\n\tr_kn_y = leg_u_r-r_y_off_out;\n\tr_kn_z = torso_height + r_z_off_out - r_z_for;\n\ttranslate([r_kn_x,r_kn_y,r_kn_z])\n\tcolor(\"red\")\n\tsphere(torso_thickness/2);\n\ttranslate([r_kn_x,r_kn_y,r_kn_z])\n\trotate([right_leg_angle_front,-right_leg_angle_out,0])\n\trotate([-right_leg_knee_bend,0,0])\n\tcylinder(leg_length*(1-leg_upper_to_lower_ratio),knee_r,ankle_r);\n\tra_y_off_out = sin(right_leg_angle_front-right_leg_knee_bend)*leg_length*(1-leg_upper_to_lower_ratio);\n\tra_z_off_out = cos(right_leg_angle_front-right_leg_knee_bend)*leg_length*(1-leg_upper_to_lower_ratio);\n\tra_x_for = sin((180 - right_leg_angle_out)/2)* sin(right_leg_angle_out/2)*ra_z_off_out*2;\n\tra_z_for = cos((180 - right_leg_angle_out)/2)* sin(right_leg_angle_out/2)*ra_z_off_out*2;\n\tr_an_x = r_kn_x - ra_x_for;\n\tr_an_y = r_kn_y - ra_y_off_out;\n\tr_an_z = r_kn_z + ra_z_off_out - ra_z_for;\n\ttranslate([r_an_x,r_an_y,r_an_z])\n\tcolor(\"red\")\n\tsphere(ankle_r);\n\ttranslate([r_an_x-ankle_r,r_an_y-foot_length+ankle_r,r_an_z])\n\trotate([-right_foot_angle,0,0])\n\tcube([ankle_r*2,foot_length,ankle_r*1.75]);\n\ttranslate([legs_space_between,leg_u_r,torso_height])\n\trotate([left_leg_angle_front,left_leg_angle_out,0])\n\tcylinder(leg_length*leg_upper_to_lower_ratio,leg_u_r,knee_r);\n\tl_y_off_out = sin(left_leg_angle_front)*leg_length*leg_upper_to_lower_ratio;\n\tl_z_off_out = cos(left_leg_angle_front)*leg_length*leg_upper_to_lower_ratio;\n\tl_x_for = sin((180 - left_leg_angle_out)/2)* sin(left_leg_angle_out/2)*l_z_off_out*2;\n\tl_z_for = cos((180 - left_leg_angle_out)/2)* sin(left_leg_angle_out/2)*l_z_off_out*2;\n\tl_kn_x = legs_space_between+l_x_for;\n\tl_kn_y = leg_u_r-l_y_off_out;\n\tl_kn_z = torso_height + l_z_off_out - l_z_for;\n\ttranslate([l_kn_x,l_kn_y,l_kn_z])\n\tcolor(\"red\")\n\tsphere(torso_thickness/2);\n\ttranslate([l_kn_x,l_kn_y,l_kn_z])\n\trotate([left_leg_angle_front,-left_leg_angle_out,0])\n\trotate([-left_leg_knee_bend,0,0])\n\tcylinder(leg_length*(1-leg_upper_to_lower_ratio),knee_r,ankle_r);\n\tla_y_off_out = sin(left_leg_angle_front-left_leg_knee_bend)*leg_length*(1-leg_upper_to_lower_ratio);\n\tla_z_off_out = cos(left_leg_angle_front-left_leg_knee_bend)*leg_length*(1-leg_upper_to_lower_ratio);\n\tla_x_for = sin((180 - left_leg_angle_out)/2)* sin(left_leg_angle_out/2)*la_z_off_out*2;\n\tla_z_for = cos((180 - left_leg_angle_out)/2)* sin(left_leg_angle_out/2)*la_z_off_out*2;\n\tl_an_x = l_kn_x - la_x_for;\n\tl_an_y = l_kn_y - la_y_off_out;\n\tl_an_z = l_kn_z + la_z_off_out - la_z_for;\n\ttranslate([l_an_x,l_an_y,l_an_z])\n\tcolor(\"red\")\n\tsphere(ankle_r);\n\ttranslate([l_an_x-ankle_r,l_an_y-foot_length+ankle_r,l_an_z])\n\trotate([-left_foot_angle,0,0])\n\tcube([ankle_r*2,foot_length,ankle_r*1.75]);\n}\nmodule draw_head() {\n\ttranslate([torso_width/2,torso_thickness/2,0])\n\tcolor(\"red\")\n\tsphere(neck_radius);\n\ttranslate([torso_width/2,torso_thickness/2,0])\n\trotate([180-head_angle_forward,head_side_tilt_angle,0])\n\tcylinder(neck_length,neck_radius,neck_r);\n\th_y_off_out = sin(head_angle_forward)*neck_length;\n\th_z_off_out = cos(head_angle_forward)*neck_length;\n\th_x_for = sin((180-head_side_tilt_angle)/2)* sin(head_side_tilt_angle/2)*h_z_off_out*2;\n\th_z_for = cos((180-head_side_tilt_angle)/2)* sin(head_side_tilt_angle/2)*h_z_off_out*2;\n\th_n_x = torso_width/2-h_x_for;\n\th_n_y = -h_y_off_out+torso_thickness/2;\n\th_n_z = -h_z_off_out+h_z_for;\n\ttranslate([h_n_x,h_n_y,h_n_z])\n\tcolor(\"red\")\n\tsphere(neck_radius);\n\ttranslate([h_n_x,h_n_y,h_n_z-head_radius])\n\tsphere(head_radius, $fn=50);\n}\nmodule draw_arms() {\n\ttranslate([-arm_r,arm_r,arm_r])\n\trotate([right_arm_angle_front,-right_arm_angle_out,0])\n\tcylinder(arm_length*arm_upper_to_lower_ratio,arm_r,arm_r);\n\tr_y_off_out = sin(right_arm_angle_front)*arm_length*arm_upper_to_lower_ratio;\n\tr_z_off_out = cos(right_arm_angle_front)*arm_length*arm_upper_to_lower_ratio;\n\tr_x_for = sin((180 - right_arm_angle_out)/2)* sin(right_arm_angle_out/2)*r_z_off_out*2;\n\tr_z_for = cos((180 - right_arm_angle_out)/2)* sin(right_arm_angle_out/2)*r_z_off_out*2;\n\tr_el_x = -arm_r-r_x_for;\n\tr_el_y = arm_r-r_y_off_out;\n\tr_el_z = arm_r+r_z_off_out-r_z_for;\n\ttranslate([r_el_x,r_el_y,r_el_z])\n\tcolor(\"red\")\n\tsphere(torso_thickness/2);\n\ttranslate([r_el_x,r_el_y,r_el_z])\n\trotate([right_arm_angle_front,-right_arm_angle_out,0])\n\trotate([right_arm_elbow_bend,0,0])\n\tcylinder(arm_length*(1-arm_upper_to_lower_ratio),arm_r,arm_r/arm_forarm_to_wrist_ratio);\n\trw_y_off_out = sin(right_arm_angle_front+right_arm_elbow_bend)*arm_length*(1-arm_upper_to_lower_ratio);\n\trw_z_off_out = cos(right_arm_angle_front+right_arm_elbow_bend)*arm_length*(1-arm_upper_to_lower_ratio);\n\trw_x_for = sin((180 - right_arm_angle_out)/2)* sin(right_arm_angle_out/2)*rw_z_off_out*2;\n\trw_z_for = cos((180 - right_arm_angle_out)/2)* sin(right_arm_angle_out/2)*rw_z_off_out*2;\n\tr_wr_x = r_el_x - rw_x_for;\n\tr_wr_y = r_el_y - rw_y_off_out;\n\tr_wr_z = r_el_z + rw_z_off_out - rw_z_for;\n\ttranslate([r_wr_x,r_wr_y,r_wr_z])\n\tcolor(\"red\")\n\tsphere(arm_r/arm_forarm_to_wrist_ratio);\n\trh_y_off_out = sin(right_arm_angle_front+right_arm_elbow_bend)*hand_lenth_width_ratio*hand_width/2;\n\trh_z_off_out = cos(right_arm_angle_front+right_arm_elbow_bend)*hand_lenth_width_ratio*hand_width/2;\n\trh_x_for = sin((180 - right_arm_angle_out)/2)* sin(right_arm_angle_out/2)*rh_z_off_out*2;\n\trh_z_for = cos((180 - right_arm_angle_out)/2)* sin(right_arm_angle_out/2)*rh_z_off_out*2;\n\tr_ha_x = r_wr_x - rh_x_for;\n\tr_ha_y = r_wr_y - rh_y_off_out;\n\tr_ha_z = r_wr_z + rh_z_off_out - rh_z_for;\n\ttranslate([r_ha_x,r_ha_y,r_ha_z])\n\trotate([right_arm_angle_front,-right_arm_angle_out,0])\n\trotate([right_arm_elbow_bend,0,0])\n\trotate([90,90,270])\n\tscale (v=[hand_lenth_width_ratio,1,1]) cylinder(h = hand_thickness, r=hand_width/2, $fn=12);\n\ttranslate([arm_r+torso_width,arm_r,arm_r])\n\trotate([left_arm_angle_front,left_arm_angle_out,0])\n\tcylinder(arm_length*arm_upper_to_lower_ratio,arm_r,arm_r);\n\tl_y_off_out = sin(left_arm_angle_front)*arm_length*arm_upper_to_lower_ratio;\n\tl_z_off_out = cos(left_arm_angle_front)*arm_length*arm_upper_to_lower_ratio;\n\tl_x_for = sin((180 - left_arm_angle_out)/2)* sin(left_arm_angle_out/2)*l_z_off_out*2;\n\tl_z_for = cos((180 - left_arm_angle_out)/2)* sin(left_arm_angle_out/2)*l_z_off_out*2;\n\tl_el_x = arm_r+torso_width+l_x_for;\n\tl_el_y = arm_r-l_y_off_out;\n\tl_el_z = arm_r+l_z_off_out-l_z_for;\n\ttranslate([l_el_x,l_el_y,l_el_z])\n\tcolor(\"red\")\n\tsphere(torso_thickness/2);\n\ttranslate([l_el_x,l_el_y,l_el_z])\n\trotate([left_arm_angle_front,left_arm_angle_out,0])\n\trotate([left_arm_elbow_bend,0,0])\n\tcylinder(arm_length*(1-arm_upper_to_lower_ratio),arm_r,arm_r/arm_forarm_to_wrist_ratio);\n\tlw_y_off_out = sin(left_arm_angle_front+left_arm_elbow_bend)*arm_length*(1-arm_upper_to_lower_ratio);\n\tlw_z_off_out = cos(left_arm_angle_front+left_arm_elbow_bend)*arm_length*(1-arm_upper_to_lower_ratio);\n\tlw_x_for = sin((180 - left_arm_angle_out)/2)* sin(left_arm_angle_out/2)*lw_z_off_out*2;\n\tlw_z_for = cos((180 - left_arm_angle_out)/2)* sin(left_arm_angle_out/2)*lw_z_off_out*2;\n\tl_wr_x = l_el_x + lw_x_for;\n\tl_wr_y = l_el_y - lw_y_off_out;\n\tl_wr_z = l_el_z + lw_z_off_out - lw_z_for;\n\ttranslate([l_wr_x,l_wr_y,l_wr_z])\n\tcolor(\"red\")\n\tsphere(arm_r/arm_forarm_to_wrist_ratio);\n\tlh_y_off_out = sin(left_arm_angle_front+left_arm_elbow_bend)*hand_lenth_width_ratio*hand_width/2;\n\tlh_z_off_out = cos(left_arm_angle_front+left_arm_elbow_bend)*hand_lenth_width_ratio*hand_width/2;\n\tlh_x_for = sin((180 - left_arm_angle_out)/2)* sin(left_arm_angle_out/2)*lh_z_off_out*2;\n\tlh_z_for = cos((180 - left_arm_angle_out)/2)* sin(left_arm_angle_out/2)*lh_z_off_out*2;\n\tl_ha_x = l_wr_x + lh_x_for;\n\tl_ha_y = l_wr_y - lh_y_off_out;\n\tl_ha_z = l_wr_z + lh_z_off_out - lh_z_for;\n\ttranslate([l_ha_x,l_ha_y,l_ha_z])\n\trotate([left_arm_angle_front,left_arm_angle_out,0])\n\trotate([left_arm_elbow_bend,0,0])\n\trotate([90,90,90])\n\tscale (v=[hand_lenth_width_ratio,1,1]) cylinder(h = hand_thickness, r=hand_width/2, $fn=12);\n}",
    "description": "Okay, here's what I'm looking for:\n\nI want to create a parametric, posable figure using OpenSCAD. I've got a basic design in mind, and I'd like an OpenSCAD file that lets me adjust a bunch of parameters to control the figure's size and pose. I'll probably want to export the final design as an STL for printing.\n\nHere's a breakdown of the parameters I'd like to control:\n\n**Torso:**\n*   `torso_height`: The height of the main torso block (e.g. 7).\n*   `torso_width`: The width of the torso block (e.g. 4).\n*   `torso_thickness`: The thickness of the torso block (e.g. 2.5).\n\n**Arms:**\n*   `arm_length`:  Total length of the arm (e.g. 10).\n*   `arm_r`: Radius of the arm cylinders, automatically derived from `torso_thickness` but exposed for adjustment if needed (e.g. `(torso_thickness/2) *0.8`).\n*    `arm_upper_to_lower_ratio`: Ratio of upper arm length to total arm length (e.g. 0.5).\n*   `arm_forarm_to_wrist_ratio`: Ratio of the forarm radius to wrist radius (e.g 1.5).\n*   `hand_thickness`: Thickness of the hand (e.g. 0.3).\n*   `hand_width`: Width of the hand (e.g. 1).\n*   `hand_lenth_width_ratio`: Ratio of hand length to hand width (e.g. 2).\n*   `left_arm_angle_out`: Angle of the left arm outward from the body, in degrees (e.g. 30).\n*   `left_arm_angle_front`: Angle of the left arm forward from the body, in degrees (e.g. 60).\n*   `left_arm_elbow_bend`: Bend angle of the left elbow, in degrees (e.g. 70).\n*   `right_arm_angle_out`: Angle of the right arm outward from the body, in degrees (e.g. 50).\n*   `right_arm_angle_front`: Angle of the right arm forward from the body, in degrees (e.g. 40).\n*   `right_arm_elbow_bend`: Bend angle of the right elbow, in degrees (e.g. 70).\n* `shoulders_h`: Height of the shoulders extending out from the torso, this should be a percentage of torso height (e.g 2 * `arm_r`).\n* `shoulders_w`:  Width of the shoulders extending out from the torso, should be a percentage of torso width (e.g 2 * `arm_r`).\n\n**Head:**\n*   `head_side_tilt_angle`: Angle of the head tilt to the side (e.g. 20).\n*   `head_angle_forward`: Angle of the head forward/backward (e.g. 40).\n*   `head_radius`: Radius of the head sphere (e.g. 2).\n*   `neck_length`: Length of the neck cylinder (e.g. 1).\n*   `neck_radius`: Radius of the neck cylinder (e.g. 0.8).\n\n**Legs:**\n*   `leg_length`: Total length of the leg (e.g. 13).\n*   `leg_u_r`: Radius of the upper leg cylinder (e.g. `torso_thickness/2`).\n*  `knee_r`: Radius of the knee joint, should be a percentage of torso thickness (e.g. `torso_thickness/2 * 0.80`).\n* `ankle_r`: Radius of the ankle joint, should be a percentage of knee radius (e.g. `knee_r * 0.75`).\n*   `leg_upper_to_lower_ratio`: Ratio of upper leg length to total leg length (e.g. 0.5).\n*   `foot_length`:  Length of the foot (e.g. 3).\n*   `legs_space_between`: Space between the legs at the hips, derived from torso width (e.g. `torso_width *.9`).\n*   `right_leg_angle_out`: Angle of the right leg outward from the body, in degrees (e.g. 23).\n*   `right_leg_angle_front`: Angle of the right leg forward from the body, in degrees (e.g. 30).\n*   `right_leg_knee_bend`: Bend angle of the right knee, in degrees (e.g. 40).\n*   `right_foot_angle`: Angle of the right foot, in degrees (e.g. 0).\n*   `left_leg_angle_out`: Angle of the left leg outward from the body, in degrees (e.g. 3).\n*   `left_leg_angle_front`: Angle of the left leg forward from the body, in degrees (e.g. 30).\n*   `left_leg_knee_bend`: Bend angle of the left knee, in degrees (e.g. 60).\n*   `left_foot_angle`: Angle of the left foot, in degrees (e.g. 6).\n\nThe figure should be constructed from basic shapes:\n*  The torso is a rectangular prism.\n*  The shoulders are cubes with a sphere at the end, attached to the torso.\n*  Arms and legs are made from cylinders and spheres for the joints, ending in a simple hand or foot shape (rectangles).\n*  The head is a sphere on a neck (cylinder and sphere).\n\nI'd like to be able to adjust all of these parameters and see the changes in the preview. \nAlso, could you please ensure that the code uses modules for the different parts of the figure (torso, head, arms, legs)?\nMake sure the calculations of the x, y, and z positions for the joints are correct to properly position the parts. \n\nI don't expect any pre-made libraries to be included, so all the math and shapes should be constructed within the file you generate.\n\nThank you!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Petal Vase Creator",
    "scad": "Number_of_Petals = 4;\nVase_Height = 50;\nNeck_Style = \"bump\";\npetals = Number_of_Petals + 0.0;\nfactors = [1,1,1,82.5,90.5,95,97.5,100.5,103,105];\nmaxSize = ((factors[petals])/petals)-1.85;\noverallHeight = Vase_Height+0.0;\ntopHeight = 3 + 0.0;\nneckHeight = 5 + 0.0;\nheight = overallHeight - topHeight;\nfor (i = [0:petals-1]) {\n\trotate([0,0,i*(360/petals)]) makePetal();\n}\nmodule makePetal() {\n\tunion() {\n\t\tdifference() {\n\t\t\t\touter();\n\t\t\t\tinner();\n\t\t}\n\t\ttop();\n\t\tif (Neck_Style != \"none\") {\n\t\t\tneck();\n\t\t}\n\t}\n}\nmodule outer() {\n\t\t\thull() {\n\t\t\t   translate([30,0,0]) cylinder(r=maxSize, h=height, $fn=36);\n\t\t\t   translate([5+petals-4,0,0]) cylinder(r=3, h=height, $fn=36);\n\t\t\t}\n}\nmodule inner() {\n\t\t\thull() {\n\t\t\t   translate([30,0,4]) cylinder(r1=maxSize-3, r2=13-petals, h=height, $fn=36);\n\t\t\t   translate([6+petals+12,0,4]) cylinder(r1=1, r2=0.1, h=height, $fn=36);\n\t\t\t}\n}\nmodule top() {\n\tdifference() {\n\t\ttranslate([0,0,height]) hull() {\n\t\t\t   translate([30,0,0]) cylinder(r=maxSize, h=topHeight, $fn=36);\n\t\t\t   translate([5+petals-4,0,0]) cylinder(r=3, h=topHeight, $fn=36);\n\t\t\t}\n\t\ttranslate([30,0,4]) cylinder(r=13-petals, h=height+5, $fn=36);\n\t}\n}\nmodule neck() {\n\tif (Neck_Style == \"angled\") {\n\t\ttranslate([30,0,overallHeight])\n\t\tdifference() {\n\t\t\tcylinder(r1=16-petals, r2=15-petals ,h=neckHeight, $fn=36);\n\t\t\ttranslate([0,0,-1]) cylinder(r=13-petals,h=neckHeight+2, $fn=36);\n\t\t}\n\t\ttranslate([30,0,overallHeight])\n\t\tdifference() {\n\t\t\trotate_extrude(convexity = 10, $fn=36) translate([15.5-petals, 0, 0]) circle(r = 1, $fn=36);\n\t\t\ttranslate([-15,-15,-5]) cube([30,30,5]);\n\t\t}\n\t\ttranslate([30,0,overallHeight])\n\t\tdifference() {\n\t\t\trotate_extrude(convexity = 10, $fn=36) translate([14-petals, neckHeight, 0]) circle(r = 1, $fn=36);\n\t\t\ttranslate([-15,-15,neckHeight-5]) cube([30,30,5]);\n\t\t}\n\t} else if (Neck_Style == \"bump\") {\n\t\ttranslate([30,0,overallHeight])\n\t\tdifference() {\n\t\t\trotate_extrude(convexity = 10, $fn=36) translate([14-petals, 0, 0]) circle(r = 3, $fn=36);\n\t\t\ttranslate([-15,-15,-5]) cube([30,30,5]);\n\t\t\ttranslate([0,0,-5]) cylinder(r=13-petals, h=height+15, $fn=36);\n\t\t}\n\t} else if (Neck_Style == \"fluted\") {\n\t\ttranslate([30,0,overallHeight])\n\t\tdifference() {\n\t\t\tcylinder(r=16-petals ,h=10, $fn=36);\n\t\t\trotate_extrude(convexity = 10) translate([20-petals, 2, 0]) scale([1,1.25,1]) circle(r = 6, $fn=36);\n\t\t\ttranslate([0,0,-1]) cylinder(r=13-petals,h=12, $fn=36);\n\t\t}\n\t}\n}",
    "description": "Okay, I'd like to create a flower using a set of vases, and I need an OpenSCAD file to do that parametrically.\n\nThe basic idea is to use the provided 'PetalVaseCreator.scad' file as inspiration, but instead of creating a single vase with multiple petals, I want to create *separate* vase objects that I can then arrange into a flower shape in the main module.\n\nHere's the breakdown of what I need:\n\n1.  **Individual Vase Modules:** Instead of the `makePetal()` module, I need a module called `vase()` that creates a single vase. This module should accept the same parameters as the global variables in `PetalVaseCreator.scad`, so we can customize each individual vase. Specifically, I want to be able to control the following for each vase:\n    *   `Number_of_Petals`: This determines the number of \"petals\" the vase is constructed from. Valid range is 3 to 8.\n    *   `Vase_Height`: This controls the height of the vase body, not including any neck. Valid range is 25 to 100.\n    *  `Neck_Style`: Controls the style of the vase neck: \"none\", \"angled\", \"bump\", \"fluted\".\n\n2.  **Flower Arrangement:** The main module should be named `flower()`. This module will arrange several vase modules. \n    *   I want to control the number of vases used to form the flower.\n    * I want to control the rotation angle of each vase individually.\n    * I want to control the x,y coordinate offset of each vase individually.\n    * I want to be able to change the vase parameters for each vase individually.\n\n3. **No Global Variables**: Do not rely on global variables, instead, be sure to include all parameters as module arguments.\n\n4. **Libraries**: I don't expect you to include any libraries besides the basic built-in OpenSCAD functions, but make sure to note if you use any third-party libraries (like MCAD, BOSL, etc.).\n\nHeres an example of how I want to call the `flower()` module:\n```openscad\nflower(\n    vase_count = 6,\n    vase_parameters = [\n    [Number_of_Petals=4, Vase_Height=50, Neck_Style=\"bump\", rotate_angle = 0, x_offset = 30, y_offset=0],\n    [Number_of_Petals=4, Vase_Height=60, Neck_Style=\"angled\", rotate_angle = 60, x_offset = 30, y_offset =0],\n    [Number_of_Petals=5, Vase_Height=70, Neck_Style=\"fluted\", rotate_angle = 120, x_offset=30, y_offset=0],\n    [Number_of_Petals=5, Vase_Height=60, Neck_Style=\"bump\", rotate_angle = 180, x_offset=30, y_offset =0],\n    [Number_of_Petals=6, Vase_Height=60, Neck_Style=\"angled\", rotate_angle = 240, x_offset =30, y_offset=0],\n    [Number_of_Petals=4, Vase_Height=50, Neck_Style=\"fluted\", rotate_angle = 300, x_offset=30, y_offset=0]\n     ]\n);\n```\n\nThis would create a flower with six vases, each with different heights, number of petals, neck styles, rotation angles, and offsets.\n\nBasically, I need to recreate the 'PetalVaseCreator.scad' logic to generate an individual vase, and then arrange multiple vases in a flower shape as described. I want to customize the vase parameters, rotation, and offsets for each individual vase within a flower.\n"
  },
  {
    "object": "Hey cadmonkey, make me a CustomizableTowel Hanger",
    "scad": "hook_diameter=50;\nhole_diameter=60;\nhook_thickness=5;\nhook_height=3;\nflaps_thickness=.5;\nresolution=75;\n$fn=resolution;\nhook();\ntranslate([(hole_diameter+10),(hook_diameter-hole_diameter)/-2,0])towel_holder();\nmodule towel_holder(){\ndifference(){\ncylinder(hook_height,(hole_diameter+(hook_thickness*2))/2,(hole_diameter+(hook_thickness*2))/2);\ntranslate([0,0,0])cylinder(hook_height+2,(hole_diameter)/2,(hole_diameter)/2);\n}\ndifference(){\ncylinder(flaps_thickness,(hole_diameter)/2,(hole_diameter)/2);\nfor ( i = [0 : 5] )\n{\n    rotate( i * 360 / 6, [0, 0, 1])\n    translate([0, (hole_diameter-(1/6*hole_diameter))/2, 0])\n\thull(){\n\ttranslate([0,0,-1])cylinder(hook_height+1,(hole_diameter/6)/4,(hole_diameter/6)/4);\n\ttranslate([0,(hole_diameter)/-4,-1])cylinder(hook_height+1,(hole_diameter/6)/4,(hole_diameter/6)/4);\n}\n}\ntranslate([0,0,-1])cylinder(hook_height+1, (hole_diameter)/6,(hole_diameter)/6);\n}\nrotate([0,0,360/12]){\nfor ( i = [0 : 5] )\n{\n    rotate( i * 360 / 6, [0, 0, 1])\n    translate([0, (hole_diameter)/6, 0])\n\tcylinder(flaps_thickness,(hole_diameter/22.22222222222222),(hole_diameter/22.22222222222222));\n}\n}\n}\nmodule hook(){\ndifference(){\nhull(){\ncylinder(hook_height,(hook_diameter+(hook_thickness*2))/2,(hook_diameter+(hook_thickness*2))/2);\ntranslate([(hole_diameter+5)*1.5,0,0])cylinder(hook_height,(hook_diameter+(hook_thickness*2))/2,(hook_diameter+(hook_thickness*2))/2);\n}\nhull(){\ntranslate([0,0,-1])cylinder(hook_height+2,(hook_diameter)/2,(hook_diameter)/2);\ntranslate([(hole_diameter+5)*1.5,0,-1])cylinder(hook_height+2,(hook_diameter)/2,(hook_diameter)/2);\n}\ntranslate([((hook_diameter*2-hole_diameter)/1.5)+(hole_diameter+10)*1.5,0,(hook_height/2)-1])cube([(hook_diameter*2+(hook_thickness*5)),(hook_diameter*2+(hook_thickness*2)),hook_height+3], center = true);\ntranslate([5,0,-1])cube([(hole_diameter+5)*1.5,(hook_diameter+hook_thickness),hook_height+2]);\n}\n}",
    "description": "Okay, I need a design for a towel hanger that I can 3D print. I've got some basic ideas, but I'd like it to be parametric so I can adjust it for different towel sizes and mounting locations.\n\nHere's what I'm thinking:\n\n**Overall Design:**\n\nThe hanger should consist of two main parts: a hook that will hang on a rod or over a cabinet door (like a standard towel bar), and a holder with small flaps to securely hold the towel. The towel would be pulled through the holder to grab or release it.\n\n**Hook:**\n\n*   **Shape:** I'd like a somewhat rounded, \"C\" shape that can rest on a rod. The inside of the \"C\" should be large enough to fit over a variety of rod sizes, but I'd like to be able to adjust that dimension.\n*   **Thickness:** The hook needs to be thick enough to be sturdy. I'd like to be able to adjust both the horizontal and vertical thicknesses.\n*   **Position:** The position of the towel holder needs to be adjustable relative to the hook. I'd like to be able to move it left, right, and up or down.\n\n**Towel Holder:**\n\n*   **Shape:** The holder should be essentially a cylinder with a hole through the middle for the towel.\n*   **Flaps:** Around the inner edge of the hole, I want small, flexible flaps. These flaps are going to be what actually grips the towel. I'd like to control how thick these flaps are and how far into the cylinder they protrude. The number of flaps should also be customizable. They should be flexible to allow the towel to be easily inserted or removed. I'm imagining maybe 6 to 12 evenly spaced flaps.\n*   **Size:** The diameter of the hole should be adjustable for different thicknesses of towels.\n\n**Parameters:**\n\nI'd like to have the following adjustable parameters:\n\n*   `hook_diameter`: The diameter of the main circle part of the hook.\n*   `hook_thickness`: The horizontal thickness of the hook.\n*   `hook_height`: The vertical thickness of the hook.\n*   `hole_diameter`: The diameter of the hole in the towel holder.\n*   `flaps_thickness`: The thickness of the towel holder flaps.\n*   `resolution`: This variable controls the smoothness of curves (using `$fn`).\n*   `flaps_count`: The number of flaps around the towel holder hole.\n*   `holder_offset_x` The horizontal position of the towel holder relative to the hook.\n*   `holder_offset_y` The vertical position of the towel holder relative to the hook.\n\n**General:**\nI would like to keep it fairly simple and clean looking. I don't need any fancy text or textures, it should be purely functional.\n\n**Libraries:**\n\nI don't have any specific libraries in mind, but I'd like the code to be as simple as possible while maintaining the ability to customize as I've described above. \n\nCould you generate an OpenSCAD file for me that implements this design?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizer Box with Lid and screw holes",
    "scad": "box_length = 50;\nbox_breadth = 50;\nbox_height = 50;\nradius_outer = 5;\nradius_hole = 2;\nmodule faceplate(l,b,r_outer,r_hole) {\n\tdifference() {\n\t\tminkowski() {\n\t\t\tcircle(r_outer);\n\t\t\tsquare([l,b]);\n\t\t}\n\t\tcircle(r_hole);\n\t\ttranslate([l,0,0])circle(r_hole);\n\t\ttranslate([0,b,0])circle(r_hole);\n\t\ttranslate([l,b,0])circle(r_hole);\n\t}\n}\nmodule inner_shape(l,b,r_outer) {\n\tdifference() {\n\t\tsquare([l,b]);\n\t\tcircle(r_outer);\n\t\ttranslate([l,0,0])circle(r_outer);\n\t\ttranslate([0,b,0])circle(r_outer);\n\t\ttranslate([l,b,0])circle(r_outer);\n\t}\n}\nmodule box(l,b,h,r_outer,r_hole) {\n\tunion() {\n\t\tlinear_extrude(height = h)\n\t\t{\n\t\t\tdifference() {\n\t\t\t\tfaceplate(l,b,r_outer,r_hole);\n\t\t\t\tinner_shape(l,b,r_outer,r_hole);\n\t\t\t}\n\t\t}\n\t\tlinear_extrude(height = 2)faceplate(l,b,r_outer,r_hole);\n\t}\n}\nbox(box_length,box_breadth,box_height,radius_outer,radius_hole);\ntranslate([box_length+2*radius_outer+5,0,0])linear_extrude(height = 2)faceplate(box_length,box_breadth,radius_outer,radius_hole);",
    "description": "Okay, I need a customizable box design in OpenSCAD, similar to the one I've been working on, but I want to add some features and make it more robust.\n\nHere's what I'm looking for:\n\n**Core Functionality (Like my existing design):**\n\n*   A rectangular box with customizable length, breadth, and height.\n*   Rounded outer corners (controllable radius).\n*   Screw holes in each corner of the box face. The radius of the screw holes should also be adjustable.\n*   A separate lid that fits on top of the box, matching the box's dimensions and rounded corners. It should also have screw holes.\n\n**New Features I'd like to add:**\n\n*   **Wall Thickness:** I want to be able to control the wall thickness of the box and lid. My current implementation makes assumptions about wall thickness.\n*   **Lid Offset:** The lid should have an optional offset to allow it to sit neatly within the outer wall of the box, but I want to be able to specify that offset amount.\n*   **Countersunk Holes:** The screw holes should be countersunk, so the screw heads don't protrude. The counter-sink angle should be parametric and there should be enough depth. This will probably need some sort of calculation, but I am hoping for a parametric approach to all measurements.\n*   **Support Structures:** I would like an option to generate small support structures, specifically tiny cylinders, that sit inside the screw holes and hold the screws in place. The diameter and height of the support cylinders will need to be parameters.\n*   **Tolerance:** The lid and box should have adjustable tolerances so that they fit together correctly. I don't want it to be too loose or too tight.\n*   **Optional Insets/Cutouts:** I'd like an option to add rectangular insets or cutouts on the sides of the box, defined by their starting location and size, including depth.\n*   **Rounded Inner Edges:** Can the inner edges of the box (where the walls meet at corners) be rounded with a specific inner radius?\n\n**Requested Code Attributes:**\n*   I'd like everything to be parametric and well-commented.\n*  I'd like to leverage the BOLTS library where applicable, especially for the countersunk hole implementation.\n*   I want to be able to easily adjust every mentioned dimension using variables.\n*   I would prefer all module code to be easy to read and understand.\n\nIn summary, I need a robust, parametric, customizable box and lid generator with countersunk screw holes, support cylinders, and an option to add inset details, as well as full control over wall thickness, offset, tolerance, and rounded edges. And I would like to use BOLTS for the countersinking logic. Please let me know if you have any clarifying questions.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Gear4",
    "scad": "nt =12;\nsd =8;\ngd=15;\nggdt=1.5;\ngh=18;\nnf=0;\n$fn=12;\nDcut=\"yes\";\ngpr=gd*3.14159/4/nt/(1+3.141592/nt/2);\ngmr=gpr*1.077;\nggd=gd+4;\ndh=gh;\noff= 360/nt/2;\nmodule pgear()\n\tunion(){\n\ttranslate([0, 0, 0]) {\n\t\tdifference() {\n         union(){\n\t\t  translate([0, 0, 0]) cylinder(h = gh, r =gd/2-gpr,$fn=48);\n      if (nf == 1){\n          translate([0, 0, gh-ggdt])cylinder(h = ggdt, r= ggd/2,$fn=96);\n      \t\t\t\t}\n      if (nf == 2){\n         translate([0, 0, gh-ggdt])cylinder(h = ggdt, r= ggd/2,$fn=96);\n         translate([0, 0, 0])cylinder(h = ggdt, r= ggd/2,$fn=96);\n                   }\n                 }\ntranslate([0, 0, -0.5])\n\t\t\tcylinder(h = gh+2.5, r= sd/2,$fn=48);\n\t\tfor (i = [0:(nt-1)]) {\n\t\t\techo(360*i/nt, sin(360*i/nt)*(gd/2-gpr), cos(360*i/nt)*(gd/2-gpr));\n\t\t\ttranslate([sin(360*i/nt)*(gd/2-gpr), cos(360*i/nt)*(gd/2-gpr), ggdt*nf*(nf-1)*0.5])\n\t\t\t\trotate([0,0,90*(1-2/$fn)-360*i/nt-($fn-1)*off]) cylinder(h = gh-ggdt*nf, r=gmr);\n\t\t                      }\n     \t\t\t\t\t\t\t}\n\t\tfor (i = [0:(nt-1)]) {\n\t\t\techo(360*i/nt+off, sin(360*i/nt+off)*(gd/2-gpr), cos(360*i/nt+off)*(gd/2-gpr));\n\t\t\ttranslate([sin(360*i/nt+off)*(gd/2-gpr), cos(360*i/nt+off)*(gd/2-gpr), 0 ])\n\t\t\t\trotate([0,0,90*(1-2/$fn)-360*i/nt-$fn*off]) cylinder(h = gh, r=gpr);\n\t\t                      }\n                }\n if (Dcut== \"yes\"){\n         translate([-(sd/2.1), 0, gh/2]) cube([sd/5,sd*0.8,dh], center = true);\n       }\n}\npgear();",
    "description": "Okay, I'm looking for help creating a parametric spur gear in OpenSCAD. I have a basic version of what I want, but it needs to be more flexible.\n\nHere's what I need the gear to do, and the parameters I'd like to control:\n\n*   **Number of Teeth:**  I want to be able to specify the number of teeth on the gear.\n*   **Shaft Diameter:**  The diameter of the central hole for the shaft needs to be adjustable.\n*   **Gear Diameter:** The overall diameter of the gear itself should be a parameter.\n*   **Fringe Thickness:**  I need to be able to add optional \"fringes\" at the top and/or bottom of the gear. The thickness of these fringes should be adjustable.\n*   **Gear Height:** I need to set the overall height/thickness of the gear.\n*   **Number of Fringes:** I need to control how many fringes the gear has (0, 1, or 2).\n*   **Tooth Shape:** I'd like some control over the shape of the teeth themselves, at least by changing the `$fn` value that controls the smoothness/resolution of the circles, and ideally a small number of preset tooth profiles to select from as well.\n*   **D-Cut:** I want an option to create a D-shaped shaft hole for keyed shafts instead of just a round hole. I need to be able to enable/disable this.\n*   **Gear Tooth Gap:** I'd also like some control over the gear tooth gap to adjust how the gear connects with other gears, such as a multiplier or offset to make the gap bigger or smaller.\n\nI've included my existing OpenSCAD code below for reference, which demonstrates the functionality I'm trying to achieve:\n\n```openscad\n// Takuya Yamaguchi\n\n// ignore variable values\n//$fn=48;\n\n//custermizing data\n\n// number of tooth\nnt =12;\n\n//shaft diameter\t\t\nsd =8;\n\n//gear diameter\t\t\ngd=15;\n\n// fringe thickness\t\t\nggdt=1.5;\t\n\n// gear hight\ngh=18;\n\n//number of fringe\t\t\nnf=0;\t//[0,1,2]\n\n//tooth shape\t\n$fn=12; //[4,5,6,7,8,12]\n\n//Dcut yes or no\nDcut=\"yes\";//[yes,no]\n\n// ignore variable values\ngpr=gd*3.14159/4/nt/(1+3.141592/nt/2);\t//gear tooth r\ngmr=gpr*1.077; \t\t\t\t\t\t\t// gear gap r\nggd=gd+4; \t\t\t\t\t\t\t\t\t// fringe diameter\ndh=gh; \t\t\t\t\t\t\t\t\t\t//Dcut hight\noff= 360/nt/2;  \t\t\t\t\t\t\t// tooth offset\n\nmodule pgear()\n\n\tunion(){\n\ttranslate([0, 0, 0]) {\n\t\tdifference() {\n         union(){  //gear & fringe\n\t\t  translate([0, 0, 0]) cylinder(h = gh, r =gd/2-gpr,$fn=48); //gear\n      if (nf == 1){\n          translate([0, 0, gh-ggdt])cylinder(h = ggdt, r= ggd/2,$fn=96); //fringe\n      \t\t\t\t}\n      if (nf == 2){\n         translate([0, 0, gh-ggdt])cylinder(h = ggdt, r= ggd/2,$fn=96); //fringe\n         translate([0, 0, 0])cylinder(h = ggdt, r= ggd/2,$fn=96); //fringe\n                   }\n                 }\ntranslate([0, 0, -0.5])  // shaft \n\t\t\tcylinder(h = gh+2.5, r= sd/2,$fn=48);\n\n\t\tfor (i = [0:(nt-1)]) { \t\t//gear gap\n\t\t\techo(360*i/nt, sin(360*i/nt)*(gd/2-gpr), cos(360*i/nt)*(gd/2-gpr));\n\t\t\ttranslate([sin(360*i/nt)*(gd/2-gpr), cos(360*i/nt)*(gd/2-gpr), ggdt*nf*(nf-1)*0.5])\n\t\t\t\trotate([0,0,90*(1-2/$fn)-360*i/nt-($fn-1)*off]) cylinder(h = gh-ggdt*nf, r=gmr);\n\t\t                      }\n     \t\t\t\t\t\t\t}\n\t\tfor (i = [0:(nt-1)]) {  // Gear tooth\n\t\t\techo(360*i/nt+off, sin(360*i/nt+off)*(gd/2-gpr), cos(360*i/nt+off)*(gd/2-gpr));\n\t\t\ttranslate([sin(360*i/nt+off)*(gd/2-gpr), cos(360*i/nt+off)*(gd/2-gpr), 0 ])\n\t\t\t\trotate([0,0,90*(1-2/$fn)-360*i/nt-$fn*off]) cylinder(h = gh, r=gpr);\n\t\t                      }\n                }\n\n\n \t\t\t\n\t // Dcut\n if (Dcut== \"yes\"){\n         translate([-(sd/2.1), 0, gh/2]) cube([sd/5,sd*0.8,dh], center = true); // Dcut\n       }\n}\n\npgear();\n```\n\nIt should use standard OpenSCAD primitives and avoid external libraries.\n\nCould you generate the OpenSCAD code for me? Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Battery Tray",
    "scad": "_diameter = 14.5;\n_height = 8;\n_columns = 2;\n_rows = 1;\n_spacing = 1.2;\n_base = 0.5;\n_cornerRounding = 4.0;\nmodule batteryQuad(diameter, height) {\n\tangle = 35;\n\tr = diameter/2;\n\tcut = 2*r*sin(angle);\n\ttan = tan(angle);\n\tfilletCenter = r - r * tan;\n\tfilletCenter2 = r + r * tan;\n\tfilletOffset = r * tan;\n\tfilletRadius = r/cos(angle) - r;\n\teps = 0.1;\n\tdifference() {\n\t\tunion() {\n\t\t\tfor (x=[-r,r]) {\n\t\t\t\tfor (y=[-r,r]) {\n\t\t\t\t\ttranslate([x,y,0]) {\n\t\t\t\t\t\tcylinder(r=r, h=height, center=true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (t=[ [ r, 0, 0],\n\t\t\t\t\t[-r, 0, 0],\n\t\t\t\t\t[ 0, r, 0],\n\t\t\t\t\t[ 0,-r, 0] ]) {\n\t\t\t\ttranslate(t) {\n\t\t\t\t\tcube(size=[cut,cut,height], center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (z=[0:90:270]) {\n\t\t\trotate([0,0,z]) {\n\t\t\t\tfor(y=[filletOffset, -filletOffset]) {\n\t\t\t\t\ttranslate([0, r+y,0]) {\n\t\t\t\t\t\tcylinder(r=filletRadius, h=height+eps, center=true, $fn=30);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule makeTray(diameter, height, rows, columns, spacing, base, rounding) {\n\teps = 0.1;\n\trounding = min(rounding, diameter/2 + spacing*2);\n\tquadSize = 2 * diameter;\n\twidth = (quadSize + spacing) * columns + spacing*2;\n\tdepth = (quadSize + spacing) * rows + spacing*2;\n\txstart = -width/2 + spacing*1.5 + quadSize/2;\n\tystart = -depth/2 + spacing*1.5 + quadSize/2;\n\tdifference() {\n\t\thull()\n\t\tfor (x=[-width/2 + rounding, width/2 - rounding])\n\t\tfor (y=[-depth/2 + rounding, depth/2 - rounding]) {\n\t\t\ttranslate([x,y])\n\t\t\tcylinder(r=rounding, h=height);\n\t\t}\n\t\ttranslate([0,0,height/2 + base]) {\n\t\t\tfor (x=[0:1:columns-1])\n\t\t\tfor (y=[0:1:rows-1]) {\n\t\t\t\ttranslate([xstart + (quadSize + spacing)*x,\n\t\t\t\t\t\t\t ystart + (quadSize + spacing)*y,0]) {\n\t\t\t\t\tbatteryQuad(diameter, height);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmakeTray(_diameter, _height, _rows, _columns, _spacing, _base, _cornerRounding, $fn=90);",
    "description": "Okay, I'd like to design a parametric battery tray using OpenSCAD. I need it to be customizable for different battery sizes and layouts.\n\nHere's what I'm looking for:\n\n**Core Functionality:**\n\n*   **Battery Diameter:** The tray should accommodate various battery diameters (like AA, AAA, 123A, and CR2). I need a parameter to set this.\n*   **Tray Height:** I need to control the overall height of the tray.\n*   **Battery Clusters:** The batteries are arranged in clusters of four. I need parameters to specify the number of these clusters across the width and depth of the tray.\n*   **Spacing:** I need to control the spacing between these clusters. This spacing should also apply to the edges of the tray.\n*   **Base Thickness:**  I need to specify the thickness of the base under the batteries.\n*   **Corner Rounding:** I'd like rounded corners for the entire tray. I need a parameter to control the corner radius.\n*   **Battery Cell Shape:** I need a cutout for each battery that supports the circular cross-section. Additionally I'd like a square cut out from each cell's side to prevent the cells from sticking, such that the resulting cutouts are a rounded square.\n\n**Specific Requirements:**\n\n*   The design should use a module (`batteryQuad`) to create a cluster of four battery cutouts and use a second module (`makeTray`) to arrange the battery clusters in the overall tray, to keep the design modular and readable.\n*   The cutouts in the base for the batteries should have rounded edges, as is achieved in the provided code using the difference function.\n*   The corner rounding should prevent the corner radius from exceeding the amount that makes sense with respect to the battery diameter and spacing.\n*   I would also like all of the battery cutouts to be oriented such that the square cutout parts of the rounded square are all pointed the same way.\n*   The tray should be a single solid piece.\n\n**OpenSCAD Libraries:**\n\nI'm not using any external libraries here, but if you think it makes sense to use one, I'm open to suggestions.\n\n**Output:**\n\nI'm expecting a single `.scad` file with all of the required code and parameters.\n\nI've included a previous design below as reference. Please use the concepts included in this design for my new design, and improve on them.\n```\n// battery diameter (AA-14.5, AAA-10.6 123A-16.8 CR2-15.5)\n_diameter = 14.5;\n\n// height of the tray\n_height = 8; // [1:80]\n\n// number of battery clusters across\n_columns = 2; // [1:12]\n\n// number of battery clusters deep\n_rows = 1; // [1:12]\n\n// padding between the clusters of batteries (also affects padding along the edges)\n_spacing = 1.2;\n\n// thickness of the base under the batteries\n_base = 0.5;\n\n// radius of corner rounding\n_cornerRounding = 4.0;\n\n\nmodule batteryQuad(diameter, height) {\n\tangle = 35;\n\tr = diameter/2;\n\tcut = 2*r*sin(angle);\n\ttan = tan(angle);\n\tfilletCenter = r - r * tan;\n\tfilletCenter2 = r + r * tan;\n\tfilletOffset = r * tan;\n\tfilletRadius = r/cos(angle) - r;\n\n\teps = 0.1;\n\n\tdifference() {\n\t\tunion() {\n\t\t\tfor (x=[-r,r]) {\n\t\t\t\tfor (y=[-r,r]) {\n\t\t\t\t\ttranslate([x,y,0]) {\n\t\t\t\t\t\tcylinder(r=r, h=height, center=true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (t=[ [ r, 0, 0],\n\t\t\t\t\t[-r, 0, 0],\n\t\t\t\t\t[ 0, r, 0],\n\t\t\t\t\t[ 0,-r, 0] ]) {\n\t\t\t\ttranslate(t) {\n\t\t\t\t\tcube(size=[cut,cut,height], center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// round\n\t\tfor (z=[0:90:270]) {\n\t\t\trotate([0,0,z]) {\n\t\t\t\tfor(y=[filletOffset, -filletOffset]) {\n\t\t\t\t\ttranslate([0, r+y,0]) {\n\t\t\t\t\t\tcylinder(r=filletRadius, h=height+eps, center=true, $fn=30);\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule makeTray(diameter, height, rows, columns, spacing, base, rounding) {\n\teps = 0.1;\n\trounding = min(rounding, diameter/2 + spacing*2);\n\tquadSize = 2 * diameter;\n\twidth = (quadSize + spacing) * columns + spacing*2;\n\tdepth = (quadSize + spacing) * rows + spacing*2;\n\txstart = -width/2 + spacing*1.5 + quadSize/2;\n\tystart = -depth/2 + spacing*1.5 + quadSize/2;\n\n\tdifference() {\n\t\thull()\n\t\tfor (x=[-width/2 + rounding, width/2 - rounding])\n\t\tfor (y=[-depth/2 + rounding, depth/2 - rounding]) {\n\t\t\ttranslate([x,y])\n\t\t\tcylinder(r=rounding, h=height);\n\t\t}\n\t\ttranslate([0,0,height/2 + base]) {\n\t\t\tfor (x=[0:1:columns-1])\n\t\t\tfor (y=[0:1:rows-1]) {\n\t\t\t\ttranslate([xstart + (quadSize + spacing)*x,\n\t\t\t\t\t\t\t ystart + (quadSize + spacing)*y,0]) {\n\t\t\t\t\tbatteryQuad(diameter, height);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nmakeTray(_diameter, _height, _rows, _columns, _spacing, _base, _cornerRounding, $fn=90);\n```\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric glass bed holder",
    "scad": "triangle_width = 20;\ntriangle_height = 5;\ntri_offset_height = 2.5;\ntri_offset_width = 17;\ncircle_radius = 5;\nscrew_hole_width = 2;\nscrewhead_diameter = 6.2;\nscrewhead_height = 3;\ntri_offset_x = (triangle_width - tri_offset_width);\ntri_offset_y = (triangle_width - tri_offset_width);\nrender (convexity = 1) {\n   create_part();\n}\nmodule create_part() {\ndifference() {\n  union() {\n\tcylinder(h = triangle_height, r = circle_radius, center = false);\n  \tpolyhedron(\n\t\tpoints = [\n\t\t\t[0, 0, 0], [0, 0, triangle_height],\n\t\t\t[0, - triangle_width, 0], [0, - triangle_width, triangle_height],\n\t\t\t[- triangle_width, 0, 0], [- triangle_width, 0, triangle_height],\n\t\t\t],\n\t\ttriangles = [\n\t\t\t[1,0,2], [1,2,3],\n\t\t\t[0,1,4], [1,5,4],\n\t\t\t[0,4,2], [1,3,5],\n\t\t\t[4,5,3], [3,2,4]\n\t\t]\n\t);\n  }\n  translate(v=[0, 0, triangle_height-screwhead_height]) {\n\tcylinder(h = screwhead_height, r = screwhead_diameter/2, center = false);\n  }\n  polyhedron(\n\tpoints = [\n\t\t[ - tri_offset_x, - tri_offset_y, -.01], [- tri_offset_x, -tri_offset_y , tri_offset_height],\n\t\t[- tri_offset_x, - triangle_width + tri_offset_y - .01, -.01], [- tri_offset_x, - triangle_width - tri_offset_y + .01, tri_offset_height],\n\t\t[- triangle_width + tri_offset_x - .01, -tri_offset_y, -.01], [- triangle_width + tri_offset_x - .01, - tri_offset_y, tri_offset_height],\n\t\t],\n\ttriangles = [\n\t\t[1,0,2], [1,2,3],\n\t\t[0,1,4], [1,5,4],\n\t\t[0,4,2], [1,3,5],\n\t\t[4,5,3], [3,2,4]\n\t]\n  );\n  translate(v = [0, 0, -0.01]) {\n  \tcylinder(h = triangle_height + 0.02, r = screw_hole_width, center = false);\n  }\n}\n}",
    "description": "Okay, I'm looking to get some help creating a parametric model in OpenSCAD. I'm designing a small part to hold the edge of a piece of custom-cut glass onto my 3D printer's heated bed, which is a Helios. The current design is a bit rough and I'd like it to be more flexible and adjustable.\n\nHere's what the part needs to do:\n\n*   **Base Shape:** The main structure will be a triangle with rounded edges where it will touch the bed. The corners of the triangle will form the edges of the part.\n*   **Glass Holding Feature:** The edges of the triangle will have a recessed inner triangle that will hold the glass. The depth of the triangle offset should be adjustable to fit different thickness of glass.\n*   **Mounting:** The part will attach to the printer bed using a single countersunk screw. There should be a cylindrical hole for the screw to pass through, and a larger recess for the screw head.\n*   **Parametric Design:** I need to be able to adjust several dimensions:\n    *   The width of the outer triangle edges.\n    *   The height/thickness of the main part.\n    *   The height/depth of the inner recessed triangle.\n    *   The width of the inner recessed triangles edges.\n    *   The radius of the rounded edges where it contacts the bed.\n    *   The diameter of the screw hole and screwhead recess.\n    *   The height/depth of the screwhead recess.\n\nI'm also using OpenSCAD's built in `hull()` function, and this design will be 3D printed so I also would like to be able to control the number of segments that are generated to create the rounded edges.\n\nI would like this to be written in OpenSCAD, and I'd like it to be parametric, meaning that all of those values above are defined as variables at the start of the file. I would also like to have comments so that it is clear what is going on, and well organized.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Hack a Day Skull and Wrenches Logo",
    "scad": "LogoScaleX=1;\nLogoScaleY=1;\nExtrudeHeight = 5;\nLogoColor = \"green\";\nfudge = 0.1;\nmodule poly_HackADayLogo(h)\n{\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[-34.245637,-29.433885],[-26.261107,-37.418335],[-35.596937,-46.002585],[-40.128276,-50.474831],[-43.199657,-54.332354],[-45.103423,-58.018425],[-46.131917,-61.976315],[-47.021502,-65.557463],[-48.459276,-68.908636],[-50.389209,-71.974442],[-52.755268,-74.699486],[-55.501423,-77.028375],[-58.571640,-78.905716],[-61.909889,-80.276114],[-65.460137,-81.084175],[-72.912299,-82.125795],[-65.730667,-75.243785],[-58.549047,-68.361755],[-65.524687,-60.468455],[-74.007293,-50.896895],[-75.057492,-50.624528],[-76.793965,-51.150160],[-78.993311,-52.374462],[-81.432125,-54.198105],[-86.046363,-57.714861],[-88.830039,-59.177585],[-89.712158,-58.740916],[-89.997226,-57.544865],[-89.751947,-55.760365],[-89.043023,-53.558351],[-86.501051,-48.585515],[-84.801409,-46.156559],[-82.904932,-43.993825],[-79.831674,-41.280832],[-76.863311,-39.565664],[-73.556015,-38.663194],[-69.465957,-38.388295],[-65.086361,-38.049234],[-61.305237,-36.807219],[-57.278391,-34.251652],[-52.161627,-29.971935],[-42.479837,-21.521895],[-34.245637,-29.433885]]);\n    linear_extrude(height=h)\n      polygon([[50.325821,-28.828675],[55.957113,-33.450676],[60.299203,-36.279533],[64.076488,-37.693810],[68.013361,-38.072075],[71.378186,-38.342122],[74.631190,-39.145109],[77.712163,-40.437796],[80.560892,-42.176943],[83.117167,-44.319306],[85.320776,-46.821647],[87.111507,-49.640724],[88.429151,-52.733295],[89.765511,-57.687719],[89.997226,-59.369685],[89.874721,-60.195035],[89.026068,-60.037145],[87.280642,-59.041989],[82.117611,-55.195985],[75.125141,-49.432265],[66.806471,-58.549335],[58.487771,-67.666425],[65.415061,-74.986215],[72.342351,-82.306025],[64.890181,-81.174295],[61.334333,-80.325112],[57.992543,-78.921395],[54.920558,-77.018562],[52.174127,-74.672031],[49.808996,-71.937220],[47.880913,-68.869547],[46.445626,-65.524429],[45.558881,-61.957285],[44.506993,-57.928705],[42.517242,-54.172484],[39.223453,-50.149486],[34.259451,-45.320575],[24.162271,-36.092395],[31.274481,-28.005385],[39.007281,-19.740695],[42.588068,-22.337006],[50.325821,-28.828675]]);\n    difference()\n    {\n       linear_extrude(height=h)\n         polygon([[-9.717087,47.988025],[-9.568745,46.875196],[-9.180220,46.013970],[-8.636261,45.433837],[-8.021618,45.164287],[-7.421043,45.234811],[-6.919284,45.674898],[-6.601092,46.514040],[-6.551217,47.781725],[-6.549053,50.195964],[-5.804445,53.108137],[-4.939182,54.463703],[-3.630858,55.599055],[-1.793655,56.399295],[0.658243,56.749525],[3.082099,56.585008],[4.847189,55.985106],[6.057338,55.050958],[6.816372,53.883700],[7.396395,51.254406],[7.417863,48.906325],[7.577543,47.327482],[7.968219,46.278839],[8.512131,45.723586],[9.131519,45.624912],[9.748625,45.946010],[10.285689,46.650067],[10.664950,47.700276],[10.808651,49.059825],[11.361433,51.938053],[12.037702,53.206860],[12.967483,54.318975],[14.140970,55.242034],[15.548357,55.943672],[17.179839,56.391524],[19.025611,56.553225],[20.742303,56.361605],[22.033485,55.808250],[22.959758,54.949045],[23.581723,53.839875],[24.155138,51.095175],[24.238541,48.021225],[24.596453,45.244995],[25.609800,42.234962],[27.188000,39.202336],[29.240471,36.358325],[31.779553,33.120117],[33.910820,29.886715],[35.655621,26.596251],[37.035308,23.186857],[38.071232,19.596668],[38.784743,15.763816],[39.197192,11.626434],[39.329931,7.122655],[38.977710,1.138705],[37.953338,-4.523229],[36.305249,-9.831098],[34.081878,-14.752852],[31.331661,-19.256440],[28.103032,-23.309814],[24.444427,-26.880922],[20.404281,-29.937716],[16.031027,-32.448146],[11.373103,-34.380161],[6.478941,-35.701711],[1.396979,-36.380748],[-3.824351,-36.385220],[-9.136611,-35.683079],[-14.491369,-34.242274],[-19.840187,-32.030755],[-24.521238,-29.338392],[-28.700709,-26.125628],[-32.369959,-22.454467],[-35.520345,-18.386913],[-38.143227,-13.984971],[-40.229963,-9.310644],[-41.771910,-4.425937],[-42.760428,0.607146],[-43.186876,5.726601],[-43.042610,10.870422],[-42.318991,15.976607],[-41.007376,20.983150],[-39.099123,25.828048],[-36.585592,30.449296],[-33.458141,34.784890],[-29.708127,38.772825],[-27.805685,40.864942],[-26.247753,43.180587],[-25.195098,45.438127],[-24.808487,47.355925],[-24.396732,51.880802],[-23.908060,53.481506],[-23.182963,54.699362],[-22.185522,55.578102],[-20.879814,56.161455],[-17.199917,56.616925],[-15.226510,56.420608],[-13.715190,55.815042],[-12.583206,54.878809],[-11.747808,53.690487],[-10.635774,50.871902],[-9.717087,47.987925]]);\n       translate([0, 0, -fudge])\n         linear_extrude(height=h+2*fudge)\n           polygon([[21.031031,19.393105],[20.012468,18.196454],[18.354321,16.819486],[14.037211,14.205495],[11.240257,12.703217],[9.032853,11.174221],[7.413837,9.615983],[6.382051,8.025982],[5.936335,6.401696],[6.075530,4.740603],[6.798476,3.040180],[8.104013,1.297905],[10.235055,-0.551777],[12.680187,-1.822225],[15.330971,-2.519401],[18.078975,-2.649269],[20.815762,-2.217791],[23.432897,-1.230930],[25.821945,0.305349],[27.874471,2.385085],[30.551567,6.499975],[31.274293,8.372375],[31.590402,10.183461],[31.502843,11.979771],[31.014564,13.807841],[28.847641,17.745415],[26.510311,20.541054],[25.464749,21.337188],[24.486692,21.735269],[23.565215,21.737598],[22.689395,21.346480],[21.031031,19.393105]]);\n       translate([0, 0, -fudge])\n         linear_extrude(height=h+2*fudge)\n           polygon([[-31.304007,17.745415],[-33.470932,13.807841],[-33.959212,11.979771],[-34.046772,10.183461],[-33.730664,8.372375],[-33.007938,6.499975],[-30.330837,2.385085],[-28.278317,0.305349],[-25.889273,-1.230930],[-23.272139,-2.217791],[-20.535352,-2.649269],[-17.787347,-2.519401],[-15.136559,-1.822225],[-12.691424,-0.551777],[-10.560377,1.297905],[-9.254841,3.040180],[-8.531896,4.740603],[-8.392703,6.401696],[-8.838420,8.025982],[-9.870206,9.615983],[-11.489222,11.174221],[-13.696626,12.703217],[-16.493577,14.205495],[-20.810687,16.819486],[-22.468835,18.196454],[-23.487397,19.393105],[-25.145761,21.346480],[-26.021581,21.737598],[-26.943058,21.735269],[-27.921116,21.337188],[-28.966677,20.541054],[-31.304007,17.745415]]);\n       translate([0, 0, -fudge])\n         linear_extrude(height=h+2*fudge)\n           polygon([[-5.944247,34.322425],[-5.314545,30.174909],[-3.761738,26.136832],[-1.790276,23.205737],[-0.805189,22.467040],[0.095393,22.379165],[1.090800,23.096398],[2.060227,24.462153],[3.691414,28.380556],[4.529500,32.617029],[4.507551,34.380371],[4.115033,35.654225],[3.543999,36.157431],[2.815473,36.179775],[2.013477,35.743944],[1.222033,34.872625],[0.308298,33.743859],[-0.397633,33.338225],[-0.981489,33.649441],[-1.528997,34.671225],[-2.771148,36.446003],[-3.501289,36.856548],[-4.227527,36.955250],[-4.892402,36.746649],[-5.438454,36.235284],[-5.808222,35.425696],[-5.944247,34.322425]]);\n    }\n    linear_extrude(height=h)\n      polygon([[65.055381,76.172225],[58.083021,70.041325],[65.831051,61.080925],[71.922358,54.752650],[74.257270,52.827559],[75.687151,52.120525],[76.921587,52.519003],[78.724361,53.603975],[83.066391,57.170625],[87.027424,60.346466],[88.392209,60.919262],[89.324085,60.828550],[89.806235,60.084260],[89.821846,58.696322],[89.354099,56.674667],[88.386181,54.029225],[86.759258,50.763643],[84.741099,47.823558],[82.379442,45.242847],[79.722025,43.055387],[76.816583,41.295058],[73.710855,39.995736],[70.452579,39.191299],[67.089491,38.915625],[62.860811,38.631619],[59.373298,37.568775],[55.948264,35.410856],[51.907021,31.841625],[48.826105,29.110067],[46.325870,27.331666],[44.562890,26.598662],[44.006801,26.653009],[43.693741,27.003295],[41.527923,30.768887],[37.477611,36.682825],[32.085311,44.126625],[38.537251,50.380025],[41.042421,53.054408],[43.093940,55.713387],[44.480101,58.049361],[44.989201,59.754725],[45.454185,64.091820],[46.775724,68.225312],[48.843694,72.039943],[51.547976,75.420450],[54.778446,78.251573],[58.424983,80.418050],[62.377465,81.804621],[66.525771,82.296025],[72.027731,82.306025],[65.055381,76.175125]]);\n    linear_extrude(height=h)\n      polygon([[-56.815957,79.441525],[-54.591631,78.033304],[-52.499413,76.214536],[-50.589995,74.067078],[-48.914070,71.672787],[-47.522330,69.113520],[-46.465468,66.471133],[-45.794176,63.827482],[-45.559147,61.264425],[-45.091945,59.132845],[-43.819857,56.469562],[-41.937165,53.614411],[-39.638147,50.907225],[-33.717137,44.798425],[-38.223337,39.280125],[-42.039476,34.338837],[-44.886637,30.207925],[-46.231599,28.370215],[-46.889618,27.999901],[-47.649343,28.026116],[-49.807962,29.360647],[-53.375547,32.558825],[-56.832517,35.395111],[-60.332556,37.379762],[-64.232673,38.670795],[-68.889877,39.426225],[-72.655448,40.039614],[-76.058572,41.052089],[-79.098563,42.463097],[-81.774733,44.272087],[-84.086395,46.478507],[-86.032861,49.081805],[-87.613443,52.081428],[-88.827454,55.476825],[-89.682935,59.659502],[-89.566044,60.786352],[-89.077811,61.272237],[-88.212044,61.118678],[-86.962553,60.327192],[-83.287631,56.836525],[-79.471072,53.505850],[-77.775000,52.492647],[-76.516633,52.120525],[-74.985704,52.827333],[-72.547486,54.751812],[-66.291267,61.078125],[-58.406397,70.035725],[-65.502047,76.169425],[-72.597681,82.303025],[-67.473647,82.303025],[-65.047435,82.077231],[-62.229278,81.462450],[-59.368884,80.552581],[-56.815957,79.441525]]);\n  }\n}\nscale([LogoScaleX, LogoScaleY , 1])\ncolor(LogoColor)\npoly_HackADayLogo(ExtrudeHeight);",
    "description": "Okay, I'm looking to get a parametric OpenSCAD file for the Hackaday logo. I saw someone made one years ago for the Makerbot Customizer, but that tool doesn't really exist anymore, and I'd like something a bit more flexible for my own projects.\n\nThe original design was based on tracing the logo in Inkscape and exporting it to OpenSCAD. It seems like it was scaled and extruded. I'd like to keep it mostly faithful to that look, but make it easy to customize.\n\nHere's what I need to be able to control:\n\n*   **Overall Size:** I'd like to be able to scale the logo along the X and Y axes independently. Let's call these `LogoScaleX` and `LogoScaleY`. This way, I can make it taller or wider as needed.\n\n*   **Extrusion Height:**  The height of the logo should be controllable via a variable called `ExtrudeHeight`. I expect to want this to be everything from a thin layer up to maybe 20mm or so.\n\n*   **Color:** It would be great to have a variable called `LogoColor` where I can specify the color of the logo when previewing. I'm familiar with web color names.\n\n*   **Fudge Factor:** There was a variable in the original code called `fudge`. It was used to ensure that subtracted solids are a bit taller, making sure the resulting STL is manifold. It looks like a default of 0.1 should work. We can keep that, and the associated operation if it's needed, but it should still be a parameter called `fudge`.\n\nThe original OpenSCAD code I'm using as a starting point defined a module `poly_HackADayLogo`. It had all the polygon points for the logo and the cutouts within it. I'd like to keep the core logic of the logo's shape in a similar module, if possible, to keep the code reasonably organized. I don't need to worry about the inkscape paths.\n\nI'm not using any special libraries, so this should be fairly straightforward.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable stick bowl art",
    "scad": "add_bottom = \"yes\";\nbottom_height = 2;\nbase_form = \"beam\";\nsize = 4;\nscale_second_dir = 1;\nr0 = 30;\nnrsticks = 10;\ngrad_per_stick = 360 / nrsticks;\nfirst_radius = 50;\nfirst_height = 40;\nfirst_extend = 1;\nfirst_skew = 9;\nsecond_radius = 30;\nsecond_height = 1;\nsecond_extend = 1;\nsecond_skew = 9;\nthird_radius = 50;\nthird_height = 40;\nthird_extend = 1;\nthird_skew = 9;\nfourth_radius = 30;\nfourth_height = 1;\nfourth_extend = 1;\nfourth_skew = 9;\nfifth_radius = 0;\nfifth_height = 20;\nfifth_extend = 2;\nfifth_skew = -27;\nsixth_radius = 0;\nsixth_height = 40;\nsixth_extend = 5;\nsixth_skew = 90;\nmax_height = 150;\nmax_width = 145;\nuse <MCAD/regular_shapes.scad>;\nuse <utils/build_plate.scad>;\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nbottomstart = -bottom_height;\nmodule baseform(length){\n  scale([1,scale_second_dir,1]){\n  if (base_form == \"beam\") {\n    translate([-size/2, -size/2, 0]) cube(size=[size, size, length]);\n  }\n  if (base_form == \"cylinder\") {\n    cylinder(r=size, h=length, $fn=20);\n  }\n  if (base_form == \"hexagon\") {\n    linear_extrude(height=length) hexagon(size);\n  }\n  if (base_form == \"triangle\") {\n    linear_extrude(height=length) triangle(size);\n  }\n  }\n}\nmodule ringbaseform(r1, h1, skew1, r2, h2, skew2, extend){\n  rotate([0,0,skew1])\n  translate([r1, 0, h1])\n  help_ringbaseform(r2*cos(-skew2)-r1, r2*sin(-skew2), h2-h1, extend);\n}\nmodule help_ringbaseform(a, b, c, extend)\n{\n  rotate([atan2(b/sqrt(pow(a, 2) + pow(b, 2) + pow(c, 2)),\n                c/sqrt(pow(a, 2) + pow(b, 2) + pow(c, 2))), 0, 0])\n  rotate([0, atan2(a/sqrt(pow(a, 2) + pow(b, 2) + pow(c, 2)),\n     sqrt(b*b/(pow(a, 2) + pow(b, 2) + pow(c, 2))\n          +c*c/(pow(a, 2) + pow(b, 2) + pow(c, 2)))), 0])\n  translate([0,0,-extend])\n  baseform(sqrt(pow(a, 2) + pow(b, 2)\n                    + pow(c, 2)) + 2*extend);\n}\nmodule ring(ringnr){\n  union() {\n    for (i = [0:nrsticks]) {\n      rotate([0,0,i*grad_per_stick]) {\n        if (ringnr == 1) {\n          ringbaseform(r0, 0, 0, first_radius, first_height,\n                       first_skew,  first_extend);}\n        if (ringnr == 2){\n          ringbaseform(first_radius, first_height, first_skew,\n                       second_radius, second_height, second_skew,\n\t\t\t\t\t\t\t  second_extend);}\n        if (ringnr == 3)\n          ringbaseform(second_radius, second_height,\n                       first_skew + second_skew,\n                       third_radius, third_height, third_skew,\n\t\t\t\t\t\t\t  third_extend);\n        if (ringnr == 4)\n          ringbaseform(third_radius, third_height,\n\t\t\t\t\t\t\t  first_skew + second_skew + third_skew,\n                       fourth_radius, fourth_height, fourth_skew,\n\t\t\t\t\t\t\t  fourth_extend);\n        if (ringnr == 5)\n          ringbaseform(fourth_radius, fourth_height,\n  first_skew + second_skew + third_skew + fourth_skew,\n                       fifth_radius, fifth_height, fifth_skew,\n\t\t\t\t\t\t\t  fifth_extend);\n        if (ringnr == 6)\n          ringbaseform(fifth_radius, fifth_height,\n  first_skew + second_skew + third_skew + fourth_skew + fifth_skew,\n                       sixth_radius, sixth_height, sixth_skew,\n\t\t\t\t\t\t\t  sixth_extend);\n      }\n    }\n  }\n}\nmodule bottom(){\n  if (add_bottom == \"yes\") {\n    translate([0,0,bottomstart])\n      cylinder(r = r0+size, h=bottom_height);\n  }\n}\nmodule bowl(){\nunion() {\n  bottom();\n  ring(1);\n  if (second_radius > 0) {\n  ring(2);}\n  if (third_radius > 0) {\n  ring(3);}\n  if (fourth_radius > 0) {\n  ring(4);}\n  if (fifth_radius > 0) {\n  ring(5);}\n  if (sixth_radius > 0) {\n  ring(6);}\n}\n}\nintersection(){\n  translate([0,0,-bottomstart]) bowl();\n  translate([-max_width/2,-max_width/2,0])\n    cube(size=[max_width,max_width,max_height]);\n}",
    "description": "Okay, I'm looking to design something similar to the \"Stick Bowl\" but with more explicit control over the shapes and a few more advanced options. I'd like an OpenSCAD file that allows me to create a structure composed of multiple rings of sticks, with the ability to customize the shape of the sticks, their arrangement, and how the rings connect to each other.\n\nHere's a breakdown of what I want:\n\n**Overall Structure:**\n\n*   **Multiple Rings:** The design should be built from a series of concentric rings of sticks, where each ring can be independently configured. There needs to be a way to define how many rings I want.\n*   **Base/Bottom:** I want the option to add a solid base (like a bottom to a bowl), and I'd like to control the size of this bottom piece, its height, and its starting height. This base should be a simple cylinder.\n*   **Bounding Box:** The design must also respect a maximum height and a maximum width, so the design can be cropped on the X/Y/Z axis.\n*   **Stick Shape Options:** I want to be able to choose the cross-sectional shape of each stick from at least the following:\n    *   Rectangle (beam)\n    *   Circle (cylinder)\n    *   Hexagon\n    *   Triangle\n*  **Stick Scaling:** I need to be able to scale the sticks in their 'width' or 'thickness' direction (the second of three possible dimensions when using the given shapes).\n\n**Ring Customization:**\n\nFor each ring, I need to control the following:\n\n*   **Radius:** The radius of the circle where the sticks of that ring are positioned.\n*   **Height:** The vertical height at which the ring is located.\n*  **Skew (Rotation):** The degree to which the ring is rotated around the Z-axis, so that subsequent rings are offset from one another.\n*   **Extension:** How far the sticks should extend past the defined radius (basically a \"length\" that is added to each stick as it comes off of each radius point).\n*   **Stick Count:** The number of sticks within a ring.  This could either be a global control, or per-ring. If global, I need an additional parameter for degrees between each stick so that I could optionally make some rings denser than others.\n* **Ring Connection:** The sticks in each ring must connect to both the previous ring, and optionally the next ring. I need to be able to specify the radii, heights, skews, and extensions for the ring before and the ring after each stick.\n\n**Parametric Design:**\n\n*   The entire design needs to be parametric, with all of the above values controllable via variables at the top of the SCAD file.\n*   I need to be able to add or remove rings and modify their properties in a simple way. I'd prefer not to have to change the code too much if I want to add a ring or two.\n\n**Libraries:**\n\nI'm already familiar with the `MCAD/regular_shapes.scad` library, so please use that to help generate the shapes I need. Also, I want to use the `utils/build_plate.scad` library to visualize this object in the context of a build plate, as well as allow me to configure the build plate size.\n\nIn summary, I want a highly customizable stick structure, with rings of varying heights, radii, rotations, and stick shapes, and with an ability to place a bottom, and a limit of maximum height and width. This should be parametric and easy to modify by editing variables at the top of the file. Please make sure the sticks can connect previous and next rings to form a complete structure.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Perpetual Motion Wheel",
    "scad": "$fn = 50;\nmode = \"preview\";\nnum_of_holes = 8;\nwheel_size = 50;\nwheel_thickness = 10;\nfizz = 0.1;\nfizzz = fizz*2;\nrot = 360/num_of_holes;\ndikte = wheel_size/10;\nstart();\nmodule start(){\n\tif (mode == \"print\"){\n\t\t color(\"green\") wheel();\n\t\ttranslate([-wheel_size*1.8,-wheel_size*.5,dikte]) rotate(-90,[1,0,0]) color(\"blue\") stand();\n\t\ttranslate([-wheel_size*1.8,wheel_size*1.3,0]) color(\"red\") weights();\n\t} else {\n\t\ttranslate([0,-wheel_thickness/2,wheel_size + wheel_size/10]) rotate(90,[1,0,0]) color(\"green\") wheel();\n\t\tcolor(\"blue\")  stand();\n\t}\n}\nmodule weights(){\n\tfor (nr=[1:num_of_holes]){\n\t\ttranslate([dikte*2.5*nr,0,0]) weight();\n\t}\n}\nmodule weight(){\n\tcylinder(wheel_thickness/2-fizzz,dikte,dikte);\n\ttranslate([0,0,wheel_thickness/2]) cylinder(wheel_thickness+fizzz*2, dikte/2, dikte/2);\n\ttranslate([0,0,wheel_thickness/2+wheel_thickness]) cylinder(wheel_thickness/2-fizzz,dikte,dikte);\n}\nmodule stand(){\n\ttranslate([-dikte,0,0]) cube([dikte*2,dikte,wheel_size + wheel_size/10]);\n\ttranslate([0,dikte,wheel_size + wheel_size/10]) rotate(90,[1,0,0]) cylinder(wheel_thickness*2+dikte+fizz,wheel_size/10,wheel_size/10);\n\ttranslate([0,dikte,wheel_size + wheel_size/10]) rotate(90,[1,0,0]) cylinder(wheel_thickness/2+dikte+fizz,wheel_size/7,wheel_size/7);\n\ttrans_x = (wheel_size + wheel_size/10)/2;\n\ttranslate([-trans_x,0,0]) cube([wheel_size + wheel_size/10,dikte,dikte]);\n\ttranslate([-trans_x,-(wheel_thickness*2.5)+fizz,0]) cube([dikte,wheel_thickness*2.5,dikte]);\n\ttranslate([trans_x - dikte,-(wheel_thickness*2.5)+fizz,0]) cube([dikte,wheel_thickness*2.5,dikte]);\n}\nmodule wheel(){\n\tdifference(){\n\t\tcylinder(wheel_thickness, wheel_size, wheel_size);\n\t\tfor (nr=[1:num_of_holes]){\n\t\t\trotate(rot*nr,[0,0,1]) translate([0,wheel_size/1.75,0]) hole();\n\t\t}\n\t\ttranslate([0,0,-fizz]) cylinder(wheel_thickness+fizzz,wheel_size/9.3+fizz,wheel_size/9.3+fizz);\n\t}\n}\nmodule hole(){\n\tdifference(){\n\t\ttranslate([0,0,-fizz]) cylinder(wheel_thickness+fizzz, wheel_size/3, wheel_size/3);\n\t\ttranslate([0,-wheel_size/2,-fizzz]) cube([wheel_size,wheel_size,wheel_size]);\n\t}\n}",
    "description": "Okay, I'd like to design a customizable overbalanced wheel, kind of like those perpetual motion toy wheels, but I want to make it parametric and printable. I've already got a basic concept in mind, and I'll describe it, but I need your help to create the OpenSCAD code.\n\nThe wheel itself should be a cylinder with holes around the circumference. I need to be able to control:\n*   The overall **wheel size** (diameter).\n*   The **wheel thickness**.\n*   The **number of holes** around the wheel.\n*   The **size of the holes**. They should be circular initially and have a cutout so the wheel can have something to rest on when not being supported by the stand.\n*   The center **hole diameter** of the wheel.\n\nI'd like to have the option to print the wheel separately, so I need the code to be able to toggle between two modes: a \"preview\" mode, which shows the wheel assembled, and a \"print\" mode, which shows the wheel, a stand, and the weights as separate parts.\n\nThe stand will be composed of:\n*   A vertical support, a rectangular prism that is attached to the wheel.\n*   A hanger that looks like a horizontal cylinder that connects to the vertical support to hold the wheel\n*   A cylinder that acts like a \"stop\" to make sure that the wheel only spins one direction.\n*   A horizontal base support, a rectangular prism that is attached to the bottom of the vertical support.\n*   Two small rectangular prism \"feet\" that extend downwards from the base of the support.\n\nThe stand should be sized appropriately to the wheel, but also be separately adjustable with at least one basic sizing parameter, and also use parameters derived from the wheel.\n\nThe weights will be added to the holes around the wheel and should be composed of 3 parts: two small cylinders at the ends and a larger one between them. They also need their thickness to be dependent on the wheel thickness. They should be printed separately and placed in the holes after printing the wheel.\n\nI'd like to be able to control the sizing of the weights independently of the wheel but dependent on the hole diameter, and be able to control the height of the cylinders to make sure they fit snugly.\n\nI think that's it for now. Could you generate the OpenSCAD code for this? I don't need anything from any particular libraries this time.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Printed Machine with Concrete",
    "scad": "use <MCAD/involute_gears.scad>\npart = \"Gear_A\";\nbearingOutsideDiameter = 35.0;\nbearingInsideDiameter = 15.0;\nbearingWidth = 11.0;\nshaftType = \"No\";\nmotorShaftLength = 50;\nmotorShaftDiamter = 8;\nmotorStandThickness = 10;\nmotorStandHeight = 150;\nmotorStandBoltSpacing = 56.3;\nmotorStandBoltSlotsWidth = 6;\nmotorStandBoltSlotStartHeight = 60;\nmotorStandSlotHeight = 80;\nmotorStandShaftWidth = 26;\nconcreteFormWidth = 170;\nconcreteFormLength = 150;\nconcreteFormHeight = 135;\nconcreteFormWallWidth = 3;\nfitBuffer = 0.1;\nmodule privateVars() {\n}\nnumberTeeth=50;\npitchRadius=40;\nwormLength=20;\nradius=10;\npitch=2*3.1415*pitchRadius/numberTeeth;\nangle=360*$t;\noffset=7.5;\naxleLength = 140.0;\ndistance=radius+pitchRadius+0.0*pitch;\nreductionFactor = 0.75;\nlower = -20.0;\nbushingWidth = 5.0;\nbearingsSpacingWidth = 55.0;\nshaftRadius = ((bearingInsideDiameter / 2));\nfudge = 0.1;\ninteration = 0;\nif (part == \"Gear_A\") {\n\tdrawGear1();\n} else if (part == \"Gear_B\") {\n\tdrawGear2();\n} else if (part == \"Worm_Gear\") {\n\tdrawWorm();\n} else if (part == \"Combined_Stand_1\") {\n\tdrawCombinedStand1();\n} else if (part == \"Combined_Stand_2\") {\n\tdrawCombinedStand2();\n} else if (part == \"Stand_A\") {\n\tdrawStandA();\n} else if (part == \"Stand_B\") {\n\tdrawStandB();\n} else if (part == \"Motor_Stand\") {\n\tdrawMotorStand();\n} else if (part == \"Motor_Worm\") {\n\tdrawMotorWorm();\n} else if (part == \"Bushing\") {\n\tdrawBushing();\n} else if (part == \"Concrete_Form\") {\n\tdrawConcreteForm();\n} else if (part == \"Assembly\") {\n\tdrawAssembly();\n}\nmodule worm() {\n\ttrapezoidThread(\n\t\tlength=wormLength,\n\t\tpitch=pitch,\n\t\tpitchRadius=radius,\n\t\tthreadHeightToPitch=0.5,\n\t\tprofileRatio=0.5,\n\t\tthreadAngle=pitchRadius,\n\t\tRH=true,\n\t\tclearance=0.1,\n\t\tbacklash=0.1,\n\t\tstepsPerTurn=24\n\t\t);\n}\nmodule wormGear() {\n\t  rotate([0,0,offset-angle/numberTeeth])\n\t\tgear (\n\t\t\tnumber_of_teeth=numberTeeth,\n\t\t\tcircular_pitch=360*pitchRadius/numberTeeth,\n\t\t\tpressure_angle=20,\n\t\t\tclearance = 0,\n\t\t\tgear_thickness=10,\n\t\t\trim_thickness=10,\n\t\t\trim_width=5,\n\t\t\thub_thickness=0,\n\t\t\thub_diameter=30,\n\t\t\tbore_diameter=0,\n\t\t\tcircles=6,\n\t\t\tbacklash=0.1,\n\t\t\ttwist=-2,\n\t\t\tinvolute_facets=0,\n\t\t\tflat=false);\n}\nmodule keyedWorm(mirrored) {\n\tcolor(\"blue\") {\n\t\trender() {\n\t\t\tunion() {\n\t\t\t\ttranslate([0,0,0]) {\n\t\t\t\t\tdifference() {\n\t\t\t\t\t\ttranslate([0,0,-wormLength/2 + 0])\n\t\t\t\t\t\trotate([0,0,180+angle])\n\t\t\t\t\t\t\tworm();\n\t\t\t\t\t\ttranslate([0,0,-(wormLength/2)-1]) {\n\t\t\t\t\t\t\tcylinder(h = wormLength+5, r=(shaftRadius*reductionFactor) + (fitBuffer * 4));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttranslate([0,bearingInsideDiameter/3,1.62]) {\n\t\t\t\t\tcube(size = [10,2.5+fitBuffer,wormLength+3.2], center = true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule wormKey(mirrored) {\n\trender();\n\tdifference() {\n\t\ttranslate([0,0,-(wormLength/2)+5]) {\n\t\t\tcolor(\"lightgreen\")\n\t\t\tcylinder(h = wormLength+5, r=(shaftRadius*reductionFactor) - (fitBuffer * 3.1));\n\t\t}\n\t\ttranslate([0,bearingInsideDiameter/3,0]) {\n\t\t\t\tcube(size = [10,2.5 + (fitBuffer * 3.1),wormLength+18], center = true);\n\t\t}\n\t}\n}\nmodule bushing(width) {\n   render() {\n      difference() {\n         cylinder(h = width, r=(bearingInsideDiameter/2) * 1.5, center = true );\n         cylinder(h = width + 1, r=(bearingInsideDiameter/2)+fitBuffer, center = true );\n      }\n   }\n}\nmodule solidBushing(width) {\n    cylinder(h = width, r=(bearingInsideDiameter/2) * 1.5, center = true );\n}\nmodule bearing() {\n   color(\"Silver\") {\n      cylinder(h = bearingWidth, r=(bearingOutsideDiameter/2)+fitBuffer );\n   }\n}\nmodule bearingStand(height, merge, sideCenter = 100.0, mountWidth = 40, mountLength = 110) {\n\tcylinderRadius = (bearingOutsideDiameter/2) + 4.0;\n\tfillet = 5;\n\tbasePlateThickness = 10;\n\ttranslate([0, (cylinderRadius + height/2) - fillet, 101.5]) {\n\t\trender();\n\t\tminkowski() {\n\t\t\tcube(size = [25-(fillet*2), height, bearingsSpacingWidth-(fillet*2)-2], center = true);\n\t\t\trotate([90,0,0]) {\n\t\t\t\tcylinder(r=fillet,h=1);\n\t\t\t}\n\t\t}\n\t}\n\ttranslate([1,(fillet/2),104]) {\n\t\trender();\n\t\tminkowski() {\n\t\t\tcylinder(h = bearingsSpacingWidth - (fillet*2), r=cylinderRadius, center = true);\n\t\t\ttranslate([-(fillet/2),-(fillet/2),-(fillet/2)]) {\n\t\t\t\tsphere(fillet, $fn=10);\n\t\t\t}\n\t\t}\n\t}\n\tif (! merge) {\n\t\ttranslate([0,(cylinderRadius + height + basePlateThickness/2) - fillet,sideCenter]) {\n\t\t\trender();\n\t\t\tminkowski() {\n\t\t\t\tcube(size = [mountWidth-(fillet*2),basePlateThickness,mountLength-(fillet*2)], center = true);\n\t\t\t\trotate([90,0,0]) {\n\t\t\t\t\tcylinder(r=fillet,h=1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule bearingStandFeet(height, sideCenter = 100.0, mountWidth = 40, mountLength = 110, height2, sideCenter2 = 100.0, mountWidth2 = 40, mountLength2 = 110) {\n\tcylinderRadius = (bearingOutsideDiameter/2) + 4.0;\n\tfillet = 5;\n\tbasePlateThickness = 10;\n\tminkowski() {\n\t\tunion() {\n\t\t\ttranslate([21.5,0,0]) {\n\t\t\t\ttranslate([0,(cylinderRadius + height + basePlateThickness/2) - fillet,sideCenter]) {\n\t\t\t\t\tcube(size = [mountWidth,basePlateThickness,mountLength], center = true);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([-37,-50,24]) {\n\t\t\t\trotate([0,90,0]) {\n\t\t\t\t\ttranslate([0,(cylinderRadius + height2 + basePlateThickness/2) - fillet,sideCenter2]) {\n\t\t\t\t\t\tcube(size = [mountWidth2,basePlateThickness,mountLength2], center = true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trotate([90,0,0]) {\n\t\t\tcylinder(r=fillet,h=1);\n\t\t}\n\t}\n}\nmodule shortStandHoles() {\n\tunion() {\n\t\ttranslate([20,0,73.9]) {\n\t\t\tbearing();\n\t\t}\n\t\ttranslate([20,0,73.9 + bearingsSpacingWidth - bearingWidth + 1]) {\n\t\t\tbearing();\n\t\t}\n\t\ttranslate([20,0,(axleLength - 80.1)]) {\n\t\t\tcylinder(h = axleLength - 30.1, r=shaftRadius+(fitBuffer * 6));\n\t\t}\n\t}\n}\nmodule tallStandHoles() {\n\ttranslate([-37,-50,24]) {\n\t\trotate([0,90,0]) {\n\t\t\tunion() {\n\t\t\t\ttranslate([0,0,74]) {\n\t\t\t\t\tbearing();\n\t\t\t\t}\n\t\t\t\ttranslate([0,0,73.0 + bearingsSpacingWidth - bearingWidth + 1]) {\n\t\t\t\t\tbearing();\n\t\t\t\t}\n\t\t\t\ttranslate([0,0,18.27]) {\n\t\t\t\t\tcylinder(h = axleLength -30.1, r=shaftRadius+(fitBuffer * 6));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule shortStand(merge) {\n\tcolor(\"Indigo\") {\n\t\ttranslate([21.5,0,0]) {\n\t\t\tbearingStand(32, merge, 104.5, 43, 123);\n\t\t}\n\t}\n}\nmodule tallStand(merge) {\n\tcolor(\"Purple\") {\n\t\ttranslate([-37,-50,24]) {\n\t\t\trotate([0,90,0]) {\n\t\t\t\tbearingStand(82, merge, 96, 38, 118);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule drawStands(merge, drawShortStand = false, drawTallStand = false) {\n\tfillet = 5;\n\tunion() {\n\t\tif (merge) {\n\t\t\tif ((drawShortStand) && (drawTallStand)) {\n\t\t\t\trender();\n\t\t\t\tdifference() {\n\t\t\t\t\trender();\n\t\t\t\t\tunion() {\n\t\t\t\t\t\tshortStand(merge);\n\t\t\t\t\t\ttallStand(merge);\n\t\t\t\t\t\tbearingStandFeet(32, 104.5, 43, 123, 82, 96, 38, 118);\n\t\t\t\t\t}\n\t\t\t\t\tunion() {\n\t\t\t\t\t\tshortStandHoles();\n\t\t\t\t\t\ttallStandHoles();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (drawShortStand) {\n\t\t\t\tcolor(\"Indigo\") {\n\t\t\t\t\trender();\n\t\t\t\t\tdifference() {\n\t\t\t\t\t\tshortStand(merge);\n\t\t\t\t\t\tshortStandHoles();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (drawTallStand) {\n\t\t\t\tcolor(\"Purple\") {\n\t\t\t\t\trender();\n\t\t\t\t\tdifference() {\n\t\t\t\t\t\ttallStand(merge);\n\t\t\t\t\t\ttallStandHoles();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule bracket(d, size_)\n{\n  size = -(size_/2);\n  union()\n  {\n    linear_extrude(height=d)\n      polygon([[size,-size],[size,size],[-size,size],[size,-size]]);\n  }\n}\nmodule motorStand(d, height_, slotSpacing_, slotWidth_, slotBaseHeight_, slotHeight_, footWidth, shaftWidth_, shaftHeight_)\n{\n\twidth_ = slotSpacing_ * 1.5;\n\tshaftHeight_ = (slotHeight_ * 0.75) + 5;\n\tscaleFactor = 3.54330708661417;\n\twidth = (width_ * scaleFactor) / 2;\n\tslotWidth = slotWidth_ * scaleFactor;\n\tslotSpacing = ((slotSpacing_ / 2) * scaleFactor) + slotWidth/2;\n\tslotBaseHeight = (slotBaseHeight_ * scaleFactor);\n\theight = (height_ / 2) * scaleFactor;\n\tslotHeight =  slotHeight_ * scaleFactor;\n\tshaftWidth = (shaftWidth_ / 2) * scaleFactor;\n\tshaftHeight =  height - ((shaftHeight_ ) * scaleFactor);\n\tbracketHeight = slotBaseHeight_ - 5;\n\tunion() {\n\t\tscale([25.4/90, -25.4/90, 1]) union()\n\t\t{\n\t\t\tdifference()\n\t\t\t{\n\t\t\t   linear_extrude(height=d)\n\t\t\t\t polygon([[width,height],[-width,height],[-width,-(height-17.71625)],[-(width - 0.359958),-(height-14.145999)],[-(width-1.392324),-(height-10.820566)],[-(width-3.025833),-(height-7.811218)],[-(width-5.163386),-(height-5.189219)],[-(width-7.811523),-(height-3.025833)],[-(width-10.820566),-(height-1.392324)],[-(width-14.145999),-(height-0.359958)],[-(width-15),-height],[-(width-16),-height],[-shaftWidth,-(height-0.359958)],[-(shaftWidth-3.325601),-(height-1.392324)],[-(shaftWidth-6.334971),-(height-3.025833)],[-(shaftWidth-8.95689),-(height-5.189219)],[-(shaftWidth-11.120137),-(height-7.811218)],[-(shaftWidth-12.753492),-(height-10.820566)],[-(shaftWidth-13.785733),-(height-14.145999)],[-(shaftWidth-14.14564),-(height-17.71625)],[-(shaftWidth-14.14564),-(shaftHeight+17.71625)],[-(shaftWidth-14.505601),-(shaftHeight+14.145999)],[-(shaftWidth-15.537984),-(shaftHeight+10.820566)],[-(shaftWidth-17.171538),-(shaftHeight+7.811218)],[-(shaftWidth-19.335015),-(shaftHeight+5.189219)],[-(shaftWidth-21.957163),-(shaftHeight+3.025833)],[-(shaftWidth-24.966734),-(shaftHeight+1.392324)],[-(shaftWidth-28.292476),-(shaftHeight+0.359958)],[-(shaftWidth-31.86314),-shaftHeight],[(shaftWidth-31.86314),-shaftHeight],[(shaftWidth-28.292889),-(shaftHeight+0.359958)],[(shaftWidth-24.967456),-(shaftHeight+1.392324)],[(shaftWidth-21.958108),-(shaftHeight+3.025833)],[(shaftWidth-19.336109),-(shaftHeight+5.189219)],[(shaftWidth-17.172723),-(shaftHeight+7.811218)],[(shaftWidth-15.539214),-(shaftHeight+10.820566)],[(shaftWidth-14.506848),-(shaftHeight+14.145999)],[(shaftWidth-14.14689),-(shaftHeight+17.71625)],[(shaftWidth-14.14689),-(height-17.71625)],[(shaftWidth-13.786983),-(height-14.145999)],[(shaftWidth-12.754742),-(height-10.820566)],[(shaftWidth-11.121387),-(height-7.811218)],[(shaftWidth-8.95814),-(height-5.189219)],[(shaftWidth-6.336221),-(height-3.025833)],[(shaftWidth-3.326851),-(height-1.392324)],[shaftWidth,-(height-0.359958)],[57.754375,-height],[(width-15),-height],[(width-14.145999),-(height-0.359958)],[(width-10.820566),-(height-1.392324)],[(width-7.811523),-(height-3.025833)],[(width-5.163386),-(height-5.189219)],[(width-3.025833),-(height-7.811218)],[(width-1.392324),-(height-10.820566)],[(width - 0.359958),-(height-14.145999)],[width,-(height-17.71625)],[width,height]]);\n\t\t\t   translate([0, 0, -fudge])\n\t\t\t\t linear_extrude(height=d+2*fudge)\n\t\t\t\t   polygon([[slotSpacing,(height-slotBaseHeight)-slotHeight],[(slotSpacing-slotWidth),(height-slotBaseHeight)-slotHeight],[(slotSpacing-slotWidth),(height-slotBaseHeight)],[slotSpacing,(height-slotBaseHeight)],[slotSpacing,(height-slotBaseHeight)-slotHeight]]);\n\t\t\t   translate([0, 0, -fudge])\n\t\t\t\t linear_extrude(height=d+2*fudge)\n\t\t\t\t   polygon([[-(slotSpacing-slotWidth),(height-slotBaseHeight)-slotHeight],[-slotSpacing,(height-slotBaseHeight)-slotHeight],[-slotSpacing,(height-slotBaseHeight)],[-(slotSpacing-slotWidth),(height-slotBaseHeight)],[-(slotSpacing-slotWidth),(height-slotBaseHeight)-slotHeight]]);\n\t\t\t}\n\t\t}\n\t\ttranslate([0, -(height_/2) + d/2, (d/2) + footWidth/2]) {\n\t\t\tcube(size = [width_,d,footWidth], center = true);\n\t\t}\n\t\ttranslate([d/2, -(height_/2) + d/2 + (bracketHeight/2), (d/2) + bracketHeight/2]) {\n\t\t\trotate([0,-90,0]) {\n\t\t\t\tbracket(d, bracketHeight);\n\t\t\t}\n\t\t}\n\t\ttranslate([width_/2, -(height_/2) + d/2 + (bracketHeight/2), (d/2) + bracketHeight/2]) {\n\t\t\trotate([0,-90,0]) {\n\t\t\t\tbracket(d, bracketHeight);\n\t\t\t}\n\t\t}\n\t\ttranslate([-((width_/2) - d), -(height_/2) + d/2 + (bracketHeight/2), (d/2) + bracketHeight/2]) {\n\t\t\trotate([0,-90,0]) {\n\t\t\t\tbracket(d, bracketHeight);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule set(interation, mirrored, doubleBearingMount = true, drawGear1 = false, drawGear2 = false, drawWorm1 = false, drawWorm2 = false, drawTallStand = false, drawShortStand = false, drawBearings = false, drawBushings = false, drawMotorStand = false, drawPlasterForm = false, combineStands = false) {\n\tif (interation != 0) {\n\t\tif (drawWorm1) {\n\t\t\ttranslate([0,0,5]) {\n\t\t\t\tkeyedWorm(mirrored);\n\t\t\t}\n\t\t}\n\t}\n\tif (drawBearings) {\n\t\ttranslate([0,0,52.4]) {\n\t\t\tbearing();\n\t\t}\n\t}\n\tif (drawBearings) {\n\t\ttranslate([0,0,52.0 + bearingsSpacingWidth - bearingWidth + 1]) {\n\t\t\tbearing();\n\t\t}\n\t}\n\tif (drawBushings) {\n\t\ttranslate([0,0,52.4 -(bushingWidth/2)])\n\t\t{\n\t\t\tbushing(bushingWidth);\n\t\t}\n\t}\n\tif (drawGear1) {\n\t\tcolor(\"green\") {\n\t\t\tunion() {\n\t\t\t\ttranslate([0,0,axleLength-20]) {\n\t\t\t\t\twormGear();\n\t\t\t\t}\n\t\t\t\ttranslate([0,0,(axleLength - 1.6) - 20]) {\n\t\t\t\t\tsolidBushing(20.5);\n\t\t\t\t}\n\t\t\t\ttranslate([0,0,18.27]) {\n\t\t\t\t\tif (shaftType == \"Yes\") {\n\t\t\t\t\t\tcylinder(h = axleLength -30.1, r=shaftRadius-(fitBuffer * 1.25),$fn=6);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcylinder(h = axleLength -30.1, r=shaftRadius-(fitBuffer * 1.25));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twormKey();\n\t\t\t}\n\t\t}\n\t}\n\tif (interation != 0) {\n\t\tif (drawGear2) {\n\t\t\tunion() {\n\t\t\t\tcolor(\"orange\") {\n\t\t\t\t\ttranslate([-5,-distance,7]) {\n\t\t\t\t\t\trotate([0,90,0]) {\n\t\t\t\t\t\t\twormGear();\n\t\t\t\t\t\t\tcolor(\"Purple\") {\n\t\t\t\t\t\t\t\ttranslate([0,0,-(0.2)]) {\n\t\t\t\t\t\t\t\t  solidBushing(20.3);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttranslate([0,0,-(axleLength - 30.1)]) {\n\t\t\t\t\t\t\t\tif (shaftType == \"Yes\") {\n\t\t\t\t\t\t\t\t\tcylinder(h = axleLength - 30.1, r=shaftRadius-(fitBuffer * 1.25),$fn=6);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tcylinder(h = axleLength - 30.1, r=shaftRadius-(fitBuffer * 1.25));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttranslate([0,0,-(axleLength - 16.3)]) {\n\t\t\t\t\t\t\t\trotate([0,0,180]) {\n\t\t\t\t\t\t\t\t\twormKey();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ttranslate([25.5,-distance,axleLength+5])\n\trotate([0,90,180+angle]) {\n\t\tcolor(\"blue\") {\n\t\t\tif (drawWorm2) {\n\t\t\t\ttranslate([20,0,16.8]) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcolor(\"Blue\") {\n\t\t\tif (drawWorm2) {\n\t\t\t\ttranslate([20,0,21.8]) {\n\t\t\t\t\tkeyedWorm(mirrored);\n\t\t\t}\n\t\t}\n\t\t}\n\t\tif (drawBearings) {\n\t\t\ttranslate([20,0,73.9]) {\n\t\t\t\tbearing();\n\t\t\t}\n\t\t}\n\t\tif (drawBearings) {\n\t\t\ttranslate([20,0,73.9 + bearingsSpacingWidth - bearingWidth + 1]) {\n\t\t\t\tbearing();\n\t\t\t}\n\t\t}\n\t\tif (drawBushings) {\n\t\t\ttranslate([20,0,73.9 -(bushingWidth/2)])\n\t\t\t{\n\t\t\t\tbushing(bushingWidth);\n\t\t\t}\n\t\t}\n\t\tif\t(doubleBearingMount) {\n\t\t\tdrawStands(combineStands, drawShortStand, drawTallStand);\n\t\t}\n\t\telse {\n\t\t\tdrawStands(combineStands, drawShortStand, drawTallStand);\n\t\t}\n\t}\n}\nmodule doubleSet(firstSet, mirrored) {\n\tif (firstSet) {\n\t   set(0, mirrored, drawGear1 = true, drawGear2 = true, drawWorm1 = true, drawWorm2 = true, drawTallStand = true, drawShortStand = true, drawBearings = true, drawBushings = true, drawMotorStand = true, drawPlasterForm = true);\n\t}\n\telse {\n\t   set(1, mirrored, drawGear1 = true, drawGear2 = true, drawWorm1 = true, drawWorm2 = true, drawTallStand = true, drawShortStand = true, drawBearings = true, drawBushings = true, drawMotorStand = true, drawPlasterForm = true);\n\t}\n\ttranslate([-120,0,118]) {\n\t\tmirror([1,0,0]) {\n\t\t\tset(1, mirrored, drawGear1 = true, drawGear2 = true, drawWorm1 = true, drawWorm2 = true, drawTallStand = true, drawShortStand = true, drawBearings = true, drawBushings = true, drawMotorStand = true, drawPlasterForm = true);\n\t\t}\n\t}\n}\nmodule drawGear1() {\n\trotate([0,180,0]) {\n\t\tset(1, mirrored, drawGear1 = true);\n\t}\n}\nmodule drawGear2() {\n\trotate([0,90,0]) {\n\t\tset(1, mirrored, drawGear2 = true);\n\t}\n}\nmodule drawWorm() {\n\trotate([0,180,0]) {\n\t\tset(1, mirrored, drawWorm1 = true);\n\t}\n}\nmodule drawBushing() {\n\tbushing(bushingWidth);\n}\nmodule drawCombinedStand1() {\n\trotate([90,0,0]) {\n\t\tset(1, false, drawTallStand = true, drawShortStand = true, combineStands = true);\n\t}\n}\nmodule drawCombinedStand2() {\n\trotate([90,0,0]) {\n\t\tmirror([0,0,1]) {\n\t\t\tset(1, false, drawTallStand = true, drawShortStand = true, combineStands = true);\n\t\t}\n\t}\n}\nmodule drawStandA() {\n\trotate([90,0,0]) {\n\t\tset(1, false, drawTallStand = true, combineStands = false);\n\t}\n}\nmodule drawStandB() {\n\trotate([90,0,0]) {\n\t\tset(1, false, drawShortStand = true, combineStands = false);\n\t}\n}\nmodule drawMotorStand() {\n\tcolor(\"Gray\") {\n\t\trotate([90,0,0]) {\n\t\t   motorStand(motorStandThickness, motorStandHeight, motorStandBoltSpacing, motorStandBoltSlotsWidth, motorStandBoltSlotStartHeight, motorStandSlotHeight, motorStandHeight/2, motorStandShaftWidth);\n\t\t}\n\t}\n}\nmodule drawMotorWorm() {\n\tdifference() {\n\t\tunion() {\n\t\t\tcylinder(h = motorShaftLength, r=shaftRadius);\n\t\t\tworm();\n\t\t}\n\t\ttranslate([0,0,(wormLength/2)]) {\n\t\t\tcylinder(h = motorShaftLength+(fudge * 2), r=(motorShaftDiamter/2)+(fitBuffer * 4));\n\t\t}\n\t}\n}\nmodule drawConcreteForm() {\n\tcolor(\"Darkgray\") {\n\t\tdifference() {\n\t\t\tcube(size = [concreteFormWidth, concreteFormLength, concreteFormHeight], center = true);\n\t\t\tcube(size = [concreteFormWidth-concreteFormWallWidth, concreteFormLength-concreteFormWallWidth, concreteFormHeight+(fudge*2)], center = true);\n\t\t}\n\t}\n}\nmodule drawMotor() {\n\tcolor(\"DarkSlateGray\") {\n\t\tcylinder(h = motorStandBoltSpacing*1.25, r=(motorStandBoltSpacing * 1.5) / 2, center = true);\n\t}\n\tcolor(\"Silver\") {\n\t\ttranslate([0,0,-20]) {\n\t\t\tcylinder(h = motorStandBoltSpacing*1.25, r=motorShaftDiamter / 2, center = true);\n\t\t}\n\t}\n}\nmodule drawAssembly() {\n\tsetLength = 118;\n\ttranslate([14,110,9]) {\n\t\tdrawConcreteForm();\n\t}\n\ttranslate([75,-(setLength * 4),15]) {\n\t\tdrawMotorStand();\n\t}\n\trotate([90,0,0]) {\n\t\ttranslate([75,50.25, ((setLength * 3) + 68)]) {\n\t\t\trotate([0,-90,0]) {\n\t\t\t\tdrawGear2();\n\t\t\t}\n\t\t}\n\t}\n\trotate([90,0,0]) {\n\t\ttranslate([75,50.25, ((setLength * 3) + 66)]) {\n\t\t\tdrawMotorWorm();\n\t\t\ttranslate([0,0,(motorStandBoltSpacing * 1.25)+27]) {\n\t\t\t\tdrawMotor();\n\t\t\t}\n\t\t}\n\t}\n\trotate([90,0,0]) {\n\t}\n\ttranslate([75,50,50]) {\n\t\trotate([90,0,0]) {\n\t\t\tdoubleSet(true, false);\n\t\t\ttranslate([0,0,setLength * 2]) {\n\t\t\t\tdoubleSet(false, true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule threadPiece(Xa, Ya, Za, Xb, Yb, Zb, radiusa, radiusb, tipRatioa, tipRatiob, threadAngleTop, threadAngleBottom)\n{\n\tangleZ=atan2(Ya, Xa);\n\ttwistZ=atan2(Yb, Xb)-atan2(Ya, Xa);\n\tpolyPoints=[\n\t\t[Xa+ radiusa*cos(+angleZ),\t\tYa+ radiusa*sin(+angleZ),\t\tZa ],\n\t\t[Xa+ radiusa*cos(+angleZ),\t\tYa+ radiusa*sin(+angleZ),\t\tZa + radiusa*tipRatioa ],\n\t\t[Xa ,\t\t\t\t\t\tYa ,\t\t\t\t\t\tZa+ radiusa*(tipRatioa+sin(threadAngleTop)) ],\n\t\t[Xa ,\t\t\t\t\t\tYa ,\t\t\t\t\t\tZa ],\n\t\t[Xa ,\t\t\t\t\t\tYa ,\t\t\t\t\t\tZa+ radiusa*sin(threadAngleBottom) ],\n\t\t[Xb+ radiusb*cos(angleZ+twistZ),\tYb+ radiusb*sin(angleZ+twistZ),\tZb ],\n\t\t[Xb+ radiusb*cos(angleZ+twistZ),\tYb+ radiusb*sin(angleZ+twistZ),\tZb+ radiusb*tipRatiob ],\n\t\t[Xb ,\t\t\t\t\t\tYb ,\t\t\t\t\t\tZb+ radiusb*(tipRatiob+sin(threadAngleTop)) ],\n\t\t[Xb ,\t\t\t\t\t\tYb ,\t\t\t\t\t\tZb ],\n\t\t[Xb ,\t\t\t\t\t\tYb ,\t\t\t\t\t\tZb+ radiusb*sin(threadAngleBottom)] ];\n\tpolyTriangles=[\n\t\t[ 0, 1, 6 ], [ 0, 6, 5 ],\n\t\t[ 1, 7, 6 ], [ 1, 2, 7 ],\n\t\t[ 0, 5, 4 ], [ 4, 5, 9 ],\n\t\t[ 4, 9, 3 ], [ 9, 8, 3 ], [ 3, 8, 2 ], [ 8, 7, 2 ],\n\t\t[ 0, 4, 3 ], [ 0, 3, 2 ], [ 0, 2, 1 ],\n\t\t[ 5, 8, 9 ], [ 5, 7, 8 ], [ 5, 6, 7 ]\n\t\t ];\n\tpolyhedron( polyPoints, polyTriangles );\n}\nmodule shaftPiece(Xa, Ya, Za, Xb, Yb, Zb, radiusa, radiusb, tipRatioa, tipRatiob, threadAngleTop, threadAngleBottom)\n{\n\tangleZ=atan2(Ya, Xa);\n\ttwistZ=atan2(Yb, Xb)-atan2(Ya, Xa);\n\tthreadAngleTop=15;\n\tthreadAngleBottom=-15;\n\tshaftRatio=0.5;\n\tpolyPoints1=[\n\t\t[Xa,\t\t\t\t\t\tYa,\t\t\t\t\t\tZa + radiusa*sin(threadAngleBottom) ],\n\t\t[Xa,\t\t\t\t\t\tYa,\t\t\t\t\t\tZa + radiusa*(tipRatioa+sin(threadAngleTop)) ],\n\t\t[Xa*shaftRatio,\t\t\t\tYa*shaftRatio ,\t\t\t\tZa + radiusa*(tipRatioa+sin(threadAngleTop)) ],\n\t\t[Xa*shaftRatio ,\t\t\t\tYa*shaftRatio ,\t\t\t\tZa ],\n\t\t[Xa*shaftRatio ,\t\t\t\tYa*shaftRatio ,\t\t\t\tZa + radiusa*sin(threadAngleBottom) ],\n\t\t[Xb,\t\t\t\t\t\tYb,\t\t\t\t\t\tZb + radiusb*sin(threadAngleBottom) ],\n\t\t[Xb,\t\t\t\t\t\tYb,\t\t\t\t\t\tZb + radiusb*(tipRatiob+sin(threadAngleTop)) ],\n\t\t[Xb*shaftRatio ,\t\t\t\tYb*shaftRatio ,\t\t\t\tZb + radiusb*(tipRatiob+sin(threadAngleTop)) ],\n\t\t[Xb*shaftRatio ,\t\t\t\tYb*shaftRatio ,\t\t\t\tZb ],\n\t\t[Xb*shaftRatio ,\t\t\t\tYb*shaftRatio ,\t\t\t\tZb + radiusb*sin(threadAngleBottom) ] ];\n\tpolyTriangles1=[\n\t\t[ 0, 1, 6 ], [ 0, 6, 5 ],\n\t\t[ 1, 7, 6 ], [ 1, 2, 7 ],\n\t\t[ 0, 5, 4 ], [ 4, 5, 9 ],\n\t\t[ 3, 4, 9 ], [ 9, 8, 3 ], [ 2, 3, 8 ], [ 8, 7, 2 ],\n\t\t[ 0, 4, 3 ], [ 0, 3, 2 ], [ 0, 2, 1 ],\n\t\t[ 5, 8, 9 ], [ 5, 7, 8 ], [ 5, 6, 7 ]\n\t\t ];\n\tpolyhedron( polyPoints1, polyTriangles1 );\n}\nmodule trapezoidThread(\n\tlength=45,\n\tpitch=10,\n\tpitchRadius=10,\n\tthreadHeightToPitch=0.5,\n\tprofileRatio=0.5,\n\tthreadAngle=30,\n\tRH=true,\n\tclearance=0.1,\n\tbacklash=0.1,\n\tstepsPerTurn=24\n\t\t)\n{\n\tnumberTurns=length/pitch;\n\tsteps=stepsPerTurn*numberTurns;\n\ttrapezoidRatio=\t\t\t\t2*profileRatio*(1-backlash);\n\tfunction\tthreadAngleTop(i)=\tthreadAngle/2;\n\tfunction\tthreadAngleBottom(i)=\t-threadAngle/2;\n\tfunction \tthreadHeight(i)=\t\tpitch*threadHeightToPitch;\n\tfunction\tpitchRadius(i)=\t\tpitchRadius;\n\tfunction\tminorRadius(i)=\t\tpitchRadius(i)-0.5*threadHeight(i);\n\tfunction \tX(i)=\t\t\t\tminorRadius(i)*cos(i*360*numberTurns);\n\tfunction \tY(i)=\t\t\t\tminorRadius(i)*sin(i*360*numberTurns);\n\tfunction \tZ(i)=\t\t\t\tpitch*numberTurns*i;\n\tfunction\ttip(i)=\t\t\ttrapezoidRatio*(1-0.5*sin(threadAngleTop(i))+0.5*sin(threadAngleBottom(i)));\n\tif (RH==true)\n\ttranslate([0,0,-threadHeight(0)*sin(threadAngleBottom(0))])\n\tfor (i=[0:steps-1])\n\t{\n\t\tthreadPiece(\n\t\t\tXa=\t\t\t\tX(i/steps),\n\t\t\tYa=\t\t\t\tY(i/steps),\n\t\t\tZa=\t\t\t\tZ(i/steps),\n\t\t\tXb=\t\t\t\tX((i+1)/steps),\n\t\t\tYb=\t\t\t\tY((i+1)/steps),\n\t\t\tZb=\t\t\t\tZ((i+1)/steps),\n\t\t\tradiusa=\t\t\tthreadHeight(i/steps),\n\t\t\tradiusb=\t\t\tthreadHeight((i+1)/steps),\n\t\t\ttipRatioa=\t\t\ttip(i/steps),\n\t\t\ttipRatiob=\t\t\ttip((i+1)/steps),\n\t\t\tthreadAngleTop=\t\tthreadAngleTop(i),\n\t\t\tthreadAngleBottom=\tthreadAngleBottom(i)\n\t\t\t);\n\t\tshaftPiece(\n\t\t\tXa=\t\t\t\tX(i/steps),\n\t\t\tYa=\t\t\t\tY(i/steps),\n\t\t\tZa=\t\t\t\tZ(i/steps),\n\t\t\tXb=\t\t\t\tX((i+1)/steps),\n\t\t\tYb=\t\t\t\tY((i+1)/steps),\n\t\t\tZb=\t\t\t\tZ((i+1)/steps),\n\t\t\tradiusa=\t\t\tthreadHeight(i/steps),\n\t\t\tradiusb=\t\t\tthreadHeight((i+1)/steps),\n\t\t\ttipRatioa=\t\t\ttip(i/steps),\n\t\t\ttipRatiob=\t\t\ttip((i+1)/steps),\n\t\t\tthreadAngleTop=\t\tthreadAngleTop(i),\n\t\t\tthreadAngleBottom=\tthreadAngleBottom(i)\n\t\t\t);\n\t}\n\tif (RH==false)\n\ttranslate([0,0,-threadHeight(0)*sin(threadAngleBottom(0))])\n\tmirror([0,1,0])\n\tfor (i=[0:steps-1])\n\t{\n\t\tthreadPiece(\n\t\t\tXa=\t\t\t\tX(i/steps),\n\t\t\tYa=\t\t\t\tY(i/steps),\n\t\t\tZa=\t\t\t\tZ(i/steps),\n\t\t\tXb=\t\t\t\tX((i+1)/steps),\n\t\t\tYb=\t\t\t\tY((i+1)/steps),\n\t\t\tZb=\t\t\t\tZ((i+1)/steps),\n\t\t\tradiusa=\t\t\tthreadHeight(i/steps),\n\t\t\tradiusb=\t\t\tthreadHeight((i+1)/steps),\n\t\t\ttipRatioa=\t\t\ttip(i/steps),\n\t\t\ttipRatiob=\t\t\ttip((i+1)/steps),\n\t\t\tthreadAngleTop=\t\tthreadAngleTop(i),\n\t\t\tthreadAngleBottom=\tthreadAngleBottom(i)\n\t\t\t);\n\t\tshaftPiece(\n\t\t\tXa=\t\t\t\tX(i/steps),\n\t\t\tYa=\t\t\t\tY(i/steps),\n\t\t\tZa=\t\t\t\tZ(i/steps),\n\t\t\tXb=\t\t\t\tX((i+1)/steps),\n\t\t\tYb=\t\t\t\tY((i+1)/steps),\n\t\t\tZb=\t\t\t\tZ((i+1)/steps),\n\t\t\tradiusa=\t\t\tthreadHeight(i/steps),\n\t\t\tradiusb=\t\t\tthreadHeight((i+1)/steps),\n\t\t\ttipRatioa=\t\t\ttip(i/steps),\n\t\t\ttipRatiob=\t\t\ttip((i+1)/steps),\n\t\t\tthreadAngleTop=\t\tthreadAngleTop(i),\n\t\t\tthreadAngleBottom=\tthreadAngleBottom(i)\n\t\t\t);\n\t}\n\trotate([0,0,180/stepsPerTurn])\n\tcylinder(\n\t\th=length+threadHeight(1)*(tip(1)+sin( threadAngleTop(1) )-1*sin( threadAngleBottom(1) ) ),\n\t\tr1=minorRadius(0)-clearance*threadHeight(0),\n\t\tr2=minorRadius(0)-clearance*threadHeight(0),\n\t\t$fn=stepsPerTurn\n\t\t\t);\n}\nmodule trapezoidThreadNegativeSpace(\n\tlength=45,\n\tpitch=10,\n\tpitchRadius=10,\n\tthreadHeightToPitch=0.5,\n\tprofileRatio=0.5,\n\tthreadAngle=30,\n\tRH=true,\n\tcountersunk=0,\n\tclearance=0.1,\n\tbacklash=0.1,\n\tstepsPerTurn=24\n\t\t)\n{\n\ttranslate([0,0,-countersunk*pitch])\n\tcylinder(\n\t\th=2*countersunk*pitch,\n\t\tr2=pitchRadius+clearance*pitch+0.25*pitch,\n\t\tr1=pitchRadius+clearance*pitch+0.25*pitch+2*countersunk*pitch,\n\t\t$fn=24\n\t\t\t);\n\ttranslate([0,0,countersunk*pitch])\n\ttranslate([0,0,-pitch])\n\ttrapezoidThread(\n\t\tlength=length+0.5*pitch,\n\t\tpitch=pitch,\n\t\tpitchRadius=pitchRadius+clearance*pitch,\n\t\tthreadHeightToPitch=threadHeightToPitch,\n\t\tprofileRatio=profileRatio,\n\t\tthreadAngle=threadAngle,\n\t\tRH=true,\n\t\tclearance=0,\n\t\tbacklash=-backlash,\n\t\tstepsPerTurn=stepsPerTurn\n\t\t\t);\n\ttranslate([0,0,length-countersunk*pitch])\n\tcylinder(\n\t\th=2*countersunk*pitch,\n\t\tr1=pitchRadius+clearance*pitch+0.25*pitch,\n\t\tr2=pitchRadius+clearance*pitch+0.25*pitch+2*countersunk*pitch,$fn=24,\n\t\t$fn=24\n\t\t\t);\n}\nmodule trapezoidNut(\n\tlength=45,\n\tradius=25,\n\tpitch=10,\n\tpitchRadius=10,\n\tthreadHeightToPitch=0.5,\n\tprofileRatio=0.5,\n\tthreadAngle=30,\n\tRH=true,\n\tcountersunk=0,\n\tclearance=0.1,\n\tbacklash=0.1,\n\tstepsPerTurn=24\n\t\t)\n{\n\tdifference()\n\t{\n\t\tcylinder(\n\t\t\th=length,\n\t\t\tr1=radius,\n\t\t\tr2=radius,\n\t\t\t$fn=6\n\t\t\t\t);\n\t\ttrapezoidThreadNegativeSpace(\n\t\t\tlength=length,\n\t\t\tpitch=pitch,\n\t\t\tpitchRadius=pitchRadius,\n\t\t\tthreadHeightToPitch=threadHeightToPitch,\n\t\t\tprofileRatio=profileRatio,\n\t\t\tthreadAngle=threadAngle,\n\t\t\tRH=true,\n\t\t\tcountersunk=countersunk,\n\t\t\tclearance=clearance,\n\t\t\tbacklash=backlash,\n\t\t\tstepsPerTurn=stepsPerTurn\n\t\t\t\t);\n\t}\n}",
    "description": "Okay, I'm looking to design a parametric version of Arthur Ganson's \"Machine with Concrete\", but in OpenSCAD. I've seen some examples online, but they aren't as parametric as I'd like. I'm envisioning a system where I can easily adjust the number of gears, their sizes, the stand dimensions, and so forth.\n\nHere's a breakdown of the key components and parameters I'd like to control:\n\n**Gears:**\n\n*   **Number of Stages:** I want to easily adjust the number of reduction stages (the \"12 gears\" mentioned). This will drastically change the final output speed and, importantly, how long it will take to rotate.\n*   **Gear Ratio:** It's currently a 50:1 reduction per stage, but I'd like the ability to change this to other values (e.g., 30:1, 40:1, or even to use a different ratio for some stages). I need the ability to specify the number of teeth and pitch radius. I understand this currently uses involute gears from a library.\n*   **Worm Gear Parameters:** I'd need to control worm length, radius, and the pitch of the worm thread itself. It needs to match the gear it drives.\n*   **Gear Thickness & Rim:** Adjustable thickness for the gears, as well as the thickness and width of the rim around the gear.\n*   **Shaft Bore:** Size and fit tolerance around shaft that gear is mounted on\n*   **Bushing Dimensions:** The size of the shaft bushings and fit tolerance.\n\n**Stands and Supports:**\n\n*   **Bearing Specifications:** I'd like control over the bearing's outer diameter, inner diameter, and width. This will allow me to use different bearings as needed.\n*   **Stand Thickness & Height:** I want control over the thickness of the stand pieces and their overall height.\n*   **Bolt Spacing & Slot Dimensions:** Parameters to control the bolt spacing for mounting the stands, and the dimensions of the bolt slots. This should also control the slot start and total height.\n*    **Shaft Width:** The width of the cutout for the shaft in the motor stand\n\n*   **Overall Axle Length:** Adjustable distance between gear mounts.\n*   **Separate and Combined Stands:** The current design has separate and combined stand options. I would like to retain this functionality and select the mode I want.\n*   **Footprint:** Ability to adjust the base dimensions of the stand components.\n\n**Motor Mount:**\n\n*   **Motor Shaft Dimensions:** Length and diameter of motor shaft.\n*    **Motor Mount Dimensions:** Height, thickness, bolt spacing and slot parameters (like the normal stands).\n\n**Concrete Form (or Plaster):**\n\n*   **Form Dimensions:** Width, length, and height of the concrete/plaster form.\n*   **Wall Thickness:** Adjustable thickness for the form's walls.\n\n**General:**\n\n*   **Fit Tolerance:** A global fit buffer or tolerance parameter that will adjust tolerances for printed parts, which is currently a small, fixed value.\n*   **Shaft Type:** The ability to specify if a round shaft or a hex shaft should be used.\n*   **Assembly Toggle:** A toggle to show the full assembly of the gears, stands and motor, as a single model.\n*   **Mirrored Parts:** A variable to toggle mirrored versions of the gears, in order to fit onto the machine as required.\n\n**Libraries:**\n\nI see that this design uses the `MCAD/involute_gears.scad` library for the gears. I'd like to continue using that for the involute gear generation, if possible. Also the `Thread_Library.scad` which should be included in my file for the threaded shaft and negative space components.\n\n**Output:**\n\nThe final OpenSCAD file should be well-commented and organized, making it easy to understand and modify. I'd prefer a single SCAD file for the whole assembly, with modules for each of the main components.\n\nThe goal is to make this as customizable as possible while still maintaining the spirit of Ganson's original piece. I need to be able to control how many stages, what the reduction per stage is and the basic sizing of each piece (so that I can use different hardware or have the correct clearance). Can you help me generate this file?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Stretchy Band",
    "scad": "_1_insideDiameter = 24;\n_2_outsideDiameter = 48;\n_3_height = 6;\n_4_radialCount = 6;\n_5_thickness = 0.8;\n_6_resolution = 60;\nmodule smallArc(radius0, radius1, angle, depth) {\n\tthickness = radius1 - radius0;\n\teps = 0.1;\n\tunion() {\n\t\tdifference() {\n\t\t\tcylinder(r=radius1, h=depth, center=true);\n\t\t\tcylinder(r=radius0, h=depth+2*eps, center=true);\n\t\t\tfor(z=[0, 180 - angle]) {\n\t\t\t\trotate([0,0,z])\n\t\t\t\ttranslate([-radius1,0,0])\n\t\t\t\tcube(size = [radius1*2, radius1*2, depth+eps], center=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule largeArc(radius0, radius1, angle, depth) {\n\teps = 1;\n\tthickness = radius1 - radius0;\n\tcutAngle = 360-angle;\n\tcenterRadius = (radius0 + radius1)/2.0;\n\tif (angle > 180) {\n\t\tunion() {\n\t\t\tsmallArc(radius0, radius1, 180, depth);\n\t\t\trotate([0,0,-180 + eps]) {\n\t\t\t\tsmallArc(radius0, radius1, angle-180 + eps, depth);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsmallArc(radius0, radius1, angle, depth);\n\t}\n}\nmodule stretchyBand(r1, r2, count, height, thickness) {\n\tangle = 180/count;\n\teps = 0.1;\n\toverlap = 2;\n\tcord2 = 2 * r2 * sin(angle/2);\n\toutsideArc = 180 + angle + overlap;\n\toutsideRadius = cord2/sin(90-angle/2)/2;\n\toutsideOffset = r2 * cos(angle/2) + cos(90-angle/2) * outsideRadius;\n\tinsideArc = 180 - angle + overlap;\n\tcord1 = 2 * r1 * sin(angle/2);\n\tinsideRadius = cord1/sin(90-angle/2)/2;\n\tinsideOffset = r1 * cos(angle/2) + cos(90-angle/2) * insideRadius;\n\tunion()\n\ttranslate([0,0,height/2])\n\tfor(a = [0:angle*2:360]) {\n\t\trotate([0,0,a]) {\n\t\t\tfor(b=[0,angle]) {\n\t\t\t\trotate([0,0,angle/2 - b])\n\t\t\t\ttranslate([0,r1 + (r2-r1)/2,0]) {\n\t\t\t\t\tcube(size = [thickness, r2 - r1 + eps, height], center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([0,outsideOffset,0])\n\t\t\trotate([0,0,outsideArc/2]) {\n\t\t\t\tlargeArc(outsideRadius-thickness/2,outsideRadius+thickness/2, outsideArc, height);\n\t\t\t}\n\t\t\trotate([0,0,angle])\n\t\t\ttranslate([0,insideOffset,0])\n\t\t\trotate([0,0,180 + insideArc/2]) {\n\t\t\t\tlargeArc(insideRadius-thickness/2,insideRadius+thickness/2, insideArc, height);\n\t\t\t}\n\t\t}\n\t}\n}\nstretchyBand(\t_1_insideDiameter > _2_outsideDiameter ? _2_outsideDiameter/2 : _1_insideDiameter/2,\n\t\t\t\t\t_2_outsideDiameter/2,\n\t\t\t\t\t_4_radialCount,\n\t\t\t\t\t_3_height,\n\t\t\t\t\t_5_thickness,\n\t\t\t\t\t$fn=_6_resolution\n);",
    "description": "Okay, I'm looking to create a flexible ring-like structure, sort of like a rubber band, using OpenSCAD. I want it to be parametric so I can adjust its size and flexibility.\n\nHere's what I envision:\n\n*   **Core Structure:** The ring will be made of repeating segments, where each segment has a straight section and curved sections. These segments will be connected end-to-end to form the full ring.\n*   **Dimensions:**\n    *   I need to define an `insideDiameter` and an `outsideDiameter` to determine the overall size of the ring (not including the curved portions).\n    *   I also need a `height` parameter to control the thickness of the ring.\n    *   I want to be able to set `radialCount`, which controls the number of repeating segments (or loops) around the ring.\n    *  There should be a `thickness` parameter to control the thickness of the material in the ring's walls and curved sections.\n    *    Finally, a `resolution` parameter for controlling the number of faces used to draw the curves in the structure. This needs to have options for Low, Medium, and High detail.\n*   **Segment Design:**\n    * Each segment will have two straight sections that are parallel with the ring's radial direction.\n    * Each straight section will be connected to a semi-circular arc. One arc will be toward the inside of the ring and the other toward the outside.\n    *   The curved sections should be arcs, not just simple fillets.\n   *    The outer arc needs to have the largest radius. The inner arc needs to have the smallest radius.\n   *    The arcs must be on the *outside* of the straight sections (i.e. not connecting the straight sections together). The ring should be continuous and not have gaps.\n*   **Parametric Behavior:**\n    *   I need the code to be able to make the inner diameter larger than the outer diameter, and correctly render by treating the given `_1_insideDiameter` as the larger of the two radii.\n    *   I should be able to adjust all parameters I mentioned and see the ring update accordingly.\n\nI'm basically trying to reproduce the functionality of the provided `stretchy_band_v1-0.scad` file, but I want to do it myself with the correct parameters. I would like to see a single OpenSCAD file that can generate a single, flexible ring.\n\nCan you help me design an OpenSCAD file with these features? It would be a massive help! No need to specify that the code will be attached. Also, I do not expect you to attach external libraries.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Rectangular-ish Quick Release Tripod mount",
    "scad": "ShoeBottomWidth = 68;\nShoeBottomLength = 61;\nShoeTopWidth = 68;\nShoeTopLength = 54;\nShoeDepth = 8;\nFrontDetentLength = 15;\nFrontDetentWidth = 2;\nSideDetentLength = 16;\nSideDetentWidth = 3;\nTopPlateWidth = 78;\nTopPlateLength = 69;\nTopPlateDepth = 1;\n$fn=50 + 0;\nrotate(a=[0,180,0])\n{\n\tdifference()\n\t{\n\t\tshoe();\n\t\tshoekeys();\n\t\tcylinder(h = ShoeDepth, r=3);\n\t\trotate(a=[0,180,0]) translate([0,0,2-ShoeDepth]) cylinder(h = ShoeDepth, r1 = 9, r2 = min(ShoeBottomWidth, ShoeBottomLength, ShoeTopWidth, ShoeTopLength) * .5);\n\t}\n\tdifference()\n\t{\n\t\tminkowski()\n\t\t{\n\t\t\ttranslate([0,0, ShoeDepth]) cube(size = [TopPlateWidth - TopPlateDepth- TopPlateDepth,TopPlateLength - TopPlateDepth - TopPlateDepth,.001], center = true);\n\t\t \tcylinder(r=TopPlateDepth,h=TopPlateDepth);\n\t\t}\n\t\ttranslate([0,0, TopPlateDepth * 2]) cylinder(h = ShoeDepth, r=3);\n\t}\n}\nmodule shoe() {\n\thull() {\n\t\ttranslate([0,0, .001]) cube(size = [ShoeBottomWidth,ShoeBottomLength,.001], center = true);\n \t\ttranslate([0,0,ShoeDepth-.001]) cube(size = [ShoeTopWidth,ShoeTopLength,.001], center = true);\n\t}\n}\nmodule shoekeys()\n{\n\thull()\n\t{\n\t\ttranslate([(ShoeTopWidth * .5) - FrontDetentLength, (ShoeTopLength * .5) - ShoeTopLength, 0]) cube(size = [FrontDetentLength,FrontDetentWidth,ShoeDepth], center = false);\n\t\ttranslate([(ShoeBottomWidth * .5) - FrontDetentLength, -(ShoeBottomLength * .5) , 0]) cube(size = [FrontDetentLength,FrontDetentWidth,ShoeDepth], center = false);\n\t}\n\thull()\n\t{\n\t\ttranslate([-(ShoeTopWidth * .5) , (ShoeTopLength * .5) - ShoeTopLength, 0]) cube(size = [FrontDetentLength,FrontDetentWidth,ShoeDepth], center = false);\n\t\ttranslate([-(ShoeBottomWidth * .5) , -(ShoeBottomLength * .5) , 0]) cube(size = [FrontDetentLength,FrontDetentWidth,ShoeDepth], center = false);\n\t}\n\thull()\n\t{\n\t\ttranslate([(ShoeTopWidth * .5) - FrontDetentLength, (ShoeTopLength * .5) -FrontDetentWidth, 0]) cube(size = [FrontDetentLength,FrontDetentWidth,ShoeDepth], center = false);\n\t\ttranslate([(ShoeBottomWidth * .5) - FrontDetentLength, (ShoeBottomLength * .5) , 0]) cube(size = [FrontDetentLength,FrontDetentWidth,ShoeDepth], center = false);\n\t}\n\thull()\n\t{\n\t\ttranslate([-(ShoeTopWidth * .5) , (ShoeTopLength * .5) -FrontDetentWidth, 0]) cube(size = [FrontDetentLength,FrontDetentWidth,ShoeDepth], center = false);\n\t\ttranslate([-(ShoeBottomWidth * .5) , (ShoeBottomLength * .5) , 0]) cube(size = [FrontDetentLength,FrontDetentWidth,ShoeDepth], center = false);\n\t}\n\thull()\n\t{\n\t\ttranslate([(ShoeTopWidth * .5) - SideDetentWidth , (ShoeTopLength * .5) - SideDetentLength, 0]) cube(size = [SideDetentWidth,SideDetentLength,ShoeDepth], center = false);\n\t\ttranslate([(ShoeBottomWidth * .5) - SideDetentWidth , (ShoeBottomLength * .5) - SideDetentLength, 0]) cube(size = [SideDetentWidth,SideDetentLength,ShoeDepth], center = false);\n\t}\n\thull()\n\t{\n\ttranslate([-(ShoeTopWidth * .5)  , (ShoeTopLength * .5) - SideDetentLength, 0]) cube(size = [SideDetentWidth,SideDetentLength,ShoeDepth], center = false);\n\t\ttranslate([-(ShoeBottomWidth * .5)  , (ShoeBottomLength * .5) - SideDetentLength, 0]) cube(size = [SideDetentWidth,SideDetentLength,ShoeDepth], center = false);\n\t}\n\thull()\n\t{\n\t\ttranslate([(ShoeTopWidth * .5) - SideDetentWidth , -(ShoeTopLength * .5), 0]) cube(size = [SideDetentWidth,SideDetentLength,ShoeDepth], center = false);\n\t\ttranslate([(ShoeBottomWidth * .5) - SideDetentWidth , -(ShoeBottomLength * .5), 0]) cube(size = [SideDetentWidth,SideDetentLength,ShoeDepth], center = false);\n\t}\n\thull()\n\t{\n\ttranslate([-(ShoeTopWidth * .5)  , -(ShoeTopLength * .5) , 0]) cube(size = [SideDetentWidth,SideDetentLength,ShoeDepth], center = false);\n\t\ttranslate([-(ShoeBottomWidth * .5)  , -(ShoeBottomLength * .5) , 0]) cube(size = [SideDetentWidth,SideDetentLength,ShoeDepth], center = false);\n\t}\n}",
    "description": "Okay, I need help designing a replacement tripod quick release shoe. I've got an existing OpenSCAD file that does *most* of what I need, but it's not fully parametric and has some keying that I want to get rid of, so I can use this shoe on any of my tripod heads.\n\nHere's what I'm looking for:\n\n1. **Basic Shape:** I need a shoe that's essentially a tapered rectangle, thicker at the base than at the top, with a central through-hole for a standard camera screw (that should be a cylinder cutout). The shape in the attached SCAD file, `TripodQuickRelease.scad`, gets the basic profile right  the `shoe()` module captures the taper. Its important to retain this hull based approach to creating the basic shape, not using linear_extrude or similar.\n\n2. **Parametric Dimensions:** I need to be able to control the following dimensions with variables:\n    * `ShoeBottomWidth`: The width of the shoe at its base (wider end).\n    * `ShoeBottomLength`: The length of the shoe at its base (wider end).\n    * `ShoeTopWidth`: The width of the shoe at its top (narrower end).\n    * `ShoeTopLength`: The length of the shoe at its top (narrower end).\n    * `ShoeDepth`: The overall thickness/height of the shoe.\n    * `ScrewHoleDiameter`: The diameter of the central through-hole for the camera screw.\n\n3. **Remove the 'Keying':** The current `shoekeys()` module creates protrusions/indents on the sides and edges of the shoe (which are used as keys), but I do not want these at all for the new parametric version. I need this removed from the design.\n\n4. **Top Plate:** I want a thin flat plate on top of the shoe, centered, with rounded edges. The current version achieves this with a minkowski sum, I would like to keep using this approach. The parameters should include:\n    * `TopPlateWidth`: The width of the top plate.\n    * `TopPlateLength`: The length of the top plate.\n    * `TopPlateDepth`: The thickness of the top plate.\n    * `TopPlateEdgeRadius`: The radius of the rounded edges for the top plate.\n\n5. **Nut Recess:** I would like to keep the nut recess on the bottom of the shoe. The current version uses a couple of cylinders to achieve this. It works.\n     * `NutRecessDepth`: the depth of the main recess to accept a camera mounting screw.\n    * `NutRecessWidth`: The width of the main recess to accept a camera mounting screw.\n    * `NutRecessSecondaryDepth`: The depth of the secondary recess to ensure the shoe is firmly mounted\n\n6.  **Orientation:** The shoe and top plate should be oriented so the widest part of the shoe is \"at the bottom\" in a 2D plane. The attached SCAD file rotates the final shape 180 degrees around the Y axis, but this is just a presentation hack and does not help us when working with the design. \n7.  **Clarity:** The code should be well-commented to explain the purpose of each section, variable and parameter.\n8.  **Compatibility:** I use BOSL2 for some of my projects, so the design would ideally use the `rounded_cube` primitive from that.\n\nEssentially, I want a fully parametric version of the shoe in the attached file, removing the keying, and ensuring that I can specify all of the dimensions, the nut recess parameters, and the edge radius for the top plate.\n\nCould you help me with a parametric OpenSCAD file for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Round to square connector",
    "scad": "inside= 2;\nthickness = 2 ;\nsquare_side = 15;\nsquare_length = 10;\ntransition_length = 20;\nround_diameter = 20;\nround_length = 10;\nlayers= 10;\nfunction normal (p1,p2) = [ p1[1] - p2[1], p2[0] - p1[0] ] ;\nfunction length(p)  =  sqrt(pow(p[0],2) + pow(p[1],2));\nfunction unit_normal(p1,p2) = normal(p1,p2) / length(normal(p1,p2));\nfunction interpolate(a, b, ratio) = a + (b - a) * ratio;\nfunction superellipse (R, p, e, theta) =\n      R * [pow(abs(cos(theta)),2/p) * sign(cos(theta)),\n           e * pow(abs(sin(theta)),2/p) * sign(sin(theta))\n          ] ;\nmodule superellipse_curve (R, p, e=1, thickness=1, sweep=360, n=50) {\n      assign(dth = sweep/n)\n        for (i = [0:n-1] )\n          assign (p1 = superellipse(R,p,e,dth*i),\n                  p2 = superellipse(R,p,e,dth*(i+1))\n                  )\n          assign (nv =  thickness * unit_normal(p1,p2)  )\n            polygon(\n                  [p1,p2,p2+nv,p1+nv] );\n}\nmodule tube(r1, r2, length, p1, p2, thickness, steps) {\n     for (i=[0:steps-1])\n        assign (ratio = i /steps)\n        assign (radius = interpolate(r1, r2, ratio),\n                    p = interpolate(p1,p2,ratio),\n                    l = interpolate(0, length, ratio)\n                   )\n        translate([0, 0, l])\n           linear_extrude(height= length /steps)\n               superellipse_curve(radius,p,1,thickness);\n}\nsquare_r= square_side * sin(45)  + (inside==1 ? thickness : 0);\nround_r= round_diameter /2 + (inside==1 ? thickness : 0) ;\necho (square_r, round_r);\n$fa=0.01; $fs=2;\nunion() {\n         tube(square_r,square_r, square_length,1,1,thickness,1);\n         translate([0,0,square_length])\n                tube(square_r,round_r,transition_length,1,2,thickness,layers);\n          translate([0,0,square_length + transition_length])\n                tube(round_r,round_r,round_length,2,2,thickness,1);\n   }",
    "description": "Okay, I'm looking to create a parametric connector that smoothly transitions between a square tube and a round tube. I've seen examples that use superellipses to achieve this, and that seems like a good approach. I'd like the OpenSCAD code to be flexible enough to adjust the key dimensions.\n\nHere's a breakdown of what I need:\n\n*   **Overall Structure:** The connector will have three sections: a square tube section, a transition section, and a round tube section.\n\n*   **Square Tube Section:**\n    *   **`square_side`:**  A parameter to control the length of the side of the square.\n    *   **`square_length`:** A parameter to control the length of the square tube section.\n\n*   **Round Tube Section:**\n    *   **`round_diameter`:** A parameter to control the diameter of the round tube.\n    *   **`round_length`:** A parameter to control the length of the round tube section.\n\n*   **Transition Section:**\n    *   **`transition_length`:** A parameter to control the length of the transition between the square and round sections.\n    *   The transition should smoothly morph from a square to a circle using a superellipse.\n    *   I want a parameter `layers` to determine how many steps or slices to create along the length of this transition. More layers will be smoother but might be slower to render.\n\n*   **Wall Thickness:**\n    *   **`thickness`:** A parameter to control the wall thickness of the entire connector.\n\n*   **Inside/Outside Dimensions:**\n    *   **`inside`:** A parameter with two states: 1 for \"inside\" dimensioning and 2 for \"outside\" dimensioning. When set to 1, the provided square_side and round_diameter parameters will define the inside dimensions. When set to 2, the given parameters should define the outside dimensions. In either case the wall thickness is applied accordingly.\n\n*   **Important Feature:** I want the superellipse to be the primary shaping function.\n\nI'd like the code to be organized clearly with well-defined parameters at the top. I'm hoping that the code will be reasonably efficient.\n\nI do not need any additional libraries for this design.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Bracelet",
    "scad": "use <utils/build_plate.scad>\nuse<Write.scad>\ninclude <write/Write.scad>\n$fn=100*1;\nbracelet_size = 65;\ninscription = \"Best Friends!\";\nemboss_or_engrave = 1;\nfont = \"write/knewave.dxf\";\nfont_height = 10;\nfont_depth = 2;\nbottom_style = 1;\ntop_surface_width_in_millimeters = 20;\nbottom_surface_width = 0.25;\ntop_thinkness_in_millimeters = 5;\nbottom_thinkness_in_millimeters = 3;\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\ninside_width = bracelet_size;\ninside_height = inside_width * 55 / 65;\ntop_thick = top_thinkness_in_millimeters;\nbottom_thick = bottom_thinkness_in_millimeters;\noutside_width = inside_width + (top_thick + bottom_thick) / 2 * 2;\noutside_height = inside_height + top_thick + bottom_thick;\nbottom_gap_enable = bottom_style;\nbottom_gap = inside_width *30/65;\ntop_broad = top_surface_width_in_millimeters;\nbottom_broad = top_surface_width_in_millimeters*bottom_surface_width;\nfudge = 0.05*1;\ntalest = top_broad;\na = (top_broad - bottom_broad);\nb = outside_height;\nc = sqrt(a*a+b*b);\nangle = asin(a/c) ;\necho(\"a\", a ,\"abs:\",a/abs(a));\necho(\"angle\", angle);\nif (top_broad < bottom_broad) {\n\techo(\"top_broad must be larger than bottom broad\");\n}\nbracelet ();\nmodule bracelet () {\nrotate(a=-angle/2,v=[1,0,0])\ntranslate (v=[0, 0,(top_broad+bottom_broad)/2/2])\ndifference () {\n\tscale (v=[outside_width/outside_height,1,1]) {\n\t\tcylinder(r = outside_height/2, h = talest, center = true);\n\t\tif (emboss_or_engrave==0) {\ntranslate([0,0,font_height/6])\n\t\t\t\twritecylinder(inscription,[0,0,0],outside_height/2,0,rotate=0,font=font,\n\t\t\t\t\tt=font_depth,h=font_height);\n\t\t}\n\t}\n\ttranslate(v = [0, (top_thick-bottom_thick)/2, 0])\n\t\tscale (v=[inside_width/inside_height,1,1])\n\t\t\tcylinder(r = inside_height/2, h = talest+fudge, center = true);\n\tblock_cuts();\n\tif(bottom_gap_enable==1){\n\t\tgap_cuts ();\n\t}\n\t\tif (emboss_or_engrave==1) {\n\t\tscale (v=[outside_width/outside_height,1,1])\ntranslate([0,0,font_height/6])\n\t\t\twritecylinder(inscription,[0,0,0],(outside_height/2)-font_depth/2+fudge,0,rotate=0,\n\t\t\t\tt=font_depth,h=font_height);\n\t\t}\n}\n}\nmodule block_cuts () {\n\trotate (a=-angle/2,v=[1,0,0])\n\t\ttranslate(v = [0, 0, 25])\n\t\t\ttranslate(v = [0, 0, (bottom_broad+top_broad)/2/2])\n\t\t\t\tcube(size = [outside_width+10,outside_height+10,50], center = true);\n\trotate (a=angle/2,v=[1,0,0])\n\t\ttranslate(v = [0, 0, -25])\n\t\t\ttranslate(v = [0, 0, -(bottom_broad+top_broad)/2/2])\n\t\t\t\tcube(size = [outside_width+10,outside_height+10,50], center = true);\n}\nmodule gap_cuts () {\n\t\ttranslate(v = [0, outside_height/2, 0])\n\tcube(size = [bottom_gap,outside_height,top_broad+bottom_broad+fudge], center = true);\n}",
    "description": "Okay, I'd like to design a custom bracelet, and I need some help creating the OpenSCAD code. I want it to be parametric so I can easily adjust the size and other features.\n\nHere's what I'm looking for:\n\n**Basic Shape:**\n\n*   The bracelet should have a generally cylindrical shape that's been sliced to have a flat top section for a custom inscription. It'll basically be a section of a thick-walled cylinder.\n*   The outer profile will be an arc and the inner profile another arc (concentric), both cut to the proper height.\n*   The top surface where the inscription will go should be wider than the bottom edge near the wrist, creating a slight taper from top to bottom. The top surface should be flat.\n*   The bracelet should have a gap on the bottom for ease of putting it on.\n*   I need to be able to control the thickness of the bracelet at both the top (inscription area) and the bottom (near the wrist).\n\n**Customization:**\n\n*   **Size:**  I need a parameter for the inside diameter (or a related dimension) to fit different wrist sizes. I'd like a good range to cover child, women's and men's sizes. Maybe even a reference list to sizes that map to specific age/sex if that's easily accomplished.\n*   **Inscription:** I want to be able to add a custom text inscription that can be either embossed (raised) or engraved (recessed). I need to choose between them.\n*   **Font:**  I want to be able to select the font from a list of options.\n*   **Font Height and Depth:**  I need parameters to control the height and depth of the font.\n*  **Taper:** the width of the top surface, where the inscription goes, needs to be independently controlled from the width of the bottom edge.\n*   **Bottom Gap:** I should be able to toggle the gap on the bottom (or the split on the bottom) off.\n*   **Surface Widths and Thicknesses:**  I need parameters for the top surface width, bottom surface width, the thickness of the top of the bracelet, and the thickness of the bracelet at the bottom near the wrist.\n\n**Libraries:**\n\n*   I know that I want to use the `Write.scad` library to help with the inscription process. And specifically, within that library, the individual font `.dxf` files, such as \"knewave.dxf\", \"Letters.dxf\", etc.\n\n**Parameters I want to control:**\n\n*   `bracelet_size`: Inside diameter (or dimension used to calculate inside diameter) of the bracelet.\n*  `inscription`: The text to be embossed/engraved.\n*  `emboss_or_engrave`:  A flag to choose emboss (0) or engrave (1).\n*  `font`: The font file to be used from the `write` directory.\n*   `font_height`:  The height of the letters.\n*   `font_depth`: The depth of the letters.\n*  `bottom_style`: Choose to split the bottom of the bracelet (1) or leave it continuous (0).\n*   `top_surface_width_in_millimeters`:  The width of the top surface of the bracelet (where inscription goes).\n*   `bottom_surface_width`: A scalar to derive the width of the bracelet at the wrist.\n*   `top_thinkness_in_millimeters`:  The thickness of the bracelet under the inscription.\n*   `bottom_thinkness_in_millimeters`:  The thickness of the bracelet at the wrist.\n\nIt'd also be helpful to have a way to visualize the build plate using the `build_plate.scad` file (also not part of the standard library) that was used in the example. It should also have parameters to specify the printer.\n\nCould you generate the OpenSCAD code for me? Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Snowflake Generator for Customizer",
    "scad": "edge_length = 22;\nflake_thickness=2;\nextrude_width=10;\nnumber_of_crystals = 3;\nbackbone_width= 1;\nel=edge_length;\nft=flake_thickness;\ncmt=edge_length / 5;\nxw=extrude_width/10;\nnc=number_of_crystals*4;\nbw=backbone_width;\ncit = xw;\nth = sqrt(3) * el/2;\nrv = rands(0,1,nc*5);\nmodule flake_part(){\n\trotate([0,0,30]) translate([0,-el/2,0])\n\t\tcube([bw,el,ft], center = true);\n\tfor(i = [0:nc-1]){\n\t\tassign(yr = sqrt(rv[i*4]),\n\t\t   xr = rv[i*4+1] * sqrt(rv[i*4]),\n\t\t   rt = (rv[i*4+2]<(1/3))?0:(rv[i*4+2]<(2/3))?60:120,\n\t\t   sl = rv[i*4+3],\n\t\t   ct = (rv[i*4+4])*(rv[i*4+4])){\n\t\t\tif(((rt != 120) || (yr + sl/2 < 1)) && (sl*el/2 > xw)){\n\t\t\t\ttranslate([xr*el/2, -yr*th,0]) rotate(rt)\n\t\t\t\t\tcube([sl*el/2, cit + max(0,cmt*ct/2-cit), ft],\n\t\t\t\t\t   center = true, $fa = 60);\n\t\t\t}\n\t\t}\n\t}\n}\nfor(ri = [0:60:300]){\n\trotate([0,0,ri]) flake_part();\n\trotate([0,180,ri]) flake_part();\n}",
    "description": "Okay, I'd like to create a more flexible snowflake generator than the one I have now. I'm basing it off this file I have, but I want a few more controls.\n\nHere's the basic design concept. We start with a central hexagonal structure. Then, branching out from each point of the hexagon, we have a series of smaller \"branches.\" These branches themselves can have even smaller branches. The main structure is essentially a 2D form, that is extruded to a specific thickness.\n\nHere are the parameters I want to control:\n\n*   **`edge_length`**: This sets the length of the main hexagon's edges. I want to be able to adjust this to make the whole snowflake bigger or smaller.\n\n*   **`flake_thickness`**: The thickness of the extruded 2D snowflake.\n\n*  **`extrude_width`**: A parameter affecting the width of the branches. This should control the base width of all branches, which might then be modified on an individual basis by another parameter.\n\n*   **`number_of_crystals`**: This parameter controls the number of branch extensions on each of the 6 \"arms\" of the snowflake; the total number of branches in the design will be this * 4 * 6.\n\n*   **`backbone_width`**: The width of the main hexagon edges that create the snowflake's base structure.\n\n*   **Branch Randomization**: Currently, the code uses random values to control branch location, angle, length and thickness, I like the effect this creates but want finer control over each branch:\n\n    *   **`branch_location`**: A value (between 0 and 1) that determines how far along the primary arm the branch should attach. It should be multiplied by `edge_length` or the current branch length to determine absolute branch location.\n\n    *   **`branch_direction`**: A value (0, 60, 120) that determines the angle of the branch relative to the primary arm. I want to use these same three possible rotations.\n\n    *   **`branch_length`**: A value (between 0 and 1) that controls the proportional length of each branch relative to `edge_length`. This will also be modified by the branch level.\n\n    *    **`branch_thickness`**: A value (between 0 and 1) that can scale the thickness of each branch relative to `extrude_width` or the thickness of the parent branch, which is set by another parameter.\n\n*   **Branch Level:** I want the ability to define a number of branch levels that cascade outward. Each branch level will generate a new branch from it's parent.\n\n*  **`branch_level_probability`** - a probability that each level of branch will generate (0.0 - 1.0)\n\nHere's what I would like the new parametric SCAD file to do:\n\n1.  Use `edge_length`, `flake_thickness`, `extrude_width`, `number_of_crystals`, and `backbone_width` as defined above.\n2.  Use `branch_location`, `branch_direction`, `branch_length` and `branch_thickness` in conjunction with the random number generation to control branch placement. Use `branch_level` and `branch_level_probability` to determine how far to continue branching.\n3.  Generate branches that are always perpendicular to the Z-axis.\n4.  Use random number generation to create these properties for each branch.\n5. Generate the branches based on a recursive module, that allows for arbitrary branch levels.\n6. Ensure the final design creates a 3D snowflake by extruding the 2D geometry using the `flake_thickness` parameter.\n7.  Do _not_ use any external libraries. I want to keep the design relatively simple.\n\nCan you create an OpenSCAD file for me that fulfills these requirements? Let me know if you have any questions.\n"
  },
  {
    "object": "Hey cadmonkey, make me a blargh customizer test blargh",
    "scad": "width_destroy = 0.7;\nwidth_keep = 3;\nwidth_tab = 4;\nfinger_length = 100;\nfinger_height = 18;\nfinger_depth = 15;\nL_ratio = 0.67;\nK_ratio = 2.5;\nK_length = 12;\nLB = 29.5715;\nT1 = 15;\nT2 = 15;\nL2 = finger_length / (1+1/L_ratio);\nL1 = finger_length - L2;\nR1 = 8;\nR2 = R_ratio*R1;\nK1 = 4.25;\nK2 = pow((K_ratio*pow(K1,3)),1/3);\nmodule finger_base(){\ncube([LB,finger_depth,finger_height],true);\ntranslate([-(LB+width_tab)/2,0,-finger_height/2+width_keep/2]) cube([width_tab,finger_depth,width_keep],true);\ntranslate([(LB+width_tab)/2,0,-finger_height/2+width_keep/2]) cube([width_tab,finger_depth,width_keep],true);\ntranslate([LB/2+K_length/2*cos(T1/2),0,K_length/2*sin(T1/2)]) {\n\trotate([0,-T1/2,0]) cube([K_length+width_keep,finger_depth,K1+2*width_destroy],true);\n\trotate([0,-T1,0]){\n\t\ttranslate([L1/2,0,-K_length/2*sin(T1/2)]){\n\t\t\tcube([L1-K_length,finger_depth,finger_height],true);\n\t\t\ttranslate([(L1-K_length)/2+K_length/2*cos(T2/2),0,K_length/2*sin(T2/2)]){\n\t\t\t\trotate([0,-T2/2,0]) cube([K_length+width_keep,finger_depth,K2+2*width_destroy],true);\n\t\t\t\trotate([0,-T2,0]){\n\t\t\t\t\ttranslate([L2/2,0,-K_length/2*sin(T2/2)]){\n\t\t\t\t\t\tcube([L2-K_length,finger_depth,finger_height],true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n}\nmodule dogbone(){\n\trotate([-90,0,0]) cylinder(finger_depth+width_destroy,width_keep/2,width_keep/2,true);\n}\nmodule flexures(){\n\ttranslate([LB/2+K_length/2*cos(T1/2),0,K_length/2*sin(T1/2)]) {\n\t\trotate([0,-T1/2,0]){\n\t\t\tcube([K_length+2*width_keep,finger_depth,K1],true);\n\t\t\ttranslate([-(K_length+2*width_keep)/2,0,K1/2]) dogbone();\n\t\t\ttranslate([-(K_length+2*width_keep)/2,0,-K1/2]) dogbone();\n\t\t\ttranslate([(K_length+2*width_keep)/2,0,K1/2]) dogbone();\n\t\t\ttranslate([(K_length+2*width_keep)/2,0,-K1/2]) dogbone();\n\t\t}\n\t\trotate([0,-T1,0]){\n\t\t\ttranslate([L1/2+(L1-K_length)/2+K_length/2*cos(T2/2),0,K_length/2*sin(T2/2)-K_length/2*sin(T1/2)]){\n\t\t\t\trotate([0,-T2/2,0]){\n\t\t\t\t\tcube([K_length+2*width_keep,finger_depth+2*width_destroy,K2],true);\n\t\t\t\t\ttranslate([-(K_length+2*width_keep)/2,0,K2/2]) dogbone();\n\t\t\t\t\ttranslate([-(K_length+2*width_keep)/2,0,-K2/2]) dogbone();\n\t\t\t\t\ttranslate([(K_length+2*width_keep)/2,0,K2/2]) dogbone();\n\t\t\t\t\ttranslate([(K_length+2*width_keep)/2,0,-K2/2]) dogbone();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\ndifference(){\n\tfinger_base();\n\tflexures();\n}",
    "description": "Okay, I'm working on a finger-like mechanism for a robot, and I need an OpenSCAD design. I've got a basic structure in mind, but I want it to be fully parametric so I can easily adjust the dimensions. \n\nHere's the basic idea: It consists of a base, two connected segments (L1 and L2), and two flexure joints connecting them. The base is a rectangular block with tabs for attachment. L1 and L2 are also rectangular, and they are connected by a flexure joint, and L1 is also connected to the base via a flexure joint.\n\nHere are the specific parameters I need to be able to control:\n\n**Fabrication Parameters:**\n\n*   `width_destroy`: This is the material width to be removed for making the flexures flexible (like the kerf). This should be adjustable, maybe between 0.5 and 0.9 mm.\n*   `width_keep`: The width of the solid material around the flexures and tab attachments, maybe around 3mm.\n*   `width_tab`: The width of the tabs on the base, for attaching to the rest of the robot. I'm thinking it should be around 4 to 6 mm.\n\n**Finger Dimensions:**\n\n*   `finger_length`: The total length of the finger (L1 + L2) between 80 and 150mm\n*   `finger_height`: The overall height of the finger segments, maybe between 15 and 25mm.\n*   `finger_depth`: The depth of the finger, maybe between 12 and 20mm.\n\n**Linkage Ratios:**\n\n*   `L_ratio`: The ratio of the length of the second segment to the first segment (L2/L1), should allow values between 0.5 and 1.\n*   `K_ratio`: The ratio of stiffness between the two flexure joints. This may require a calculation on your part because the flexure stiffness is related to its thickness, but can be approximated using K2/K1 which I would like to be between 1.5 and 3.\n\n**Flexure Geometry:**\n\n*   `K_length`: The length of the flexure joint itself, between 10 and 15mm.\n\n**Base Geometry:**\n\n*   `LB`: The length of the base of the finger, I'd like to be able to adjust this from 25 to 35mm.\n\n**Angular Offsets:**\n\n*   `T1`: The offset angle of the first flexure joint, adjustable between 15 and 45 degrees.\n*   `T2`: The offset angle of the second flexure joint, also adjustable between 15 and 45 degrees.\n\nI'd like the design to:\n\n1.  Use `difference()` operations to carve away material from a basic shape to generate the flexure joints\n2.  Have dogbone-like structures on the ends of the flexures.\n3. Have two tab features on the base to allow for a method of attachment.\n\nI need this to be a single OpenSCAD file, but I'm not worried about using any external libraries right now. I also think it would be helpful to have the `K1` and `K2` stiffness values calculated within the scad file based on the provided `K_ratio`. The `R1` and `R2` flexure radius is not a critical value at this time so we can keep `R1=8` and `R2 = R_ratio*R1`. \n\nCould you generate that for me?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Open Frame Ring/Bracelet Thing",
    "scad": "use <utils/build_plate.scad>\nsides = 4;\nsegments = 8;\nmesh_quality = 3;\ntube_diameter = 3;\nwidth_of_band = 10;\nheight_of_band = 10;\ninside_diameter = 60;\nrotate_all_sides_angle = 0;\nfull_twists_per_rotation = 0;\ntube_offset_per_segment = 0;\nsegment_twist_variation_angle = 0;\nsegment_twist_variation_periods = 2;\nface_twist_variation_angle = 0;\nface_twist_variation_periods = 2;\nface_rotational_variation_angle = 0;\nface_rotational_variation_periods = 2;\nsegment_spacing_variation_angle = 0;\nsegment_spacing_variation_periods = 2;\nz_shift_length = 0;\nz_shift_period = 2;\nradial_shift_length = 0;\nradial_shift_periods = 2;\nscale_segment_variation_max = 1;\nscale_segment_variation_min = 1;\nscale_segment_variation_periods = 4;\nlevel_of_solid_fill = \"hollow\";\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\ndist_from_center = inside_diameter/2+width_of_band/2+tube_diameter/2;\ntranslate([0,0,-(height_of_band+tube_diameter)/2])\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nunion(){\n\tfor (i=[0:segments-1]){\n\t\tif (level_of_solid_fill == \"partial fill\"){\n\t\t\tcolor(\"FireBrick\")\n\t\t\tmakeNSidedBlock(sides,\n\t\t\t\t\t\t\t\t \ttube_diameter,\n\t\t\t\t\t\t\t\t\twidth_of_band,\n\t\t\t\t\t\t\t\t\theight_of_band,\n\t\t\t\t\t\t\t\t\t360/segments*i,\n\t\t\t\t\t\t\t\t\tdist_from_center,\n\t\t\t\t\t\t\t\t\ti);\n\t\t}\n\t\telse {\n\t\t\tcolor(\"FireBrick\")\n\t\t\tmakeNSidedTube(sides,\n\t\t\t\t\t\t\t\t \ttube_diameter,\n\t\t\t\t\t\t\t\t\twidth_of_band,\n\t\t\t\t\t\t\t\t\theight_of_band,\n\t\t\t\t\t\t\t\t\t360/segments*i,\n\t\t\t\t\t\t\t\t\tdist_from_center,\n\t\t\t\t\t\t\t\t\ti);\n\t\t}\n\t\tif (level_of_solid_fill == \"solid fill\"){\n\t\t\tcolor(\"Red\")\n\t\t\tconnectTubesSolid(sides,\n\t\t\t\t\t\t\t\t tube_diameter,\n\t\t\t\t\t\t\t\t width_of_band,\n\t\t\t\t\t\t\t\t height_of_band,\n\t\t\t\t\t\t\t\t 360/segments*i,\n\t\t\t\t\t\t\t\t 360/segments*(i+1),\n\t\t\t\t\t\t\t\t dist_from_center,\n\t\t\t\t\t\t\t\t tube_offset_per_segment,\n\t\t\t\t\t\t\t\t segments,\n\t\t\t\t\t\t\t\t i);\n\t\t}\n\t\telse {\n\t\t\tcolor(\"Red\")\n\t\t\tconnectTubes(sides,\n\t\t\t\t\t\t\t\t tube_diameter,\n\t\t\t\t\t\t\t\t width_of_band,\n\t\t\t\t\t\t\t\t height_of_band,\n\t\t\t\t\t\t\t\t 360/segments*i,\n\t\t\t\t\t\t\t\t 360/segments*(i+1),\n\t\t\t\t\t\t\t\t dist_from_center,\n\t\t\t\t\t\t\t\t tube_offset_per_segment,\n\t\t\t\t\t\t\t\t segments,\n\t\t\t\t\t\t\t\t i);\n\t\t}\n\t}\n}\nmodule connectTubes(sides,tubeDiameter,width,height,angleStart,angleStop,distFromCenter,twist,segments,j){\n\tfor (i=[0:sides-1]){\n\t\thull(){\n\t\t\ttranslate([0,0,zShift(i+twist,j+1)])\n\t\t\trotate([0,0,angleStop+rotateAmt(i+twist,j+1)])\n\t\t\ttranslate([0,distFromCenter+radialShift(i+twist,j+1),0])\n\t\t\ttranslate([0,scaleBand(i+twist,j+1)*width/2*cos(twistAmt(i+twist,j+1)),scaleBand(i+twist,j+1)*height/2*sin(twistAmt(i+twist,j+1))])\n\t\t\tsphere(r=tubeDiameter/2,$fn = mesh_quality,center=true);\n\t\t\ttranslate([0,0,zShift(0,j)])\n\t\t\trotate([0,0,angleStart+rotateAmt(i,j)])\n\t\t\ttranslate([0,distFromCenter+radialShift(i,j),0])\n\t\t\ttranslate([0,scaleBand(i,j)*width/2*cos(twistAmt(i,j)),scaleBand(i,j)*height/2*sin(twistAmt(i,j))])\n\t\t\tsphere(r=tubeDiameter/2,$fn = mesh_quality,center=true);\n\t\t}\n\t}\n}\nmodule makeNSidedTube(sides,tubeDiameter,width,height,angle,distFromCenter,j){\n\ttranslate([0,0,zShift(0,j)])\n\tfor (i=[0:sides-1]){\n\t\thull(){\n\t\t\trotate([0,0,angle+rotateAmt(i,j)])\n\t\t\ttranslate([0,distFromCenter+radialShift(i,j),0])\n\t\t\ttranslate([0,scaleBand(i,j)*width/2*cos(twistAmt(i,j)),scaleBand(i,j)*height/2*sin(twistAmt(i,j))])\n\t\t\tsphere(r=tubeDiameter/2,$fn = mesh_quality,center=true);\n\t\t\trotate([0,0,angle+rotateAmt(i+1,j)])\n\t\t\ttranslate([0,distFromCenter+radialShift(i+1,j),0])\n\t\t\ttranslate([0,scaleBand(i+1,j)*width/2*cos(twistAmt(i+1,j)),scaleBand(i+1,j)*height/2*sin(twistAmt(i+1,j))])\n\t\t\tsphere(r=tubeDiameter/2,$fn = mesh_quality,center=true);\n\t\t}\n\t}\n}\nmodule connectTubesSolid(sides,tubeDiameter,width,height,angleStart,angleStop,distFromCenter,twist,segments,j){\n\thull(){\n\t\tfor (i=[0:sides-1]){\n\t\t\ttranslate([0,0,zShift(i+twist,j+1)])\n\t\t\trotate([0,0,angleStop+rotateAmt(i+twist,j+1)])\n\t\t\ttranslate([0,distFromCenter+radialShift(i+twist,j+1),0])\n\t\t\ttranslate([0,scaleBand(i+twist,j+1)*width/2*cos(twistAmt(i+twist,j+1)),scaleBand(i+twist,j+1)*height/2*sin(twistAmt(i+twist,j+1))])\n\t\t\tsphere(r=tubeDiameter/2,$fn = mesh_quality,center=true);\n\t\t\ttranslate([0,0,zShift(0,j)])\n\t\t\trotate([0,0,angleStart+rotateAmt(i,j)])\n\t\t\ttranslate([0,distFromCenter+radialShift(i,j),0])\n\t\t\ttranslate([0,scaleBand(i,j)*width/2*cos(twistAmt(i,j)),scaleBand(i,j)*height/2*sin(twistAmt(i,j))])\n\t\t\tsphere(r=tubeDiameter/2,$fn = mesh_quality,center=true);\n\t\t}\n\t}\n}\nmodule makeNSidedBlock(sides,tubeDiameter,width,height,angle,distFromCenter,j){\n\ttranslate([0,0,zShift(0,j)])\n\thull(){\n\t\tfor (i=[0:sides-1]){\n\t\t\trotate([0,0,angle+rotateAmt(i,j)])\n\t\t\ttranslate([0,distFromCenter+radialShift(i,j),0])\n\t\t\ttranslate([0,scaleBand(i,j)*width/2*cos(twistAmt(i,j)),scaleBand(i,j)*height/2*sin(twistAmt(i,j))])\n\t\t\tsphere(r=tubeDiameter/2,$fn = mesh_quality,center=true);\n\t\t}\n\t}\n}\nfunction twistAmt(side,segment) =\n\trotate_all_sides_angle\n\t+ 360*side/sides\n\t+ full_twists_per_rotation*360*segment/segments\n\t+ segment_twist_variation_angle/2*cos(segment_twist_variation_periods*360*segment/segments)\n\t+ face_twist_variation_angle/2*cos(face_twist_variation_periods*360*side/sides);\nfunction rotateAmt(side,segment) =\n\tface_rotational_variation_angle/2*cos(face_rotational_variation_periods*360*side/sides)\n\t+ segment_spacing_variation_angle/2*cos(segment_spacing_variation_periods*360*segment/segments);\nfunction zShift(side,segment) = z_shift_length/2*cos(z_shift_period*360*segment/segments);\nfunction radialShift(side,segment) = radial_shift_length/2*cos(radial_shift_periods*360*segment/segments);\nfunction scaleBand(side,segment) = (scale_segment_variation_max+scale_segment_variation_min)/2+(scale_segment_variation_max-scale_segment_variation_min)/2*cos(scale_segment_variation_periods*360*segment/segments);",
    "description": "Okay, I'm looking to design a kind of open, skeletal ring or bracelet, and I think I need a parametric OpenSCAD file to do it. The design is based on a series of connected tubes forming a circular structure. I want to be able to control a bunch of aspects of this design, including twisting and shifting of the tubes.\n\nHere's a breakdown of the features and parameters I'm envisioning:\n\n*   **Basic Structure:**\n    *   It should be built from a number of segments that form a circle.\n    *   Each segment should consist of tubes that form an n-sided shape around the circle. So, imagine a square or hexagon at each segment.\n    *   The segments should be connected together via the tubes which should be \"hull\"ed together.\n*   **Parameters:**\n    *   `sides`: The number of sides on each segment's polygon (e.g., 3 for a triangle, 4 for a square, 6 for a hexagon, etc.).\n    *   `segments`: The number of segments that make up the full circular structure.\n    *   `mesh_quality`: Controls the resolution of the spheres/tubes. I think a $fn value is best for this.\n    *   `tube_diameter`: The diameter of the tubes used to construct the frame.\n    *   `width_of_band`: The width of each polygon shape in the band. Imagine a square, this would be the length of the side.\n    *   `height_of_band`: The height of the sides of the polygons.\n    *   `inside_diameter`: The inner diameter of the entire bracelet/ring.\n    *   `rotate_all_sides_angle`: A base rotation angle for each polygon on a segment.\n    *   `full_twists_per_rotation`: The amount of twist applied to the tubes of a segment across a full rotation of the object.\n    *   `tube_offset_per_segment`: An offset between the tubes on two adjacent segments.\n    *   `segment_twist_variation_angle`: The variation in twist angle that should be applied across the different segments of the structure.\n    *   `segment_twist_variation_periods`: The number of periods of the twist variation applied to segments.\n    *   `face_twist_variation_angle`: The variation in twist angle that should be applied across each side of the polygon on the segment.\n    *   `face_twist_variation_periods`: The number of periods of the twist variation applied to the sides of the polygon.\n    *    `face_rotational_variation_angle`:  The variation in the rotational angle of each polygon face. \n    *    `face_rotational_variation_periods`: The number of periods of the rotational variation of each polygon face.\n    *   `segment_spacing_variation_angle`: The variation in the spacing of each segment.\n    *   `segment_spacing_variation_periods`: The number of periods of variation in spacing between segments.\n    *    `z_shift_length`:  The max length of the Z-shift variation.\n    *    `z_shift_period`: The number of periods for Z-shift variation between segments.\n    *    `radial_shift_length`: The max length of radial shift variation.\n    *    `radial_shift_periods`: The number of periods for the radial shift variation between segments.\n    *  `scale_segment_variation_max`: The maximum scale value for the scaling of band width.\n    *  `scale_segment_variation_min`: The minimum scale value for the scaling of band width.\n    *   `scale_segment_variation_periods`: The number of periods of variation for the width of each face.\n    *   `level_of_solid_fill`: Should have 3 options, `\"hollow\"`, `\"partial fill\"`, and `\"solid fill\"`.\n    *    `build_plate_selector`: This is just for display, not function. Should have options for a Replicator 2, Replicator, Thingomatic, or manual plate dimensions.\n    *   `build_plate_manual_x`: The x-dimension of the build plate for manual mode.\n    *   `build_plate_manual_y`: The y-dimension of the build plate for manual mode.\n*   **Functionality:**\n    *  The `makeNSidedTube` function should create the open tube shapes for each segment with the appropriate twist.\n    *  The `connectTubes` function should connect adjacent segments tubes using the hull() method in OpenSCAD.\n    *   The `makeNSidedBlock` function should build a solid n-sided \"block\" shape when level of fill is set to partial.\n    *   The `connectTubesSolid` function should connect adjacent segments using solid tubes for when solid fill is selected.\n    *   The `twistAmt`, `rotateAmt`, `zShift`, `radialShift`, and `scaleBand` functions should calculate the twisting, rotation, z-shift, radial shift, and scaling amount, respectively, using a cosine function for the variations.\n\nI think this is a lot, but it's what I'm hoping to achieve. I'd also like it if you could use the `build_plate` module from the `utils/build_plate.scad` library for a visual representation of the build plate.\n\nLet me know if you have any questions!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Message Keychain",
    "scad": "include <write/Write.scad>\nmessage = \"allenZ\";\nFont = \"write/orbitron.dxf\";\nfont_size = 10;\nfont_thickness = 5;\nstick_thickness = 3;\nstick_width = 8;\nhole_radius = 3;\nflat_bottom = 2;\ntranslate ([0,0,font_thickness/2])\nunion () {\nwrite(message,t=font_thickness, h=font_size, center = true, font = Font);\nif (flat_bottom == 1) translate ([0,0,-font_thickness/2+stick_thickness/2]) flatstickwithhole();\nif (flat_bottom == 2) flatstickwithhole();\n}\nmodule flatstickwithhole() {\ndifference () {\nunion () {\ntranslate ([-2,0,0]) cube ([font_size*len(message)/1.3, stick_width, stick_thickness],center=true);\ntranslate ([-2,0,0]) translate ([-font_size*len(message)/2.6,0,0]) cylinder (r=stick_width/2,h=stick_thickness,center=true,$fn=50);\n}\ntranslate ([-2,0,0]) translate ([-font_size*len(message)/2.6,0,0]) cylinder (r=hole_radius,h=stick_thickness+2,center=true,$fn=50);\n}\n}",
    "description": "Okay, I'm looking for an OpenSCAD design for a customizable keychain with a message on it, and I'd like it to be parametric so I can easily change various aspects of it. I have an example that kind of does what I want, but I want it to be a lot more flexible.\n\nHere's the basic idea: The keychain will have a text message on the front. This message should be customizable. The font of the text should also be customizable; I'd like to be able to use different DXF fonts. It's got to use the `write` module from the `Write.scad` library for text generation so that the fonts can be set. The text is extruded to a given depth/thickness, so it's 3D. Underneath the text, there should be a flat, supporting stick.\n\nI would like these parameters to be controllable by the user:\n\n*   **Message:** The text to be displayed on the keychain.\n*   **Font:** Which DXF font to use from the Write library.\n*   **Font Size:** The size of the font to use for the text.\n*   **Font Thickness:** The depth of the extruded text.\n*   **Stick Thickness:** The thickness of the flat stick support.\n*   **Stick Width:** The width of the flat stick support.\n*   **Hole Radius:** The radius of the hole for the keychain.\n*   **Flat Bottom Option:**  I'd like to choose whether the stick support goes all the way to the bottom edge of the text or if it's offset a little bit. (Maybe a boolean or a dropdown). When it's \"offset\", then it acts as a standard flat stick. When not offset, the stick is raised to meet the bottom edge of the text.\n    \n*   **Text Centering:** The text should always be centered in the x-dimension of the part, and the supporting stick should also be centered to the text.\n\nI also need:\n\n*   A small circular hole in the flat stick support on the end, for the keyring itself to go through. This hole should be a simple cylinder cut from the stick.\n*   The hole should always be centered along the stick width, and offset to the end of the stick.\n*   The length of the support stick should be proportional to the length of the text message.\n*   I'd prefer if the overall design was a single module/function.\n\nCould you generate the OpenSCAD code for this? Make sure to use the `write` module from the `Write.scad` library.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable House / Padlock Key  ",
    "scad": "use <utils/build_plate.scad>\nuse <write/Write.scad>\ntype_of_key = 0;\necho( \"type_of_key\" , type_of_key );\nstyle_of_key = 1;\necho ( \"style_of_key\" , style_of_key );\npolygon_count = 5;\necho( \"Print Quality / Polygon Count\" , polygon_count );\nkeycutcode = \"\";\necho ( \"keycutcode\" , keycutcode );\ncustom_key_text =\"\";\necho ( \"custom_key_text\" , custom_key_text );\ndummycall();\nbuild_plate_selector = 2;\nbuild_plate_manual_x = 100 + 0;\nbuild_plate_manual_y = 100 + 0;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\npi_value = 3.14159 *1;\necho ( \"Pi\" , pi_value );\nfudge_factor = 0 + 0.001;\necho ( \"fudge_factor\" , fudge_factor );\nmaxcylindercount = 10+0;\necho( \"maxcylindercount\" , maxcylindercount );\nkeycylindercount = [5,4];\necho ( \"keycylindercount\" , keycylindercount );\nnumber_cylinders = keycylindercount[ type_of_key ];\necho ( \"number_cylinders\" , number_cylinders );\nlayerthickness = [0.30,0.30];\necho ( \"layerthickness\" , layerthickness );\nlayer_thickness = layerthickness[ type_of_key ];\necho ( \"layer_thickness\" , layer_thickness );\nkeybladelength = [28.50,18.50];\necho ( \"keybladelength\" , keybladelength );\nblade_length = keybladelength[ type_of_key ];\necho ( \"blade_length\" , blade_length );\nkeybladeheight = [8.30,7.25];\necho ( \"keybladeheight\" , keybladeheight );\nblade_height = keybladeheight[ type_of_key ];\necho ( \"blade_height\" , blade_height );\nkeybladewidth = [(7*layer_thickness),(7*layer_thickness)];\necho ( \"keybladewidth\" , keybladewidth );\nblade_width = keybladewidth[ type_of_key ];\necho ( \"blade_width\" , blade_width );\ntexthsize = [5.5,4.5];\necho( \"texthsize\" , texthsize );\ntext_h_size = texthsize[ type_of_key ];\necho ( \"text_h_size\" , text_h_size );\nnumber_lookup = str( \"0123456789\" , \"\" );\necho( \"number_lookup\" ,  number_lookup );\nrandom_key_array = rands( 0 , 9.9 , maxcylindercount + 1 );\necho( \"random_key_array\" , random_key_array );\nrandom_key = str( floor( random_key_array[1] ) , floor( random_key_array[2] ) , floor( random_key_array[3] ) , floor( random_key_array[4] ) , floor( random_key_array[5] ) , floor( random_key_array[6] ) , floor( random_key_array[7] ) , floor( random_key_array[8] ) , floor( random_key_array[9] ) , floor( random_key_array[10] ) );\necho ( \"random_key: \" , random_key );\nkey_cut_code = str(keycutcode,random_key);\necho ( \"key_cut_code\" , key_cut_code );\nfrontslotheight = [1.65,0.00];\necho ( \"frontslotheight\" , frontslotheight );\nfrontslotyoffset = [0.60,0.00];\necho ( \"frontslotyoffset\" , frontslotyoffset );\nfrontslotzoffset = [(3*layer_thickness),0.00];\necho ( \"frontslotzoffset\" , frontslotzoffset );\nkey_fslot_height = frontslotheight[ type_of_key ];\necho ( \"key_fslot_height\" , key_fslot_height );\nkey_fslot_yoffset = frontslotyoffset[ type_of_key ];\necho ( \"key_fslot_yoffset\" , key_fslot_yoffset );\nkey_fslot_zoffset = frontslotzoffset[ type_of_key ];\necho ( \"key_fslot_zoffset\" , key_fslot_zoffset );\nbackslotheight = [1.35,1.35];\necho ( \"backslotheight\" , backslotheight );\nbackslotyoffset = [2.75,1.00];\necho ( \"backslotyoffset\" , backslotyoffset );\nbackslotzoffset = [-(2*layer_thickness),-(2*layer_thickness)];\necho ( \"backslotzoffset\" , backslotzoffset );\nbackslotangle = [210,210];\necho ( \"backslotangle\" , backslotangle );\nkey_bslot_height = backslotheight[ type_of_key ];\necho ( \"key_bslot_height\" , key_bslot_height );\nkey_bslot_yoffset = backslotyoffset[ type_of_key ];\necho ( \"key_bslot_yoffset\" , key_bslot_yoffset );\nkey_bslot_zoffset = backslotzoffset[ type_of_key ];\necho ( \"key_bslot_zoffset\" , key_bslot_zoffset );\nkey_bslot_angle = backslotangle[ type_of_key ];\necho ( \"key_bslot_angle\" , key_bslot_angle );\ntopslotheight = [3.50,3.50];\necho ( \"topslotheight\" , topslotheight );\ntopslotzoffset = [(4*layer_thickness),(3*layer_thickness)];\necho ( \"topslotzoffset\" , topslotzoffset );\nkey_tslot_height = topslotheight[ type_of_key ];\necho ( \"key_tslot_height\" , key_tslot_height );\nkey_tslot_zoffset = topslotzoffset[ type_of_key ];\necho ( \"key_tslot_zoffset\" , key_tslot_zoffset );\ntopslotangle = [30,30];\necho ( \"topslotangle\" , topslotangle );\nkey_tslot_angle = topslotangle[ type_of_key ];\necho ( \"key_tslot_angle\" , key_tslot_angle );\nkeytiptopangle = [58,50];\necho ( \"keytiptopangle\" , keytiptopangle );\nkey_tip_topangle = keytiptopangle[ type_of_key ];\necho ( \"key_tip_topangle\" , key_tip_topangle );\nkeytiptopyoffset = [(key_bslot_yoffset+key_bslot_height),(blade_height-key_tslot_height)];\necho( \"keytiptopyoffset\" , keytiptopyoffset );\nkey_tip_topyoffset = keytiptopyoffset[ type_of_key ];\necho ( \"key_tip_topyoffset\" , key_tip_topyoffset );\nkeytipbotangle = [225,225];\necho ( \"keytipbotangle\" , keytipbotangle );\nkey_tip_botangle = keytipbotangle[ type_of_key ];\necho ( \"key_tip_botangle\" , key_tip_botangle );\nkeytipbotyoffset = [key_bslot_yoffset,(blade_height/2)];\necho( \"keytipbotyoffset\" , keytipbotyoffset );\nkey_tip_botyoffset = keytipbotyoffset[ type_of_key ];\necho ( \"key_tip_botyoffset\" , key_tip_botyoffset );\nfirstcyloffset = [6.00,5.00];\necho ( \"firstcyloffset\" , firstcyloffset );\nfirst_offset = firstcyloffset[ type_of_key ];\necho ( \"first_offset\" , first_offset );\ncylseparation = [4.00,3.00];\necho ( \"cylseparation\" , cylseparation );\ncylinder_separation = cylseparation[ type_of_key ];\necho ( \"cylinder_separation\" , cylinder_separation );\ncylwidth = [2.00,1.00];\necho ( \"cylwidth\" , cylwidth );\nkey_cyl_width = cylwidth[ type_of_key ];\necho ( \"key_cyl_width\" , key_cyl_width );\npinstep = [(key_tslot_height / 10), (key_tslot_height / 10) ];\necho ( \"pinstep\" , pinstep );\npin_step = pinstep[ type_of_key ];\necho( \"pin_step\" , pin_step );\nstraightlength = [27,22];\necho ( \"straightlength\" , straightlength );\nstraight_length = straightlength[ type_of_key ];\necho ( \"straight_length\" , straight_length );\nlayersthick = [3,3];\necho ( \"layersthick\" , layersthick );\nlayers_thick = layersthick[ type_of_key ];\necho ( \"layers_thick\" , layers_thick );\ntextseparation = [3.8,3.5];\necho ( \"textseparation\" , textseparation );\ntext_separation = textseparation[ type_of_key ];\necho ( \"text_separation\" , text_separation );\nkeyringradius = [4.5,4.0];\necho ( \"keyringradius\" , keyringradius );\nkey_ring_radius = keyringradius[ type_of_key ];\necho ( \"key_ring_radius\" , key_ring_radius );\nkeyheaddiameter = [25,20];\necho ( \"keyheaddiameter\" , keyheaddiameter );\nkey_head_diameter = keyheaddiameter[ type_of_key ];\necho ( \"key_head_diameter\" , key_head_diameter );\necho ( \"start of the program\" );\n{\ndifference()\n{\nunion()\n{\ncreate_key_blade();\ncreate_key_shoulder();\ncreate_key_header();\n}\ncreate_key_ringhole();\ncreate_belfry_B();\n}\n}\necho (\"end of program\" );\nmodule cut_slots()\n{\necho ( \"cut the main key slots module\" );\necho ( \"front slot setup\" );\nfront_slot();\necho ( \"back slot setup\" );\nback_slot();\necho ( \"top slot setup\" );\ntop_slot();\n}\nmodule front_slot()\n{\necho ( \"front slot setup module\" );\ntranslate([-1,key_fslot_yoffset,key_fslot_zoffset]) cube( [ blade_length + 2 , key_fslot_height , blade_width ] );\n}\nmodule back_slot()\n{\necho ( \"back slot setup module\" );\ntranslate([-1,key_bslot_yoffset,key_bslot_zoffset])\n{\nunion()\n{\ncube( [ blade_length + 2 , key_bslot_height , blade_width ] );\nif ( key_bslot_angle != 0 )\n{\ntranslate([0,key_bslot_height,blade_width]) rotate( [key_bslot_angle,0,0] ) cube( [ blade_length + 2 , key_bslot_height , blade_width * 2 ] );\n}\n}\n}\n}\nmodule top_slot()\n{\necho ( \"top slot setup module\" );\ntranslate( [-1,blade_height-key_tslot_height,key_tslot_zoffset] )\n{\nunion()\n{\nrotate( [key_tslot_angle,0,0] ) cube( [ blade_length + 2 , blade_height , blade_width * 2 ] );\ncube( [ blade_length + 2 , blade_height  , blade_width * 2 ] );\n}\n}\n}\nmodule cut_the_tip()\n{\necho ( \"cut off the tip of the blade module\" );\nunion()\n{\ntranslate( [blade_length,key_tip_topyoffset,-1] ) rotate( [0,0,key_tip_topangle] ) cube( blade_height );\ntranslate( [blade_length,key_tip_botyoffset,-1] ) rotate( [0,0,key_tip_botangle] ) cube( blade_height );\n}\n}\nmodule cut_cylinders( total_cylinders = 1 )\n{\necho ( \"start of cylinder cutting loop for\" , total_cylinders , \"cylinders\" );\nfor ( cyl_loop = [1 : total_cylinders] )\n{\n\techo(str(\"cylinder:\" , cyl_loop , \" - key_cut_code:\" , key_cut_code[cyl_loop-1]));\n\tpin_position( what_str_digit = key_cut_code[cyl_loop-1] , what_cyl = cyl_loop );\n}\n}\nmodule key_cyl_cutout( cylinder_number = 1 )\n{\necho (\"Key Cylinder Cutout Shape for Cylinder:\" , cylinder_number );\nunion()\n{\ntranslate([(first_offset-(key_cyl_width/2)) + ((cylinder_number-1)*cylinder_separation) ,blade_height,-1]) cube([key_cyl_width,blade_height,blade_width+2 ]);\ntranslate([(first_offset-(key_cyl_width/2)) + ((cylinder_number-1)*cylinder_separation),blade_height,-1]) rotate( [0 , 0 , 45] )cube([blade_height,blade_height,blade_width+2]);\ntranslate([(first_offset+(key_cyl_width/2)) + ((cylinder_number-1)*cylinder_separation),blade_height,-1]) rotate( [0 , 0 , 45] )cube([blade_height,blade_height,blade_width+2]);\n}\n}\nmodule pin_position( what_str_digit = \"0\" , what_cyl = 1 )\n{\necho( \"Cylinder: \" , what_cyl , \"Digit: \" , what_str_digit );\nfor ( value_lookup = [1:9] )\n{\nif ( what_str_digit == number_lookup[value_lookup] )\n{\necho( \"match found: \" , value_lookup , what_str_digit );\ntranslate([0,(-1*(value_lookup*pin_step)),0]) key_cyl_cutout(cylinder_number=what_cyl);\n}\n}\n}\nmodule straight_key_header( sheader_length = 25 , sheader_text = \"0123456789\" )\n{\necho ( \"sheader_length\" , sheader_length );\necho ( \"sheader_text\" , sheader_text );\ntranslate([(-1*sheader_length)+fudge_factor,0,0])\n{\nunion()\n{\ncube( [ sheader_length , blade_height  , blade_width ] );\nfor ( sdigit_loop = [0:number_cylinders-1] )\n{\n\techo ( \"sdigit_loop\" , sdigit_loop , \"text\" , sheader_text[sdigit_loop] );\n\ttranslate([(text_separation+(text_separation*sdigit_loop)),1,blade_width-fudge_factor]) write(sheader_text[sdigit_loop],h=text_h_size,t=(layer_thickness*layers_thick));\n}\n}\n}\n}\nmodule round_key_header( rheader_diameter = 25 , rheader_text = \"0123456789\" )\n{\necho ( \"rheader_diameter\" , rheader_diameter );\necho ( \"rheader_text\" , rheader_text );\ntranslate([(-1*rheader_diameter)+fudge_factor,0,0])\n{\ntranslate([(rheader_diameter/2),(blade_height/2),0]) cylinder( h=blade_width , r=rheader_diameter/2 , center = false , $fn=polygon_count);\nif ( polygon_count > 4 )\n{\nrotate([0,0,90]) union()\n{\nfor ( rdigit_loop = [0:number_cylinders-1] )\n{\n\techo ( \"rdigit_loop\" , rdigit_loop , \"text\" , rheader_text[rdigit_loop] );\n\ttranslate([(text_separation*(rdigit_loop+1))+(blade_height/2)-(rheader_diameter/2),-(rheader_diameter/2)-(text_h_size),blade_width-fudge_factor]) write(rheader_text[rdigit_loop],h=text_h_size,t=(layer_thickness*layers_thick));\n}\n}\n}\n}\n}\nmodule create_text( text_to_print=\"Belfry 6050\" )\n{\necho ( \"text_to_print\" , text_to_print );\nwrite(text_to_print,h=text_h_size,t=(layer_thickness*layers_thick));\n}\nmodule dummycall()\n{\necho ( \"dummycall\" );\n}\nmodule five_cyl_housekey_shoulder()\n{\ntranslate([fudge_factor-blade_height,-(blade_height*0.25),0])\ncube([blade_height,(blade_height*1.5),blade_width]);\n}\nmodule four_cyl_padlock_shoulder()\n{\ntranslate([fudge_factor-blade_height,0,0])\ncube([blade_height,(blade_height*1.25),blade_width]);\n}\nmodule create_key_blade()\n{\necho ( \"start of the create_key_blade module\" );\necho ( \"start of the difference function\" );\ndifference()\n{\necho ( \"main blade setup\" );\ncube( [ blade_length , blade_height , blade_width ] );\necho ( \"cut the main key slots\" );\ncut_slots()\necho ( \"cut off the tip of the blade\" );\ncut_the_tip();\necho ( \"start cutting\" , number_cylinders , \"cylinders\" );\ncut_cylinders( total_cylinders = number_cylinders );\n}\n}\nmodule create_key_shoulder()\n{\necho ( \"start of create_key_shoulder module\" );\nif ( style_of_key > 0 )\n{\n\tif ( type_of_key == 0 )\n\t\tfive_cyl_housekey_shoulder();\n\tif ( type_of_key == 1 )\n\t\tfour_cyl_padlock_shoulder();\n}\n}\nmodule create_key_ring_hole()\n{\necho( \"key_ring_radius for cylinder\" , key_ring_radius );\nif ( style_of_key > 0 )\n{\n\tcylinder( h=blade_width*3 , r=key_ring_radius , center = true , $fn=polygon_count);\n}\n}\nmodule create_key_header()\n{\nif ( style_of_key == 0 )\n{\nstraight_key_header(sheader_length=straight_length,sheader_text=str(custom_key_text,key_cut_code));\n}\nif ( style_of_key == 1 )\n{\nround_key_header(rheader_diameter=key_head_diameter,rheader_text=str(custom_key_text,key_cut_code));\n}\n}\nmodule create_key_ringhole()\n{\nif ( style_of_key > 0 )\n{\nif ( polygon_count == 5 )\n{\n\tif ( type_of_key == 0 )\n{\n\ttranslate([(-1*(key_head_diameter))+(key_ring_radius*2)-2,(blade_height/2),0]) create_key_ring_hole();\n}\nelse\n{\n\ttranslate([((-1*(key_head_diameter))+ key_ring_radius + 2 ),(blade_height/2),0]) create_key_ring_hole();\n}\n}\nelse\n{\n\ttranslate([((-1*(key_head_diameter))+ key_ring_radius + 2 ),(blade_height/2),0]) create_key_ring_hole();\n}\n}\n}\nmodule create_belfry_B()\n{\nif ( style_of_key == 0 )\n{\n\ttranslate([-15,0.5,(layer_thickness*3)]) rotate([0,180,270])\n{\n\tif (type_of_key == 0 )\n{\n\t\twrite(\"B\",h=11,t=layer_thickness*4);\n}\n\tif (type_of_key == 1)\n{\n\t\twrite(\"B\",h=10,t=layer_thickness*4);\n}\n}\n}\nif ( style_of_key == 1 )\n{\n\tif ( type_of_key == 0 )\n{\n\t\ttranslate([-1.25,7,(layer_thickness*3)]) rotate([0,180,90]) write(\"B\",h=11,t=(layer_thickness*4));\n}\n\tif ( type_of_key == 1 )\n{\n\t\ttranslate([-0.75,6,(layer_thickness*3)]) rotate([0,180,90]) write(\"B\",h=8,t=(layer_thickness*4));\n}\n}\n}",
    "description": "Okay, I'd like to design a parametric key generator that can handle both 5-cylinder house keys and 4-cylinder padlock keys. I want to be able to customize several aspects of the key.\n\nHere are the key parameters I'd like to control:\n\n1.  **Key Type:** I need a dropdown to select whether to create a \"5 Cylinder House Key\" or a \"4 Cylinder Pad Lock\".\n\n2.  **Key Header Style:** I want a dropdown to choose between a \"Straight Header\" or a \"Round Header\". The round header's shape will depend on the \"Polygon Count\" setting.\n\n3.  **Print Quality / Polygon Count:** This should be a dropdown or slider to control the polygon count used for creating the round header, ranging from 4 to at least 32 (e.g., options like 4, 5, 6, 7, 8, 9, 10, 11, 12, 16, 20, 24, 28, 32). This impacts the roundness of the key header.\n\n4.  **Key Cutting Code:** This should be a text field where I can enter the cut code for the key. The code should be a string of digits (0-9), and the length will be determined by the type of key (5 digits for house key, 4 for padlock key). If left blank, a random key cut should be generated.\n\n5.  **Custom Key Text:** This should be a text field for additional custom text that will print on the key in place of or in addition to the key cut code.\n\nThe design should also include these features, which shouldn't need to be user-configurable parameters but should still be controllable by the parameters above:\n\n*   **Build Plate:** It needs to use the `build_plate.scad` library (I have that file already, so you don't need to include it) to show a build plate for a Replicator 2, Replicator, Thingomatic or manual dimensions.\n*   **Text Printing:** It needs to use the `Write.scad` library (I have that file too) to print text on the key.\n*   The key blades should have front, back, and top slots/grooves cut into them. These will be different for the house and padlock keys\n*   The tip of the key blade should have a custom cut shape that will be different for the house and padlock keys\n*   The key pin cuts should be along the top of the key blade with a step value determined by dividing the key top slot height by 10\n*   The design should automatically adjust the cylinder positions, lengths, heights, and widths based on the type of key selected (house or padlock).\n*   There should be a key ring hole in the header and its location should be adjustable based on whether or not it's a round or straight key\n*   There should be a printed 'B' for the author on the back of the key, and its placement will also depend on key type and key header style.\n\nEssentially, I want a single parametric OpenSCAD file that handles all of this. I am using `build_plate.scad` and `Write.scad`.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Measuring Spoons",
    "scad": "include <write/Write.scad>\nType=0;\nUnits=2;\nSize=1;\nLabel=\"Spoon!\";\nFont = \"write/orbitron.dxf\";\nThickness=3;\nTextThickness=1.5*1;\nHandleWidth=15*1;\nHandleLength=90*1;\nTextHeight=6*1;\nHoleDiameter=5*1;\nConversion=[1,29.5735,4.92892,14.7868,28.4131,5.91939,17.7582];\nVolume=Size*Conversion[Units];\nInsideRadius=pow((3 * Volume) / (2 * 3.14), 1/3)*10;\nOutsideRadius=InsideRadius+Thickness;\nConeBottomRadius=OutsideRadius*.5;\nConeTopRadius=OutsideRadius*.85;\nConeHeight=OutsideRadius*.5;\nif (Type==0)\n{\nrotate (a = [0, 0, 45])\n{\ndifference()\n{\nunion()\n{\n\ttranslate([HandleLength/2 - HandleWidth*.75 -\n\t  len(Label)*TextHeight*.125*5.5/2,0,Thickness - 0.001 + TextThickness/2])\n\t  write(Label,t=TextThickness,h=TextHeight,center=true,font=Font);\n\ttranslate([0,0,Thickness/2])\n\t  cube([HandleLength-HandleWidth, HandleWidth, Thickness], center=true);\n\ttranslate([HandleLength/2 - HandleWidth/2 + 0.001, 0, Thickness/2])\n\t  cylinder(h=Thickness, r=HandleWidth/2, center=true);\n\ttranslate([0 - (HandleLength/2 - HandleWidth/2 + 0.001), 0, Thickness/2])\n\t  cylinder(h=Thickness, r=HandleWidth/2, center=true);\n\ttranslate([0 - (HandleLength/2 - HandleWidth/2 + 0.001), 0, ConeHeight/2])\n\t\tcylinder(h=ConeHeight, r1=ConeBottomRadius, r2=ConeTopRadius,\n\t\t\tcenter=true);\n\tdifference()\n\t{\n\t\ttranslate([0 - (HandleLength/2 - HandleWidth/2), 0, OutsideRadius])\n\t\t  sphere(r=OutsideRadius, $fn=50);\n\t\ttranslate([0 - (HandleLength/2 - HandleWidth/2), 0, OutsideRadius*2.5])\n\t\t  cube([OutsideRadius*3, OutsideRadius*3, OutsideRadius*3],\n\t\t\t center=true);\n\t}\n}\ntranslate([0 - (HandleLength/2 - HandleWidth/2), 0,\n\tOutsideRadius+.002])\n\t\tsphere(r=InsideRadius, $fn=50);\ntranslate([HandleLength/2 - HandleWidth/2 + 0.002, 0, Thickness/2])\n  cylinder(h=Thickness*2, r=HoleDiameter/2, $fn=15, center=true);\n}\n}\n}\nif (Type==1)\n{\ntranslate([0,0,OutsideRadius])\n{\nrotate (a = [180, 0, 45])\n{\ndifference()\n{\nunion()\n{\n\trotate (a = [180, 0, 0])\n\t{\n\t\ttranslate([HandleLength/2 - HandleWidth*.75 -\n\t  \t\t\tlen(Label)*TextHeight*.125*5.5/2,0,Thickness - 0.001 +\n\t\t\t\tTextThickness/2 - OutsideRadius])\n\t  \t\twrite(Label,t=TextThickness,h=TextHeight,center=true,font=Font);\n\t}\n\ttranslate([0,0,OutsideRadius - Thickness/2])\n\t  cube([HandleLength-HandleWidth, HandleWidth, Thickness], center=true);\n\ttranslate([HandleLength/2 - HandleWidth/2 + 0.001, 0, OutsideRadius - Thickness/2])\n\t  cylinder(h=Thickness, r=HandleWidth/2, center=true);\n\tdifference()\n\t{\n\t\ttranslate([0 - (HandleLength/2 - HandleWidth/2), 0, OutsideRadius])\n\t\t  sphere(r=OutsideRadius, $fn=50);\n\t\ttranslate([0 - (HandleLength/2 - HandleWidth/2), 0, OutsideRadius*2.5])\n\t\t  cube([OutsideRadius*3, OutsideRadius*3, OutsideRadius*3],\n\t\t\t center=true);\n\t}\n}\ntranslate([0 - (HandleLength/2 - HandleWidth/2), 0,\n\tOutsideRadius+.002])\n\t\tsphere(r=InsideRadius, $fn=50);\ntranslate([HandleLength/2 - HandleWidth/2 + 0.002, 0, OutsideRadius - Thickness/2])\n  cylinder(h=Thickness*2, r=HoleDiameter/2, $fn=15, center=true);\n}\n}\n}\n}\nif (Type==2)\n{\nrotate (a = [0, 0, 45])\n{\ndifference()\n{\nunion()\n{\n\ttranslate([HandleLength/2 - HandleWidth*.75 -\n\t  len(Label)*TextHeight*.125*5.5/2,0,Thickness - 0.001 + TextThickness/2])\n\t  write(Label,t=TextThickness,h=TextHeight,center=true,font=Font);\n\ttranslate([0,0,Thickness/2])\n\t  cube([HandleLength-HandleWidth, HandleWidth, Thickness], center=true);\n\ttranslate([HandleLength/2 - HandleWidth/2 + 0.001, 0, Thickness/2])\n\t  cylinder(h=Thickness, r=HandleWidth/2, center=true);\n\ttranslate([0 - (HandleLength/2 - HandleWidth/2 + 0.001), 0, Thickness/2])\n\t  cylinder(h=Thickness, r=HandleWidth/2, center=true);\n}\ntranslate([HandleLength/2 - HandleWidth/2 + 0.002, 0, Thickness/2])\n  cylinder(h=Thickness*2, r=HoleDiameter/2, $fn=15, center=true);\n}\n}\n}\nif (Type==3)\n{\n\tdifference()\n\t{\n\t\ttranslate([0,0,13/2])\n\t\t\tcylinder(h=13, r=4, $fn=15, center=true);\n\t\ttranslate([0,0,13/2])\n\t\t\tcylinder(h=15, r=1.15, $fn=15, center=true);\n\t}\n}",
    "description": "Okay, I'm looking to design a set of measuring spoons, and I'd like a parametric OpenSCAD file to do it. I've seen some existing designs, and I want to incorporate the best parts of them, plus add a few improvements.\n\nSpecifically, I want the user to be able to select between a few different types of spoons:\n\n1.  **Flat on Counter:** These are spoons that sit flat on a surface without tipping over.\n2.  **Nestable:** These are spoons designed to nest inside each other for compact storage. This type will likely need support material during printing.\n3. **Sweep:** A flat piece that you can use to level off a measure.\n4.  **Ring Coupler:** A small, simple ring to hold all the spoons together.\n\nThe user should be able to select the units for the spoon measurements. I'd like the options to be:\n\n*   Milliliters\n*   U.S. Ounces\n*   U.S. Teaspoons\n*   U.S. Tablespoons\n*   Imperial Ounces\n*   Imperial Teaspoons\n*   Imperial Tablespoons\n\nThe user should also be able to specify the *size* of the spoon in the selected units (e.g., if the user selects \"U.S. Teaspoons\" and enters \"1\", they'd get a 1 teaspoon measuring spoon).\n\nI also want the option for a custom text label to be included on the handle. The font should be customizable and use the \"write/Write.scad\" library, particularly the following fonts: \"write/orbitron.dxf\", \"write/Letters.dxf\" and \"write/BlackRose.dxf\"\n\nI'd like a few advanced parameters too, which will help with customizability:\n\n*   **Text Thickness:** The height of the raised text label.\n*   **Handle Width:** The width of the spoon handle.\n*   **Handle Length:** The total length of the handle (including rounded ends).\n*   **Text Height:** The character height of the label.\n*   **Hole Diameter:** The diameter of an optional hole at the end of the handle.\n*   **Thickness:** Wall thickness of the spoon bowl and handle.\n\nThe script should calculate the required dimensions of the bowl based on the selected unit and size. For the bowl, it should make a basic sphere, truncated on the top, with the bottom a cone shape. Also, make sure there is the appropriate conversion rate for all units, particularly for U.S. and Imperial measurements of teaspoons, tablespoons, and ounces.\n\nFinally, can you make sure the \"nestable\" type is designed so it can sit upside down on a surface? I've noticed many designs for this type of spoon will not do this, and I'd like to use this feature.\n\nI need a parametric design so that these parameters can be changed easily by the user. Im not looking to include any example values to start with.\n\nI will be using the `write/Write.scad` library for the text labels. Please make sure to incorporate that properly in the generated file.\n\nCould you generate that OpenSCAD file for me?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Laird's Customizable Collapsing Cup",
    "scad": "use <write/Write.scad>;\nuse <utils/build_plate.scad>\npi=3.1415926*1;\ncup=236.588237*1000;\n$fn=64*1;\npreview=0;\ndiameter=60;\nh=20;\nnumRings = 3;\nspacing=4;\ntt=2;\ng=0.6;\nhalf=0;\nhandle=2;\nhandleSize = 10;\nholeSize=2.5;\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nfsize=5;\ns=spacing+tt;\nfullHeight=numRings*(h-tt);\necho(\"Height = \",fullHeight,\" mm.\");\nor=diameter/2;\nir=or-(numRings-1)*s;\necho(str(\"Outer radius \",or,\" and inner radius \",ir,\".\"));\necho(str(\"ir=\",ir,\" and or=\",or,\".\"));\nv=(1/3)*pi*fullHeight*(ir*ir+or*or+ir*or);\necho(str(\"vol=\",v,\".\"));\ncups=v/cup;\nlabel3=str(floor(cups*100+.5)/100,\" Cups\");\necho(label3);\nmodule ring(radius, thickness, height, slant) {\n\tdifference() {\n\t\tcylinder(r=radius+thickness, h=height);\n\t\ttranslate([0,0,-.1]) cylinder(r=radius, h=height+.2);\n\t\t}\n\t}\nmodule ring2(ir1, or1, ir2, or2, height) {\n\tdifference() {\n\t\tcylinder(r1=ror1, r2=or2, h=height);\n\t\ttranslate([0,0,-.01]) cylinder(r1=ir1, r2=ir2, h=height+.02);\n\t\t}\n\t}\nmodule writeText() {\n\ttranslate([0,fsize,0]) write(label1,center=true,h=fsize,t=tt*2/3);\n\ttranslate([0,-fsize,0]) write(label2,center=true,h=fsize,t=tt*2/3);\n\t}\no=tt/2;\nb=o/2;\nh1=0;\nh2=o;\nh3=h2+b;\nh4=h3+b;\nh8=h;\nh7=h8-o;\nh6=h7-b;\nh5=h6-b;\nr1=g;\nr2=g+o;\nr4=s;\nr3=s-tt;\nr5=s+b;\nr6=r4+o;\npoints = [[r2,h1],[r1,h2],[r2,h4],[r3,h4],[r3,h8],[r6,h8],\n\t\t\t\t[r4,h7],[r5,h6],[r4,h5],[r4,h4],[r5,h3],[r4,h2],[r6,h1],[r2,h1]];\nmodule cup() {\n\tdifference() {\n\t\tunion() {\n\t\t\tcylinder(r=ir-tt,h=tt);\n\t\t\techo(str(\"Rings from \",ir,\" to \",or,\" step \",s,\".\"));\n\t\t\tfor (rad=[ir:s:or]) {\n\t\t\t\ttranslate([0,0,preview*((rad-ir)/s)*(h-tt)]) rotate_extrude() translate([rad-s,0,0])\n\t\t\t\t\tpolygon(points,convexity=10);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\ttranslate([0,0,preview*(fullHeight-h+tt)]) difference() {\n\t\ttranslate([or,0,0]) {\n\t\t\tif (handle==1) translate([0,-tt,0]) cube([handleSize,2*tt,h]);\n\t\t\tif (handle==2) difference() {\n\t\t\t\tcylinder(r=handleSize, h=h);\n\t\t\t\ttranslate([tt+holeSize, 0, -.1]) cylinder(r=holeSize, h=h+.2);\n\t\t\t\ttranslate([-or,0,-1]) cylinder(r=or-o, h=h+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\ndifference() {\n\tcup();\n\tif (half) translate([-200,-200,-1]) cube([400,200,100]);\n\t}\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);",
    "description": "Okay, I need a custom, collapsible measuring cup designed in OpenSCAD. I've seen a design that uses rings that slide inside of each other, which is exactly what I'm looking for.\n\nHere are the key features I want in the design, and I'd like them to be adjustable parameters:\n\n**Overall Structure:**\n\n*   **Collapsible Rings:** The cup should be made of multiple concentric rings that slide inside of each other, allowing the cup to collapse flat for storage and expand for use.\n*   **Captive Rings:** The rings need to be designed so they cannot separate from each other, even when fully expanded or collapsed. They should \"snap\" into place at both the collapsed and expanded positions. I want to avoid the rings from rattling around loosely.\n*  **Volume**: I want to be able to set a desired cup volume, and have that affect the ring sizes.\n\n**Parameters:**\n\n*   **`diameter`**: The inside diameter of the largest (outermost) ring in millimeters. I'd like to be able to set this.\n*   **`ringHeight`**: The height of each individual ring when the cup is collapsed. This can be adjusted. I need this to be adjustable.\n*   **`numRings`**: The number of rings making up the cup. I need to be able to adjust this as well.\n*   **`wallSpacing`**: The space between the outer wall of one ring and the inner wall of the next larger ring (when expanded). This determines the cup's expanded diameter and needs to be an adjustable value.\n*   **`wallThickness`**: The thickness of each ring wall.\n*   **`gap`**: The clearance (or gap) between parts, which is also important for printing. This needs to be adjustable to accommodate different printer tolerances.\n*   **`handleType`**: An option to choose different handle types. It would be great to have options for \"none\", a \"vertical\" handle (a simple straight bar on the side), or a \"round\" handle (a loop for hanging).\n*   **`handleSize`**: If a handle is included, the size of the handle (width of a vertical bar, or radius of a circle).\n*   **`holeSize`**: If a round handle is chosen, the radius of the hole within the handle to hang the cup from.\n*  **`cupVolume`**: The target volume in cubic millimeters of the cup.\n* **`font_size`**: The size of any label text printed.\n\n**Other considerations:**\n\n*   **Smoothness:** The code should allow for setting `$fn` for smooth circles.\n*   **Preview Mode:** A \"preview\" mode to stretch the rings out, showing them in a stacked-but-not-collapsed view. This would help show how the rings fit together.\n\n**Libraries:**\n* The `write/Write.scad` library for creating labels.\n* The `utils/build_plate.scad` library for including a build plate.\nI don't need the specific files of those libraries, just that the code uses them.\n\nI'd like to have the cup volume displayed as a label, including the unit \"Cups\" and rounded to two decimal places.\n\nI'd also like the option to cut a cross-section in half for checking the design.\n\nPlease provide the complete OpenSCAD code, including all parameter definitions.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Glasses",
    "scad": "use <write/Write.scad>\nSquare_or_Circle=0;\nFrame_Length=70;\nFrame_Border_Width=12;\nRounded_shape=10;\nFrame_Height=50;\nFrame_Depth=4;\nNose_Frame_Length=30;\nNose_Frame_Placement=12;\nEar_Frame_Length=125;\nEar_Frame_Height=8;\nEar_Frame_Distance=2;\nright_text=\"Makerbot\";\nleft_text= \"Glasses\";\nText_Depth=2;\nText_Height=5;\nText_Distance=18;\nmodule createMeniscus(h,radius)\ndifference(){\n   translate([radius/2+0.1,radius/2+0.1,0]){\n      cube([radius+0.2,radius+0.1,h+0.2],center=true);\n   }\n   cylinder(h=h+0.2,r=radius,$fn = 25,center=true);\n}\nmodule roundCornersCube(x,y,z,r)\ndifference(){\n   cube([x,y,z], center=true);\ntranslate([x/2-r,y/2-r]){\n      rotate(0){\n         createMeniscus(z,r);\n      }\n   }\n   translate([-x/2+r,y/2-r]){\n      rotate(90){\n         createMeniscus(z,r);\n      }\n   }\n      translate([-x/2+r,-y/2+r]){\n      rotate(180){\n         createMeniscus(z,r);\n      }\n   }\n      translate([x/2-r,-y/2+r]){\n      rotate(270){\n         createMeniscus(z,r);\n      }\n   }\n}\nif (Square_or_Circle==0)\n{\ndifference()\n{\nrotate([90,0,0])roundCornersCube(Frame_Length,Frame_Height,Frame_Depth,Rounded_shape);\nrotate([90,0,0])roundCornersCube(Frame_Length-Frame_Border_Width,Frame_Height-Frame_Border_Width, Frame_Depth, Rounded_shape);\n}\ndifference()\n{\ntranslate([Frame_Length+Nose_Frame_Length,0,0])rotate([90,0,0])roundCornersCube(Frame_Length,Frame_Height,Frame_Depth,Rounded_shape);\ntranslate([Frame_Length+Nose_Frame_Length,0,0])rotate([90,0,0])roundCornersCube(Frame_Length-Frame_Border_Width,Frame_Height-Frame_Border_Width, Frame_Depth, Rounded_shape);\n}\ntranslate([Frame_Length/2-Frame_Border_Width/2,-Frame_Depth/2,Frame_Height/2-Frame_Border_Width/2-Nose_Frame_Placement])cube([Nose_Frame_Length+Frame_Border_Width,Frame_Depth,Frame_Border_Width/2]);\n}\nelse\n{\ndifference()\n{\nrotate([270,0,0])linear_extrude(height=Frame_Depth)circle(Frame_Length/2);\nrotate([270,0,0])linear_extrude(height=Frame_Depth)circle(Frame_Length/2-Frame_Border_Width/2);\n}\ndifference()\n{\nrotate([270,0,0])translate([Frame_Length+Nose_Frame_Length,0,0])linear_extrude(height=Frame_Depth)circle(Frame_Length/2);\nrotate([270,0,0])translate([Frame_Length+Nose_Frame_Length,0,0])linear_extrude(height=Frame_Depth)circle(Frame_Length/2-Frame_Border_Width/2);}\ntranslate([Frame_Length/2-Frame_Border_Width/2,0,Frame_Height/2-Frame_Border_Width/2-Nose_Frame_Placement])cube([Nose_Frame_Length+Frame_Border_Width,Frame_Depth,Frame_Border_Width/2]);\n}\nEar_Frame_Angle=6;\ntranslate([-Frame_Length/2,Frame_Depth/2,Frame_Height/2-Ear_Frame_Height-Ear_Frame_Distance])\ncube([Frame_Border_Width/2,Ear_Frame_Length,Ear_Frame_Height]);\ntranslate([-Frame_Length/2,Frame_Depth/2+Text_Distance,Frame_Height/2-Ear_Frame_Distance-Ear_Frame_Height/2])rotate([90,0,270])\nwrite(right_text, t=Text_Depth, h=Text_Height, center=true);\nhull()\n{\ntranslate([-Frame_Length/2,Frame_Depth/2+Ear_Frame_Length,Frame_Height/2-Ear_Frame_Height-Ear_Frame_Distance])cube([Frame_Border_Width/2,0.01,Ear_Frame_Height]);\nrotate([0,90,0])rotate([0,0,360-Ear_Frame_Angle])translate([Frame_Height/2-Ear_Frame_Height-Ear_Frame_Distance-10,Ear_Frame_Length+15,-Frame_Length/2+1])rotate([360+Ear_Frame_Angle,0,0])linear_extrude(height=Frame_Border_Width/2)circle(2.5);\n}\nhull()\n{\nrotate([0,90,0])rotate([0,0,360-Ear_Frame_Angle])translate([Frame_Height/2-Ear_Frame_Height-Ear_Frame_Distance-10,Ear_Frame_Length+15,-Frame_Length/2+1])rotate([360+Ear_Frame_Angle,0,0])linear_extrude(height=Frame_Border_Width/2)circle(2.5);\nrotate([0,90,0])rotate([0,0,360-Ear_Frame_Angle])translate([Frame_Height/2-Ear_Frame_Height-Ear_Frame_Distance+4,Ear_Frame_Length+25,-Frame_Length/2+2])rotate([360+Ear_Frame_Angle,0,0])linear_extrude(height=Frame_Border_Width/2)circle(3);\n}\nEar_Frame_Angle=6;\ntranslate([1.5*Frame_Length+Nose_Frame_Length-Frame_Border_Width/2,Frame_Depth/2,Frame_Height/2-Ear_Frame_Height-Ear_Frame_Distance])cube([Frame_Border_Width/2,Ear_Frame_Length,Ear_Frame_Height]);\ntranslate([1.5*Frame_Length+Nose_Frame_Length,Frame_Depth/2+Text_Distance,Frame_Height/2-Ear_Frame_Height/2-Ear_Frame_Distance])rotate([90,0,90])\nwrite(left_text, t=Text_Depth, h=Text_Height, center=true);\nhull()\n{\ntranslate([1.5*Frame_Length+Nose_Frame_Length-Frame_Border_Width/2,Frame_Depth/2+Ear_Frame_Length,Frame_Height/2-Ear_Frame_Height-Ear_Frame_Distance])cube([Frame_Border_Width/2,0.01,Ear_Frame_Height]);\nrotate([0,90,0])rotate([0,0,360-Ear_Frame_Angle])translate([Frame_Height/2-Ear_Frame_Height-Ear_Frame_Distance-10,Ear_Frame_Length+15,Frame_Length*1.5+Nose_Frame_Length-Frame_Border_Width+4])rotate([360+Ear_Frame_Angle,0,0])linear_extrude(height=Frame_Border_Width/2)circle(2.5);\n}\nhull()\n{\nrotate([0,90,0])rotate([0,0,360-Ear_Frame_Angle])translate([Frame_Height/2-Ear_Frame_Height-Ear_Frame_Distance-10,Ear_Frame_Length+15,Frame_Length*1.5+Nose_Frame_Length-Frame_Border_Width+4])rotate([360+Ear_Frame_Angle,0,0])linear_extrude(height=Frame_Border_Width/2)circle(2.5);\nrotate([0,90,0])rotate([0,0,360-Ear_Frame_Angle])translate([Frame_Height/2-Ear_Frame_Height-Ear_Frame_Distance+4,Ear_Frame_Length+25,Frame_Length*1.5+Nose_Frame_Length-Frame_Border_Width+2])rotate([360+Ear_Frame_Angle,0,0])linear_extrude(height=Frame_Border_Width/2)circle(3);\n}",
    "description": "Okay, I'd like to design some glasses, and I need a parametric OpenSCAD file to do it. I'm looking for something that allows me to choose between square/rectangular frames with rounded corners or circular frames. Here are the specific parameters I need to control:\n\n**Frame Shape & Size:**\n\n*   **`Square_or_Circle`**: A boolean (0 or 1) or a dropdown to select between square/rectangular frames (0) or circular frames (1).\n*   **`Frame_Length`**: The overall length of one frame (before nose bridge) in millimeters.\n*   **`Frame_Border_Width`**: The thickness of the frame material.\n*   **`Rounded_shape`**: When using square/rectangular frames, the radius of the rounded corners.\n*   **`Frame_Height`**: When using square/rectangular frames, the height of the frame. This parameter should be ignored when using circular frames.\n*   **`Frame_Depth`**: The thickness/depth of the frame material.\n\n**Nose Bridge:**\n\n*   **`Nose_Frame_Length`**: The length of the nose bridge.\n*   **`Nose_Frame_Placement`**:  How far the nose bridge is offset vertically.\n\n**Ear Pieces (Temples):**\n\n*   **`Ear_Frame_Length`**: The length of the ear pieces.\n*   **`Ear_Frame_Height`**: The height/thickness of the ear pieces.\n*   **`Ear_Frame_Distance`**: How far from the top edge of the lens the ear pieces are placed.\n\n**Text:**\n\n*   **`right_text`**: Text to place on the right ear piece.\n*   **`left_text`**: Text to place on the left ear piece.\n*   **`Text_Depth`**: The depth of the text.\n*  **`Text_Height`**: The height of the text.\n*   **`Text_Distance`**:  How far the text is from the ear piece.\n\n**Other Requirements:**\n\n*   The code should use the `write` module from the `Write.scad` library for placing the text.\n*   The ear pieces should have a slight angle to them. You can set that to `Ear_Frame_Angle=6`. They should also have two circles on the ends that act as a hinge that are connected by a hull.\n*   The units should be in millimeters.\n*   Please make the code well-documented so it is easy to understand.\n*  I would like the code to be written such that it is easy to change individual parameters from a GUI.\n\nI think that's everything. Let me know if you need any further clarification.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Pillbox",
    "scad": "include<write/Write.scad>\nNumber_of_days=1;\nExtra=2;\nText=1;\nNumber_of_weeks=1;\nmodule clasp()\n{\n\tcube([1,5,1]);\n}\nmodule pill()\n{\n\tunion()\n\t{\n\t\tdifference()\n\t\t{\n\t\t\tcube(20,20,20);\n\t\t\ttranslate([1,1,3])cube(18,18,18);\n\t\t}\n\t\ttranslate([19,7.5,20])clasp();\n\t\ttranslate([0,7.5,20])clasp();\n\t}\n}\nmodule pillbox()\n{\n\tunion()\n\t{\n\t\tpill();\n\t}\n}\nmodule pillcontaineroneweek()\n{\n\tif(Extra==1)\n\t{\n\t\tunion()\n\t\t{\n\t\t\tfor(i=[0:Number_of_days])\n\t\t\t{\n\t\t\t\ttranslate([0,i*19,0])pillbox();\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tunion()\n\t\t{\n\t\t\tfor(i=[0:Number_of_days-1])\n\t\t\t{\n\t\t\t\ttranslate([0,i*19,0])pillbox();\n\t\t\t}\n\t\t}\n\t}\n}\nmodule pillcontainer()\n{\n\tif(Number_of_weeks==1)\n\t{\n\t\tpillcontaineroneweek();\n\t}\n\telse\n\t{\n\t\tunion()\n\t\t{\n\t\t\tfor(i=[0:Number_of_weeks-1])\n\t\t\t{\n\t\t\t\ttranslate([i*20,0,0])pillcontaineroneweek();\n\t\t\t}\n\t\t}\n\t}\n}\nmodule lid()\n{\n\tunion()\n\t{\n\t\tdifference()\n\t\t{\n\t\t\ttranslate([-25,0,0])cube([20,19,1]);\n\t\t\ttranslate([-6,7.5,-.1])cube([1,5,1]);\n\t\t\ttranslate([-25,7.5,-.1])cube([1,5,1]);\n\t\t}\n\t}\n}\nmodule lidoneweek()\n{\n\tif(Extra==1)\n\t{\n\t\tunion()\n\t\t{\n\t\t\tfor(i=[0:Number_of_days])\n\t\t\t{\n\t\t\t\ttranslate([0,i*21,0])lid();\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tunion()\n\t\t{\n\t\t\tfor(i=[0:Number_of_days-1])\n\t\t\t{\n\t\t\t\t\ttranslate([0,i*21,0])lid();\n\t\t\t}\n\t\t}\n\t}\n}\nmodule textonlid()\n{\n\tif(Text==1)\n\t{\n\t\tif(Extra==1&&Number_of_days==7)\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tfor(i=[0:Number_of_days])\n\t\t\t\t{\n\t\t\t\t\trotate([0,0,90])translate([7,10,1])write(\"SMTWTFSE\",h=10,t=2,space=3.05);\n\t\t\t\t\trotate([0,0,90])translate([9,5,1])write(\"SMTWTFSE\",h=5,t=2,font=\"braille.dxf\",space=6.1);\n\t\t\t\t\tlidoneweek();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(Extra==2&&Number_of_days==7)\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tfor(i=[0:Number_of_days-1])\n\t\t\t\t{\n\t\t\t\t\trotate([0,0,90])translate([7,10,1])write(\"SMTWTFS\",h=10,t=2,space=3.05);\n\t\t\t\t\trotate([0,0,90])translate([9,5,1])write(\"SMTWTFS\",h=5,t=2,font=\"braille.dxf\",space=6.1);\n\t\t\t\t\tlidoneweek();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(Extra==1&&Number_of_days==6)\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tfor(i=[0:Number_of_days])\n\t\t\t\t{\n\t\t\t\t\trotate([0,0,90])translate([7,10,1])write(\"123456E\",h=10,t=2,space=3.05);\n\t\t\t\t\trotate([0,0,90])translate([9,5,1])write(\"123456E\",h=5,t=2,font=\"braille.dxf\",space=6.1);\n\t\t\t\t\tlidoneweek();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(Extra==2&&Number_of_days==6)\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tfor(i=[0:Number_of_days-1])\n\t\t\t\t{\n\t\t\t\t\trotate([0,0,90])translate([7,10,1])write(\"123456\",h=10,t=2,space=3.05);\n\t\t\t\t\trotate([0,0,90])translate([9,5,1])write(\"123456\",h=5,t=2,font=\"braille.dxf\",space=6.1);\n\t\t\t\t\tlidoneweek();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(Extra==1&&Number_of_days==5)\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tfor(i=[0:Number_of_days])\n\t\t\t\t{\n\t\t\t\t\trotate([0,0,90])translate([7,10,1])write(\"12345E\",h=10,t=2,space=3.05);\n\t\t\t\t\trotate([0,0,90])translate([9,5,1])write(\"12345E\",h=5,t=2,font=\"braille.dxf\",space=6.1);\n\t\t\t\t\tlidoneweek();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(Extra==2&&Number_of_days==5)\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tfor(i=[0:Number_of_days-1])\n\t\t\t\t{\n\t\t\t\t\trotate([0,0,90])translate([7,10,1])write(\"12345\",h=10,t=2,space=3.05);\n\t\t\t\t\trotate([0,0,90])translate([9,5,1])write(\"12345\",h=5,t=2,font=\"braille.dxf\",space=6.1);\n\t\t\t\t\tlidoneweek();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(Extra==1&&Number_of_days==4)\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tfor(i=[0:Number_of_days])\n\t\t\t\t{\n\t\t\t\t\trotate([0,0,90])translate([7,10,1])write(\"1234E\",h=10,t=2,space=3.05);\n\t\t\t\t\trotate([0,0,90])translate([9,5,1])write(\"1234E\",h=5,t=2,font=\"braille.dxf\",space=6.1);\n\t\t\t\t\tlidoneweek();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(Extra==2&&Number_of_days==4)\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tfor(i=[0:Number_of_days-1])\n\t\t\t\t{\n\t\t\t\t\trotate([0,0,90])translate([7,10,1])write(\"1234\",h=10,t=2,space=3.05);\n\t\t\t\t\trotate([0,0,90])translate([9,5,1])write(\"1234\",h=5,t=2,font=\"braille.dxf\",space=6.1);\n\t\t\t\t\tlidoneweek();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(Extra==1&&Number_of_days==3)\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tfor(i=[0:Number_of_days])\n\t\t\t\t{\n\t\t\t\t\trotate([0,0,90])translate([7,10,1])write(\"123E\",h=10,t=2,space=3.05);\n\t\t\t\t\trotate([0,0,90])translate([9,5,1])write(\"123E\",h=5,t=2,font=\"braille.dxf\",space=6.1);\n\t\t\t\t\tlidoneweek();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(Extra==2&&Number_of_days==3)\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tfor(i=[0:Number_of_days-1])\n\t\t\t\t{\n\t\t\t\t\trotate([0,0,90])translate([7,10,1])write(\"123\",h=10,t=2,space=3.05);\n\t\t\t\t\trotate([0,0,90])translate([9,5,1])write(\"123\",h=5,t=2,font=\"braille.dxf\",space=6.1);\n\t\t\t\t\tlidoneweek();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(Extra==1&&Number_of_days==2)\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tfor(i=[0:Number_of_days])\n\t\t\t\t{\n\t\t\t\t\trotate([0,0,90])translate([7,10,1])write(\"12E\",h=10,t=2,space=3.05);\n\t\t\t\t\trotate([0,0,90])translate([9,5,1])write(\"12E\",h=5,t=2,font=\"braille.dxf\",space=6.1);\n\t\t\t\t\tlidoneweek();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(Extra==2&&Number_of_days==2)\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tfor(i=[0:Number_of_days-1])\n\t\t\t\t{\n\t\t\t\t\trotate([0,0,90])translate([7,10,1])write(\"12\",h=10,t=2,space=3.05);\n\t\t\t\t\trotate([0,0,90])translate([9,5,1])write(\"12\",h=5,t=2,font=\"braille.dxf\",space=6.1);\n\t\t\t\t\tlidoneweek();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(Extra==1&&Number_of_days==1)\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tfor(i=[0:Number_of_days])\n\t\t\t\t{\n\t\t\t\t\trotate([0,0,90])translate([7,10,1])write(\"1E\",h=10,t=2,space=3.05);\n\t\t\t\t\trotate([0,0,90])translate([9,5,1])write(\"1E\",h=5,t=2,font=\"braille.dxf\",space=6.1);\n\t\t\t\t\tlidoneweek();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(Extra==2&&Number_of_days==1)\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tfor(i=[0:Number_of_days-1])\n\t\t\t\t{\n\t\t\t\t\trotate([0,0,90])translate([7,10,1])write(\"1\",h=10,t=2,space=3.05);\n\t\t\t\t\trotate([0,0,90])translate([9,5,1])write(\"1\",h=5,t=2,font=\"braille.dxf\",space=6.1);\n\t\t\t\t\tlidoneweek();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\tlidoneweek();\n\t}\n}\nmodule fulllid()\n{\n\tif(Number_of_weeks==1)\n\t{\n\t\ttextonlid();\n\t}\n\tif(Number_of_weeks==2)\n\t{\n\t\ttextonlid();\n\t\ttranslate([-25,0,0])textonlid();\n\t}\n\tif(Number_of_weeks==3)\n\t{\n\t\ttextonlid();\n\t\ttranslate([-25,0,0])textonlid();\n\t\ttranslate([-50,0,0])textonlid();\n\t}\n\tif(Number_of_weeks==4)\n\t{\n\t\ttextonlid();\n\t\ttranslate([-25,0,0])textonlid();\n\t\ttranslate([-50,0,0])textonlid();\n\t\ttranslate([-75,0,0])textonlid();\n\t}\n}\nfulllid();\npillcontainer();",
    "description": "Okay, I'm looking to create a customizable pill organizer using OpenSCAD, and I've seen some designs that seem close, but I want something more tailored to my needs. I'd like to be able to specify the number of days, weeks, and whether the lid has text on it.\n\nHere's what I'm thinking:\n\n**Core Structure:**\n\n*   **Individual Pill Compartment:** Each compartment should be a small rectangular box with a slightly recessed interior, basically a cube with a smaller cube cut out.  It needs a small clasping mechanism on the top face, that will allow for the lid to be attached. Two clasps per pillbox should do it.\n*   **Day Modules:**  A collection of these individual compartments should be combined into \"day modules\" arranged horizontally, this makes the pillbox easy to understand and use. The number of compartments per day should be user defined, for some people they may take 7 pills a day, others might only take one.\n\n*   **Week Modules:** These day modules will be further arranged to represent the weeks, each week module being placed horizontally from the previous one. The number of week modules should be customizable as well.\n*   **Lid:** The lid will consist of a rectangular piece that mirrors the base and has small tabs that can slot into the clasps on the box and hold the lid firmly in place.\n\n**Customization Requirements:**\n\n1.  **Number of Days:** I want to be able to specify the number of days (and thus, the number of pill compartments in a row) to include in each \"week\" of the pillbox. This could be anywhere from 1 to 7, or perhaps even more in the future.\n2.  **Extra Compartment:**  I'd like to have an optional \"extra\" compartment at the end of each \"day row\". This would be useful for things like PRN medications or supplements.\n3.  **Number of Weeks:** I need to be able to choose how many week rows to include. This could range from 1 to 4 or even more, allowing me to prepare pills for a full month.\n4.  **Text on Lid:** I'd like an option to add text to the lids of each week section. If the user does not select this option, then no text should be included. The text should be the letters of the week if there are 7 days, or numbers for less, plus the letter E at the end for the extra compartment, if it exists. I'd also like this text in Braille below each section of text, using a braille font.\n    *   The text should be placed on the lid of the \"week module\", oriented so that when the lid is placed on the pillbox it is correctly oriented.\n    *   I'd prefer the standard letters to be large and clear, and the braille to be smaller but still legible.\n\n**Other Requirements/Notes:**\n\n*   I'm not familiar with all the libraries, but I'm using the `Write.scad` library for text rendering.\n*   I'd like the compartments to have a reasonable size - say, 20mm x 20mm x 20mm with 18x18x18 inner, and the clasps 1x5x1.\n*   I'd like the lid to have tabs that are slightly recessed, to keep the lid firmly in place, with the dimensions being 1x5x1, and recessed by .1.\n*   The spacing between individual compartments within a day row should be consistent and, say, 19mm.\n*   I'd like to ensure the braille text is well-spaced so the dots don't overlap.\n*   The overall design needs to be parametric so that I can easily adjust all of these values.\n*   I'm expecting the OpenSCAD to generate a solid 3D printable object.\n\nCould you help me generate an OpenSCAD script that meets these specifications? Let me know if you have any questions.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Pill Box Lid",
    "scad": "Length_For_Each_Compartment = 20;\nWidth_For_Each_Compartment = 35;\nHeight_For_Entire_Model = 15;\nnumber_days = 7;\nnumber_per_day = 3;\nrow_one = \"B\";\nrow_two = \"L\";\nrow_three = \"D\";\nrow_four = \"4\";\nrow_five = \"5\";\nrow_six = \"6\";\nnubs = 0;\nlength_x = Length_For_Each_Compartment;\nwidth_y = Width_For_Each_Compartment;\nheight_z = Height_For_Entire_Model;\no_x = length_x;\no_y = width_y;\no_z = height_z;\ni_x = o_x-4;\ni_y = o_y-4;\ni_z = o_z;\nd = number_days-2;\ne = number_days-1;\nn = number_per_day-2;\nl = number_per_day-1;\nmodule inside(){\nunion()\n{\ntranslate([-1,1,1])cube([((length_x*number_per_day)-(2*l)+2),(width_y*number_days)+1,6]);\ntranslate([3,-1,3])\n{\nrotate([270,0,0]){cylinder(400,2,2);\n}\n}\n}\n}\ndifference(){\ntranslate([0,0,0])cube([((length_x*number_per_day)-(2*l)+2),(width_y*number_days)+3,6]);\ninside();\n}",
    "description": "Okay, so I'm trying to create a lid for a customizable pill box I found online, and I need help generating the OpenSCAD code. The pill box itself is made up of individual compartments arranged in a grid, and the lid needs to fit snugly over the entire thing.\n\nHere's how the pill box is structured:\n\n*   **Compartment Dimensions:** Each individual compartment has a length and a width, which I can adjust. These are specified as `Length_For_Each_Compartment` and `Width_For_Each_Compartment` respectively. I can change them, but in the example code, the defaults are 20 and 35.\n*   **Overall Height:** The height of the entire lid is specified by `Height_For_Entire_Model` and in the example is 15.\n*   **Grid Arrangement:** The compartments are arranged in a grid. I can specify the number of days (i.e., the number of rows), `number_days`, and the number of compartments per day (i.e., the number of columns), `number_per_day`. The example uses 7 days and 3 compartments per day.\n\nThe OpenSCAD code I started (which I'll provide below) uses subtraction to cut out the interior of the lid, leaving a thin shell. The lid sits over the container itself and would be slightly larger than the box so that the two fit together. This difference is specified as 4mm in both the X and Y dimensions.\n\nI'm using text for each row that will be embossed on the side of the lid. I have variables to do this: `row_one`, `row_two`, `row_three`, `row_four`, `row_five`, and `row_six`, and these will correspond to one letter for each row. I would like the program to accommodate the correct number of rows automatically using only the variables `number_days` and the strings. So, if I only specify 3 days, I would expect only 3 rows, etc.\n\nI'd also like to include an option for small nubs on the bottom of the lid that correspond to the number of compartments per day (so 3 nubs if there are 3 compartments per day). I have a parameter for this, `nubs`, which I would like to handle with a 0 (yes) and 1 (no). This feature is not included in the code I started.\n\nCould you generate the OpenSCAD code for this lid, incorporating these parameters and the text and nub options? Specifically, the lid should have the same height as specified by `Height_For_Entire_Model` and extend slightly past the main pill box body as specified. I am not using any special libraries at this time, but I am not opposed to incorporating one, should you think it necessary.\n\nI'm also including the code I have to show how I was doing the subtraction before:\n```\n//Applies To Each \"Individual\" Container\nLength_For_Each_Compartment = 20; //[1:50]\n\n//Applies To Each \"Individual\" Container\nWidth_For_Each_Compartment = 35; //[1:50]\n\n//Applies To Entire Model\nHeight_For_Entire_Model = 15; //[1:50]\n\n\n//number of boxes\n\nnumber_days = 7; // [1,2,3,4,5,6,7,8,9,10]\nnumber_per_day = 3; // [1,2,3,4,5,6]\n\n//letters\n\n//One Letter Works Best\nrow_one = \"B\"; \n\n//One Letter Works Best\nrow_two = \"L\";\n\n//One Letter Works Best\nrow_three = \"D\";\n\n//One Letter Works Best\nrow_four = \"4\";\n\n//One Letter Works Best\nrow_five = \"5\";\n\n//One Letter Works Best\nrow_six = \"6\";\n\n//nub parameter\n\nnubs = 0; //[0:Yes,1:No,2]\n//Click Yes If You Are Printing A Lid\n\n\n\n//MODEL VARIABLES\n\n//box\nlength_x = Length_For_Each_Compartment;\nwidth_y = Width_For_Each_Compartment;\nheight_z = Height_For_Entire_Model;\no_x = length_x;\no_y = width_y;\no_z = height_z;\ni_x = o_x-4;\ni_y = o_y-4;\ni_z = o_z;\n\n//number of days\nd = number_days-2;\ne = number_days-1;\n\n//number of times per day\nn = number_per_day-2;\nl = number_per_day-1;\n\n\n\n\n//MODULE - subtraction\n\nmodule inside(){\nunion()\n{\ntranslate([-1,1,1])cube([((length_x*number_per_day)-(2*l)+2),(width_y*number_days)+1,6]);\n\ntranslate([3,-1,3])\n{\nrotate([270,0,0]){cylinder(400,2,2);\n}\n}\n}\n}\n\ndifference(){\ntranslate([0,0,0])cube([((length_x*number_per_day)-(2*l)+2),(width_y*number_days)+3,6]);\ninside();\n}\n```\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable RepRap filament holder",
    "scad": "use <utils/build_plate.scad>;\nbuild_plate_selector = 3;\nbuild_plate_manual_x = 200;\nbuild_plate_manual_y = 200;\npeg_tolerance = 5;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\npart = \"all\";\ncrossbar_diameter = 8;\ncrossbar_spacing = 58;\nvertical_bar_diameter = 6;\nprint_part();\nmodule print_part() {\n    if (part == \"bottom\") {\n        translate([0,0,crossbar_diameter]) bottom_bar();\n    } else if (part == \"top\") {\n        translate([0,0,crossbar_diameter]) top_bar();\n    } else if (part == \"cap\") {\n        retaining_cap();\n    } else if (part == \"all\") {\n        all_parts();\n    } else {\n        all_parts();\n    }\n}\nmodule bottom_bar() {\n    translate([0,0,crossbar_diameter]) rotate([90,0,0]) {\n        difference() {\n            union() {\n                cube(\n                    size = [\n                        crossbar_spacing + vertical_bar_diameter*4,\n                        crossbar_diameter * 2,\n                        crossbar_diameter * 2\n                    ],\n                    center = true\n                );\n                translate(v = [(crossbar_spacing + vertical_bar_diameter*4)/2, 0, 0]) rounded_end();\n                translate(v = [-(crossbar_spacing + vertical_bar_diameter*4)/2, 0, 0]) rounded_end();\n            }\n            hull() {\n                translate(v = [crossbar_spacing/2,0,0]) bar_hole(crossbar_diameter);\n                translate(v = [crossbar_spacing/2,0,-crossbar_diameter]) bar_hole(crossbar_diameter);\n            }\n            hull() {\n                translate(v = [-crossbar_spacing/2,0,0]) bar_hole(crossbar_diameter);\n                translate(v = [-crossbar_spacing/2,0,-crossbar_diameter]) bar_hole(crossbar_diameter);\n            }\n            rotate([90,0,0]) translate(v = [(crossbar_spacing/2) + (crossbar_diameter + vertical_bar_diameter/2),0,0]) bar_hole(vertical_bar_diameter);\n            rotate([90,0,0]) translate(v = [-((crossbar_spacing/2) + (crossbar_diameter + vertical_bar_diameter/2)),0,0]) bar_hole(vertical_bar_diameter);\n        }\n    }\n}\nmodule top_bar() {\n    translate([0,0,crossbar_diameter]) rotate([-90,0,0]) {\n        difference() {\n            union() {\n                cube(\n                    size = [\n                        crossbar_spacing + vertical_bar_diameter*4,\n                        crossbar_diameter * 2,\n                        crossbar_diameter * 2\n                    ],\n                    center = true\n                );\n                translate(v = [(crossbar_spacing + vertical_bar_diameter*4)/2, 0, 0]) rounded_end();\n                translate(v = [-(crossbar_spacing + vertical_bar_diameter*4)/2, 0, 0]) rounded_end();\n            }\n            rotate([90,0,0]) translate(v = [(crossbar_spacing/2) + (crossbar_diameter + vertical_bar_diameter/2),0,0]) bar_hole(vertical_bar_diameter);\n            rotate([90,0,0]) translate(v = [-((crossbar_spacing/2) + (crossbar_diameter + vertical_bar_diameter/2)),0,0]) bar_hole(vertical_bar_diameter);\n            hull() {\n                bar_hole(vertical_bar_diameter);\n                translate(v = [0,0,crossbar_diameter]) bar_hole(vertical_bar_diameter);\n            }\n            translate(v = [0,-crossbar_diameter,0]) cap_holes(1 + peg_tolerance / 100.0);\n        }\n    }\n}\nmodule retaining_cap() {\n    translate([0,0,(vertical_bar_diameter*.25)/2]) rotate([90,0,0]) union() {\n        difference() {\n            hull() {\n                translate([vertical_bar_diameter*2,0,0]) rotate([90,0,0]) cylinder(\n                    h = vertical_bar_diameter * .25,\n                    r = vertical_bar_diameter,\n                    center = true\n                );\n                translate([-vertical_bar_diameter*2,0,0]) rotate([90,0,0]) cylinder(\n                    h = vertical_bar_diameter * .25,\n                    r = vertical_bar_diameter,\n                    center = true\n                );\n            }\n            hull() {\n                bar_hole(vertical_bar_diameter);\n                translate(v = [0,0,crossbar_diameter]) bar_hole(vertical_bar_diameter);\n            }\n        }\n        translate(v = [0,vertical_bar_diameter * (.25/3) + crossbar_diameter/4,0]) cap_pegs(1 - peg_tolerance / 100.0);\n    }\n}\nmodule all_parts() {\n    translate([0,-crossbar_diameter*4,0]) retaining_cap();\n    translate([0,0,0]) top_bar();\n    translate([0,crossbar_diameter*4,0]) bottom_bar();\n}\nmodule cap_pegs(tolerance) {\n    translate(v = [vertical_bar_diameter*2, 0, 0]) scale([tolerance,tolerance,tolerance]) cap_peg();\n    translate(v = [-vertical_bar_diameter*2, 0, 0]) scale([tolerance,tolerance,tolerance]) cap_peg();\n}\nmodule cap_peg() {\n    rotate([90,0,0]) cylinder(\n        h = crossbar_diameter/2,\n        r = vertical_bar_diameter / 2,\n        center = true\n    );\n}\nmodule cap_holes(tolerance) {\n    translate(v = [vertical_bar_diameter*2, 0, 0])  scale([tolerance,tolerance,tolerance]) cap_hole();\n    translate(v = [-vertical_bar_diameter*2, 0, 0]) scale([tolerance,tolerance,tolerance]) cap_hole();\n}\nmodule cap_hole() {\n    rotate([90,0,0]) cylinder(\n        h = crossbar_diameter,\n        r = vertical_bar_diameter / 2,\n        center = true\n    );\n}\nmodule bar_hole(diameter) {\n    rotate([90,90,0]) cylinder(\n        h = crossbar_diameter * 3,\n        r = diameter/2,\n        center = true\n    );\n}\nmodule rounded_end() {\n    rotate([90,90,0]) cylinder(\n        h = crossbar_diameter * 2,\n        r = crossbar_diameter,\n        center = true\n    );\n}",
    "description": "Okay, I'm looking to design a filament holder that sits on top of two crossbars and interfaces with a spindle from another design. I have a pretty good starting point using a file I found online, `filament-holder.scad`, but I need it to be more flexible and customizable.\n\nHere's what I have in mind, and what I'd like to be able to control with parameters:\n\n**General Structure:**\n\nThe design consists of three main parts: a bottom bar, a top bar, and two retaining caps.  The bottom and top bars are essentially identical except for the pegs on the top and the peg holes on the bottom for connecting to the retaining caps. The design uses a horizontal cross bar which is meant to be 8mm diameter (parameterized later) and two crossbars parallel to that are meant to be 6mm in diameter(parameterized later).\n\n**Key Parameters I Need:**\n\n1.  **`crossbar_diameter`**: The diameter of the horizontal threaded rod that goes through the top and bottom bars. This is currently hardcoded to 8mm.\n2.  **`crossbar_spacing`**:  The center-to-center distance between the two crossbars. This is currently hardcoded to 58mm.\n3.  **`vertical_bar_diameter`**: The diameter of the vertical rods that connect the top and bottom bars together. Currently hardcoded to 6mm.\n4.  **`peg_tolerance`**:  The percentage adjustment for the pegs/holes used to secure the retaining cap.  For example, a `peg_tolerance` of 5 would mean peg holes are 5% larger and pegs are 5% smaller.\n5. **`bar_width`**: The width of the main body of the top and bottom bars. Currently this appears to be `crossbar_diameter * 2`\n6. **`bar_height`**: The height of the main body of the top and bottom bars.  Currently this appears to be `crossbar_diameter * 2`\n7. **`cap_height`**: The height of the retaining cap that holds the filament spool in place. Currently this appears to be `vertical_bar_diameter * .25`\n8.  **`peg_height`**: The length of the retaining cap's pegs. Currently appears to be `crossbar_diameter/2`\n\n**Functionality and Changes:**\n\n*   The design should use the `build_plate` module from `utils/build_plate.scad` to define the print area, as the existing design does. I don't need you to provide the code for `build_plate.scad`, just include the use statement.\n*   The top and bottom bars should be identical aside from the peg/hole differences. I'd like to have a single module for the bar, and then call it twice with different rotation parameters, and a different translate for the hole or peg locations.\n*   The retaining caps need to connect using pegs that should have a variable tolerance relative to the holes on the top bar.\n*   I'd like to be able to specify which part of the assembly (or all) to render.  Specifically,  \"bottom\", \"top\", \"cap\", or \"all\" just like the original code.\n*   I want the bars to have rounded edges on the ends, as the current code does.\n*   I do not want the holes for the horizontal crossbar in the center to use a `hull()`, this can just be a simple cylinder subtraction.\n\n**Output:**\n\nI want a single OpenSCAD file that can produce all of the parts based on parameters.\n\n**Library Requirements:**\n\n*   I expect to see a `use <utils/build_plate.scad>;` line, just like the existing code. Please make sure to include this.\n\nI think that covers everything. Let me know if you have any questions.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Diamond shape, Brilliant cut 58",
    "scad": "module sea_urchin()\ndifine();\ndd=20;\nhr=0.615;\npag1=42.45*1;\npag2=40.75*1;\ncag3=40.16*1;\ncag4=34.5*1;\ncag5=24.35*1;\ndh=dd*hr;\ndifference() {\n\t\t\ttranslate([0,0,-dd*0.431])cylinder(h=dh,r=dd/2,$fn=48);\nunion(){\n\tfor (i = [ 0 : 8-1] ) {\n\t\t\t\trotate([0,0,360/8*i]) translate([dd/2,0,-5/cos(pag1)]) rotate([0,90-pag1,0])cube(size=[dd/2,dd/2,1.1*dd], center=true);\n\t\t\t\t\t\t\t}\nfor (i = [ 0 : 8-1] ) {\n\t\t\t\trotate([0,0,360/8*i+22.5]) translate([dd/2,0,-5/cos(pag1)]) rotate([0,90-pag1,0])cube(size=[dd/2,dd/2,1.1*dd], center=true);\n\t\t\t\t\t\t\t}\n\tfor (i = [ 0 : 8-1] ) {\n\t\t\t\trotate([0,0,360/8*i+11.25]) translate([dd/2,0,-5/cos(pag1)]) rotate([0,90-pag2,0])cube(size=[dd/2,dd/2,dd], center=true);\n\t\t\t\t\t\t\t}\n}\nunion(){\n\tfor (i = [ 0 : 8-1] ) {\n\t\trotate([0,0,360/8*i]) translate([dd/2,0,5/cos(cag3)]) rotate([0,90-cag3,180])cube(size=[dd/2,dd/2,dd], center=true);\n\t\t\t\t\t\t\t}\nfor (i = [ 0 : 8-1] ) {\n\t\trotate([0,0,360/8*i+22.5]) translate([dd/2,0,5/cos(cag3)]) rotate([0,90-cag3,180])cube(size=[dd/2,dd/2,dd], center=true);\n\t\t\t\t\t\t\t}\n}\nunion(){\n\tfor (i = [ 0 : 4-1] ) {\n\t\trotate([0,0,360/4*i+11.25]) translate([dd/2,0,5/cos(cag4)+0.0085*dd]) rotate([0,90-cag4,180])cube(size=[dd/2,dd/2,dd], center=true);\n\t\t\t\t\t\t\t}\nfor (i = [ 0 : 4-1] ) {\n\t\trotate([0,0,360/4*i+11.25+45]) translate([dd/2,0,5/cos(cag4)+0.0085*dd]) rotate([0,90-cag4,180])cube(size=[dd/2,dd/2,dd], center=true);\n\t\t\t\t\t\t\t}\n\tfor (i = [ 0 : 8-1] ) {\n\trotate([0,0,360/8*i-11.25]) translate([dd/2,0,5/cos(cag5)+0.060*dd]) rotate([0,90-cag5,180])cube(size=[dd/2,dd/2,dd], center=true);\n\t\t\t\t\t\t\t}\n\t\t}\n\t\t\t}\nmodule sea_urchin();",
    "description": "Okay, I'm trying to create a customizable 3D model of a gemstone, specifically a brilliant cut diamond, but I want to be able to play with the parameters without completely losing the diamond-like shape. I have a starting point SCAD file (attached), but it's very specific and not very flexible.\n\nHere's what I'm looking for:\n\n**Overall Goal:** A parametric OpenSCAD model of a faceted gemstone that starts with the general shape of a brilliant cut diamond, but allows for significant customization while still maintaining an interesting geometric shape. I understand that moving away from the precise proportions of a brilliant cut will result in something other than a true brilliant cut, but I want a tool to explore these variations.\n\n**Key Parameters I'd like to control:**\n\n*   **`diamond_diameter` (or `dd` in my current file):** The diameter of the diamond at its widest point. I want to be able to easily change the overall size of the gem. I would like it to be possible to express other dimensions relative to this size.\n*   **`height_ratio` (or `hr` in my current file):** A ratio that determines the overall height of the gemstone relative to its diameter. For a brilliant cut this is near 0.615, but I want to be able to control this parameter independently of the diameter.\n*    **Pavillion angle 1 (`pag1`):** The angle of the first facets of the pavilion.\n*    **Pavillion angle 2 (`pag2`):** The angle of the second facets of the pavilion.\n*    **Crown angle 3 (`cag3`):** The angle of the first facets of the crown.\n*    **Crown angle 4 (`cag4`):** The angle of the second facets of the crown.\n*   **Crown angle 5 (`cag5`):** The angle of the third facets of the crown.\n\n**Desired Functionality:**\n\n*   The model should generate a faceted shape that somewhat resembles a diamond with a crown and pavilion, but with the parameters above controlling the general proportions, and angles, of the facets.\n*   It should be easy to modify these parameters in the OpenSCAD code to create many different variations on the general diamond shape.\n*   I don't need to be married to the specific number of facets that are in the attached SCAD file; more or less would be fine. I do want them evenly distributed around the gem for the most part.  I want to be able to control how many facets there are, but don't need that to be a specific user input.\n* The facets should be created using a `difference()` and `cube()` combination like is present in the file I included.\n*   I'd like the code to be reasonably well-organized and commented so I can understand how it works and modify it further myself.\n\n**Things I don't need:**\n\n*   I don't need the model to be physically accurate in terms of light refraction or anything like that. I'm primarily interested in the geometric form.\n*   I don't need any specific libraries, I'd prefer just basic OpenSCAD primitives.\n\nEssentially, I want a flexible tool to explore gemstone shapes using a brilliant-cut diamond as a starting point. Can you help me with this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Heart Chain",
    "scad": "Type=1;\nLinks=15;\nmodule HEARTS(){\n\tmodule HEARTHALF(h){\n\t  scale([25.4/90, -25.4/90, 1]) union()\n\t  {\n\t\tlinear_extrude(height=h)\n\t\t  polygon([[-14.571719,-20.933442],[-11.207616,-24.148396],[-7.888872,-26.422799],[-4.654128,-27.828605],[-1.542030,-28.437764],[1.408781,-28.322229],[4.159661,-27.553951],[6.671966,-26.204883],[8.907054,-24.346975],[10.826281,-22.052181],[12.391004,-19.392452],[13.562581,-16.439740],[14.302367,-13.265996],[14.571719,-9.943174],[14.331995,-6.543223],[13.544550,-3.138097],[12.170743,0.200252],[6.765776,10.362507],[3.868395,15.114093],[0.774276,19.408022],[-2.566689,23.065825],[-6.204606,25.909031],[-10.189580,27.759167],[-12.327873,28.256063],[-14.571719,28.437764],[-14.571719,25.281037],[-12.239405,24.716464],[-9.824168,23.279968],[-7.410414,21.096956],[-5.082551,18.292834],[-2.924986,14.993006],[-1.022124,11.322880],[0.541627,7.407860],[1.681860,3.373354],[2.314169,-0.655233],[2.354147,-4.552496],[1.717387,-8.193028],[0.319482,-11.451424],[-1.923974,-14.202277],[-5.097388,-16.320181],[-9.285168,-17.679732],[-14.571719,-18.155522]]);\n\t  }\n\t}\n\tres1=50;\n\tdifference(){\n\t\tunion(){\n\t\t\ttranslate([4,0,0]) HEARTHALF(1);\n\t\t\ttranslate([-.52,0,4.17]) rotate([0,-110,0]) HEARTHALF(1);\n\t\t}\n\t\ttranslate([-20,-20,-2]) cube([40,40,2]);\n\t\ttranslate([-5,-10,-1]) cube([10,2.1,10]);\n\t}\n}\nmodule StraightChain(){\n\tfor (i=[1:Links]){\n\t\tif (i%2==1){\n\t\t\ttranslate([0,10*(i),0]) HEARTS();\n\t\t} else {\n\t\t\ttranslate([1,10*(i),0]) mirror([1,0,0]) HEARTS();\n\t\t}\n\t}\n}\nmodule LoopChain(){\n\tfor (i=[1:Links]){\n\t\trotate([0,0,i*Seg]) translate([Rad,0,0])\n\t\tif (i%2==1){\n\t\t\tHEARTS();\n\t\t} else {\n\t\t\ttranslate([1,0,0]) mirror([1,0,0]) HEARTS();\n\t\t}\n\t}\n}\nPi=3.1415926535897;\nSeg=360/Links;\nRad=(Links*10)/(2*Pi);\nif (Type==0){\n\tStraightChain();\n} else {\n\tLoopChain();\n}",
    "description": "Okay, I'd like to design a custom heart chain for my sweetheart, and I'm hoping you can help me with the OpenSCAD code.\n\nHere's what I'm looking for:\n\nI want to be able to choose between a straight chain and a closed loop chain. For the closed loop option, the hearts should form a circle.\n\nI also need to be able to easily set the number of hearts in the chain, which should control the length of the straight chain or the circumference of the loop.\n\nThe basic heart design is good as-is, but I would like to control it's overall size.\n\nHere's a little more detail about the specifics:\n\n*   **Chain Type:** I'd like a parameter to switch between a straight chain (hearts placed one after the other) and a closed loop chain (hearts forming a circle). A dropdown selection would be great for this.\n*   **Number of Links:** I need a parameter to set the number of heart links in the chain. A numerical slider with a reasonable min/max would be great, maybe 1 to 100.\n*   **Heart Size:** I'd like a way to control the scale of the heart itself, so I can make the links bigger or smaller without altering the overall shape.\n*   **Heart Orientation:** The code should make the hearts alternate orientation, so they are each mirrored from the last, like they are now.\n*   **Basic Heart Shape:** The core heart shape is perfect and I don't want to change that.\n*   **Default Size:** The current heart size, about 20mm in size, is a good starting point.\n\nEssentially, I want to control the basic parameters of the heart chain, choose between a straight or circular chain, and easily adjust the size and number of hearts. Could you generate the OpenSCAD code for me, please?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Pill Box",
    "scad": "use <write.scad>\ninclude <write/Write.scad>\nLength_For_Each_Compartment = 20;\nWidth_For_Each_Compartment = 35;\nHeight_For_Entire_Model = 15;\nnumber_days = 7;\nnumber_per_day = 3;\nrow_one = \"B\";\nrow_two = \"L\";\nrow_three = \"D\";\nrow_four = \"4\";\nrow_five = \"5\";\nrow_six = \"6\";\nnubs = 0;\nlength_x = Length_For_Each_Compartment;\nwidth_y = Width_For_Each_Compartment;\nheight_z = Height_For_Entire_Model;\no_x = length_x;\no_y = width_y;\no_z = height_z;\ni_x = o_x-4;\ni_y = o_y-4;\ni_z = o_z;\nd = number_days-2;\ne = number_days-1;\nn = number_per_day-2;\nmodule box()\n{\ndifference(){\ncube([o_x,o_y,o_z]);\ntranslate([2,2,2]){\ncube([i_x,i_y,i_z]);\n}}}\nmodule box2()\n{\ndifference(){\ncube([o_x,o_y,o_z]);\ntranslate([2,2,2]){\ncube([i_x,i_y+2,i_z]);\n}}}\nmodule row()\n{\nfor ( i = [0 : d] )\n{\ntranslate([o_x-2,o_y*i,0])box2();\n}\ntranslate([o_x-2,o_y*e,0])box();\n}\nif (n < 0)\n{\nfor ( i = [0 : d] )\n{\ntranslate([0,o_y*i,0])box2();\n}\ntranslate([0,o_y*e,0])box();\n} else {\nfor ( i = [0 : d] )\n{\ntranslate([0,o_y*i,0])box2();\n}\ntranslate([0,o_y*e,0])box();\nfor ( k = [0 : n] )\n{\ntranslate([(o_x-2)*k,0,0])row();\n}\n}\nif (nubs == 0){\ntranslate([1.5,0,o_z-1.5])rotate([90,0,0])linear_extrude(height=2)circle(r=1);\ntranslate([1.5,(number_days*o_y+2),o_z-1.5])rotate([90,0,0])linear_extrude(height=2)circle(r=1);\n}\nfor ( i = [0 : e] )\n{\ntranslate([length_x/2,(width_y/2)+(width_y*i+2),3])rotate([0,0,90])write(row_one,t=2,h=8,center=true);\n}\nif (number_per_day>1)\n{\nfor ( i = [0 : e] )\n{\ntranslate([length_x*1.5-2,(width_y/2)+(width_y*i+2),3])rotate([0,0,90])write(row_two,t=2,h=8,center=true);\n}\n}\nif (number_per_day>2){\nfor ( i = [0 : e] )\n{\ntranslate([length_x*2.5-4,(width_y/2)+(width_y*i+2),3])rotate([0,0,90])write(row_three,t=2,h=8,center=true);\n}\n}\nif (number_per_day>3){\nfor ( i = [0 : e] )\n{\ntranslate([length_x*3.5-6,(width_y/2)+(width_y*i+2),3])rotate([0,0,90])write(row_four,t=2,h=8,center=true);\n}\n}\nif (number_per_day>4){\nfor ( i = [0 : e] )\n{\ntranslate([length_x*4.5-8,(width_y/2)+(width_y*i+2),3])rotate([0,0,90])write(row_five,t=2,h=8,center=true);\n}\n}\nif (number_per_day>5){\nfor ( i = [0 : e] )\n{\ntranslate([length_x*5.5-10,(width_y/2)+(width_y*i+2),3])rotate([0,0,90])write(row_six,t=2,h=8,center=true);\n}\n}",
    "description": "Okay, I'm looking to create a customizable pill organizer using OpenSCAD. I'd like the design to be parametric so I can easily adjust the number of compartments, their size, and the overall dimensions of the box.\n\nHere are the specific things I need:\n\n*   **Compartments:**\n    *   I need to be able to specify the length, width, and height of each individual compartment.\n    *   The compartments should be arranged in a grid.\n    *   I need to specify the number of days (rows) and the number of doses per day (columns). For example, I might want a 7 day organizer, with 3 doses per day.\n    *   There needs to be an option for the walls of each compartment to be a consistent thickness. This thickness can be hardcoded, as it won't be varied by me.\n\n*   **Labels:**\n    *   I want to include text labels above each column to designate the time of day (e.g., \"B\", \"L\", \"D\" for Breakfast, Lunch, and Dinner, for example).\n    *   These labels need to be customizable. I should be able to specify the text for each column. I expect these labels to be relatively short, probably one or two letters each.\n\n*   **Nubs:**\n    *   I need an option to add small nubs, or pegs, to the bottom of the pill organizer. I will use this to align a lid (though the lid design isn't part of this request).\n    *   There should be an option to turn these nubs on or off.\n\n*   **Overall:**\n    *   I need to be able to specify the total height of the box.\n    *   I need to specify whether I am printing a lid or not, as this will determine the inclusion of the nubs.\n    *   I'm using the `write.scad` library to generate the text for the labels, specifically the `write()` module.\n\nI think that covers everything. Could you provide me with an OpenSCAD file that does all of that?\n"
  },
  {
    "object": "Hey cadmonkey, make me a RC car wheel 12mm hex hub nut (customizer-enabled)",
    "scad": "include <MCAD/shapes.scad>;\n$fn = 50;\nhex_mm = 12;\nhex_height = 6;\npin_depth = 2.3;\npin_length = 11.2;\npin_width = 2.3;\naxle_hole = 3;\nflare_height = 2;\ndifference(){\n\tunion(){\n\t\tdifference(){\n\t\t\ttranslate([0,0,(hex_height-flare_height-((hex_height-6)/2))]) hexagon(hex_mm,(hex_height-flare_height));\n\t\t\t translate([0,0,(hex_height-(pin_depth/2))]) rotate([90,90,90]) cylinder(pin_length,(pin_depth/2),(pin_depth/2), center = true);\n\t\t\t translate([(pin_length/2*-1),(pin_width/2*-1),(hex_height-(pin_depth/2))]) cube(size=[pin_length,pin_width,pin_depth+1], center = false);\n\t\t}\n\t\tdifference(){\n\t\t\tcylinder(flare_height,5.5,7);\n\t\t\tdifference(){\n\t\t\t\thexagon((hex_mm+3),(flare_height*2));\n\t\t\t\thexagon(hex_mm,(flare_height*2));\n\t\t\t\t}\n\t\t}\n\t}\n\tcylinder(hex_height,axle_hole,axle_hole);\n}",
    "description": "Okay, I need a parametric OpenSCAD file for a 12mm hex hub nut for an RC car, but I want to be able to easily adjust the key dimensions. I've got a basic design in mind but it needs to be properly parameterized.\n\nHeres the breakdown of what I need:\n\n**Core Shape:** The nut is based on a hexagon, specifically a 12mm hex across the flats by default. I need to be able to easily change the `hex_mm` parameter.\n\n**Overall Height:** The total height of the nut (the dimension along the central axis) should be adjustable. I need a `hex_height` parameter for this.\n\n**Axle Hole:**  There needs to be a hole going all the way through the center for the axle. This needs a `axle_hole` parameter to control its diameter.\n\n**Pin Feature:** I need to add a rectangular pin feature on one side of the hex. This pin will engage with a slot in the wheel hex. This pin needs several parameters:\n\n*   `pin_depth`:  How far the pin extends from the hex face (the depth).\n*   `pin_length`: The length of the pin.\n*   `pin_width`: The width of the pin.\n\n**Base Flare (Fillet):**  The base of the hex should have a small flared portion or fillet that transitions into the hex shape. This flare needs a parameter:\n\n*   `flare_height`: The vertical height of the flare.\n\n**Parameters:**\nI'd like to define the following parameters:\n\n*   `hex_mm`: Default value of 12,  adjusts the size of the hex across the flats.\n*   `hex_height`: Default value of 6, overall height of the hex nut body.\n*   `pin_depth`: Default value of 2.3,  depth of pin.\n*  `pin_length`: Default value of 11.2,  length of pin.\n*   `pin_width`: Default value of 2.3, width of pin.\n*   `axle_hole`: Default value of 3,  diameter of the axle hole.\n*   `flare_height`: Default value of 2, height of flare/fillet at base.\n*   `$fn`: Default value of 50, controls the smoothness of curves.\n\n**Functionality:**\n* The design should use the `shapes.scad` library from MCAD for the hexagon function.\n* The nut should be built by combining the main hex body with the flared base and subtracting the axle hole.\n* The pin should be cut out of the hex body using a combination of cylinders and cubes.\n* The flared base should have a hex \"OD\" and \"ID\" to cut the proper shape.\n\nEssentially, I want to have all the important dimensions controlled by these parameters so I can easily create different sizes and shapes. Could you write an OpenSCAD file for this, using the MCAD library?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Monogram Cube",
    "scad": "SIZE = 40 * 1;\nDETAIL = 30 * 1;\ntypeface = \"blocks\";\ntop_letter = \"A\";\nleft_side_letter = \"B\";\nright_side_letter = \"C\";\nmodule arc(cubeSize, rotation, x, y)\n{\n    translate(v = [(cubeSize / 4 + 1) / 2 + x, (cubeSize / 4 + 1) / 2 + y, (cubeSize + 2) / 2 - 1])\n\t\trotate(a = [0, 0, -1 * rotation])\n\t\t    translate(v = [(cubeSize / 4 + 1) / -2, (cubeSize / 4 + 1) / -2, (cubeSize + 2) / -2])\n\t\t        difference()\n\t\t        {\n\t\t            cube(size = [cubeSize / 4 + 1, cubeSize / 4 + 1, cubeSize + 2]);\n\t\t            translate(v = [cubeSize / 4 + 1, cubeSize / 4 + 1, 0])\n\t\t                cylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n\t\t        }\n}\nmodule arcWithMargin(cubeSize, rotation, marginX, marginY, x, y)\n{\n\tif (90 == rotation || 270 == rotation)\n\t{\n\t    translate(v = [(cubeSize / 4 + marginY) / 2 + x, (cubeSize / 4 + marginX) / 2 + y, (cubeSize + 2) / 2 - 1])\n\t\t\trotate(a = [0, 0, -1 * rotation])\n\t\t\t    translate(v = [(cubeSize / 4 + marginX) / -2, (cubeSize / 4 + marginY) / -2, (cubeSize + 2) / -2])\n\t\t\t        difference()\n\t\t\t        {\n\t\t\t            cube(size = [cubeSize / 4 + marginX, cubeSize / 4 + marginY, cubeSize + 2]);\n\t\t\t            translate(v = [cubeSize / 4 + marginX, cubeSize / 4 + marginY, 0])\n\t\t\t                cylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n\t\t\t        }\n\t} else {\n\t    translate(v = [(cubeSize / 4 + marginX) / 2 + x, (cubeSize / 4 + marginY) / 2 + y, (cubeSize + 2) / 2 - 1])\n\t\t\trotate(a = [0, 0, -1 * rotation])\n\t\t\t    translate(v = [(cubeSize / 4 + marginX) / -2, (cubeSize / 4 + marginY) / -2, (cubeSize + 2) / -2])\n\t\t\t        difference()\n\t\t\t        {\n\t\t\t            cube(size = [cubeSize / 4 + marginX, cubeSize / 4 + marginY, cubeSize + 2]);\n\t\t\t            translate(v = [cubeSize / 4 + marginX, cubeSize / 4 + marginY, 0])\n\t\t\t                cylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n\t\t\t        }\n\t}\n}\nmodule carveLetterA(cubeSize)\n{\n    translate(v = [cubeSize / 4, -1, -1])\n        cube(size = [cubeSize / 2, cubeSize / 4 + 1, cubeSize + 2]);\n    translate(v = [cubeSize / 2, cubeSize * 5 / 8, -1])\n        cylinder(r = cubeSize / 8, h = cubeSize + 2, $fn = DETAIL);\n\tarc(cubeSize, 90, -1, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize * 3 / 4 + 1);\n}\nmodule carveLetterB(cubeSize)\n{\n    translate(v = [cubeSize / 2, cubeSize * 3 / 4, -1])\n        cylinder(r = cubeSize / 8, h = cubeSize + 2, $fn = DETAIL);\n    translate(v = [cubeSize / 2, cubeSize * 1 / 4, -1])\n        cylinder(r = cubeSize / 8, h = cubeSize + 2, $fn = DETAIL);\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 270, cubeSize * 3 / 4, -1);\n\tarcWithMargin(cubeSize, 270, 0, 5, cubeSize * 3 / 4, cubeSize / 2 - 0.1);\n\tarcWithMargin(cubeSize, 180, 5, 0, cubeSize * 3 / 4, cubeSize / 4 + 0.1);\n}\nmodule carveLetterC(cubeSize)\n{\n\tarc(cubeSize, 90, -1, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 270, cubeSize * 3 / 4, -1);\n\tarc(cubeSize, 0, -1, -1);\n    translate(v = [cubeSize * 3 / 4, cubeSize * 3 / 8, -1])\n\t\tcube(size = [cubeSize / 4 + 1, cubeSize / 4, cubeSize + 2]);\n}\nmodule carveLetterCAlt(cubeSize)\n{\n\tarc(cubeSize, 90, -1, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 270, cubeSize * 3 / 4, -1);\n\tarc(cubeSize, 0, -1, -1);\n\ttranslate(v = [cubeSize / 2, cubeSize / 2, -1])\n\t\tcylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n    translate(v = [cubeSize / 2, cubeSize / 4, -1])\n\t\tcube(size = [cubeSize / 2 + 1, cubeSize / 2, cubeSize + 2]);\n}\nmodule carveLetterD(cubeSize)\n{\n    translate(v = [cubeSize / 2, cubeSize / 2, -1])\n        cylinder(r = cubeSize / 8, h = cubeSize + 2, $fn = DETAIL);\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 270, cubeSize * 3 / 4, -1);\n}\nmodule carveLetterDAlt(cubeSize)\n{\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 270, cubeSize * 3 / 4, -1);\n\ttranslate(v = [cubeSize / 2, cubeSize / 2, -1])\n\t\tcylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n    translate(v = [cubeSize / 4, cubeSize / 4, -1])\n\t\tcube(size = [cubeSize / 4, cubeSize / 2, cubeSize + 2]);\n}\nmodule carveLetterE(cubeSize)\n{\n    translate(v = [cubeSize * 3 / 4, cubeSize * 5 / 8, -1])\n        cube(size = [cubeSize / 4 + 1, cubeSize / 8, cubeSize + 2]);\n    translate(v = [cubeSize * 3 / 4, cubeSize / 4, -1])\n        cube(size = [cubeSize / 4 + 1, cubeSize / 8, cubeSize + 2]);\n}\nmodule carveLetterEAlt(cubeSize)\n{\n    translate(v = [cubeSize / 4, cubeSize * 5 / 8, -1])\n        cube(size = [cubeSize * 3 / 4 + 1, cubeSize / 8, cubeSize + 2]);\n    translate(v = [cubeSize / 4, cubeSize  / 4, -1])\n        cube(size = [cubeSize * 3 / 4 + 1, cubeSize / 8, cubeSize + 2]);\n    translate(v = [cubeSize * 5 / 8, cubeSize * 3 / 8 - 1, -1])\n        cube(size = [cubeSize / 2, cubeSize / 4 + 2, cubeSize + 2]);\n}\nmodule carveLetterF(cubeSize)\n{\n    translate(v = [cubeSize * 3 / 4, cubeSize / 2, -1])\n\t\tcube(size = [cubeSize / 4 + 1, cubeSize / 4, cubeSize + 2]);\n    translate(v = [cubeSize * 3 / 4, -1, -1])\n\t\tcube(size = [cubeSize / 4 + 1, cubeSize / 4 + 1, cubeSize + 2]);\n}\nmodule carveLetterFAlt(cubeSize)\n{\n    translate(v = [cubeSize / 4, cubeSize / 2, -1])\n\t\tcube(size = [cubeSize * 3/ 4 + 1, cubeSize / 4, cubeSize + 2]);\n    translate(v = [cubeSize / 4, -1, -1])\n\t\tcube(size = [cubeSize * 3 / 4 + 1, cubeSize / 4 + 1, cubeSize + 2]);\n    translate(v = [cubeSize * 5 / 8, cubeSize / 4 - 1, -1])\n        cube(size = [cubeSize / 2, cubeSize / 4 + 2, cubeSize + 2]);\n}\nmodule carveLetterG(cubeSize)\n{\n\tarc(cubeSize, 90, -1, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 0, -1, -1);\n    translate(v = [cubeSize * 3 / 4, cubeSize * 3 / 8, -1])\n\t\tcube(size = [cubeSize / 4 + 1, cubeSize / 4, cubeSize + 2]);\n}\nmodule carveLetterGAlt(cubeSize)\n{\n\tarc(cubeSize, 90, -1, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 0, -1, -1);\n\ttranslate(v = [cubeSize / 2, cubeSize / 2, -1])\n\t\tcylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n    translate(v = [cubeSize / 2, cubeSize / 2, -1])\n\t\tcube(size = [cubeSize / 2 + 1, cubeSize / 4, cubeSize + 2]);\n    translate(v = [cubeSize / 2, cubeSize / 4, -1])\n\t\tcube(size = [cubeSize / 4, cubeSize / 4 + 1, cubeSize + 2]);\n}\nmodule carveLetterH(cubeSize)\n{\n    translate(v = [cubeSize / 4, -1, -1])\n        cube(size = [cubeSize / 2, cubeSize / 4 + 1, cubeSize + 2]);\n    translate(v = [cubeSize / 4, cubeSize * 3 / 4, -1])\n        cube(size = [cubeSize / 2, cubeSize / 4 + 1, cubeSize + 2]);\n}\nmodule carveLetterHAlt(cubeSize)\n{\n    translate(v = [cubeSize / 4, -1, -1])\n        cube(size = [cubeSize / 2, cubeSize * 3 / 8 + 1, cubeSize + 2]);\n    translate(v = [cubeSize / 4, cubeSize * 5 / 8, -1])\n        cube(size = [cubeSize / 2, cubeSize * 3 / 8 + 1, cubeSize + 2]);\n}\nmodule carveLetterI(cubeSize)\n{\n    translate(v = [-1, cubeSize / 4, -1])\n        cube(size = [cubeSize / 4 + 1, cubeSize / 2, cubeSize + 2]);\n    translate(v = [cubeSize * 3 / 4, cubeSize / 4, -1])\n        cube(size = [ cubeSize / 4 + 1, cubeSize / 2,cubeSize + 2]);\n}\nmodule carveLetterIAlt(cubeSize)\n{\n    translate(v = [-1, cubeSize / 4, -1])\n        cube(size = [cubeSize * 3 / 8 + 1, cubeSize / 2, cubeSize + 2]);\n    translate(v = [cubeSize * 5 / 8, cubeSize / 4, -1])\n        cube(size = [ cubeSize * 3 / 8 + 1, cubeSize / 2,cubeSize + 2]);\n}\nmodule carveLetterJ(cubeSize)\n{\n\tarc(cubeSize, 270, cubeSize * 3 / 4, -1);\n\tarc(cubeSize, 0, -1, -1);\n    translate(v = [-1, cubeSize / 2, -1])\n\t\tcube(size = [cubeSize / 4 + 1, cubeSize / 2 + 1, cubeSize + 2]);\n}\nmodule carveLetterJAlt(cubeSize)\n{\n\tarc(cubeSize, 270, cubeSize * 3 / 4, -1);\n\tarc(cubeSize, 0, -1, -1);\n\ttranslate(v = [cubeSize / 2, cubeSize / 2, -1])\n\t\tcylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n    translate(v = [-1, cubeSize / 2, -1])\n\t\tcube(size = [cubeSize * 3 / 4 + 1, cubeSize / 2 + 1, cubeSize + 2]);\n}\nmodule carveLetterK(cubeSize)\n{\n\ttranslate(v = [cubeSize / 2, cubeSize, -1])\n\t\tcylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n\ttranslate(v = [cubeSize / 4, cubeSize * 3 / 4, -1])\n\t\tcube(size = [cubeSize / 4, cubeSize / 4 + 1, cubeSize + 2]);\n\ttranslate(v = [cubeSize / 2, 0, -1])\n\t\tcylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n\ttranslate(v = [cubeSize / 4, -1, -1])\n\t\tcube(size = [cubeSize / 4, cubeSize / 4 + 1, cubeSize + 2]);\n\tarc(cubeSize, 270, cubeSize * 3 / 4, cubeSize / 2);\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize / 4);\n}\nmodule carveLetterKAlt(cubeSize)\n{\n\ttranslate(v = [cubeSize / 2, cubeSize * 7 / 8, -1])\n\t\tcylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n\ttranslate(v = [cubeSize / 4, cubeSize * 5 / 8, -1])\n\t\tcube(size = [cubeSize / 4, cubeSize / 2, cubeSize + 2]);\n\ttranslate(v = [cubeSize / 2 - 1, cubeSize * 7 / 8, -1])\n\t\tcube(size = [cubeSize / 4 + 1, cubeSize / 4, cubeSize + 2]);\n\ttranslate(v = [cubeSize / 2, cubeSize / 8, -1])\n\t\tcylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n\ttranslate(v = [cubeSize / 4, -1, -1])\n\t\tcube(size = [cubeSize / 4, cubeSize * 3 / 8 + 1, cubeSize + 2]);\n\ttranslate(v = [cubeSize / 2 - 1, -1, -1])\n\t\tcube(size = [cubeSize / 4 + 1, cubeSize / 8 + 1, cubeSize + 2]);\n\tarc(cubeSize, 270, cubeSize * 3 / 4, cubeSize / 2);\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize / 4);\n}\nmodule carveLetterL(cubeSize)\n{\n    translate(v = [cubeSize * 3 / 4, cubeSize / 2, -1])\n\t\tcube(size = [cubeSize / 4 + 1, cubeSize / 2 + 1, cubeSize + 2]);\n}\nmodule carveLetterLAlt(cubeSize)\n{\n    translate(v = [cubeSize / 4, cubeSize / 4, -1])\n\t\tcube(size = [cubeSize * 4 / 4 + 1, cubeSize * 3 / 4 + 1, cubeSize + 2]);\n}\nmodule carveLetterM(cubeSize)\n{\n\tarc(cubeSize, 90, -1, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize * 3 / 4 + 1);\n\tarcWithMargin(cubeSize, 180, 0.1, 5, cubeSize / 4 + 0.1, cubeSize * 3 / 4);\n\tarcWithMargin(cubeSize,  90, 5, 0.1, cubeSize / 2 - 0.1, cubeSize * 3 / 4);\n    translate(v = [cubeSize / 4, -1, -1])\n\t\tcube(size = [cubeSize / 8, cubeSize / 4 + 1, cubeSize + 2]);\n    translate(v = [cubeSize * 5 / 8, -1, -1])\n\t\tcube(size = [cubeSize / 8, cubeSize / 4 + 1, cubeSize + 2]);\n}\nmodule carveLetterN(cubeSize)\n{\n\tarcWithMargin(cubeSize, 180, 0, 5, cubeSize * 3 / 8, cubeSize * 3 / 4);\n\tarcWithMargin(cubeSize,   0, 0, 5, cubeSize * 3 / 8, -5);\n}\nmodule carveLetterO(cubeSize)\n{\n\tarc(cubeSize, 90, -1, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 270, cubeSize * 3 / 4, -1);\n\tarc(cubeSize, 0, -1, -1);\n    translate(v = [cubeSize / 2, cubeSize / 2, -1])\n\t\tcylinder(r = cubeSize / 8, h = cubeSize + 2,$fn = DETAIL);\n}\nmodule carveLetterOAlt(cubeSize)\n{\n\tarc(cubeSize, 90, -1, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 270, cubeSize * 3 / 4, -1);\n\tarc(cubeSize, 0, -1, -1);\n    translate(v = [cubeSize / 2, cubeSize / 2, -1])\n\t\tcylinder(r = cubeSize / 4, h = cubeSize + 2,$fn = DETAIL);\n}\nmodule carveLetterP(cubeSize)\n{\n    translate(v = [cubeSize / 2, cubeSize * 3 / 4, -1])\n        cylinder(r = cubeSize / 8, h = cubeSize + 2, $fn = DETAIL);\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize * 3 / 4 + 1);\n\tarcWithMargin(cubeSize, 270, 5, 5, cubeSize * 3 / 4, cubeSize / 2 - 5);\n\ttranslate(v = [cubeSize * 3 / 4, -1, -1])\n\t\tcube(size = [cubeSize / 4 + 1, cubeSize / 2 + 1, cubeSize + 2]);\n}\nmodule carveLetterPAlt(cubeSize)\n{\n    translate(v = [cubeSize / 2, cubeSize * 3 / 4, -1])\n        cylinder(r = cubeSize / 8, h = cubeSize + 2, $fn = DETAIL);\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize * 3 / 4 + 1);\n\tarcWithMargin(cubeSize, 270, 5, 5, cubeSize * 3 / 4, cubeSize / 2 - 5);\n\ttranslate(v = [cubeSize / 2, -1, -1])\n\t\tcube(size = [cubeSize / 2 + 1, cubeSize / 2 + 1, cubeSize + 2]);\n}\nmodule carveLetterQ(cubeSize)\n{\n\tarc(cubeSize, 90, -1, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 0, -1, -1);\n    translate(v = [cubeSize / 2, cubeSize / 2, -1])\n\t\tcylinder(r = cubeSize / 8, h = cubeSize + 2,$fn = DETAIL);\n}\nmodule carveLetterR(cubeSize)\n{\n    translate(v = [cubeSize / 2, cubeSize * 3 / 4, -1])\n        cylinder(r = cubeSize / 8, h = cubeSize + 2, $fn = DETAIL);\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize * 3 / 4 + 1);\n\tarcWithMargin(cubeSize, 270, 0, 5, cubeSize * 3 / 4, cubeSize / 2 - 0.1);\n\tarcWithMargin(cubeSize, 180, 5, 0, cubeSize * 3 / 4, cubeSize / 4 + 0.1);\n\ttranslate(v = [cubeSize / 2, 0, -1])\n\t\tcylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n\ttranslate(v = [cubeSize / 4, -1, -1])\n\t\tcube(size = [cubeSize / 4, cubeSize / 4 + 1, cubeSize + 2]);\n}\nmodule carveLetterS(cubeSize)\n{\n\tarc(cubeSize, 90, -1, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 270, cubeSize * 3 / 4, -1);\n\tarcWithMargin(cubeSize,   0, 5, 0, -5, cubeSize * 3 / 8);\n\tarcWithMargin(cubeSize, 180, 5, 0, cubeSize * 3 / 4, cubeSize * 3 / 8);\n}\nmodule carveLetterT(cubeSize)\n{\n\ttranslate(v = [-1, -1, -1])\n\t\tcube(size = [cubeSize / 4 + 1, cubeSize * 5 / 8 + 1, cubeSize + 2]);\n\ttranslate(v = [cubeSize * 3 / 4, -1, -1])\n\t\tcube(size = [cubeSize / 4 + 1, cubeSize * 5 / 8 + 1, cubeSize + 2]);\n}\nmodule carveLetterU(cubeSize)\n{\n\tarc(cubeSize, 270, cubeSize * 3 / 4, -1);\n\tarc(cubeSize, 0, -1, -1);\n    translate(v = [cubeSize / 4, cubeSize * 3 / 4, -1])\n\t\tcube(size = [cubeSize / 2, cubeSize / 4 + 1, cubeSize + 2]);\n}\nmodule carveLetterUAlt(cubeSize)\n{\n\tarc(cubeSize, 270, cubeSize * 3 / 4, -1);\n\tarc(cubeSize, 0, -1, -1);\n    translate(v = [cubeSize / 2, cubeSize / 2, -1])\n\t\tcylinder(r = cubeSize / 4, h = cubeSize + 2,$fn = DETAIL);\n    translate(v = [cubeSize / 4, cubeSize / 2, -1])\n\t\tcube(size = [cubeSize / 2, cubeSize / 2 + 1, cubeSize + 2]);\n}\nmodule carveLetterV(cubeSize)\n{\n\ttranslate(v = [0, 0, -1])\n\t\tlinear_extrude(height = cubeSize + 2, center = false, convexity = 3)\n\t\t\tpolygon(points = [[-0.1, cubeSize * 3 / 8], [cubeSize * 3 / 8, -0.1], [-0.1, -0.1]], paths = [[0, 1, 2]], convexity = 3);\n\ttranslate(v = [0, 0, -1])\n\t\tlinear_extrude(height = cubeSize + 2, center = false, convexity = 3)\n\t\t\tpolygon(points = [[cubeSize * 5 / 8, - 0.1], [cubeSize + 0.1, cubeSize * 3 / 8 + 0.1], [cubeSize + 0.1, -0.1]], paths = [[0, 1, 2]], convexity = 3);\n\ttranslate(v = [0, 0, -1])\n\t\tlinear_extrude(height = cubeSize + 2, center = false, convexity = 3)\n\t\t\tpolygon(points = [[cubeSize / 4, cubeSize + 0.1], [cubeSize * 3 / 4, cubeSize + 0.1], [cubeSize / 2, cubeSize * 5 / 8]], paths = [[0, 1, 2]], convexity = 3);\n}\nmodule carveLetterW(cubeSize)\n{\n\tarc(cubeSize, 270, cubeSize * 3 / 4, -1);\n\tarc(cubeSize, 0, -1, -1);\n\tarcWithMargin(cubeSize, 270, 5, 0.1, cubeSize / 4 + 0.1, -5);\n\tarcWithMargin(cubeSize,   0, 0.1, 5, cubeSize / 2 - 0.1, -5);\n    translate(v = [cubeSize / 4, cubeSize * 3 / 4, -1])\n\t\tcube(size = [cubeSize / 8, cubeSize / 4 + 1, cubeSize + 2]);\n    translate(v = [cubeSize * 5 / 8, cubeSize * 3 / 4, -1])\n\t\tcube(size = [cubeSize / 8, cubeSize / 4 + 1, cubeSize + 2]);\n}\nmodule carveLetterX(cubeSize)\n{\n\ttranslate(v = [cubeSize / 2, 0, -1])\n\t\tcylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n\ttranslate(v = [0, cubeSize / 2, -1])\n\t\tcylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n\ttranslate(v = [cubeSize / 2, cubeSize, -1])\n\t\tcylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n\ttranslate(v = [cubeSize, cubeSize / 2, -1])\n\t\tcylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n}\nmodule carveLetterY(cubeSize)\n{\n\ttranslate(v = [cubeSize / 2, cubeSize, -1])\n\t\tcylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n\tarcWithMargin(cubeSize, 270, 5, 5, cubeSize * 3 / 4, cubeSize / 2 - 5);\n\ttranslate(v = [cubeSize * 3 / 4, -1, -1])\n\t\tcube(size = [cubeSize / 4 + 1, cubeSize / 2 + 1, cubeSize + 2]);\n\tarcWithMargin(cubeSize, 0, 5, 5, -5, cubeSize / 2 - 5);\n\ttranslate(v = [-1, -1, -1])\n\t\tcube(size = [cubeSize / 4 + 1, cubeSize / 2 + 1, cubeSize + 2]);\n}\nmodule carveLetterYAlt(cubeSize)\n{\n\ttranslate(v = [cubeSize / 2, cubeSize, -1])\n\t\tcylinder(r = cubeSize / 4, h = cubeSize + 2, $fn = DETAIL);\n\tarcWithMargin(cubeSize, 270, 5, 5, cubeSize * 3 / 4, cubeSize / 2 - 5);\n\ttranslate(v = [cubeSize * 5 / 8, -1, -1])\n\t\tcube(size = [cubeSize * 3 / 8 + 1, cubeSize / 2 + 1, cubeSize + 2]);\n\tarcWithMargin(cubeSize, 0, 5, 5, -5, cubeSize / 2 - 5);\n\ttranslate(v = [-1, -1, -1])\n\t\tcube(size = [cubeSize * 3 / 8 + 1, cubeSize / 2 + 1, cubeSize + 2]);\n}\nmodule carveLetterZ(cubeSize)\n{\n\tarc(cubeSize, 180, cubeSize * 3 / 4, cubeSize * 3 / 4 + 1);\n\tarc(cubeSize, 0, -1, -1);\n\tarcWithMargin(cubeSize,  90, 0, 5, -5, cubeSize * 3 / 8);\n\tarcWithMargin(cubeSize, 270, 0, 5, cubeSize * 3 / 4, cubeSize * 3 / 8);\n}\nmodule carveLetter(typeface, theLetter, cubeSize)\n{\n    if (theLetter == \"A\")\n        carveLetterA(cubeSize);\n    if (theLetter == \"B\")\n        carveLetterB(cubeSize);\n    if (theLetter == \"C\")\n\t{\n\t\tif (typeface == \"alternate\")\n\t\t\tcarveLetterCAlt(cubeSize);\n\t\telse\n        \tcarveLetterC(cubeSize);\n\t}\n    if (theLetter == \"D\")\n\t{\n\t\tif (typeface == \"alternate\")\n\t\t\tcarveLetterDAlt(cubeSize);\n\t\telse\n        \tcarveLetterD(cubeSize);\n\t}\n    if (theLetter == \"E\")\n\t{\n\t\tif (typeface == \"alternate\")\n\t\t\tcarveLetterEAlt(cubeSize);\n\t\telse\n        \tcarveLetterE(cubeSize);\n\t}\n    if (theLetter == \"F\")\n\t{\n\t\tif (typeface == \"alternate\")\n\t\t\tcarveLetterFAlt(cubeSize);\n\t\telse\n        \tcarveLetterF(cubeSize);\n\t}\n    if (theLetter == \"G\")\n\t{\n\t\tif (typeface == \"alternate\")\n\t\t\tcarveLetterGAlt(cubeSize);\n\t\telse\n        \tcarveLetterG(cubeSize);\n\t}\n    if (theLetter == \"H\")\n\t{\n\t\tif (typeface == \"alternate\")\n\t\t\tcarveLetterHAlt(cubeSize);\n\t\telse\n        \tcarveLetterH(cubeSize);\n\t}\n    if (theLetter == \"I\")\n\t{\n\t\tif (typeface == \"alternate\")\n\t\t\tcarveLetterIAlt(cubeSize);\n\t\telse\n        \tcarveLetterI(cubeSize);\n\t}\n    if (theLetter == \"J\")\n\t{\n\t\tif (typeface == \"alternate\")\n\t\t\tcarveLetterJAlt(cubeSize);\n\t\telse\n        \tcarveLetterJ(cubeSize);\n\t}\n    if (theLetter == \"K\")\n\t{\n\t\tif (typeface == \"alternate\")\n\t\t\tcarveLetterKAlt(cubeSize);\n\t\telse\n        \tcarveLetterK(cubeSize);\n\t}\n    if (theLetter == \"L\")\n\t{\n\t\tif (typeface == \"alternate\")\n\t\t\tcarveLetterLAlt(cubeSize);\n\t\telse\n        \tcarveLetterL(cubeSize);\n\t}\n    if (theLetter == \"M\")\n        carveLetterM(cubeSize);\n    if (theLetter == \"N\")\n        carveLetterN(cubeSize);\n    if (theLetter == \"O\")\n\t{\n\t\tif (typeface == \"alternate\")\n\t\t\tcarveLetterOAlt(cubeSize);\n\t\telse\n        \tcarveLetterO(cubeSize);\n\t}\n    if (theLetter == \"P\")\n\t{\n\t\tif (typeface == \"alternate\")\n\t\t\tcarveLetterPAlt(cubeSize);\n\t\telse\n        \tcarveLetterP(cubeSize);\n\t}\n    if (theLetter == \"Q\")\n        carveLetterQ(cubeSize);\n    if (theLetter == \"R\")\n        carveLetterR(cubeSize);\n    if (theLetter == \"S\")\n        carveLetterS(cubeSize);\n    if (theLetter == \"T\")\n       \tcarveLetterT(cubeSize);\n    if (theLetter == \"U\")\n\t{\n\t\tif (typeface == \"alternate\")\n\t\t\tcarveLetterUAlt(cubeSize);\n\t\telse\n        \tcarveLetterU(cubeSize);\n\t}\n    if (theLetter == \"V\")\n        carveLetterV(cubeSize);\n    if (theLetter == \"W\")\n        carveLetterW(cubeSize);\n    if (theLetter == \"X\")\n        carveLetterX(cubeSize);\n    if (theLetter == \"Y\")\n\t{\n\t\tif (typeface == \"alternate\")\n\t\t\tcarveLetterYAlt(cubeSize);\n\t\telse\n        \tcarveLetterY(cubeSize);\n\t}\n    if (theLetter == \"Z\")\n        carveLetterZ(cubeSize);\n}\nmodule carveBlock(typeface, letter1, letter2, letter3)\n{\n\ttranslate(v = [SIZE / -2, SIZE / -2, 0])\n\t    difference()\n\t    {\n\t        cube(size = [SIZE, SIZE, SIZE]);\n\t        carveLetter(typeface, letter3, SIZE);\n\t        translate(v = [0, SIZE, 0])\n\t            rotate(a = [90, 0, 0])\n\t                carveLetter(typeface, letter1, SIZE);\n\t        translate(v = [0, 0, 0])\n\t            rotate(a = [0, 90, 0])\n\t                rotate(a = [0, 0, 90])\n\t                    carveLetter(typeface, letter2, SIZE);\n\t    }\n}\nmodule test()\n{\n    difference()\n    {\n        cube(size = [SIZE, SIZE, SIZE]);\n        carveLetterFAlt(SIZE);\n    }\n}\ncarveBlock(typeface, left_side_letter, right_side_letter, top_letter);",
    "description": "Okay, I'm looking to create a personalized monogram cube, sort of like the one described in this OpenSCAD file I found. It's inspired by the \"Godel, Escher, Bach\" book cover. I'd like to be able to specify three letters, one for the top, one for the left side, and one for the right side. When you look at the cube straight on from the top, the top letter is visible. When you rotate it, the other two letters are revealed. \n\nThe provided SCAD file also has a couple of typeface options; \"blocks\" and \"alternate.\" I'd like to maintain that functionality. The \"blocks\" typeface is a bit more stylized, while \"alternate\" is more traditional. It also uses a variable called \"DETAIL\" which determines the smoothness of the curves. So the user query should have a way to control \"DETAIL\" too. I'd also like the ability to adjust the overall size of the cube using a SIZE variable.\n\nI'm envisioning a parametric OpenSCAD file that can do all of this. I know there's a lot of code in the existing one, but I'd like to focus on making it parametric so I can easily adjust letters and the typefaces, size and detail. I'm assuming it uses basic OpenSCAD primitives, so I don't need specific libraries mentioned, but the existing code does include functions like `arc` and `arcWithMargin`. I'd like to keep the core logic of those functions. Can you generate the OpenSCAD code that will achieve this, including the ability to choose specific letters and typeface for the output, as well as the overall size and smoothness?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Clothes Rod Linking Bracket",
    "scad": "use <utils/build_plate.scad>\nbuild_plate_selector = 0;\nrod_diameter_in = 1.5;\nstem_length_in = 2.0;\nhanger_height_in = 0.625;\nhanger_width_in = 0.625;\nwall_thickness_in=0.25;\ncreate_raft = 0;\nIN = 25.4/1;\nrod_diameter = rod_diameter_in*IN;\nstem_length = stem_length_in*IN;\nhanger_height = hanger_height_in*IN;\nhanger_width = hanger_width_in*IN;\nwall_thickness = wall_thickness_in*IN;\npart_width = wall_thickness_in*IN;\nraft_section_width = 0.5/1;\nraft_section_spacing = 1.5/1;\nraft_manifold_tweak = 0.01/1;\nmodule rod_holder() {\n\tod = wall_thickness*2 + rod_diameter;\n    heights = [-part_width*1.5, 0, part_width*1.5];\ncylinder(h=part_width*4, r=od/2, $fs=1);\n\tunion() {\n\t\tfor ( i = [0:2] ) {\n\t\t\ttranslate([od/2,0,heights[i]])\n\t\t\tdifference() {\n\t\t\t\tcylinder(h=part_width, r=od/2, $fs=1);\n\t\t\t\ttranslate([0,0,-part_width/2])\n\t\t\t\tcylinder(h=part_width*2, r=rod_diameter/2, $fs=1);\n\t\t\t}\n\t\t}\n\t\tfor(j = [0, 2]) {\n\t\t\tfor ( i = [0:11] ) {\n\t\t\t\tcolor(\"green\")\n\t\t\t\ttranslate([od/2, 0, heights[j]/2])\n\t\t\t\trotate(i*360 / 12, [0, 0, 1])\n\t\t\t\ttranslate([od/2-wall_thickness/2, 0, 0])\n\t\t\t\tcylinder(h=part_width, r=wall_thickness/2);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule stem() {\n\ttranslate([0, -rod_diameter/4, 0])\n\tcube([stem_length+wall_thickness*2, rod_diameter/2, part_width]);\n}\nmodule hanger() {\n\ttranslate([0, -rod_diameter/4, 0])\n\tdifference() {\n\t\tcube([hanger_height+wall_thickness*2, rod_diameter/2, hanger_width+wall_thickness*2]);\n\t\ttranslate([wall_thickness, -rod_diameter/4, wall_thickness])\n\t\tcube([hanger_height, rod_diameter, hanger_width]);\n\t}\n}\nmodule make_raft(x, y, z) {\n\tintersection() {\n\t\tcube([x, y*2, z*2]);\n\t\tunion() {\n\t\t\tfor( i = [ 0 : raft_section_spacing*2 : x ] ) {\n\t\t\t\ttranslate([i, 0, 0])\n\t\t\t\tcube([raft_section_width, y, z+raft_manifold_tweak*2]);\n\t\t\t\ttranslate([i, 0, 0])\n\t\t\t\tcube([raft_section_spacing+raft_section_width, raft_section_width, z+raft_manifold_tweak*2]);\n\t\t\t\ttranslate([i+raft_section_spacing, 0, 0])\n\t\t\t\tcube([raft_section_width, y, z+raft_manifold_tweak*2]);\n\t\t\t\ttranslate([i+raft_section_spacing, y, 0])\n\t\t\t\tcube([raft_section_spacing+raft_section_width, raft_section_width, z+raft_manifold_tweak*2]);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule raft() {\n\tbox_length = stem_length;\n\tbox_width = part_width*1.5;\n\tbox_height = rod_diameter/2 - part_width/2 + raft_manifold_tweak;\n\tcolor(\"purple\")\n\ttranslate([hanger_height+wall_thickness*2, -(hanger_width+wall_thickness*2)+(hanger_width+wall_thickness)/3, 0])\n\tmake_raft(box_length, box_width, box_height);\n\tcolor(\"purple\")\n\ttranslate([0,-(hanger_width+wall_thickness*2.5), 0])\n\tmake_raft(hanger_height+wall_thickness*2, hanger_width+wall_thickness*3, (rod_diameter/2+wall_thickness) - rod_diameter/4 + raft_manifold_tweak);\n}\ntotal_part_length = (rod_diameter + wall_thickness*2) + stem_length + (hanger_height+wall_thickness*2);\ntranslate([-total_part_length/2, 0, 0])\nunion() {\n\ttranslate([0, 0, wall_thickness + rod_diameter/2])\n\trotate([90,0,0])\n\ttranslate([hanger_height+wall_thickness, 0, 0])\n\tunion() {\n\t\ttranslate([-(hanger_height+wall_thickness), 0, 0])\n\t\thanger();\n\t\ttranslate([(stem_length+wall_thickness), 0, (hanger_width+2*wall_thickness)/2-(part_width/2)])\n\t\tunion()\n\t\t{\n\t\t\trod_holder();\n\t\t\ttranslate([-(stem_length+wall_thickness), 0, 0])\n\t\t\tstem();\n\t\t}\n\t}\n\tif (create_raft) {\n\t\traft();\n\t}\n}\nbuild_plate(build_plate_selector);",
    "description": "Okay, I need a customizable closet rod support bracket, and I've got some specific requirements in mind.\n\nThe basic idea is a bracket that slides onto an existing closet rod and then hooks onto something above, like a shelf support. The bracket will consist of a few key parts: a circular \"holder\" that wraps around the rod, a straight \"stem\" that extends horizontally from that holder, and a vertical \"hanger\" that will hook onto the support above.\n\nHere's what I need to be customizable:\n\n1.  **Rod Diameter:** I need to be able to specify the diameter of the closet rod in inches.\n2.  **Stem Length:** I need to specify how far the stem extends out from the rod in inches.\n3.  **Hanger Height:** I need to specify the vertical height of the opening in the hanger, in inches.\n4.  **Hanger Width:** I need to specify the horizontal width of the opening in the hanger, in inches.\n5.  **Wall Thickness:** This controls the thickness of the entire bracket, and I want to be able to set that in inches. I'm thinking options like 1/8\", 1/4\", 1/2\", and 3/4\" would be good presets.\n6.  **Raft:** I want the option to add a raft underneath as well as a section of raft against the hanger in order to improve bed adhesion during printing. This should be optional.\n\nI also need a couple of things baked in:\n\n*   The whole bracket should be created such that it prints well vertically.\n*   I'd like to have a \"build plate\" function to show a common build plate size. I don't need you to write this, but just include the proper include for `utils/build_plate.scad`. That is, please include `use <utils/build_plate.scad>` in the code.\n*   It'd be nice if the rod holder section had some printed supports internal to its outer circle.\n\nI'm open to how you create these, but the goal is to have something that can be printed and provide some support for a sagging clothes rod. I need this to be parametric in OpenSCAD, so that I can modify the measurements for my closet. Could you generate the .scad code for me?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Half Circle Chain Bracelet",
    "scad": "use <utils/build_plate.scad>\nnumber_links = 16;\necho ( \"Number of Links\" , number_links );\npi_value = 3.14159 *1;\necho ( \"Pi\" , pi_value );\ndefault_size = 10;\necho ( \"Link Size\" , default_size );\nhow_thick = 0.15;\necho ( \"Thickness %\" , how_thick );\ninner_separation = 1.05;\nouter_separation = 1.05;\npolygon_count = 16;\necho( \"Print Quality / Polygon Count\" , polygon_count );\nshow_overlap = 0;\nlink_radius = default_size * how_thick;\nlink_offset = default_size + link_radius;\nlink_length = link_offset * 2;\necho ( \"Inner Separation\" , inner_separation );\necho ( \"Outer Separation\" , outer_separation );\necho ( \"Link Radius\" , link_radius );\necho ( \"Link Offset\" , link_offset );\necho ( \"Link Length\" , link_length );\ncircle_links = round( number_links / 2 );\ncircle_loops = circle_links - 1;\noffset_angle = (360/number_links);\necho ( \"Angle\" , offset_angle);\ninner_circumference = link_length * circle_links;\ninner_diameter = ( inner_circumference / pi_value );\ninner_radius = inner_diameter / 2;\necho ( \"Inner Circumference\" , inner_circumference );\necho ( \"Inner Diameter\" , inner_diameter );\necho ( \"Inner Radius\" , inner_radius );\nx_translate = sqrt( pow( inner_radius , 2 ) - pow( default_size , 2 ) );\ninner_trans = x_translate * inner_separation;\nouter_trans = ( x_translate + default_size - ( link_radius * 4 )) * outer_separation;\ntotal_diameter = ( ( inner_trans + default_size + link_radius ) * 2 );\necho ( \"Total Diameter\" , total_diameter );\necho ( \"Show Overlap / Intersection\" , show_overlap );\nbuild_plate_selector = 2;\nbuild_plate_manual_x = 100 + 0;\nbuild_plate_manual_y = 100 + 0;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nif ( show_overlap == 1 )\n{\n#circle(inner_radius);\nintersection()\n{\ninner_circle();\nouter_circle();\n}\n}\nelse\n{\ninner_circle();\nouter_circle();\n}\nmodule inner_circle()\n{\nfor(i=[0:circle_loops])\n\t{\n\techo ( \"Inner Circle Count\" , i );\n\trotate([0,0,(360/circle_links) * i])\n\t{\n\ttranslate([inner_trans,0,0]) rotate([0,0,270]) chain_link( link_size=default_size );\n\t}\n\t}\n}\nmodule outer_circle()\n{\nfor(i=[0:circle_loops])\n\t{\n\techo ( \"Outer Circle Count\" , i );\n\trotate([0,0,((360/circle_links) * i)+offset_angle])\n\t{\n\ttranslate([outer_trans,0,0]) rotate([0,0,90]) chain_link( link_size=default_size);\n\t}\n\t}\n}\nmodule doughnut( r1=4 , r2=1 )\n{\necho (\"Doughnut Shape\");\nrotate_extrude($fn=polygon_count)\n\ttranslate([r1,0,0])\n\tcircle(r=r2,$fn=polygon_count);\n}\nmodule ring( rsize = default_size )\n{\necho (\"Ring Shape\");\ndifference()\n{\ndoughnut( r1=rsize , r2=(rsize*how_thick));\n}\n}\nmodule arch( arch_size = default_size )\n{\necho (\"Arch Shape\");\ndifference()\n{\nrotate([90,0,0]) ring( rsize = arch_size );\ntranslate([0,0,-arch_size*2]) cube(arch_size*4,center=true,$fn=polygon_count);\n}\n}\nmodule split_arch( split_arch_size = default_size )\n{\necho (\"Split Arch Shape\");\ndifference()\n{\nrotate([-90,0,0]) arch( arch_size = split_arch_size );\ntranslate([0,0,-split_arch_size*2]) cube(split_arch_size*4,center=true,$fn=polygon_count);\n}\n}\nmodule chain_link( link_size = default_size )\n{\necho (\"Chain Link Object\");\nunion()\n{\narch( arch_size = link_size );\nsplit_arch( split_arch_size = link_size );\n}\n}",
    "description": "Okay, I'm looking to design a customizable chain bracelet made of interlocking half-circle links, similar to the \"Customizable Half Circle Chain vBelfry001.scad\" file I found online but with a few modifications and improvements.\n\nHere's what I need in the OpenSCAD file you'll create:\n\n*   **Basic Structure:** The design should consist of two concentric circles of these half-circle links. The inner circle of links should alternate with the outer circle of links, creating an interlocking chain.\n\n*   **Number of Links:** The user should be able to control the total number of links in the chain, and this should be easily adjustable. A dropdown selection with common values would be ideal, or at the least a comment indicating good values. The original file uses values like 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, and 48 which seem appropriate for a bracelet.\n\n*   **Link Size:** The overall size of each half-circle link needs to be adjustable, probably by a single size parameter. Perhaps a dropdown like the original with \"Tiny\", \"Small\", \"Medium\", \"Large\", \"Extra Large\" and corresponding numeric values would be helpful, the original had 5, 8, 10, 12, and 15.\n\n*   **Link Thickness:** The thickness of each link should also be user adjustable, as a percentage of the overall link size, similar to the `how_thick` parameter in the reference file, which used 0.1, 0.15, or 0.2. The comments with \"Thin, Medium, Thick\" seem like good descriptions.\n\n*   **Spacing:** The spacing between the inner and outer circles of links should be adjustable using separate multipliers, one for inner spacing and one for outer, similar to the `inner_separation` and `outer_separation` parameters in the original code which used 1.05.\n\n*   **Print Quality:**  The user should be able to set the print quality using the `$fn` parameter for curves/circles. The original example provided choices of 8, 12, 16, 20, 24, 28, and 32.\n\n*   **Overlap Display (Optional):** An optional debug feature to show the overlapping intersections between the links to help understand sizing. The original code used a show_overlap parameter.\n\n*   **Build Plate Display:** It would be helpful to include a visual representation of the build plate. It looks like the original used a `build_plate.scad` library for this. I expect that's available.\n\n*   **Parametric Design:** Everything should be defined with parameters so it's easy to modify. The final result should render as a single joined chain without any intersections.\n\n*   **Clarity of Code:**  It would be ideal if the code was well-commented so I can understand what's going on.\n\n*   **Libraries:** The design will use the `utils/build_plate.scad` library which seems standard. I don't have it, but I assume you can provide the relevant code for that if necessary.\n\nThe code I provided as reference used multiple modules like 'inner\\_circle', 'outer\\_circle', 'doughnut', 'ring', 'arch', and 'chain\\_link'. I thought these were a good organizational strategy.\n\nI'm looking for a single `.scad` file that I can load into OpenSCAD. I do not need any other files. Please let me know if you have any questions. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Knob!",
    "scad": "HoleDiameter = 6;\nHoleDepth = 10;\nHoleFlatThickness = 0;\nKnobHeight = 20;\nKnobDiameter = 20;\nCapType = 1;\nTimerKnob=0;\nPointer1 = 0;\nPointer2 = 1;\nKnurled = 1;\nTaperPercentage = 20;\nRingWidth = 0;\nRingMarkings = 10;\nScrewHoleDiameter = 3;\nShaftLength = 0;\nShaftDiameter = 10;\nNotchedShaft = 0;\nRingThickness = 5*1;\nDivotDepth = 1.5*1;\nMarkingWidth = 1.5*1;\nDistanceBetweenKnurls = 3*1;\nTimerKnobConst = 1.8*1;\nPI=3.14159265*1;\nKnobMajorRadius = KnobDiameter/2;\nKnobMinorRadius = KnobDiameter/2 * (1 - TaperPercentage/100);\nKnobRadius = KnobMinorRadius + (KnobMajorRadius-KnobMinorRadius)/2;\nKnobCircumference = PI*KnobDiameter;\nKnurls = round(KnobCircumference/DistanceBetweenKnurls);\nDivot=CapType;\nTaperAngle=asin(KnobHeight / (sqrt(pow(KnobHeight, 2) +\n\t\tpow(KnobMajorRadius-KnobMinorRadius,2)))) - 90;\nDivotRadius = KnobMinorRadius*.4;\nunion()\n{\ntranslate([0, 0, (ShaftLength==0)? 0 : ShaftLength-0.001])\ndifference()\n{\nunion()\n{\n\tcylinder(h=KnobHeight, r1=KnobMajorRadius, r2=KnobMinorRadius,\n\t\t\t$fn=50);\n\tif (Knurled)\n\t\tfor (i=[0 : Knurls-1])\n\t\t\trotate([0, 0, i * (360/Knurls)])\n\t\t\t\ttranslate([KnobRadius, 0, KnobHeight/2])\n\t\t\t\t\trotate([0, TaperAngle, 0]) rotate([0, 0, 45])\n\t\t\t\t\t\tcube([2, 2, KnobHeight+.001], center=true);\n \tif (RingMarkings>0)\n\t\tfor (i=[0 : RingMarkings-1])\n\t\t\trotate([0, 0, i * (360/RingMarkings)])\n\t\t\t\ttranslate([KnobMajorRadius + RingWidth/2, 0, 1])\n\t\t\t\t\tcube([RingWidth*.5, MarkingWidth, 2], center=true);\n\tif (Pointer2==1)\n\t\ttranslate([KnobRadius, 0, KnobHeight/2-2])\n\t\t\trotate([0, TaperAngle, 0])\n\t\t\t\tcube([8, 3, KnobHeight], center=true);\n\tif (RingWidth>0)\n\t\ttranslate([0, 0, RingThickness/2])\n\t\t\tcylinder(r1=KnobMajorRadius + RingWidth, r2=KnobMinorRadius,\n\t\t\t\t\th=RingThickness, $fn=50, center=true);\n\tif (Divot==2)\n\t\ttranslate([0, 0, KnobHeight])\n\t\t\tdifference()\n\t\t\t{\n\t\t\t\tscale([1, 1, 0.5])\n\t\t\t\t\tsphere(r=KnobMinorRadius, $fn=50, center=true);\n\t\t\t\ttranslate([0, 0, 0-(KnobMinorRadius+.001)])\n\t\t\t\t\tcube([KnobMinorRadius*2.5, KnobMinorRadius*2.5,\n\t\t\t\t\t\t\tKnobMinorRadius*2], center=true);\n\t\t\t}\n\tif (TimerKnob==1) intersection()\n\t\t{\n\t\t\ttranslate([0, 0, 0-(KnobDiameter*TimerKnobConst) + KnobHeight])\n\t\t\tsphere(r=KnobDiameter*TimerKnobConst, $fn=50, center=true);\n\t\t\ttranslate([0-(KnobDiameter*TimerKnobConst)*0.1, 0,\n\t\t\t\t\tKnobHeight/2])\n\t\t\t\tscale([1, 0.5, 1])\n\t\t\t\t\tcylinder(h=KnobHeight, r=(KnobDiameter*TimerKnobConst) *\n\t\t\t\t\t\t\t0.8, $fn=3, center=true);\n\t\t}\n}\nif (Pointer1==1)\n\ttranslate([KnobMinorRadius*.55, 0, KnobHeight + DivotRadius*.6])\n\t\tsphere(r=DivotRadius, $fn=40);\nif (Divot==1)\n\ttranslate([0, 0, KnobHeight])\n\t\tcylinder(h=DivotDepth*2, r=KnobMinorRadius-1.5, $fn=50,\n\t\t\t\tcenter=true);\nif (ShaftLength==0)\n{\n\ttranslate([0, 0, HoleDepth/2 - 0.001])\n\t\tdifference()\n\t\t{\n\t\t\tcylinder(r=HoleDiameter/2, h=HoleDepth, $fn=20,\n\t\t\t\t\tcenter=true);\n\t\t\ttranslate([(0-HoleDiameter)+HoleFlatThickness, 0, 0])\n\t\t\t\tcube([HoleDiameter, HoleDiameter, HoleDepth+.001],\n\t\t\t\t\t\tcenter=true);\n\t\t}\n\tif (ScrewHoleDiameter>0)\n\t\ttranslate([0 - (KnobMajorRadius+RingWidth+1)/2, 0,\n\t\t\t\tHoleDepth/2])\n\t\t\trotate([0, 90, 0])\n\t\t\tcylinder(h=(KnobMajorRadius+RingWidth+1),\n\t\t\t\t\tr=ScrewHoleDiameter/2, $fn=20, center=true);\n}\ntranslate([0, 0, -10])\n\tcube([(KnobMajorRadius+RingWidth) * 3,\n\t\t\t(KnobMajorRadius+RingWidth) * 3, 20], center=true);\n}\nif (ShaftLength>0)\n\tdifference()\n\t{\n\t\ttranslate([0, 0, ShaftLength/2])\n\t\t\tcylinder(h=ShaftLength, r=ShaftDiameter/2, $fn=20,\n\t\t\t\t\tcenter=true);\n\t\tif (NotchedShaft==1)\n\t\t{\n\t\t\tcube([HoleDiameter/2, ShaftDiameter*2, ShaftLength],\n\t\t\t\t\tcenter=true);\n\t\t}\n\t\ttranslate([0, 0, HoleDepth/2 - 0.001])\n\t\t\tdifference()\n\t\t\t{\n\t\t\t\tcylinder(r=HoleDiameter/2, h=HoleDepth, $fn=20,\n\t\t\t\t\t\tcenter=true);\n\t\t\t\ttranslate([(0-HoleDiameter)+HoleFlatThickness, 0, 0])\n\t\t\t\t\tcube([HoleDiameter, HoleDiameter, HoleDepth+.001],\n\t\t\t\t\t\t\tcenter=true);\n\t\t\t}\n\t\tif (ScrewHoleDiameter>0)\n\t\t\ttranslate([0 - (KnobMajorRadius+RingWidth+1)/2, 0,\n\t\t\t\t\tHoleDepth/2])\n\t\t\t\trotate([0, 90, 0])\n\t\t\t\tcylinder(h=(KnobMajorRadius+RingWidth+1),\n\t\t\t\t\t\tr=ScrewHoleDiameter/2, $fn=20, center=true);\n\t}\n}",
    "description": "Okay, I'm looking for a way to create custom knobs for various projects and I want to use OpenSCAD to design them. I like the flexibility offered by the CustomizableKnob.scad file I've found. It has a lot of the features I'm looking for but it's not *quite* perfect for my needs.\n\nI want a design that uses parameters to control all the major aspects, and I want it to be easily adjustable for a range of uses. I have some specific features that I care about, but I also want the generated OpenSCAD file to be well-commented and easy to use and modify further.\n\nHere are the main features I need, and some notes about them:\n\n*   **Hole Options**:\n    *   The knob needs a central hole with a diameter and depth that I can set.\n    *   I need an option for a D-shaped hole. I should be able to control the thickness of the flat part of the \"D\".\n*   **Knob Body**:\n    *   The overall height of the knob, without the dome or shaft, should be a parameter.\n    *   The diameter of the main part of the knob needs to be adjustable.\n    *   I need a \"taper\" option, where the knob can be a cylinder or taper from a larger diameter at the base to a smaller one at the top. I'd like to be able to specify the taper in terms of a percentage difference in diameter between the base and top.\n*  **Top Shape**:\n    *   I need a few options for the top shape: Flat, Recessed, and Domed. I'd like these as an enum type of sorts if that's easily doable. The recessed shape should be a cylindrical divot to allow for painting or labeling. The domed shape should be a dome on the top surface.\n*   **Pointer/Direction**:\n    *   I need options for visual indicators of direction: a timer-knob style pointer (a large conical or triangular pointer), a small divot on the top, and a line on the front. Each of these needs to be independently controlled by boolean parameters.\n*   **Knurling**:\n    *   I need the option to add knurled ridges around the knob, and that the knurling should be applied to the tapered surface when appropriate.\n*   **Dial Ring**:\n    *   I need an option for a dial ring around the base of the knob.\n        *   I need to be able to control the width of this ring.\n        *   I want the ability to add markings to the dial ring, controlled by the number of markings around it.\n*   **Set Screw Hole**:\n    *   I need an option for a set screw hole, and the diameter of this hole should be controlled by a parameter.\n*   **Shaft Options**:\n    *   I need an option for a shaft on the bottom of the knob.\n        *   The length and diameter of the shaft should be controllable via parameters.\n        *   I need an option for a notch on the shaft for press-on type attachment.\n*   **Advanced Parameters**:\n     *   The current code has some parameters like \"RingThickness\", \"DivotDepth\", etc. I would like to be able to change these if I need to, but they should be set to reasonable defaults.\n*   **Code Quality**:\n    *   I would like the code to be clean, well-formatted and easy to read. \n    *   Use comments liberally to explain what parts of the design are doing and how the code is working.\n    *   The code should not use any global variables outside of parameters (I see PI as a \"global\" in the current code, this should be avoided.) Use `PI = acos(-1);` when you need pi instead of hard-coding 3.1415.\n  \nI'm not looking to use any external libraries for this, I want it to be self-contained as a single .scad file.\n\nCan you provide me with an OpenSCAD file based on these specifications?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Press-fit Broom or Mop Handle",
    "scad": "stick_diameter = 25;\nfinger_spacing = 23;\npadding = \"Some\";\nif(padding==\"A lot thicker\") assign(pad=12) handle(pad);\nif(padding==\"Only a little\") assign(pad=3) handle(pad);\nif(padding==\"Some\") assign(pad=7) handle(pad);\nmodule handle(padd){\n\tir=stick_diameter/2;\n\tor=ir+padd;\n\thi=4*finger_spacing+10;\n\tedge=padd+5;\n\tres=50*1;\n\tdifference(){\n\t\tcylinder(r=or,h=hi);\n\t\tunion(){\n\t\t\tfor(i=[0:3])translate([(or-ir)/2,0,edge+((hi-2*edge)*(i+.5)/4)]){\n\t\t\t\trotate_extrude(convexity = 10, $fn = res)\n\t\t\t\ttranslate([or*(2+.4*(12/padd)), 0, 0])\n\t\t\t\tcircle(r = (1+.4*(12/padd))*or, $fn = res);\n\t\t\t}\n\t\t\ttranslate([0,0,edge])cylinder(r=ir,h=hi-edge);\n\t\t}\n\t}\n}",
    "description": "Okay, I'm looking to design a custom handle for my broom, something that will be more comfortable to grip. I'm thinking about a design where there are these sort of indented, bulbous finger grips along the length of the handle, so my fingers can comfortably rest there while using the broom.\n\nHere's what I'm envisioning and some specific parameters I'd like to be able to control:\n\n1.  **Broom Handle Diameter:** I need a parameter, probably called `stick_diameter`, to define the diameter of the broom handle itself. This will be the inner diameter of the new handle. I expect to change this based on the broom, but I have a common one that's around 25mm.\n\n2.  **Finger Spacing:** I want to specify the average distance between my fingers when gripping the handle. This will affect the spacing of the indentations. I'm thinking `finger_spacing` should be a parameter, and I imagine it will be around 23mm. I want to be able to adjust this if it doesn't feel quite right.\n\n3.  **Handle Padding:** I'd like a way to control how much thicker the handle is compared to the original broom handle. Im thinking something like `padding` that could be set to A lot thicker, \"Some\", or \"Only a little\" with a default of \"Some\". Internally, it should probably use a numerical value that controls how much the handle is padded. This padding thickness should also affect the size of the indentations, making them larger when the padding is larger, proportional to the padding amount.\n\n4.  **Indentation Geometry:** Id like the indentations to be generated via `rotate_extrude` of a circle. I think a smooth, circular cross-section for the indentation is best. I'd also like to control the amount of subdivision used to make this circle smooth with a parameter called `$fn`.\n\n5. **Handle Length:** The length of the handle should be based on the `finger_spacing`. I was thinking 4 times the `finger_spacing` plus 10mm of extra length for each of the ends. Id like this to be automatically computed based on `finger_spacing` and for there to be some length added to both ends.\n\n6. **Indentation Edge:** I'd like the indentations to start a distance away from the ends of the handle. I'd like to control this distance via a parameter called `edge`, and for this to be dependent on the `padding` plus an additional 5 mm.\n\n7.  **Inner Cylinder:** Inside, there should be a cylindrical hollow to fit over the broom handle. It should have the same inner diameter as the broom handle and should extend the full length of the handle minus the edge.\n\nI'm hoping to use OpenSCAD to generate this. I don't want to use any non-standard libraries, so standard OpenSCAD should be sufficient.\n\nCould you write the OpenSCAD code that would handle these parameters and generate the handle? Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Pulley",
    "scad": "Bearing_Outer_Diameter = 22;\nBearing_Width = 7;\nBelt_Width = 6;\nPulley_Thickness = 1;\nFlange_Depth = 3;\nFlange_Thickness = 2;\nFlange_Shape = 2;\nRim_Thickness = 0.5;\nRim_Count = 3;\npulley(Bearing_Outer_Diameter, Bearing_Width, Belt_Width, Pulley_Thickness, Flange_Depth, Flange_Thickness, Flange_Shape, Rim_Thickness, Rim_Count);\nmodule pulley(Bearing_Outer_Diameter, Bearing_Width, Belt_Width, Pulley_Thickness, Flange_Depth, Flange_Thickness, Flange_Shape, Rim_Thickness, Rim_Count) {\n    width = max(Bearing_Width, Belt_Width);\n    union() {\n        difference() {\n            cylinder(h = width + (Rim_Thickness * 2), r = (Bearing_Outer_Diameter / 2) + Pulley_Thickness, center = true);\n            cylinder(h = width + (Rim_Thickness * 2) + 1, r = (Bearing_Outer_Diameter / 2), center = true);\n        }\n        translate([0, 0, (Belt_Width + Flange_Thickness) / 2])\n            pulley_flange(Bearing_Outer_Diameter, Pulley_Thickness, Flange_Depth, Flange_Thickness, Flange_Shape);\n        translate([0, 0, -(Belt_Width + Flange_Thickness) / 2])\n            rotate([180, 0, 0])\n                pulley_flange(Bearing_Outer_Diameter, Pulley_Thickness, Flange_Depth, Flange_Thickness, Flange_Shape);\n        translate([0, 0, (Bearing_Width + Rim_Thickness) / 2])\n            pulley_rim(Bearing_Outer_Diameter, Rim_Thickness, Rim_Count);\n        translate([0, 0, -(Bearing_Width + Rim_Thickness) / 2])\n            rotate([0, 0, 180 / Rim_Count])\n                pulley_rim(Bearing_Outer_Diameter, Rim_Thickness, Rim_Count);\n    }\n}\nmodule pulley_flange(Bearing_Outer_Diameter, Pulley_Thickness, Flange_Depth, Flange_Thickness, Flange_Shape) {\n    if(Flange_Shape == 2) {\n        translate([0, 0, Flange_Thickness / 2])\n            difference() {\n                union() {\n                    rotate_extrude(convexity = 10)\n                        translate([(Bearing_Outer_Diameter / 2) + Pulley_Thickness, 0, 0])\n                            scale([Flange_Depth / Flange_Thickness, 1, 1])\n                                circle(r = Flange_Thickness, $fn = 30);\n                    cylinder(h = Flange_Thickness * 2, r = (Bearing_Outer_Diameter / 2) + Pulley_Thickness, center = true);\n                }\n                cylinder(h = (Flange_Thickness * 2) + 1, r = (Bearing_Outer_Diameter / 2), center = true);\n                translate([0, 0, (Flange_Thickness + 1)/ 2])\n                    cube([Bearing_Outer_Diameter + (2 * (Pulley_Thickness + Flange_Depth)), Bearing_Outer_Diameter + (2 * (Pulley_Thickness + Flange_Depth)), Flange_Thickness + 1], center = true);\n            }\n    } else {\n        difference() {\n            cylinder(h = Flange_Thickness, r = (Bearing_Outer_Diameter / 2) + Pulley_Thickness + Flange_Depth, center = true);\n            cylinder(h = Flange_Thickness + 1, r = (Bearing_Outer_Diameter / 2), center = true);\n        }\n    }\n}\nmodule pulley_full_rim(Bearing_Outer_Diameter, Rim_Thickness) {\n    rotate_extrude(convexity = 10)\n        translate([Bearing_Outer_Diameter / 2, 0, 0])\n            circle(r = Rim_Thickness / 2);\n}\nmodule pulley_rim(Bearing_Outer_Diameter, Rim_Thickness, Rim_Count) {\n    if(Rim_Count < 2) {\n        pulley_full_rim(Bearing_Outer_Diameter, Rim_Thickness);\n    } else {\n        intersection() {\n            pulley_full_rim(Bearing_Outer_Diameter, Rim_Thickness);\n            union() {\n                for(index = [1 : Rim_Count]) {\n                    rotate([0, 0, (index * 360) / Rim_Count])\n                        translate([(Bearing_Outer_Diameter + Rim_Thickness)/ 2, 0, 0])\n                            sphere(r = (Bearing_Outer_Diameter * PI) / (Rim_Count * 4));\n                }\n            }\n        }\n    }\n}",
    "description": "Okay, I need to design a parametric pulley that fits onto a standard bearing. I want to be able to adjust several parameters, like the bearing size, belt width, flange design, and the rim pattern. I'm basing this design on an existing one, but I need something more flexible.\n\nHere's a breakdown of the features I'm looking for:\n\n*   **Bearing Integration:** The core of the pulley should be designed to fit a specific bearing. I need to define the bearing's outer diameter and width as parameters. The pulley should essentially \"clip\" onto the bearing.\n\n*   **Belt Channel:** The pulley needs a channel to guide the belt. I need to be able to define the width of this channel. The channel needs to be able to be specified to be wider than the bearing, if desired.\n\n*   **Pulley Thickness:** The base thickness of the pulley (the part that sits directly on the bearing, before any flanges or rims) should be adjustable.\n\n*   **Flanges:** The pulley needs flanges on either side of the belt channel to prevent the belt from slipping off. These should have adjustable:\n    *   **Depth:** How far the flange extends from the pulley base.\n    *   **Thickness:** The thickness of the flange itself.\n    *   **Shape:** I want to choose between square flanges and round flanges. I'd prefer this to be a parameter with a value of 1 for square and 2 for round.\n\n*   **Rims:**  I want to add rims to the outer edges of the pulley for additional grip or aesthetic appeal. These should have adjustable:\n    *   **Thickness:** The thickness of the rim feature.\n    *   **Count:** The number of \"teeth\" in the rim. If this is one, then it should just be a full rim.\n\n*   **Units:** I'm working in millimeters, so all dimensions should be in mm.\n\nSo, to sum it all up, I need a single, parametric OpenSCAD file that can generate a pulley with the following adjustable parameters:\n\n*   `Bearing_Outer_Diameter`: The outer diameter of the bearing (mm).\n*   `Bearing_Width`: The width of the bearing (mm).\n*   `Belt_Width`: The width of the belt that will sit in the pulley channel (mm).\n*   `Pulley_Thickness`: The thickness of the main pulley body (mm).\n*   `Flange_Depth`: How far the flange extends from the pulley base (mm).\n*   `Flange_Thickness`: The thickness of the flange itself (mm).\n*   `Flange_Shape`: 1 for square flanges, 2 for round flanges.\n*   `Rim_Thickness`: The thickness of the rim feature (mm).\n*   `Rim_Count`: The number of teeth in the rim (1 means a full rim).\n\nI don't need any external libraries for this design.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Basic Customizable Gear",
    "scad": "use <utils/build_plate.scad>\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\ninternal_diameter=40;\nhole_diameter=20;\nheight=30;\nres = 50;\ncogs=17;\ncog_length=20;\ncog_base_width=10;\ncog_base_height=30;\ncog_tip_width=5;\ntip_height=20;\nno_angle = 10;\nmodule cog(){\n\tunion(){\n\t\tdifference(){\n\t\t\ttranslate ([0,0,0]){\n\t\t\t\tcylinder(height,internal_diameter,internal_diameter, $fn = res, center=true) ;\n\t\t\t}\n\t\t\ttranslate ([0,0,0]){\n\t\t\t\tcylinder(height+2,hole_diameter,hole_diameter, $fn = res, center=true);\n\t\t\t}\n\t\t}\n\t}\n\tfor ( i = [0 : (cogs-1)] ){\n\t\thull(){\n    \t\trotate( i * 360 / cogs, [0, 0, 1])\n    \t\t\ttranslate([internal_diameter,0,0]){\n    \t\t\t\tcube ([no_angle,cog_base_width,cog_base_height],center=true);\n\t\t\t\t\t\ttranslate([cog_length,0,0]) {\n\t\t\t\t\t\t\tcube ([.1,cog_tip_width,tip_height],center=true);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t}\n}\ntranslate([0,0,height/2]){\n\tcolor([0,0.6,0.8]){\n\t\tcog();\n\t}\n}",
    "description": "Okay, I'm trying to design a customizable replacement gear for 3D printing, and I think I have a good starting point but I need a bit of help. I've already made a simple gear in OpenSCAD, but I'd like to make it more robust and easier for other people to use.\n\nHere's the gist of what I've got so far. It's a cylindrical gear with teeth/cogs sticking out, and I want the user to have a lot of control over the dimensions. I'm already using the `build_plate.scad` library for build plate definition.\n\nMy current parameters are:\n\n*   **Build Plate Selection:**  I've got a basic selector for a few common printers (Replicator 2, Replicator, Thingomatic, and manual) using `build_plate.scad`.  For manual, you can set build plate x and y dimensions.\n*   **Internal Diameter:** The diameter of the inner hole of the gear.\n*   **Hole Diameter:** The diameter of the center hole for a shaft.\n*   **Height:** The overall thickness/height of the gear.\n*   **Resolution:** A resolution parameter `$fn` to control the number of segments for the cylinders.\n*   **Number of Cogs:**  The number of teeth around the circumference of the gear.\n*   **Cog Length:** The total length of a single tooth.\n*   **Cog Base Width:** The width of the base of each tooth.\n*   **Cog Base Height:** The height of the base of each tooth.\n*   **Cog Tip Width:** The width of the tip of each tooth.\n*   **Tip Height:**  The height of the tip of each tooth.\n*   **No Angle:** The length along the tooth that has no angle and matches the `cog_base_height`\n\nHere's what I'd like help with:\n\n1.  **Profile Option**:  I would really like to give the user an option to toggle between square-cut teeth, as I have now, and angled/tapered sides on the teeth.  The angle or shape of the taper should ideally be parametrically defined, maybe as an angle from the base of the tooth to the tip.  This would make it closer to an involute gear. I'm picturing some kind of boolean or dropdown that lets you chose a profile. If they chose tapered they would then set the angle, or maybe there would be some more options to chose from.\n2.  **Pressure Angle**: It would be great if I could add the option for the user to input an angle for the cogs. This would help in situations where the two cogs need to connect at a certain angle and should be easy to adjust. Ideally this would be an angle on the base of the cog and would not affect the taper mentioned above.\n3. **Clearance:** I'd like to add a parameter to easily add a small amount of clearance to the teeth. This would be useful to account for tolerances in 3D printing and ensure that gears will mesh properly. The clearance should be configurable, so that a user can chose how much they want.\n\nI would like to use the same basic structure I have now, which uses a central cylinder with teeth added using `hull()` and rotations.  Also, please keep using the same `build_plate.scad` file I'm using right now, and if there is an accepted way of adding documentation please tell me.\n\nIm still new to all of this, so Im open to any suggestions on how to make this code better, more user-friendly, and more accurate as a gear. Thanks in advance for your help!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Cube Gears",
    "scad": "use <MCAD/involute_gears.scad>\nuse <write/Write.scad>\nchoose(i=object);\nobject=1;\ntype=2;\nsize=50;\ntol=0.5;\ngap=2;\nBacklash=0.5;\nword1=\"\";\nword2=\"\";\nword3=\"\";\nfontsize=6;\nFont = \"write/Letters.dxf\";\nuse <utils/build_plate.scad>\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nrf1=size;\npd=rf1*7/50;\nph=pd*gap;\npc=rf1*0.35;\npL=rf1*0.54;\n$fs=0.5*1;\nNR=[[18,9,0.7493,0.3746,1,0.24],\n\t[9,6,0.6860,0.4573,2,0.24],\n\t[18,15,0.6285,0.5238,5,0.3]];\nNr=NR[type];\nn1=Nr[0];\nn2=Nr[1];\nr1=Nr[2];\nr2=Nr[3];\nnt=Nr[4];\ncp=Nr[5];\ndc=rf1/sqrt(1-pow(r1,2));\ntheta=asin(1/sqrt(3));\npitch=360*r1*dc/n1;\nrf2=sqrt(pow(dc,2)-pow(r2*dc,2));\nmodule choose(i=0){\n\tif(i==0)translate([0,0,rf1*cp])center();\n\tif(i==1)gear1();\n\tif(i==2)gear2();\n\tif(i==3)longpin();\n\tif(i==4){twogears();rotate([theta+90,0,0])center();}\n\tif(i==5)assembly();\n\tif(i<4)build_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\n}\nmodule assembly()\nrotate([0,0,45]){\n\trotate([theta+90,0,0])center();\n\ttwogears();\n\trotate([0,0,180])twogears();\n\trotate([180,0,90])twogears();\n\trotate([180,0,-90])twogears();\n}\nmodule twogears(){\n\trotate(a=[0,90-theta,90])rotate([0,0,nt*120*$t])translate([0,0,rf1*cp])gear1();\n\trotate(a=[0,90-theta,0])rotate([0,0,-nt*n1/n2*120*$t])translate([0,0,rf2*cp])gear2();\n}\nmodule longpin()\nunion(){\n\ttranslate([0,pL/2-ph,0])pin_horizontal(r=pd/2,h=ph,t=tol);\n\tpinshaft(r=pd/2,h=pL-2*ph+0.2,side=true,t=tol);\n\trotate([0,0,180])translate([0,pL/2-ph,0])pin_horizontal(r=pd/2,h=ph,t=tol);\n}\nmodule center(){\nintersection(){\n\tbox();\n\trotate([2*(90-theta),0,0])box();\n\trotate([2*(90-theta),0,120])box();\n\trotate([2*(90-theta),0,-120])box();\n\trotate(-[theta+90,0,0])rotate([0,0,45])cube(0.85*size,center=true);\n}}\nmodule box(){\ntranslate([0,0,(rf2-rf1)*cp/2])difference(){\n\tcube(size=[dc,dc,(rf1+rf2)*cp],center=true);\n\ttranslate([0,0,-(rf1+rf2)*cp/2])pinhole(h=pL-(rf1*(1-cp)-pc),r=pd/2,fixed=true);\n\trotate([180,0,0])translate([0,0,-(rf1+rf2)*cp/2])pinhole(h=pL-(rf1-rf2*cp-pc),r=pd/2,fixed=true);\n}}\nmodule gear1(){\nintersection(){\n\ttranslate([0,0,-rf1*cp])rotate([0,theta-90,0])rotate([0,0,45])difference(){\n\t\tcube(size=size, center=true);\n\t\trotate([0,0,45-180])translate([0,rf1/sqrt(2)-3,rf1/2])monogram(h=2);\n\t\ttext(word1);\n\t\trotate([-90,0,-90])text(word2);\n\t\trotate([90,-90,0])text(word3);\n\t}\n\tdifference(){\n\t\ttranslate([0,0,rf1*(1-cp)])rotate([180,0,90/n1])\n\t\tbevel_gear (number_of_teeth=n1,\n\t\t\toutside_circular_pitch=pitch,\n\t\t\tcone_distance=dc,\n\t\t\tface_width=dc*(1-cp),\n\t\t\tbore_diameter=0,\n\t\t\tbacklash=Backlash,\n\t\t\tfinish=0);\n\t\tpinhole(h=rf1*(1-cp)-pc,r=pd/2,tight=false);\n\t}\n}}\nmodule gear2(){\nintersection(){\n\ttranslate([0,0,-rf2*cp])rotate([0,theta-90,0])rotate([0,0,45])cube(size=size, center=true);\n\tdifference(){\n\t\ttranslate([0,0,rf2*(1-cp)])rotate([180,0,90/n2])\n\t\tbevel_gear (number_of_teeth=n2,\n\t\t\toutside_circular_pitch=pitch,\n\t\t\tcone_distance=dc,\n\t\t\tface_width=dc*(1-cp),\n\t\t\tbore_diameter=0,\n\t\t\tbacklash=Backlash,\n\t\t\tfinish=0);\n\t\tpinhole(h=rf1-rf2*cp-pc,r=pd/2,tight=false);\n\t}\n}}\nmodule text(word)\nrotate([0,0,45-180])translate([0,rf1*0.35,rf1/2])\n\twrite(word,t=2,h=fontsize,center=true,font=Font);\nmodule monogram(h=1)\nlinear_extrude(height=h,center=true)\ntranslate(-[2,5])union(){\n\tdifference(){\n\t\tsquare([4,5]);\n\t\ttranslate([1,1])square([2,3]);\n\t}\n\tsquare([6,1]);\n\ttranslate([0,2])square([2,1]);\n}\nmodule pinhole(h=10, r=4, lh=3, lt=1, t=0.3, tight=true, fixed=false) {\nintersection(){\n  union() {\n\tif (tight == true || fixed == true) {\n      pin_solid(h, r, lh, lt);\n\t  translate([0,0,-t/2])cylinder(h=h+t, r=r, $fn=30);\n\t} else {\n\t  pin_solid(h, r+t/2, lh, lt);\n\t  translate([0,0,-t/2])cylinder(h=h+t, r=r+t/2, $fn=30);\n\t}\n  }\n  if (fixed == true) {\n\ttranslate([-r*2, -r*0.75, -1])cube([r*4, r*1.5, h+2]);\n  }\n}}\nmodule pin(h=10, r=4, lh=3, lt=1, t=0.2, side=false) {\n  if (side) {\n    pin_horizontal(h, r, lh, lt, t);\n  } else {\n    pin_vertical(h, r, lh, lt, t);\n  }\n}\nmodule pintack(h=10, r=4, lh=3, lt=1, t=0.2, bh=3, br=8.75) {\n  union() {\n    cylinder(h=bh, r=br);\n    translate([0, 0, bh]) pin(h, r, lh, lt, t);\n  }\n}\nmodule pinpeg(h=20, r=4, lh=3, lt=1, t=0.2) {\n  union() {\n    translate([0,-0.05, 0]) pin(h/2+0.1, r, lh, lt, t, side=true);\n    translate([0,0.05, 0]) rotate([0, 0, 180]) pin(h/2+0.1, r, lh, lt, t, side=true);\n  }\n}\nmodule pin_vertical(h=10, r=4, lh=3, lt=1, t=0.2) {\n  difference() {\n    pin_solid(h, r-t/2, lh, lt);\n    translate([-lt*3/2, -(r*2+lt*2)/2, h/5+lt*3/2]) cube([lt*3, r*2+lt*2, h]);\n    translate([0, 0, h/5+lt*3/2]) rotate([90, 0, 0]) cylinder(h=r*2, r=lt*3/2, center=true, $fn=20);\n    translate([-r*2, -r-r*0.75+t/2, -1]) cube([r*4, r, h+2]);\n    translate([-r*2, r*0.75-t/2, -1]) cube([r*4, r, h+2]);\n  }\n}\nmodule pin_horizontal(h=10, r=4, lh=3, lt=1, t=0.2) {\n  translate([0, 0, r*0.75-t/2]) rotate([-90, 0, 0]) pin_vertical(h, r, lh, lt, t);\n}\nmodule pin_solid(h=10, r=4, lh=3, lt=1) {\n  union() {\n    cylinder(h=h-lh, r=r, $fn=30);\n    translate([0, 0, h-lh]) cylinder(h=lh*0.25, r1=r, r2=r+(lt/2), $fn=30);\n    translate([0, 0, h-lh+lh*0.25]) cylinder(h=lh*0.25, r=r+(lt/2), $fn=30);\n    translate([0, 0, h-lh+lh*0.50]) cylinder(h=lh*0.50, r1=r+(lt/2), r2=r-(lt/2), $fn=30);\n  }\n}\nmodule pinshaft(h=10, r=4, t=0.2, side=false){\nflip=side ? 1 : 0;\ntranslate(flip*[0,h/2,r*0.75-t/2])rotate(flip*[90,0,0])\nintersection(){\n\tcylinder(h=h, r=r-t/2, $fn=30);\n\ttranslate([-r*2, -r*0.75+t/2, -1])cube([r*4, r*1.5-t, h+2]);\n}\n}",
    "description": "Okay, I'd like to design a customizable cube gear, similar to the one described in the `cubeGears4.scad` file I've been looking at, but I want to create my own design from scratch and would like your help generating the OpenSCAD code.\n\nHere are the key features I'm looking for, drawing inspiration from that existing file:\n\n**Core Structure:**\n\n*   **Cube Framework:** The core of the design should be a cube with gears rotating on its faces. The overall size of the cube should be adjustable via a parameter.\n*   **Rotating Gears:** Each face should have a large gear that rotates. The gears should be bevel gears. There should be some kind of center block for the cube core.\n*   **Gear Ratios:** I need to be able to select between different gear ratios for the large and small gears, which can affect the number of turns for the cube to return to its starting position. I'd like to have at least the following options: 18 & 9 teeth, 9 & 6 teeth, and 18 & 15 teeth. The small gears will need to rotate against the large gears.\n*   **Pin Mechanism:** The gears need to be connected to the cube via a pin system, allowing them to rotate smoothly. I need to be able to control the pin diameter and the gap between the pin and the hole for fit and rotation.\n*   **Tolerance:** I need a way to set a tolerance value, which should primarily affect the pin fits to allow for easier assembly depending on printer precision. I'd like to control the size of the pins, with some option for horizontal pins.\n*   **Animated Assembly (Optional):** If feasible, it would be awesome to have the assembly animated, similar to how it's done in the example code. This would be purely for visual purposes and not affect the final output.\n\n**Customization Parameters (exposed to the user):**\n\n*   `object`: An integer parameter to select which part to render (e.g., the center block, a large gear, a small gear, pin, or the full assembly).\n*   `type`: An integer parameter to choose the gear ratio (referring to the tooth combinations: 18 & 9, 9 & 6, 18 & 15).\n*   `size`: The edge length of the overall cube.\n*   `tol`:  Tolerance value for pin fits.\n*  `gap`: The ratio of the pin gap to pin diameter.\n*   `Backlash`: The space between gear teeth.\n*   `word1`, `word2`, `word3`: Text strings that will appear on the large gear faces.\n*   `fontsize`: The font size for the text strings on the gears.\n*   `Font`: A drop-down menu to select a font, including at least \"write/Letters.dxf\", \"write/orbitron.dxf\" and \"write/BlackRose.dxf\"\n*  `build_plate_selector`: A drop-down to select from a few printer buildplates or a manual override.\n*  `build_plate_manual_x` and `build_plate_manual_y`: the manual buildplate dimensions.\n\n**Modules and Libraries:**\n\n*   I'd like the design to utilize the `involute_gears.scad` module from the MCAD library for generating the bevel gears.\n*   The text writing should use functionality from the `Write.scad` file that's shown as being within a `/write/` subdirectory of the main project folder in the `use` statements.\n*   I want to use a module for adding a build plate for display purposes as seen in the example code, using `build_plate.scad` from the `/utils/` subdirectory.\n* I'll need to implement the pin design and pinhole modules similar to what's defined in the example code. This can either be done using custom modules or if there's a better way of implementing pin design in the MCAD library or another common library, that would be great.\n\n**Specific Design Notes:**\n\n*   The pin design should include a lip for secure fitting and to prevent it from coming out. I'd like to ensure that the pin module is flexible enough to produce the pin object and a negative space of the appropriate size, allowing the tolerance to apply on both sides of the connection, and including the pinhole geometry in gear faces and in the center cube.\n*   The text on the gear face should be positioned correctly. The example file shows a way of doing this that I'd like to replicate, if possible.\n*   The parameters in the existing file used to define the sizes of gear features should ideally be included as parameters so that the gear dimensions can be controlled via equations, similar to what is done in the example file.\n\nCould you generate the base OpenSCAD file for me based on these requirements? I'm looking for a modular structure that is easy to understand and modify.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Battery Case (magnetic)",
    "scad": "use <write/Write.scad>\n_1a_batteryDiameter = 14.6;\n_1b_insideHeight = 12;\n_2a_columns = 2;\n_2b_rows = 2;\n_3a_walls = 0.8;\n_3b_base = 0.8;\n_4a_magnetType = \"cylinder\";\n_4b_magnetDiameter = 3.1;\n_4c_magnetHeight = 3.1;\n_5a_labelText = \"\";\n_5b_labelFont = \"write/orbitron.dxf\";\n_5c_labelDepth = -0.3;\n_5d_labelHeight = 8;\nmodule cylinderAt(r, h, x, y, z) {\n\ttranslate([x,y,z]) {\n\t\tcylinder(r=r, h=h, center=true);\n\t}\n}\nmodule cubeAt(xy, h, x, y) {\n\ttranslate([x,y,0]) {\n\t\tcube(size=[xy,xy,h], center=true);\n\t}\n}\nmodule magnetCubeAt(xy, h, x, y, z) {\n\ttranslate([x,y,z]) {\n\t\trotate([0,0,45]) {\n\t\t\tcube(size=[xy,xy,h], center=true);\n\t\t}\n\t}\n}\nmodule batteryGrid(diameter, height, rows, columns, mtype, mdiameter, mheight) {\n\tangle = 35;\n\tr = diameter/2;\n\tcut = 2*r*sin(angle);\n\ttan = tan(angle);\n\tfilletCenter = r - r * tan;\n\tfilletCenter2 = r + r * tan;\n\tfilletOffset = r * tan;\n\tfilletRadius = r/cos(angle) - r;\n\txstart = ((columns-1) * diameter)/2;\n\tystart = ((rows-1) * diameter)/2;\n\teps = 0.1;\n\tunion() {\n\t\tdifference() {\n\t\t\tunion() {\n\t\t\t\tfor (x=[-xstart:diameter:xstart+eps]) {\n\t\t\t\t\tfor (y=[-ystart:diameter:ystart+eps]) {\n\t\t\t\t\t\tcylinderAt(r,height,x,y,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rows > 1) {\n\t\t\t\t\tfor (x=[-xstart:diameter:xstart+eps])\n\t\t\t\t\tfor (y=[-ystart+r:diameter:ystart-r+eps]) {\n\t\t\t\t\t\tcubeAt(cut, height, x, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (columns > 1) {\n\t\t\t\t\tfor (x=[-xstart+r:diameter:xstart-r+eps])\n\t\t\t\t\tfor (y=[-ystart:diameter:ystart+eps]) {\n\t\t\t\t\t\tcubeAt(cut, height, x, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (columns > 1) {\n\t\t\t\tfor (x=[-xstart+r:diameter:xstart-r+eps])\n\t\t\t\tfor (y=[-ystart-r:diameter:ystart+r+eps])\n\t\t\t\tfor(y2=[filletOffset, -filletOffset]) {\n\t\t\t\t\tcylinderAt(filletRadius,height+eps,x,r+y+y2,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rows > 1) {\n\t\t\t\tfor (x=[-xstart:diameter:xstart+eps])\n\t\t\t\tfor (y=[-ystart:diameter:ystart+eps])\n\t\t\t\tfor(x2=[filletOffset, -filletOffset]) {\n\t\t\t\t\tcylinderAt(filletRadius, height+eps,x + x2, r+y, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (rows > 1 && columns > 1) {\n\t\t\tfor (x=[-xstart+r:diameter:xstart-r+eps])\n\t\t\tfor (y=[-ystart+r:diameter:ystart-r+eps]) {\n\t\t\t\tif (mtype == \"cylinder\") {\n\t\t\t\t\tcylinderAt(mdiameter/2, mheight, x, y, height/2-mheight/2);\n\t\t\t\t} else if (mtype == \"cube\") {\n\t\t\t\t\tmagnetCubeAt(mdiameter, mheight, x, y, height/2-mheight/2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule makeTray(diameter, height, rows, columns, wall, base, mtype, mdiameter, mheight, label, lfont, ldepth, lheight) {\n\teps = 0.1;\n\trounding = diameter/2 + wall;\n\twidth = diameter * columns + wall*2;\n\tdepth = diameter * rows + wall*2;\n\tunion() {\n\t\tdifference() {\n\t\t\thull()\n\t\t\tfor (x=[-width/2 + rounding, width/2 - rounding])\n\t\t\tfor (y=[-depth/2 + rounding, depth/2 - rounding]) {\n\t\t\t\ttranslate([x,y])\n\t\t\t\tcylinder(r=rounding, h=height+base);\n\t\t\t}\n\t\t\ttranslate([0,0,height/2 + base]) {\n\t\t\t\tbatteryGrid(diameter, height+eps, rows, columns, mtype, mdiameter, mheight+eps);\n\t\t\t}\n\t\t\tif (ldepth < 0) {\n\t\t\t\taddLabel(label, (-ldepth+eps)/2 - eps, -ldepth+eps, lheight, lfont);\n\t\t\t}\n\t\t}\n\t\tif (ldepth > 0) {\n\t\t\taddLabel(label, -(ldepth+eps)/2 + eps, ldepth+eps, lheight, lfont);\n\t\t}\n\t}\n}\nmodule addLabel(label, zoffset, depth, height, font) {\n\tif (label != \"\") {\n\t\ttranslate([0,0,zoffset])\n\t\tmirror([0,1,0])\n\t\twrite(label, t=depth, h=height, font=font, space=1.2, center=true);\n\t}\n}\nmakeTray(_1a_batteryDiameter, _1b_insideHeight,\n\t\t\t_2b_rows, _2a_columns,\n\t\t\t_3a_walls, _3b_base,\n\t\t\t_4a_magnetType, _4b_magnetDiameter, _4c_magnetHeight,\n\t\t\t_5a_labelText, _5b_labelFont, _5c_labelDepth, _5d_labelHeight,\n\t\t\t$fn=90);",
    "description": "Okay, I need a custom battery holder design, and I'd like to be able to tweak a bunch of different parameters to make it fit different battery types and configurations.\n\nHere's what I'm looking for:\n\n**Core Functionality:**\n\n*   **Battery Grid:** The holder should have a grid of circular recesses to hold cylindrical batteries.\n*   **Adjustable Size:** I want to control the number of rows and columns of batteries.\n*   **Battery Size:** I need to be able to specify the diameter of the batteries, and the depth of the recess. This should effectively dictate the size of the cylindrical cutout for each battery.\n\n**Customizable Parameters:**\n\n*   **Battery Dimensions:**\n    *   `_1a_batteryDiameter`: The diameter of the battery (e.g., 14.6mm for AA, 10.7mm for AAA).\n    *   `_1b_insideHeight`: The height of the battery recess (should be equal to or slightly larger than the battery height).\n*   **Grid Layout:**\n    *   `_2a_columns`: The number of batteries across (in a row).\n    *   `_2b_rows`: The number of batteries deep.\n*   **Wall Thickness:**\n    *   `_3a_walls`: The thickness of the walls of the holder.\n*   **Base Thickness:**\n    *   `_3b_base`: The thickness of the bottom layer of the holder.\n*   **Magnet Cutouts (Optional):**\n    *   `_4a_magnetType`: The shape of the magnet cutout (e.g., \"cylinder\" or \"cube\").\n    *   `_4b_magnetDiameter`: The diameter of the magnet cutout.\n    *   `_4c_magnetHeight`: The height of the magnet cutout.\n    * The magnet cutouts should only be added if there is at least a 2x2 array of batteries, and should be placed at the corners of the grid of battery cutouts.\n\n*   **Labeling (Optional):**\n    *   `_5a_labelText`: The text to label the battery holder.\n    *   `_5b_labelFont`: The font to use for the label (I'd like to use fonts from the \"write\" library if possible - like \"write/orbitron.dxf\", \"write/letters.dxf\", \"write/knewave.dxf\", \"write/BlackRose.dxf\", \"write/braille.dxf\" )\n    *   `_5c_labelDepth`: The depth of the label. Negative values should emboss, positive should extrude the label.\n    *   `_5d_labelHeight`: The height of the label in mm. The label should be rendered centered on the top or bottom of the tray based on whether the labelDepth is negative or positive.\n\n**Design Details:**\n\n*   The main body should be a rounded rectangle with filleted edges, created using a `hull` and cylinders.\n*   The battery recesses should use a combination of cylinders and cubes to make the rounded edges, as shown in the example code.\n*   I expect to be able to place the label on either side of the tray, based on a negative or positive label depth.\n*   I'm assuming the design can make use of the `write` library.\n\n**Output:**\n\nI'm expecting a single `.scad` file that I can open and customize with these parameters.\n\nBasically, I want to be able to easily make a custom battery holder for any combination of battery type and grid size. This should also include an option to add magnets to the case to be able to close and hold a lid in place. Let me know if you have any questions.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Lego Heart",
    "scad": "size = 15;\nheight = 5;\nmodule half(){\n\tdifference(){\n\t\tcylinder(r=size/2,h=height,$fn=50, center=true);\n\t\ttranslate([(size+1)/2,0,0]) cube([size + 1, size + 1,height + 1],center = true);\n\t}\n}\nmodule plate(){\n\tunion() {\n\t\thalf();\n\t\ttranslate([0,-size/2,-height/2]) cube([size,size,height]);\n\t}\n}\nknob_diameter = 4;\nknob_hight = 1.5;\nhole_diameter = 4;\nhole_depth = 1.5;\nkeyring_hole=1.5;\ndifference(){\n\tunion(){\n\t\tplate();\n\t\ttranslate([size/4, size/4 , height/2]) cylinder(r=knob_diameter/2,h=knob_hight,$fn=50);\n\t\ttranslate([size/4, -size/4, height/2]) cylinder(r=knob_diameter/2,h=knob_hight,$fn=50);\n\t\ttranslate([3*(size/4), size/4, height/2]) cylinder(r=knob_diameter/2,h=knob_hight,$fn=50);\n\t\ttranslate([3*(size/4),-size/4, height/2]) cylinder(r=knob_diameter/2,h=knob_hight,$fn=50);\n\t}\n\ttranslate([size/4,size/4,-height/2-0.01]) cylinder(r=hole_diameter/2,h=hole_depth+0.01,$fn=50);\n\ttranslate([size/4,-size/4,-height/2-0.01]) cylinder(r=hole_diameter/2,h=hole_depth+0.01,$fn=50);\n\ttranslate([3*(size/4),size/4,-height/2-0.01]) cylinder(r=hole_diameter/2,h=hole_depth+0.01,$fn=50);\n\ttranslate([3*(size/4),-size/4,-height/2-0.01]) cylinder(r=hole_diameter/2,h=hole_depth+0.01,$fn=50);\n\ttranslate([-size/4,0,-height/2-0.01]) cylinder(r=keyring_hole, h=height+0.02, $fn=50);\n}",
    "description": "Okay, I'm looking to create a parametric version of a Lego heart pendant. I have a basic design already, but I want to make it more flexible so I can easily adjust the size, thickness, and other features.\n\nRight now, my design is essentially two mirrored \"plate\" shapes that connect to form a heart. Each plate has a semi-circular top and a rectangular bottom, and four studs on the top surface (like Lego studs) and matching holes on the bottom for connecting to another piece. It also has a small hole on the flat edge that lets you attach it to a keyring or necklace.\n\nHere's what I'd like to be able to control in my parametric design:\n\n*   **Overall Size:** I want to be able to easily change the overall size of the heart, ideally by setting a single parameter (e.g., `overall_size`) that scales everything proportionally.\n*   **Thickness:** I need to control the height (or thickness) of the heart pieces. Let's call this `plate_thickness`.\n*   **Stud Size:** I need to be able to adjust the diameter and height of the studs (the knobs) on the top surface. We can call these `stud_diameter` and `stud_height`.\n*   **Hole Size:** I need to adjust the diameter and depth of the holes on the bottom surface. These should match the studs, let's call these `hole_diameter` and `hole_depth`.\n*   **Keyring Hole:** I need to be able to adjust the diameter of the keyring hole. Let's call this `keyring_hole_diameter`\n*   **Positioning:** I would like the studs to be arranged symmetrically, two on each side of the center, and the keyring hole centered on one of the flat sides. I'd like the position of the studs to scale with the `overall_size` parameter.\n\nI'd also prefer if the code used a library for generating circles. The `circle()` function from the `BOSL` library would be great. Please don't include the library code though, just make sure it references the library.\n\nFinally, I want to be able to easily 3D print this. I would like it designed in such a way that it can be printed with minimal supports.\n\nCan you provide an OpenSCAD file that lets me control all of these parameters and generates the two halves of the heart, which I could then mirror and put together to form the whole piece?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Coved Picture Frame -- Customizable  ",
    "scad": "include <write/Write.scad>\npicture_height = 101;\npicture_width = 152;\nframe_width = 40;\nframe_thickness = 15;\ntop_message = \"Thingiverse\";\nbottom_message = \"Love\";\nleft_message = \"From\";\nright_message = \"With\";\nback_message = \"By Loren\";\nFont = \"write/BlackRose.dxf\";\nfont_size = 20;\nfont_space = 1;\nfont_thickness = 2;\ncove_depth = 5;\ncove_margin = 5;\ncove_width = frame_width - cove_margin*2;\nrabbet_width = 5;\nrabbet_depth = 6;\nmodule null() {}\nfudge = 0.001;\nmodule gen_cove_moulding(length,message,invert_message=false) {\n\toa_length = length + 2*frame_width - 2*rabbet_width;\n\tcove_fn = 200;\n\ttriangle_height = cove_depth;\n\ttriangle_base = cove_width;\n\ttriangle_side = sqrt((triangle_height*triangle_height) + ((triangle_base/2)*(triangle_base/2)));\n\ttriangle_angle = acos((2 * (triangle_side * triangle_side) - (triangle_base * triangle_base)) / (2 * triangle_side * triangle_side));\n\tcove_diameter= cove_width / sin(triangle_angle);\n\ttranslate(v=[-frame_width+rabbet_width,-rabbet_width,0] ){\n\tunion () {\n\t\tdifference() {\n\t\t\tcube(size = [oa_length, frame_width, frame_thickness]);\n\t\t\tcube(size = [oa_length, rabbet_width, rabbet_depth]);\n\t\t\trotate(a=[0,90,0]){\n\t\t\t\ttranslate(v=[(-1*(frame_thickness+cove_diameter/2-cove_depth)),frame_width/2,-0.5]) {\n\t\t\t\t\tcylinder(h=oa_length+1,r=cove_diameter/2,$fn=cove_fn);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlinear_extrude(height=frame_thickness) polygon(points=[[0,0],[frame_width,0],[0,frame_width]]);\n\t\t\tlinear_extrude(height=frame_thickness) translate(v=[oa_length,0,0]) polygon(points=[[0,0],[-frame_width,0],[0,-frame_width]]);\n\t\t\tlinear_extrude(height=frame_thickness) translate(v=[oa_length,0,0]) polygon(points=[[0,0],[-frame_width,0],[0,frame_width]]);\n\t\t}\n\t\tif (message != \"\") {\n\t\trotate(a=[0,90,0]){\n\t\t\ttranslate(v=[(-1*(frame_thickness+cove_diameter/2-cove_depth)),frame_width/2,frame_width-(frame_width-cove_width)/2]) {\n\t\t\t\tdifference() {\n\t\t\t\tintersection(){\n\t\t\t\tcylinder(h=length+fudge,r=cove_diameter/2 + fudge,$fn=cove_fn);\n\t\t\t\ttranslate (v=[0,0,length])\n\t\t\t\tif (invert_message == false) {\n\t\t\t\t\tmirror([0,0,1])\n\t\t\t\t\twritecylinder(text=message, where=[0,0,0], radius=cove_diameter/2-cove_depth/2-fudge, height=length,\n\t\t\t\t\t\t\t\trotate=90, east=94, center=false,\n\t\t\t\t\t\t\t\tt=font_thickness*10,h=font_size, font=Font, space=font_space);\n\t\t\t\t} else {\n\t\t\t\t\ttranslate([0,0,-length])\n\t\t\t\t\trotate(180,[0,1,0])\n\t\t\t\t\tmirror([0,0,1])\n\t\t\t\t\twritecylinder(text=message, where=[0,0,0], radius=cove_diameter/2-cove_depth/2-fudge, height=length,\n\t\t\t\t\t\t\t\trotate=90, east=274, center=false,\n\t\t\t\t\t\t\t\tt=font_thickness*10,h=font_size, font=Font, space=font_space);\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcylinder(h=length+fudge,r=cove_diameter/2 - font_thickness  ,$fn=cove_fn);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t}\n\t}\n}\nmodule gen_frame_backer(thickness=3, clearance=1, tab_width=10, message=\"\") {\n\twidth = picture_width-clearance;\n\theight = picture_height-clearance;\n\tdifference() {\n\tunion() {\n\tcube(size = [width, height, thickness]);\n\ttranslate([width/2-tab_width/2,     0,thickness/2]) rotate(90,[0,1,0]) cylinder(h=tab_width, r = thickness/2,$fn=50);\n\ttranslate([width/2-tab_width/2,height,thickness/2]) rotate(90,[0,1,0]) cylinder(h=tab_width, r = thickness/2,$fn=50);\n\ttranslate([      0,height/2+tab_width/2,thickness/2]) rotate(90,[1,0,0]) cylinder(h=tab_width, r = thickness/2,$fn=50);\n\ttranslate([  width,height/2+tab_width/2,thickness/2]) rotate(90,[1,0,0]) cylinder(h=tab_width, r = thickness/2,$fn=50);\n\t}\n\tif (message != \"\") {\n\t\twritecube(text=message,where=[width/2,height/2,thickness/2],size=[width, height, thickness],face=\"top\",t=thickness,h=font_size/2, font=Font);\n\t}\n\t}\n}\ntranslate(v=[frame_width-rabbet_width,frame_width-rabbet_width,0]) {\n\tdifference() {\n\tunion() {\n\ttranslate(v=[0,picture_height,0])                                      gen_cove_moulding(length=picture_width+fudge, message=top_message);\n\ttranslate(v=[picture_width,0,0])               rotate(a=[  0,  0,180]) gen_cove_moulding(length=picture_width+fudge, message=bottom_message, invert_message=true);\n\ttranslate(v=[0,0,0])                           rotate(a=[  0,  0, 90]) gen_cove_moulding(length=picture_height+fudge, message=left_message);\n\ttranslate(v=[picture_width,picture_height,0])  rotate(a=[  0,  0,270]) gen_cove_moulding(length=picture_height+fudge, message=right_message);\n\t}\n\tgen_frame_backer(thickness=3, clearance=fudge, tab_width=10.5);\n\t}\n\ttranslate([0.5,0.5,0]) gen_frame_backer(thickness=3, clearance=1, tab_width=10, message=back_message);\n}\nframe_y = picture_height+2*frame_width-2*rabbet_width;\nframe_x = picture_width+2*frame_width-2*rabbet_width;\necho (\"Overall Height = \", frame_y);\necho (\"Overall Width  = \", frame_x);",
    "description": "Okay, I'm looking to create a parametric picture frame design in OpenSCAD, and I'd like some help building it. I have a specific aesthetic in mind, and I'm hoping to make it very customizable for different print sizes and personalizations. I'm including a description of my current design and my goals.\n\nHeres what Im aiming for:\n\n**Core Design:**\n\n*   The picture frame should have a classic, woodworking-inspired design, featuring a cove-shaped profile on the inner edge.\n*   The frame needs a rabbet on the back to hold the picture, backing material, and possibly a piece of glass or clear plastic. This rabbet needs to be configurable for different material thicknesses.\n*   I want the frame to have text engraved on the curved cove profile, so it follows the curve of the cove. This needs to be fully customizable, allowing different messages on the top, bottom, left, and right sides of the frame.\n*   The backing plate should have a few small cylindrical tabs to hold it securely in the frame's rabbet.\n*   The back plate should also have customizable text.\n\n**Customization Goals:**\n\n*   **Artwork Size:**  The core parameter is the size of the artwork to be framed (width and height, in mm).\n*   **Frame Width:** The width of the frame border around the artwork (in mm).\n*   **Frame Thickness:**  The overall thickness/depth of the frame (in mm).\n*   **Cove Parameters:** I need to control the depth of the cove feature, the margin between the cove and the frame's edges, and therefore also the cove width.\n*   **Rabbet Parameters:** I need to control both the width and depth of the rabbet on the back of the frame.\n*   **Text Parameters:** I need to be able to input the text strings for the top, bottom, left, and right sides of the frame, as well as the text for the back plate. I also need to control:\n    *   The font choice using a font file from the 'write' library.\n    *   The font size (in mm).\n    *   The space between characters.\n    *   The thickness of the raised text.\n*   **Back Plate Parameters:**  I need to control the thickness of the back plate, the clearance (offset) between the back plate and the frame opening, and the width of the retention tabs.\n\n**Specific Functionality:**\n\n*   The text on the cove should be engraved so that the text is raised, not cut into the frame. The text should follow the curve of the cove.\n*   The text on the bottom of the frame needs to be inverted, so it's readable when the frame is viewed from the front. The code will have to invert the text.\n*   The back plate should have an easy snap-in design using cylindrical tabs.\n\n**Libraries:**\n\n*   Im already using a library called `write.scad` for the font rendering. I need to ensure this is included in the new design, and I need the `writecylinder` and `writecube` functions from that library.\n\n**Output:**\n\n*   I need a single .scad file that includes all of the parametric controls and produces the picture frame design.\n\nCan you help me build this parametric picture frame design in OpenSCAD?\n"
  },
  {
    "object": "Hey cadmonkey, make me a manacles",
    "scad": "left_wrist_hole=27;\nright_wrist_hole=27;\ntranslate ([-51,25,10]) rotate ([90,90,0]) union (){\nunion () {\ntranslate ([-20,0,-5]) cube ([10,100,10]);\ntranslate ([0,102,0]) rotate ([0,0,-90])union () {translate ([0,10,-7]) rotate ([180,180,0]) union () {cube ([65,5,15]);\ntranslate ([0,15,0])cube ([65,5,15]);\ntranslate ([53,20,-14]) rotate ([90,0,0]) cube ([11,20,20]);\ntranslate ([0,0,7])rotate ([0,90,90])cylinder (h=30,r1=5.5,r2=5.5);}\ndifference (){scale([1,0.3,1]) translate([-70,0,0])rotate([0,180,90]) cylinder(h=21,r1=10,r2=10);\nunion (){translate ([-2,1,17])difference (){\ntranslate ([-71,-4,-35])rotate ([0,0,0])union (){cube ([8, 1, 20]);cube ([8,6,6]);} translate ([-72,1,-44.5])rotate ([45,0,0])cube (10);}\ntranslate ([-8,0,34])difference (){translate ([-2,1,-47])\ntranslate ([-71,-4,-5])rotate ([0,0,0])union (){translate ([0,1,-10])cube ([3, 40, 45]); cube ([8,6,6]);} translate ([-72,-4,-53])rotate ([0,39,0])cube (10);}}}}\nrotate ([0,0,90])union () {translate ([0,10,-7]) rotate ([180,180,0]) union () {cube ([65,5,15]);\ntranslate ([0,15,0])cube ([65,5,15]);\ntranslate ([53,20,-14]) rotate ([90,0,0]) cube ([11,20,20]);\ntranslate ([0,-10,7])rotate ([0,90,90])cylinder (h=30,r1=5.5,r2=5.5);}\ndifference (){scale([1,0.3,1]) translate([-70,0,0])rotate([0,180,90]) cylinder(h=21,r1=10,r2=10);\nunion (){translate ([-2,1,17])difference (){\ntranslate ([-71,-4,-35])rotate ([0,0,0])union (){cube ([8, 1, 20]);cube ([8,6,6]);} translate ([-72,1,-44.5])rotate ([45,0,0])cube (10);}\ntranslate ([-8,0,34])difference (){translate ([-2,1,-47])\ntranslate ([-71,-4,-5])rotate ([0,0,0])union (){translate ([0,1,-10])cube ([3, 40, 45]); cube ([8,6,6]);} translate ([-72,-4,-53])rotate ([0,39,0])cube (10);}}}}}\nrotate ([-28.5,0,0])union (){\ndifference () {union () {translate ([4,-70,-20]) rotate ([0,0,90]) cube ([4,2,25]); translate ([2,-70,-20])rotate ([0,0,90])cube([4,4,8]); translate ([3,-70,-22])cube([4,4,10]); translate ([6,-70,-23])cube([3,4,11]);} translate ([-2,-84,-23])cube([4,2,4]); translate ([6,-73,-35])rotate ([0,-45,0]) cube ([10,15,25]);}\ndifference () {union () {translate ([-2,-84,-23])cube([4,6,4]); translate ([-2,-80,-20])rotate ([90,0,0])cube([4,8,4]); translate ([-2,-80,-20])cube ([4,2,25]); translate ([2,-80,-20])rotate ([0,0,90])cube([5,4,8]); } translate ([-7,-90,-31])rotate ([-39,0,0]) cube ([10,5,25]);}\ndifference () {difference (){union () {\nscale ([0.3,1,1]) translate ([0,-70,52]) sphere(r=10); scale([0.3,1,1]) translate([0,-70,0])rotate([0,0,90]) cylinder(h=52,r1=10,r2=10);\nscale([0.3,1,1])translate ([0,0,52])rotate([90,90,0]) cylinder (h=70,r1=5,r2=10);\ntranslate([-2,-20,30])rotate ([0,90,0])cylinder (h=4,r1=23,r2=23);\ntranslate([-2,-46,32])rotate ([0,90,0])cylinder (h=4,r1=24,r2=24);\nscale([0.3,1,1])\ncylinder(h=52,r1=15,r2=5);\ntranslate([0,0,-3]) scale([0.3,1,1])sphere(r=15); scale([0.3,1,1])\ntranslate([0,0,52]) sphere(r=5);}\nrotate([0,90,0]) translate ([0,0,-20])cylinder(h=55,r1=6,r2=6);}\ntranslate([-8,-35,25])rotate ([0,90,0]) scale([1,1.2,.8])cylinder(h=20, r1=left_wrist_hole,r2=27);}\n}\ntranslate ([0,102,0]) rotate ([-28.5,0,180])union (){\ndifference () {union () {translate ([4,-70,-20]) rotate ([0,0,90]) cube ([4,2,25]); translate ([2,-70,-20])rotate ([0,0,90])cube([4,4,8]); translate ([3,-70,-22])cube([4,4,10]); translate ([6,-70,-23])cube([3,4,11]);} translate ([-2,-84,-23])cube([4,2,4]); translate ([6,-73,-35])rotate ([0,-45,0]) cube ([10,15,25]);}\ndifference () {union () {translate ([-2,-84,-23])cube([4,6,4]); translate ([-2,-80,-20])rotate ([90,0,0])cube([4,8,4]); translate ([-2,-80,-20])cube ([4,2,25]); translate ([2,-80,-20])rotate ([0,0,90])cube([5,4,8]); } translate ([-7,-90,-31])rotate ([-39,0,0]) cube ([10,5,25]);}\ndifference () {difference (){union () {\nscale ([0.3,1,1]) translate ([0,-70,52]) sphere(r=10); scale([0.3,1,1]) translate([0,-70,0])rotate([0,0,90]) cylinder(h=52,r1=10,r2=10);\nscale([0.3,1,1])translate ([0,0,52])rotate([90,90,0]) cylinder (h=70,r1=5,r2=10);\ntranslate([-2,-20,30])rotate ([0,90,0])cylinder (h=4,r1=23,r2=23);\ntranslate([-2,-46,32])rotate ([0,90,0])cylinder (h=4,r1=24,r2=24);\nscale([0.3,1,1])\ncylinder(h=52,r1=15,r2=5);\ntranslate([0,0,-3]) scale([0.3,1,1])sphere(r=15); scale([0.3,1,1])\ntranslate([0,0,52]) sphere(r=5);}\nrotate([0,90,0]) translate ([0,0,-20])cylinder(h=55,r1=6,r2=6);}\ntranslate([-8,-35,25])rotate ([0,90,0]) scale([1,1.2,.8])cylinder(h=20, r1=right_wrist_hole,r2=27);}\n}\n}",
    "description": "Okay, I'm looking to create a 3D printable design for a set of manacles, and I want it to be parametric so I can adjust it for different wrist sizes. I've got an initial design in mind, which I've included, but it's a bit rough and needs some refinement.\n\nHere's what I'm envisioning:\n\n**Overall Structure:**\n\n*   The manacles will consist of two mirrored cuffs connected by a central bar.\n*   Each cuff has a pivoting arm that swings open and latches shut on the other side.\n*   The latching mechanism should be a robust one, using a male/female setup with some interlocking parts and a cutout.\n*   I need to be able to adjust the internal diameter of the cuff to fit varying wrist sizes.\n\n**Specific Design Elements:**\n\n*   **Cuffs:**\n    *   Each cuff needs a hole for the wrist that can be adjusted with a variable.\n    *   The cuffs need to be strong, probably with some reinforcement bracing at key points.\n    *   Each cuff has a female latch side that interacts with a male latch.\n    *   The female latch has two interlocking sections with a cylindrical cut.\n    *   The female latch has a cutout to allow for the male latch to lock in.\n    *   The female latch has 2 cutouts from the main body to give the male latch something to interlock with.\n*  **Pivoting Arms:**\n    * Each arm needs to have a robust pivot joint. The file has a \"swing arm\" which I intend to be this pivoting arm.\n    *   The \"swing arm\" connects to the cuff with a rotational support.\n    *   The \"swing arm\" needs to be bored out to accept a pin or screw.\n    *  Each swing arm has a male latch.\n    *  The male latch has a protruding section to insert into the cutouts in the female latch.\n*   **Central Bar:**\n    *   A solid bar to join both cuffs.\n*   **Reinforcement Braces:**\n    *   Corner braces to strengthen the cuff.\n    *   Cross support bracing, as well as support for the pivot.\n\n**Parametric Adjustments:**\n\n*   I need variables for:\n    *   `left_wrist_hole`: To adjust the inner diameter of the left cuff.\n    *   `right_wrist_hole`: To adjust the inner diameter of the right cuff.\n\n**OpenSCAD Details:**\n* I would like the code to use a few openSCAD libraries for more advanced designs and ease of use. Specifically:\n    *   **BOSL2**: I would like to use BOSL2 for its parametric design features and to allow for ease of use.\n\n**Additional Notes:**\n* The included file should provide a good starting point for the structure.\n*   I'm open to suggestions for improvements to the latching mechanism, pivot joint, or bracing.\n*   The goal is to create a robust, functional design that is relatively easy to print.\n\nCould you help me create a parametric OpenSCAD file that meets these requirements? I've included the existing code for reference; it might be helpful. I am expecting the result to be generated with BOSL2 modules.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Gear5",
    "scad": "nt =16;\nsd =8;\ngd=15;\nggdt=1.5;\ngh=18;\nnf=2;\nfs=4;\nfang=\"no\";\nfr=0*1;\n$fn=12;\nDcut=\"yes\";\ngpr=gd*3.14159/4/nt/(1+3.141592/nt/2);\ngmr=gpr*1.077;\nggd=gd+fs;\ndh=gh*1;\noff= 360/nt/2;\nfr=0*1;\nfr1=180*1;\nfa=0*1;\nfa1=ggdt;\nmodule pgear()\n\tunion(){\n\ttranslate([0, 0, 0]) {\n\t\tdifference() {\n         union(){\n\t\t  translate([0, 0, 0]) cylinder(h = gh, r =gd/2-gpr,$fn=48);\nif(fang== \"no\") {\n      if (nf == 1){\n          translate([0, 0, gh-ggdt])rotate([fr,0,0])cylinder(h = ggdt, r1= ggd/2,r2=ggd/2-fa, $fn=96);\n      \t\t\t\t}\n      if (nf == 2){\n         translate([0, 0, gh-ggdt])rotate([fr,0,0])cylinder(h = ggdt, r1= ggd/2,r2=ggd/2-fa,$fn=96);\n         translate([0, 0, 0])cylinder(h = ggdt,  r1= ggd/2,r2=ggd/2-fa,$fn=96);\n\t\t\t}\n\t\t\t}\nif(fang== \"yes\") {\n if (nf == 1){\n          translate([0, 0, gh])rotate([fr1,0,0])cylinder(h = ggdt, r1= ggd/2,r2=ggd/2-fa1, $fn=96);\n      \t\t\t\t}\n      if (nf == 2){\n         translate([0, 0, gh])rotate([fr1,0,0])cylinder(h = ggdt, r1= ggd/2,r2=ggd/2-fa1,$fn=96);\n         translate([0, 0, 0])cylinder(h = ggdt,  r1= ggd/2,r2=ggd/2-fa1,$fn=96);\n\t\t\t\t}\n}\n\t}\ntranslate([0, 0, -0.5])\n\t\t\tcylinder(h = gh+2.5, r= sd/2,$fn=48);\n\t\tfor (i = [0:(nt-1)]) {\n\t\t\techo(360*i/nt, sin(360*i/nt)*(gd/2-gpr), cos(360*i/nt)*(gd/2-gpr));\n\t\t\ttranslate([sin(360*i/nt)*(gd/2-gpr), cos(360*i/nt)*(gd/2-gpr), ggdt*nf*(nf-1)*0.5])\n\t\t\t\trotate([0,0,90*(1-2/$fn)-360*i/nt-($fn-1)*off]) cylinder(h = gh-ggdt*nf, r=gmr);\n\t\t                      }\n     \t\t\t\t\t\t\t}\n\t\tfor (i = [0:(nt-1)]) {\n\t\t\techo(360*i/nt+off, sin(360*i/nt+off)*(gd/2-gpr), cos(360*i/nt+off)*(gd/2-gpr));\n\t\t\ttranslate([sin(360*i/nt+off)*(gd/2-gpr), cos(360*i/nt+off)*(gd/2-gpr), 0 ])\n\t\t\t\trotate([0,0,90*(1-2/$fn)-360*i/nt-$fn*off]) cylinder(h = gh, r=gpr);\n\t\t                      }\n}\n if (Dcut== \"yes\"){\n         translate([-(sd/2.1), 0, gh/2]) cube([sd/5,sd*0.8,dh], center = true);\n       }\n}\npgear();",
    "description": "Okay, I'm looking to create a parametric gear with some customizable fringe details, and I'd like an OpenSCAD file to do it. I have a pretty good base design already, but want to make it fully parametric and easier to adjust.\n\nHere's a breakdown of what I need:\n\n**Core Gear Parameters:**\n\n*   **`nt` (Number of Teeth):** This should be an integer, controlling how many teeth the gear has. Default value should be 16.\n*   **`sd` (Shaft Diameter):** This is the diameter of the central hole. Should be numeric. Default 8.\n*   **`gd` (Gear Diameter):** The main diameter of the gear (excluding fringe). Numeric. Default 15.\n*   **`gh` (Gear Height):** The height of the main gear body. Numeric. Default 18.\n*   **`$fn` (Tooth Detail):** This is the number of segments used to approximate a circle for each tooth. I want to make sure this is an option for controlling the detail in the tooth shape, and should be easily changeable, not just for the whole file. I need to be able to set this to be 4, 5, 6, 7, 8, or 12. Default to 12.\n\n**Fringe Parameters:**\n\n*   **`ggdt` (Fringe Thickness):** The thickness of the fringe. Numeric. Default 1.5.\n*   **`nf` (Number of Fringes):**  I want to be able to set whether I have 0, 1, or 2 fringes. Default should be 2.\n*   **`fs` (Fringe Size):**  How much bigger in diameter the fringe is compared to the gear. Needs to be adjustable (default 4).\n*   **`fang` (Fringe Angle):** This controls whether the fringe is angled or not. Should be a string variable, either \"yes\" or \"no\". Default \"no.\"\n*  **`fr` (Fringe Rotate):** A value in degrees to rotate the fringe (not currently used in my provided code, but it would be nice to have this). Default is 0.\n\n**Additional Features:**\n\n*   **`Dcut` (D-Cut):** A parameter to add or remove a D-shaped cutout on the shaft hole, which can help secure it to a D-shaped shaft. Should be a string variable, either \"yes\" or \"no\", with a default of \"yes\".\n\n**Functionality:**\n\n*   The code needs to generate a gear with the specified number of teeth, diameter, and height.\n*   The fringe should be added to the top and/or bottom of the gear based on the `nf` parameter.\n*   When `fang` is \"yes\", the fringe should be slightly angled outward from the gear at an angle calculated by a fixed offset.\n*   The code should calculate the tooth and gap radius properly based on the gear diameter and the number of teeth.\n*   The `Dcut` feature should be properly sized, placed, and toggleable with the `Dcut` parameter.\n\n**Libraries:**\n\nI am not using any external libraries, but I think having these libraries would be useful for later versions:\n\n*   `MCAD` (would be good to have a gear module from that, or something similar if there are better alternatives)\n* `BOSL`\n\nEssentially, I want a more robust and parametrically driven version of my current code, which I can then adjust as needed for future projects. I'd prefer that the values are assigned using `=` rather than `// ignore variable values` as in the attached file. I'd also like to have a comment specifying the default values above each of the parameters, like in the code snippet below, instead of writing it out here. Finally, I'd prefer if you avoid `echo()` statements in the output, since I was using that for debug purposes.\n\n```\n// number of tooth, default = 16\nnt =16;\n```\n\nCan you please generate the OpenSCAD code based on these requirements?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Mouthstachepiece ",
    "scad": "CupDiameter=16;\nCupDepth=8;\nCupSphereFactor=0.5;\nRimWidth=6;\nRimShape=0.7;\nRimRadius=RimShape*RimWidth/2;\nThroatRadius=3.5;\nThroatDiameter=4;\nBackPipeDiameter=9.5;\nFrontPipeDiameter=BackPipeDiameter+3;\nBoreDiameter=BackPipeDiameter-1.5;\nMouthPieceLength=88;\nMustacheSize=100;\nMakeMouthPiece();\nmodule MakeMouthPiece(){\n$fs=1;\n$fa=8;\nCupBottom=[ThroatDiameter/2+ThroatRadius*(0.17+CupSphereFactor*0.3),CupDepth+ThroatRadius*(0.43-CupSphereFactor*0.3)];\nCupTop=[CupDiameter/2+RimRadius*0.02,RimRadius-RimRadius*.2];\nCup45Deg=(0.5+CupSphereFactor*.15);\nCup30Deg=(0.25+CupSphereFactor*.1);\nCup60Deg=(0.75+CupSphereFactor*.1);\nCupshapePoint1=[Cup30Deg*CupTop[0]+Cup60Deg*CupBottom[0],Cup30Deg*CupTop[1]+Cup60Deg*CupBottom[1]];\nCupshapePoint2=[Cup45Deg*CupTop[0]+Cup45Deg*CupBottom[0],Cup45Deg*CupTop[1]+Cup45Deg*CupBottom[1]];\nCupshapePoint3=[Cup60Deg*CupTop[0]+Cup30Deg*CupBottom[0],Cup60Deg*CupTop[1]+Cup30Deg*CupBottom[1]];\nrotate_extrude()\ndifference(){\nunion() {\npolygon( [\nCupTop,\n[CupDiameter/2+RimRadius,0],\n[CupDiameter/2+RimWidth-RimRadius,0],\n[CupDiameter/2+RimWidth,RimRadius],\n[CupTop[0]+RimWidth/2,CupTop[1]+RimWidth],\n[CupshapePoint3[0]+RimWidth/2,CupshapePoint3[1]+RimWidth*2],\n[CupshapePoint2[0]+RimWidth/2,CupshapePoint2[1]+RimWidth*2],\n[CupshapePoint1[0]+RimWidth/2,CupshapePoint1[1]+RimWidth*2],\n[FrontPipeDiameter/2,CupDepth+RimWidth*2],\n[BackPipeDiameter/2,MouthPieceLength],\n[BoreDiameter/2,MouthPieceLength],\n[ThroatDiameter/2,CupDepth+ThroatRadius],\nCupBottom,\nCupshapePoint1,\nCupshapePoint2,\nCupshapePoint3,\n]);\ntranslate([CupDiameter/2+RimRadius,RimRadius, 0])circle(RimRadius);\ntranslate([CupDiameter/2+RimWidth-RimRadius,RimRadius, 0])circle(RimRadius);\ntranslate([ThroatDiameter/2+ThroatRadius,CupDepth+ThroatRadius,0])circle(ThroatRadius);\n}\ntranslate([FrontPipeDiameter/1.4,CupDepth+RimWidth*2.5, 0])circle(RimRadius*1.5);\ntranslate([FrontPipeDiameter/1.5,CupDepth+RimWidth*3.5, 0])circle(RimRadius*1.3);\ntranslate([FrontPipeDiameter/1.6,CupDepth+RimWidth*4.5, 0])circle(RimRadius*1.1);\n}\n}\ntranslate([0,CupDiameter/2+RimWidth-RimRadius,0])\nscale([MustacheSize,MustacheSize,MustacheSize]/120)\ntranslate([0,-6,0])\npolyhedron(\ntriangles=[[0,1,2], [3,4,5], [6,3,5], [7,3,6], [7,8,9], [10,8,7], [6,10,7], [6,11,10], [6,12,11], [12,13,14], [11,12,14], [15,12,6], [16,17,18], [16,6,17], [16,15,6], [19,18,20], [17,6,21], [20,18,17], [6,1,22], [6,23,21], [6,22,23], [24,1,0], [24,22,1], [25,24,0], [2,25,0], [26,1,6], [15,27,12], [8,10,28], [29,6,5], [29,26,6], [2,1,26], [29,30,26], [25,2,31], [2,26,31], [25,32,24], [31,32,25], [30,33,34], [34,33,35], [34,35,32], [24,32,22], [32,35,22], [33,36,37], [37,35,33], [38,35,37], [38,39,35], [39,23,35], [23,22,35], [39,21,23], [19,20,40], [18,41,42], [16,18,42], [40,41,19], [41,18,19], [41,40,43], [41,43,44], [44,43,45], [44,45,46], [44,46,47], [16,42,27], [15,16,27], [42,41,44], [42,44,48], [48,44,47], [12,49,13], [14,13,49], [50,11,14], [10,51,28], [52,8,28], [52,9,8], [9,52,7], [3,7,53], [54,3,53], [54,4,3], [55,4,54], [5,4,55], [5,55,56], [5,56,29], [32,31,34], [36,33,30], [38,57,39], [39,57,21], [40,20,58], [40,58,43], [48,47,59], [49,50,14], [10,50,51], [11,50,10], [47,46,60], [47,60,59], [59,60,61], [59,61,51], [61,28,51], [50,59,51], [62,28,61], [52,63,7], [7,63,53], [55,64,56], [56,64,65], [30,56,65], [36,30,65], [56,30,29], [31,30,34], [26,30,31], [21,57,17], [49,59,50], [49,48,59], [48,49,27], [42,48,27], [27,49,12], [62,52,28], [54,64,55], [38,37,57], [57,66,17], [17,66,58], [20,17,58], [43,58,45], [54,65,64], [57,37,66], [58,66,46], [58,46,45], [60,62,61], [67,52,62], [67,63,52], [67,68,63], [63,68,53], [65,54,53], [60,67,62], [65,53,69], [36,69,37], [37,69,66], [46,66,67], [69,53,68], [68,66,69], [66,68,67], [46,67,60], [36,65,69]],\npoints = [[-58.584091,28.197536,0.000000],[-52.402328,20.506527,0.358841],[-54.800526,17.841995,0.784564],[-2.501032,24.170961,0.015048],[-9.552012,26.627146,0.017661],[-31.154655,19.643610,0.056052],[-44.969563,17.125895,0.016061],[0.000000,21.608608,0.004536],[9.176403,26.642111,0.021504],[2.581123,24.216633,0.016562],[31.159174,19.659206,0.130380],[45.120594,17.133677,0.066386],[54.991936,17.056479,0.194453],[58.584091,28.197536,0.000000],[51.291359,19.966629,0.156079],[49.738537,9.989874,0.000463],[43.278549,4.272926,0.009120],[-0.008242,7.004466,0.209614],[27.192152,0.793691,0.045869],[7.471235,2.503072,0.133520],[2.212253,4.728950,0.346563],[-2.146399,4.782774,0.295524],[-27.192234,0.780368,0.045171],[-7.369259,2.513148,0.046471],[-43.278549,4.272926,0.009121],[-49.810093,9.879161,0.126356],[-47.162132,16.298798,1.529032],[49.784290,10.898610,1.232523],[10.741753,25.962414,1.879541],[-42.937698,16.678349,1.332302],[-41.689590,11.881547,3.436377],[-50.267471,12.405128,1.511218],[-43.140366,5.042169,1.658040],[-28.532618,7.175683,4.583108],[-42.933926,7.437732,2.836552],[-27.605600,2.075034,2.597941],[-7.985993,14.311512,6.152612],[-6.474453,9.613080,5.521743],[-7.452224,5.137392,3.761260],[-6.295128,3.312337,1.773837],[6.465118,3.385351,1.955972],[27.227238,1.939077,2.386184],[43.342510,5.222044,1.810563],[7.736251,5.082082,3.731648],[28.051895,5.904336,4.304694],[6.974583,8.923686,5.317905],[6.558849,12.365727,5.993841],[26.977474,11.160126,5.102334],[42.999367,8.874681,3.112731],[50.156013,16.614939,1.554570],[45.755207,16.255020,1.356992],[30.981188,18.785643,2.009778],[3.500952,24.358774,1.895301],[-2.548270,23.113472,2.539699],[-7.130406,25.382286,2.418850],[-12.033466,25.573273,2.032217],[-31.717640,18.094902,2.627007],[-2.435404,6.976079,3.294168],[3.227587,6.781414,3.575889],[42.141052,13.963333,2.850352],[8.560343,18.462833,5.848720],[11.693113,22.998571,4.199893],[6.927012,23.504366,3.809480],[-0.000000,21.090641,1.418737],[-11.822267,22.579479,4.305679],[-9.060463,19.881535,5.513857],[-0.003193,11.637861,3.475341],[1.729550,18.091600,4.430985],[0.001450,18.014307,3.166783],[-2.453690,17.291109,4.794230]]\n);",
    "description": "Okay, I need help creating a parametric OpenSCAD file for a brass instrument mouthpiece with a mustache attached. I'm starting from a design I already have, and want to improve on the parameters and potentially add some more complex features.\n\nHere's what the current design does:\n\n*   **Mouthpiece Body:** It generates a basic brass mouthpiece shape using a rotate_extrude of a polygon. The polygon is defined by several points that control the cup diameter, depth, rim width, and throat diameter. There are parameters for:\n    *   `CupDiameter`: Diameter of the cup opening.\n    *   `CupDepth`: Depth of the cup.\n    *   `CupSphereFactor`: Controls the shape of the cup from conical to spherical.\n    *   `RimWidth`: Width of the rim.\n    *   `RimShape`: Controls the roundness of the rim.\n    *   `ThroatRadius`: Radius of the throat contour.\n    *   `ThroatDiameter`: Diameter of the throat.\n    *  `BackPipeDiameter`: Diameter of the back pipe fitting into instrument.\n     *  `FrontPipeDiameter`: Diameter of the front pipe.\n     *  `BoreDiameter`: Diameter of the bore.\n    *   `MouthPieceLength`: Total length of the mouthpiece.\n\n*   **Decorative Rims:** It adds some decorative circles as small rims on the outer part of the mouthpiece.\n\n*   **Mustache:** The design includes a mustache attached to the side of the mouthpiece, scaled and positioned using a polyhedron. The mustache geometry seems to be defined by a hardcoded list of triangles and points, and its scaled using `MustacheSize`.\n\nHere's what I'd like in the new design:\n\n1.  **Improved Parametric Control:**\n    *   I want to be able to control the cup curve using a spline instead of just intermediate points between the cup top and bottom. This will make more complex cup shapes possible.\n    *   I want more control over the mouthpiece shank. Instead of just a straight back pipe and a bore diameter, I'd like to define the shank profile with multiple diameters and lengths along the shank to be able to create complex shank geometries.\n    *   I'd like to control the decorative rims with individual parameters for each rim: radius, x position, y position, and z position instead of just the simple circles that are there now. I'd like to be able to specify these parameters as a list of lists.\n    *   I'd like to add a parameter for the angle of the mouthpiece cup with respect to the instrument.\n\n2.  **Refined Mustache:**\n    *   Instead of using a hardcoded polyhedron, I want to be able to import an STL or DXF file for the mustache shape and then position, scale, and rotate it.\n    *   I'd like a parameter to control the mustache material, for example, the surface texture to make it look hairy.\n    *   I want a parameter to control the distance of the mustache from the mouthpiece.\n    *    I would like the option to choose the mustache location, such as on top of, or underneath the mouthpiece.\n\n3.  **Additional Features:**\n    *   Add an option to generate a threaded shank for screw-in mouthpieces, defining thread parameters like diameter, length, and pitch.\n    *   Add an optional base for the mouthpiece so it can stand on a flat surface.\n    *   I want to use the `hull()` function to create a smooth connection between different sections of the mouthpiece, if appropriate.\n\n4. **Library Usage**:\n  * I would like to use the `threads.scad` from the BOSL library for creating the threaded shank and potentially `transforms.scad` for moving parts of the mouthpiece.\n\nI'd like the code to be well-organized, using modules and comments to explain each part. I'd also like the code to be as robust as possible, handling invalid inputs gracefully.\n\nCan you generate an OpenSCAD file based on these requirements?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Template",
    "scad": "use <utils/build_plate.scad>\n$fn = 50*1;\nTemplate_Shape = 2;\nWidth = 20;\nHeight = 50;\nThickness = 4;\nstrip_x=Height;\nstrip_y=Width;\nstrip_z=Thickness;\nhandle_d=5*1;\nhandle_r=handle_d/2;\nhandle_z=strip_z*3;\nhandle_x = handle_d;\narrow_y = strip_y*1.5;\nfudge=0.05*1;\nshape = Template_Shape;\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nif (shape == 1) landingStrip();\nif (shape == 2) arrowStrip();\nif (shape == 3) heartStrip();\nmodule landingStrip() {\n\ttranslate([0,0,strip_z/2]) {\n\t\tcube ([strip_x,strip_y,strip_z],center=true);\n\t\ttranslate ([handle_x,0,handle_z/2])\n\t\t\tcylinder(r=handle_r,h=handle_z,center=true);\n\t\ttranslate ([-handle_x,0,handle_z/2])\n\t\t\tcylinder(r=handle_r,h=handle_z,center=true);\n\t}\n}\nmodule arrowStrip() {\n\ttranslate([0,0,strip_z/2]) {\n\t\tcube ([strip_x,strip_y,strip_z],center=true);\n\t\ttranslate([strip_x/2,0,0])\n\t\t\tdifference() {\n\t\t\t\trotate(45,[0,0,1])\n\t\t\t\t\tcube ([arrow_y,arrow_y,strip_z],center=true);\n\t\t\t\ttranslate([-arrow_y,0,0])\n\t\t\t\t\tcube ([arrow_y*2,arrow_y*2,strip_z+fudge],center=true);\n\t\t\t}\n\t\ttranslate ([handle_x,0,handle_z/2])\n\t\t\tcylinder(r=handle_r,h=handle_z,center=true);\n\t\ttranslate ([-handle_x,0,handle_z/2])\n\t\t\tcylinder(r=handle_r,h=handle_z,center=true);\n\t}\n}\nmodule heartStrip() {\n\ttranslate([0,0,strip_z/2]) {\n\t\trotate(45,[0,0,1])\n\t\t\tcube ([strip_y,strip_y,strip_z],center=true);\n\t\ttranslate ([-strip_y/3.14,-strip_y/3.14,0])\n\t\tcylinder(r=strip_y/2,h=strip_z,center=true);\n\t\ttranslate ([-strip_y/3.14,strip_y/3.14,0])\n\t\tcylinder(r=strip_y/2,h=strip_z,center=true);\n\t\ttranslate ([handle_x,0,handle_z/2])\n\t\t\tcylinder(r=handle_r,h=handle_z,center=true);\n\t\ttranslate ([-handle_x,0,handle_z/2])\n\t\t\tcylinder(r=handle_r,h=handle_z,center=true);\n\t}\n}",
    "description": "Okay, I'm trying to make a customizable template for a 3D printer, and I'd like to use OpenSCAD. I have a basic template that works, but it's not as flexible as I need. I want to be able to select different shapes, adjust the dimensions, and the overall thickness easily, plus add a couple of small handles.\n\nThe basic idea is a 2D template with a constant thickness, and it should have two small cylindrical handles attached at the sides. I need to be able to select from three template shapes:\n\n1.  **A simple strip**:  This is just a rectangle. I want to control its length and width. The current code uses a `height` parameter for the length, but that's not super intuitive. I'd rather call that `length` instead. I also want to be able to control its width with a `width` parameter.\n2.  **An arrow**: This starts with a rectangular strip like the one above, and then has a triangular arrow at one end. I should be able to control the width and length of the rectangular strip part, and the arrow section should dynamically adjust based on the width of the base rectangle, maybe making it 1.5x the base rectangle's width.\n3.  **A heart**: This is a heart shape, which should be controlled by a single `width` parameter to determine its overall size. It's constructed from a rotated square and two intersecting cylinders.\n\nFor all three shapes, I'd like:\n\n*   A `thickness` parameter that controls the thickness of the template.\n*   Two cylindrical handles attached to the sides. The handle diameter should also be parameterizable as `handleDiameter`. The handles should stick out on both sides, and the length of the handles (along the Z-axis) should scale based on thickness, maybe 3x the `thickness`.\n*   I'd like a small amount of overlap (using a `fudge` parameter) when generating the arrow part to ensure there are no gaps between arrow and strip.\n*   I'm using the `build_plate.scad` library to make sure my designs fit, so I'd like that incorporated.\n\nAlso, let's get rid of the somewhat confusing `$fn = 50*1;` variable. I'm not sure why that's there. I would prefer to explicitly control `$fn` when I need to control the resolution, instead of setting it directly in the design.\n\nI need the code to use parameters like:\n* `templateShape` (integer 1, 2, or 3 for strip, arrow, or heart respectively)\n* `length` for the strip and arrow shapes\n* `width` for all shapes\n* `thickness` for all shapes\n* `handleDiameter` for the handles\n\nI also want to keep the `build_plate_selector`, `build_plate_manual_x`, and `build_plate_manual_y` options from my current code. I'm not sure if `fudge` is used in a good way currently, so maybe consider how it could be used better or removed as well if it's not that helpful.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Multi-Rounded Container",
    "scad": "Outer_Container_Width = 100;\nOuter_Container_Height = 40;\nOuter_Container_Depth =  200;\nRadius_InnerAndOuter_Edges =  10;\nWall_InnerAndPartition_Thickness  = 1.5;\nNumber_Inner_Cell_Rows = 3;\nNumber_Inner_Cell_Columns = 2;\nmakeContainer(\n\tOuter_Container_Width,\n\tOuter_Container_Height,\n\tOuter_Container_Depth,\n\tRadius_InnerAndOuter_Edges,\n\tWall_InnerAndPartition_Thickness,\n\tNumber_Inner_Cell_Rows,\n\tNumber_Inner_Cell_Columns\n);\nmodule makeContainer(\n\tintWidth,\n\tintHeight,\n\tintDepth,\n\tintRadius,\n\tintWallthickness,\n\tintRowsSpecified,\n\tintColumnsSpecified) {\n\tintColumns = (intColumnsSpecified == 0) ? 1 : intColumnsSpecified;\n\tintRows = (intRowsSpecified == 0) ? 1 : intRowsSpecified;\n\tintContainerCell_Width = ((intWidth - (((intColumns -1) * intWallthickness) + (intWallthickness * 2))) / intColumns) - ((intColumns > 1) ? ((intRadius*2)*(intColumns-1))/intColumns:0);\n\tintContainerCell_Height = intHeight;\n\tintContainerCell_Depth = ((intDepth - (((intRows -1) * intWallthickness) + (intWallthickness * 2))) / intRows) - ((intRows > 1) ? ((intRadius*2)*(intRows-1))/intRows:0);\n\tintBaseXPosition = intWallthickness;\n\tintBaseYPosition = intWallthickness+0.1;\n\tintBaseZPosition = intWallthickness;\n\tfunction getXPosition(intColumnIndex) = intBaseXPosition + ((intContainerCell_Width+intBaseXPosition) * (intColumnIndex-1)) + ((intColumnIndex > 1) ? ((intRadius*2)*(intColumnIndex-1)):0);\n\tfunction getZPosition(intRowIndex) = intBaseZPosition + ((intContainerCell_Depth+intBaseZPosition) * (intRowIndex-1)) + ((intRowIndex > 1) ? ((intRadius*2)*(intRowIndex-1)):0);\n\tdifference() {\n\t\tcreateContainerShape(intWidth, intHeight, intDepth, intRadius);\n\t\tfor (intRowCount= [1: intRows])\n\t\t{\n\t\t\tfor (intColumnCount = [1: intColumns])\n\t\t\t{\n\t\t\t    \ttranslate (v=[getXPosition(intColumnCount),intBaseYPosition,getZPosition(intRowCount)]) {\n\t\t\t\t\tcreateContainerShape(intContainerCell_Width, intContainerCell_Height, intContainerCell_Depth, intRadius);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule createContainerShape(\n\twidth,\n\theight,\n\tdepth,\n\tradius) {\n\thull() {\n\t\ttranslate(v = [0, 0, 0]) { sphere(r=radius); }\n\t\ttranslate(v = [width, 0, 0]) { sphere(r=radius); }\n\t\ttranslate(v = [width, 0, depth]) { sphere(r=radius); }\n\t\ttranslate(v = [0, 0, depth]) { sphere(r=radius); }\n\t\ttranslate(v = [0, height, 0]) { rotate(a=[90,0,0]) { cylinder(h=1, r=radius, center = true); } }\n\t\ttranslate(v = [width, height, 0]) { rotate(a=[90,0,0]) { cylinder(h=1, r=radius, center = true); } }\n\t\ttranslate(v = [width, height, depth]) { rotate(a=[90,0,0]) { cylinder(h=1, r=radius, center = true); } }\n\t\ttranslate(v = [0, height, depth]) { rotate(a=[90,0,0]) { cylinder(h=1, r=radius, center = true); } }\n\t}\n}",
    "description": "Okay, I'm looking to create a customizable, multi-compartment container, kind of like a drawer insert or a parts organizer. I've already made a design, but I'd like it to be much more robust and parametric. Here's what I need:\n\n**Overall Requirements:**\n\nI need a function (or module) called `makeRoundedContainer` that generates the entire container. It should be possible to specify the following:\n\n*   **Outer Dimensions:**\n    *   `outerWidth`: The overall width of the container (X-axis).\n    *   `outerHeight`: The overall height of the container (Y-axis).\n    *   `outerDepth`: The overall depth of the container (Z-axis).\n\n*   **Rounding:**\n    *   `edgeRadius`: The radius of the rounded edges of the container (both outer and inner corners).\n\n*   **Wall Thickness:**\n    *   `wallThickness`: The thickness of the outer walls and the inner dividing walls.\n\n*   **Internal Cells:**\n    *   `numRows`: The number of rows of inner cells along the Z-axis.\n    *   `numColumns`: The number of columns of inner cells along the X-axis.\n     \n*   **Clearance:**\n    *   `clearance`: A uniform gap between cells to allow for tolerance in 3D printing (for both x and z directions between the cell, walls, and container). This should be added between the rounded edges for the internal walls.\n\n**Desired Functionality:**\n\n1.  **Rounded Corners/Edges:** All corners and edges (both external and internal) of the container and cells should be rounded with the specified `edgeRadius`. The code I have now uses `hull()` and spheres which works, but I'm wondering if there is a cleaner way to generate rounded boxes.\n\n2.  **Cell Layout:** The internal cells should be arranged in a grid defined by the `numRows` and `numColumns` parameters. The cells should all have the same dimensions, automatically calculated from the other parameters (overall size, wall thickness, number of rows/columns, and clearance).\n\n3.  **Parametric:** Everything must be parametric. Changing any of the input values should result in a correctly updated container.\n\n4.  **Negative Space:** The container itself should be a solid block of material with negative space cut out for the individual cells.\n\n5.  **Avoid Overlap:**  The cell layout should *not* cause the rounded edges of the internal walls to overlap if too many cells are requested with a large edge radius. (i.e., account for the space needed for the radius). My code currently tries to account for this, but it's not as clear.\n\n6.  **No Overhangs:** The cells will all be the same height as the container. I'd like to make sure I avoid overhangs as much as possible. The height of the top walls should be flush with the top of each cell.\n\n**Additional Considerations:**\n\n*   I'm not looking for a bottom or lid at this stage; just the main body of the container with cells.\n*   I'd like to use the `BOSL2` library if that makes things easier, particularly the `roundedCube` module, but I'm open to alternatives. Please make sure you include the appropriate `use` statement if you use the library. If there are other libraries you think might be helpful, let me know and we can explore them.\n*   I'd like the code to be as clean and readable as possible, using comments to explain the steps.\n\nEssentially, I want a very flexible and robust generator for multi-compartment containers. Let me know if you have any questions.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Modular Tetris Shelves",
    "scad": "use <utils/build_plate.scad>\nshape = \"L\";\ngrid_size = 50;\nwall_thickness = 2;\ndepth = 50;\nback_wall = \"yes\";\ngrid_pattern = \"yes\";\nwant_shape = \"yes\";\nconnector_depth = 15;\nconnector_width = 15;\nconnector_clearance = 0.25;\nconnector_shape = \"square\";\nnumber_of_4_slot_connectors = 0;\nnumber_of_3_slot_connectors = 0;\nnumber_of_2_slot_straight_connectors = 0;\nnumber_of_2_slot_corner_connectors = 0;\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nconnector_diameter = connector_width;\nnumConnectors = number_of_4_slot_connectors+number_of_3_slot_connectors+number_of_2_slot_straight_connectors+number_of_2_slot_corner_connectors;\nCC = connector_clearance;\noff = wall_thickness/grid_size;\nbackWallOffset = back_wall == \"yes\" ? 1 : -1;\nif (want_shape == \"yes\") makeShape(shape);\ntranslate([-grid_size,grid_size*1.5,0])\nmakeConnectors();\nmodule makeConnectors(){\n\tif (numConnectors > 0){\n\t\tfor (i = [0:numConnectors-1]){\n\t\t\tmakeConnectorX(i);\n\t\t}\n\t}\n}\nmodule makeConnectorX(i){\n\tcolor(\"Gray\")\n\ttranslate([grid_size*(i%4),grid_size*round(i/4-0.49),0])\n\tif (number_of_4_slot_connectors > i) make4Connector();\n\telse if (number_of_4_slot_connectors + number_of_3_slot_connectors > i) make3Connector();\n\telse if (number_of_4_slot_connectors + number_of_3_slot_connectors + number_of_2_slot_straight_connectors > i) make2ConnectorA();\n\telse make2ConnectorB();\n}\nmodule connectorBase(){\n\tif (connector_shape == \"circle\") cylinder(h=connector_depth,r=connector_diameter/2);\n\telse{\n\t\ttranslate([-connector_diameter/2,-connector_diameter/2,0])\n\t\tcube(size = [connector_diameter,connector_diameter,connector_depth]);\n\t}\n}\nmodule make4Connector(){\n\tdifference(){\n\t\tconnectorBase();\n\t\ttranslate([0,0,wall_thickness*2+connector_depth/2])\n\t\tcube(size = [connector_diameter*1.1,wall_thickness*2+CC,connector_depth],center = true);\n\t\ttranslate([0,0,wall_thickness*2+connector_depth/2])\n\t\tcube(size = [wall_thickness*2+CC,connector_diameter*1.1,connector_depth],center = true);\n\t}\n}\nmodule make3Connector(){\n\tdifference(){\n\t\tconnectorBase();\n\t\ttranslate([0,0,wall_thickness*2+connector_depth/2])\n\t\tcube(size = [connector_diameter*1.1,wall_thickness*2+CC,connector_depth],center = true);\n\t\ttranslate([-wall_thickness-CC/2,0,wall_thickness*2])\n\t\tcube(size = [wall_thickness*2+CC,connector_diameter*.55,connector_depth]);\n\t}\n}\nmodule make2ConnectorA(){\n\tdifference(){\n\t\tconnectorBase();\n\t\ttranslate([0,0,wall_thickness*2+connector_depth/2])\n\t\tcube(size = [connector_diameter*1.1,wall_thickness*2+CC,connector_depth],center = true);\n\t}\n}\nmodule make2ConnectorB(){\n\tdifference(){\n\t\tconnectorBase();\n\t\ttranslate([-wall_thickness-CC/2,-wall_thickness-CC/2,wall_thickness*2])\n\t\tcube(size = [connector_diameter*1,wall_thickness*2+CC,connector_depth]);\n\t\ttranslate([-wall_thickness-CC/2,0,wall_thickness*2])\n\t\tcube(size = [wall_thickness*2+CC,connector_diameter*.55,connector_depth]);\n\t}\n}\nmodule makeShape(shape){\n\tcolor(shape == \"L\" ? \"Orange\" : shape == \"J\" ? \"Blue\" : shape == \"O\" ? \"Yellow\" : shape == \"I\" ? \"Cyan\" : shape == \"S\" ? \"Lime\" : shape == \"Z\" ? \"Red\" : \"Magenta\")\n\tdifference(){\n\t\tlinear_extrude(height=depth, convexity = 10)\n\t\tscale([grid_size,grid_size,1])\n\t\tif (shape == \"L\") L();\n\t\telse if (shape == \"J\") J();\n\t\telse if (shape == \"O\") O();\n\t\telse if (shape == \"I\") I();\n\t\telse if (shape == \"S\") S();\n\t\telse if (shape == \"Z\") Z();\n\t\telse if (shape == \"T\") T();\n\t\tdifference(){\n\t\t\ttranslate([0,0,backWallOffset*wall_thickness])\n\t\t\tlinear_extrude(height=depth*2, convexity = 10)\n\t\t\tscale([grid_size,grid_size,1])\n\t\t\tif (shape == \"L\") offsetL();\n\t\t\telse if (shape == \"J\") offsetJ();\n\t\t\telse if (shape == \"O\") offsetO();\n\t\t\telse if (shape == \"I\") offsetI();\n\t\t\telse if (shape == \"S\") offsetS();\n\t\t\telse if (shape == \"Z\") offsetZ();\n\t\t\telse if (shape == \"T\") offsetT();\n\t\t\tif (grid_pattern == \"yes\"){\n\t\t\t\ttranslate([0,0,wall_thickness])\n\t\t\t\tcuttingGrid();\n\t\t\t}\n\t\t}\n\t\tif (grid_pattern == \"yes\") cuttingGrid();\n\t}\n}\nmodule cuttingGrid(){\n\ttranslate([0,-grid_size*.5,0])\n\trotate([0,0,90])\n\trotate([90,0,0])\n\ttranslate([0,0,-grid_size*1.55])\n\tlinear_extrude(height=grid_size*4.1, convexity = 10)\n\tscale([grid_size,grid_size,1])\n\tpolygon(points = [ [-1,-1],[-1,-.35],[-.5,.15],[0,-.35],[.5,.15],[1,-.35],[1.5,.15],[2,-.35],[2,-1]],paths = [[0,1,2,3,4,5,6,7,8]]);\n\trotate([90,0,0])\n\ttranslate([0,0,-grid_size*1.05])\n\tlinear_extrude(height=grid_size*2.1, convexity = 10)\n\tscale([grid_size,grid_size,1])\n\tpolygon(points = [ [-2,-1],[-2,-.35],[-1.5,.15],[-1,-.35],[-.5,.15],[0,-.35],[.5,.15],[1,-.35],[1.5,.15],[2,-.35],[2.5,.15],[3,-.35],[3,-1]],paths = [[0,1,2,3,4,5,6,7,8,9,10,11,12]]);\n}\nmodule L() {\n\tcolor(\"Orange\")\n\tpolygon(points = [ [-1.5,-1],[1.5,-1],[1.5,1],[.5,1],[.5,0],[-1.5,0]],paths = [[0,1,2,3,4,5]]);\n}\nmodule J() {\n\tcolor(\"Blue\")\n\tpolygon(points = [ [-1.5,-1],[1.5,-1],[1.5,0],[-.5,0],[-.5,1],[-1.5,1]],paths = [[0,1,2,3,4,5]]);\n}\nmodule O() {\n\tcolor(\"Yellow\")\n\tpolygon(points = [ [-.5,-1],[1.5,-1],[1.5,1],[-.5,1]],paths = [[0,1,2,3]]);\n}\nmodule I() {\n\tcolor(\"Cyan\")\n\tpolygon(points = [ [-1.5,0],[2.5,0],[2.5,1],[-1.5,1]],paths = [[0,1,2,3]]);\n}\nmodule S() {\n\tcolor(\"Lime\")\n\tpolygon(points = [ [-1.5,-1],[.5,-1],[.5,0],[1.5,0],[1.5,1],[-.5,1],[-.5,0],[-1.5,0]],paths = [[0,1,2,3,4,5,6,7]]);\n}\nmodule Z() {\n\tcolor(\"Red\")\n\tpolygon(points = [ [1.5,-1],[-.5,-1],[-.5,0],[-1.5,0],[-1.5,1],[.5,1],[.5,0],[1.5,0]],paths = [[0,1,2,3,4,5,6,7]]);\n}\nmodule T() {\n\tcolor(\"Magenta\")\n\tpolygon(points = [ [-1.5,-1],[1.5,-1],[1.5,0],[.5,0],[.5,1],[-.5,1],[-.5,0],[-1.5,0]],paths = [[0,1,2,3,4,5,6,7]]);\n}\nmodule offsetL() {\n\tcolor(\"Orange\")\n\tpolygon(points = [ [-1.5+off,-1+off],[1.5-off,-1+off],[1.5-off,1-off],[.5+off,1-off],[.5+off,0-off],[-1.5+off,0-off]],paths = [[0,1,2,3,4,5]]);\n}\nmodule offsetJ() {\n\tcolor(\"Blue\")\n\tpolygon(points = [ [-1.5+off,-1+off],[1.5-off,-1+off],[1.5-off,0-off],[-.5-off,0-off],[-.5-off,1-off],[-1.5+off,1-off]],paths = [[0,1,2,3,4,5]]);\n}\nmodule offsetO() {\n\tcolor(\"Yellow\")\n\tpolygon(points = [ [-.5+off,-1+off],[1.5-off,-1+off],[1.5-off,1-off],[-.5+off,1-off]],paths = [[0,1,2,3]]);\n}\nmodule offsetI() {\n\tcolor(\"Cyan\")\n\tpolygon(points = [ [-1.5+off,off],[2.5-off,off],[2.5-off,1-off],[-1.5+off,1-off]],paths = [[0,1,2,3]]);\n}\nmodule offsetS() {\n\tcolor(\"Lime\")\n\tpolygon(points = [ [-1.5+off,-1+off],[.5-off,-1+off],[.5-off,0+off],[1.5-off,0+off],[1.5-off,1-off],[-.5+off,1-off],[-.5+off,0-off],[-1.5+off,0-off]],paths = [[0,1,2,3,4,5,6,7]]);\n}\nmodule offsetZ() {\n\tcolor(\"Red\")\n\tpolygon(points = [ [1.5-off,-1+off],[-.5+off,-1+off],[-.5+off,0+off],[-1.5+off,0+off],[-1.5+off,1-off],[.5-off,1-off],[.5-off,0-off],[1.5-off,0-off]],paths = [[0,1,2,3,4,5,6,7]]);\n}\nmodule offsetT() {\n\tcolor(\"Magenta\")\n\tpolygon(points = [ [-1.5+off,-1+off],[1.5-off,-1+off],[1.5-off,0-off],[.5-off,0-off],[.5-off,1-off],[-.5+off,1-off],[-.5+off,0-off],[-1.5+off,0-off]],paths = [[0,1,2,3,4,5,6,7]]);\n}",
    "description": "Okay, I have this idea for some modular shelving based on Tetris shapes and I'm hoping you can help me create an OpenSCAD design. I've already played around with a basic version (I can share that if it helps!), but I need something more parametric and robust. \n\nHere's what I'm imagining:\n\n**Core Concept:**\n\n*   **Tetris Shapes:** The shelving units will be based on the standard Tetris shapes: I, J, L, O, S, Z, and T.\n*   **Modular Design:** Each shape should be a standalone unit that can be connected to others using some kind of connector system. This needs to be customizable.\n\n**Key Parameters I want to Control:**\n\n*   **Shape Selection:** The user should be able to select which Tetris shape to generate (I, J, L, O, S, Z, or T).\n*   **Grid Size:**  The size of the base unit \"grid square\" of the Tetris shape, in millimeters.\n*   **Wall Thickness:** The thickness of the walls of each shape, also in millimeters.\n*   **Depth:** The depth of the shelving unit (how far it extends out from the wall), in millimeters.\n*   **Back Wall:** A boolean option to include a back wall on each shelving unit.\n*   **Back Wall Grid:** A boolean option to add a grid pattern to the back of the shelving unit for aesthetics/strength.\n*   **Connectors:**\n    *   **Connector Depth:** The depth of the connectors that fit into the shelving units.\n    *   **Connector Width:** The width of the connectors.\n    *   **Connector Clearance:**  Clearance around the connectors for ease of fit (needs to be adjustable for different printer tolerances).\n    *   **Connector Shape:** Option for circle or square connectors.\n    *   **Number of Connectors:** Ability to specify how many of each connector type are generated (4-slot, 3-slot, straight 2-slot, and corner 2-slot).\n    *   **Connector Layout:** Connectors should be laid out in a reasonable way, possibly in a grid, so they are easy to print.\n\n**Other Considerations:**\n\n*   **Build Plate Visualization:** I'd like a way to visualize the build plate size and dimensions so I can see how the shapes and connectors will fit. It would be cool to have some common printer presets for this or even be able to define manual build plate dimensions\n*   **Coloring:** It might be nice to have the shapes be colored based on the standard Tetris shape colors for easier visualization in the preview (I=Cyan, J=Blue, L=Orange, O=Yellow, S=Lime, Z=Red, T=Magenta).\n*   **Library:** It looks like I am already using a build_plate.scad file, so please use that if it's possible.\n\n**My Goals**\n\n*   **Parametric Design:** Everything should be adjustable via parameters.\n*   **Ease of Use:** I should be able to easily select a shape, adjust sizes, and generate the STL files I need for 3D printing.\n*   **Functional and Printable:** The design should be strong enough for shelving while being printable without excessive supports.\n\nCould you help me develop a parametric OpenSCAD file that achieves these goals? I want to be able to generate both individual Tetris shapes and a set of connectors.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Platform Clips",
    "scad": "_style = \"square\";\n_platformGap = 6.8;\n_length = 16.0;\n_wallThickness = 1.0;\n_diameter = 2.2;\nmodule smallArc(radius0, radius1, angle, depth) {\n\tthickness = radius1 - radius0;\n\teps = 0.01;\n\tunion() {\n\t\tdifference() {\n\t\t\tcylinder(r=radius1, h=depth, center=true);\n\t\t\tcylinder(r=radius0, h=depth+2*eps, center=true);\n\t\t\tfor(z=[0, 180 - angle]) {\n\t\t\t\trotate([0,0,z])\n\t\t\t\ttranslate([-radius1,0,0])\n\t\t\t\tcube(size = [radius1*2, radius1*2, depth+eps], center=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule roundArc(radius0, radius1, angle, depth) {\n\tthickness = radius1 - radius0;\n\tcutAngle = 360-angle;\n\tcenterRadius = (radius0 + radius1)/2.0;\n\tunion() {\n\t\tif (angle > 180) {\n\t\t\tsmallArc(radius0, radius1, 180, depth);\n\t\t\trotate([0,0,-180]) {\n\t\t\t\tsmallArc(radius0, radius1, angle-180, depth);\n\t\t\t}\n\t\t} else {\n\t\t\tsmallArc(radius0, radius1, angle, depth);\n\t\t}\n\t\tfor(t = [ [0,centerRadius,0],\n\t\t\t\t\t [centerRadius * -sin(cutAngle), centerRadius * cos(cutAngle),0] ]) {\n\t\t\ttranslate(t) {\n\t\t\t\tcylinder(r=thickness/2, h=depth, center=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule clip(arcRadius, angle, height, outerThickness, hingeRadius, hingeAngle, clipAngle, hingeGap) {\n\tir = arcRadius;\n\tor = ir + outerThickness;\n\tclipRadius = hingeRadius;\n\thx = (ir-hingeRadius)*sin(angle/2);\n\thy = (ir-hingeRadius)*cos(angle/2);\n\tcx = (ir-clipRadius)*sin(angle/2);\n\tcy = (ir-clipRadius)*cos(angle/2);\n\tunion() {\n\t\tdifference() {\n\t\t\trotate([0,0,angle/2]) {\n\t\t\t\troundArc(ir, or, angle, height);\n\t\t\t}\n\t\t}\n\t\ttranslate([-hx, hy, 0])\n\t\trotate([0,0,angle/2+hingeAngle]) {\n\t\t\troundArc(hingeRadius, hingeRadius+outerThickness, hingeAngle, height);\n\t\t}\n\t\ttranslate([cx, cy, 0])\n\t\trotate([0,0,-angle/2]) {\n\t\t\troundArc(clipRadius, clipRadius+outerThickness, clipAngle, height);\n\t\t}\n\t}\n}\nmodule buildRoundClip(gap, width, wall, diameter) {\n\tcurvature = 25;\n\tclipAngle = 120;\n\thingeAngle = 280 - wall*10;\n\tlength = gap + diameter/3 + wall;\n\tradius = length / (2 *(curvature/100));\n\tangle = 2 * asin(length/(2*radius));\n\ttranslate([0,-radius,width/2]) {\n\t\tclip(radius, angle, width, wall, diameter/2, hingeAngle, clipAngle);\n\t}\n}\nmodule buildSquareClip(gap, width, wall, diameter) {\n\tradius = diameter/2;\n\ttipRadius = diameter * 0.3;\n\tclipDepth = 1.0;\n\tspace = 0.6;\n\teps = 0.1;\n\tfor (y = [-1,1]) {\n\t\thull() {\n\t\t\ttranslate([0,y*(gap/2 + radius),0]) {\n\t\t\t\tcylinder(r=radius, h=width);\n\t\t\t}\n\t\t\ttranslate([-diameter*clipDepth,y*(gap/2 + tipRadius),0]) {\n\t\t\t\tcylinder(r=tipRadius, h=width);\n\t\t\t}\n\t\t}\n\t\ttranslate([(radius+space)/2, y*(gap/2 + diameter - wall/2), width/2]) {\n\t\t\tcube(size=[radius + space + eps, wall, width], center=true);\n\t\t}\n\t}\n\ttranslate([radius + space + wall/2, 0, width/2]) {\n\t\tcube(size=[wall, gap + diameter*2, width], center=true);\n\t}\n}\nmodule make($fn = 120) {\n\tif (_style == \"round\") {\n\t\tbuildRoundClip(_platformGap, _length, _wallThickness, _diameter);\n\t} else {\n\t\tbuildSquareClip(_platformGap, _length, _wallThickness, _diameter);\n\t}\n}\nmake();",
    "description": "Okay, I'm looking to design a parametric clip for securing a build platform, and I've seen some examples that get me close to what I need, but I'd like to make some changes and have it be more flexible.\n\nEssentially, the clip needs to grasp a platform from the top and bottom, using either a round or a square style of grip. The existing example I've seen uses a \"spine\" with two \"grips\" on either side that grab the platform. I'm thinking of a design where the user can control the following parameters:\n\n*   **`style`**: A string, either `\"round\"` or `\"square\"`, to choose the grip style.\n*   **`platformGap`**: The height of the gap between the two grips that the platform fits into. This is a critical dimension.\n*   **`length`**: The overall length of the clip (including the grip areas and the central spine).\n*   **`wallThickness`**: The thickness of the clip material, which impacts its strength.\n*  **`diameter`**: The diameter of the round grip, or the size of the square grip.\n\nFor the \"round\" style, the existing examples are pretty close. The grip is formed using an arc that wraps around the platform edge, with a hinged portion that opens to accept the platform. Id like to be able to adjust:\n* the curvature of the grip portion\n* the hinge angle\n* the clip angle\n\nFor the \"square\" style grip, it should have a rectangular central spine with two opposing grips on each side. These grips will be semi-cylindrical with a small, almost-rectangular \"prong\" section that actually contacts the platform. I need to be able to set the following:\n* The radius of the semi-cylindrical section.\n* The radius of the tips of the prongs.\n* The depth of the prongs\n* The space between the spine and the grip.\n\nSo, to sum up, I'd like a single OpenSCAD file with these parameters, switching between a \"round\" style and a \"square\" style of clip, with the above mentioned adjustable values. The general structure of the file should be like this:\n\n```openscad\n_style = \"square\"; // [round, square]\n\n// height of the platform (use a slightly smaller value, about 0.2mm to make the clip tight)\n_platformGap = 6.8;\n\n// length of the clip\n_length = 16.0; \n\n// thickness of the clip.\n_wallThickness = 1.0;\n\n// size of the top of the clip\n_diameter = 2.2;\n\n////////////////////////////////////////////////////////////////////////\n// Round clip parameters\n_curvature = 25;\n_clipAngle = 120;\n_hingeAngle = 280;\n\n////////////////////////////////////////////////////////////////////////\n// Square clip parameters\n_clipDepth = 1.0;\n_space = 0.6;\n\n// function to build and return the clip\nmodule make($fn = 120) {\n    if (_style == \"round\") {\n      // round clip code\n    } else {\n      // square clip code\n    }\n}\n\nmake();\n```\nI am not using any external libraries for this project. Could you provide an OpenSCAD file that implements all of this functionality?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Spear for LIONFISH Fishing / Hunting",
    "scad": "radius_cylinder=5;\nheight_spikes=120;\nspike_length=160;\nsum=height_spikes+spike_length;\nspike_bar_width=90;\nbar=spike_bar_width;\nNumber_of_spikes=3;\na=Number_of_spikes-1;\nrotate_z=90*1;\nrotate_y=0*1;\nwidth_of_spikes=3;\nradius_spike=5;\nb=width_of_spikes;\ndis=spike_bar_width/a;\nmodule spear()\n{\ntranslate([0,bar/2,0])rotate([0,90,0])cylinder(100,r=radius_cylinder);\ntranslate([0,bar,0])rotate([90,0,0])cylinder(spike_bar_width,r=radius_cylinder);\ntranslate([0,0,0])sphere(5,r=radius_cylinder);\ntranslate([0,bar,0])sphere(5,r=radius_cylinder);\nfor(i=[0:a])\n{\ntranslate([-spike_length,dis*i,0])rotate([0,90,0])cylinder(spike_length,r=radius_cylinder);\ntranslate([-sum,dis*i,0])rotate([0,90,0])cylinder(height_spikes,0,r2=radius_cylinder);\ntranslate([-sum,dis*i,0])rotate([rotate_x,rotate_z,rotate_y])cylinder(height_spikes,0,r2=radius_spike);\nfor(y=[0:b])\n{\ntranslate([-sum,dis*i,0])rotate([y,rotate_z,rotate_y])cylinder(height_spikes,0,r2=radius_spike);\n}\n}\n}\nspear();",
    "description": "Okay, I'm looking to create a customizable 3D-printable spear for lionfish hunting, based on the existing design I found online. I've seen some basic versions, but I'd really like a more parametric model so I can adjust it to my own needs.\n\nSpecifically, I'm thinking about something with the following features:\n\n*   **Main Spear Shaft:** This should be a cylinder with an adjustable radius (thickness) and length. I need to be able to set the radius and the length separately.\n*  **Spike Bar:** This is the bar that connects the main spear shaft to the actual spikes. It should be a cylindrical bar perpendicular to the spear shaft, with adjustable length and radius.\n*   **Spikes:** I want to have multiple spikes coming off of the spike bar. The number of spikes should be adjustable, as well as the length of the main spike (the longer part) and the length of the short barb portion at the tip of the spike. I'd also like to adjust the radius of the spikes. The spikes should also be evenly spaced around the spike bar. Ideally, the barb would be like a small cone or rounded point, also with an adjustable radius.\n*   **Rotation:** The base spear shaft should run along the y-axis, with the bar running along the x-axis. I need to be able to rotate the entire design using x, y, and z rotation parameters, but for now the rotation should start at 0 for all axes.\n\nFor all parameters, I need to set minimum and maximum values. The original file uses sliders to adjust the parameters which makes it easy to visualize. Here's what I envision:\n\n*   `radius_cylinder`: The radius of the main spear shaft and spike bar. Minimum: 0, Maximum: 30.\n*   `height_spikes`: The length of the barb at the tip of each spike. Minimum: 0, Maximum: 200.\n*   `spike_length`: The length of the main part of each spike. Minimum: 0, Maximum: 200.\n*  `spike_bar_width`: The length of the spike bar. Minimum 15, Maximum 300.\n*   `Number_of_spikes`:  Number of spikes on the spike bar. Minimum 0, Maximum 12.\n*  `width_of_spikes`: The number of sides on the spike bar. Minimum 0, Maximum 12.\n* `radius_spike`: The radius of the barb on the spike.\n\nI want the code to be in OpenSCAD and be easily customizable by the user. I don't need any external libraries for this. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Fish-On NOW !",
    "scad": "include <utils/build_plate.scad>\npart\t = \"plate\";\nrodDiameter = 3;\nretainerClipFitTolerance = 0.1;\ncableTieWidth = 4;\ncableTieHeight = 2;\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nmodule dummy() {}\nbuzzerDiameter = 17.5;\nbuzzerLipDiameter = 14.5;\nbuzzerLipLength = 2;\nbuzzerLength = 14.5;\nbuzzerRetainerDiameter = buzzerDiameter - 4;\nbuzzerRetainerLength = 10;\nbuzzerPosition = [0, 0, 0];\nledDiameter = 5.75;\nledLipDiameter = 7.5;\nledLipThickness = 1.4;\nledHoleLength = 1.5;\nledRetainerLength = 2.0;\nledPosition = [0, ledRetainerLength - 2, 13];\nresistorDiameter = 3.5;\nresistorLength = 15;\nresistorPosition = [0, 10, 14];\ntiltSwitchDiameter = 6;\ntiltSwitchLength = 24;\ntiltSwitchRotation = 0;\ntiltSwitchPosition = [0, 26, -4];\nonOffSwitchDimensions = [6, 12, 8];\nonOffSwitchSwitchDimensions = [3, 6, 1.0];\nonOffSwitchRetainerDimensions = [onOffSwitchDimensions[0], 8, 2];\nonOffSwitchFlangeDimensions = [5, 20, 1];\nonOffSwitchPosition = [0, 30, 18];\nbatteryDiameter = 10.35;\nbatteryLength = 27 + 1 + 2;\nbatteryPositiveDiameter = 5.5;\nbatteryPositiveLength = 1;\nbatteryPositiveTerminalDiameter = 8.25;\nbatteryPositiveTerminalThickness = 3.25;\nbatterySpringRetainerLength = 6;\nbatterySpringRetainerDiameter = 6;\nbatteryPosition = [0, 45, 6];\ncaseBorder = 1;\ncaseDimensions = [buzzerDiameter + caseBorder * 2,\n\t\t\t\t batteryPosition[1] + batteryLength + batteryPositiveTerminalThickness + batteryPositiveLength + batterySpringRetainerLength + caseBorder,\n\t\t\t\t caseBorder + buzzerDiameter / 2 + onOffSwitchPosition[2]];\ncaseTranslation =  [-caseDimensions[0] / 2, 0, -(buzzerDiameter / 2 + caseBorder)];\nmanifoldCorrection = 0.01;\nmanifoldCorrectionVect = [manifoldCorrection, manifoldCorrection, manifoldCorrection];\ndistanceBetweenLeftRightHolder = 5;\ndistanceBetweenLeftRightAndRodAttachment = 5;\ndistanceBetweenLeftRightAndRetainerClip = 5;\ncableTieRodHolderClearance = 2;\nrodAttachmentDimensions = [rodDiameter * 2, 20, cableTieHeight + cableTieRodHolderClearance + rodDiameter / 2];\nrodFlangeDimensions = [caseDimensions[0], caseDimensions[1], 3];\nrodAttachmentPosition = [rodAttachmentDimensions[0] - caseDimensions[0] / 2 + rodFlangeDimensions[2],\n\t\t\t\t\t\t- rodAttachmentDimensions[1] / 2,\n\t\t\t\t\t\t-(buzzerDiameter / 2 + caseBorder + rodAttachmentDimensions[2] + rodFlangeDimensions[2]) ];\nrodAttachmentPositionPlate = [(rodAttachmentDimensions[2] + rodFlangeDimensions[2]) - caseDimensions[0] / 2, -(caseDimensions[1] / 2 + rodFlangeDimensions[0] / 2 + distanceBetweenLeftRightAndRodAttachment), -caseDimensions[2]];\nrodAttachmentPositionAll = [0, 0, -(buzzerDiameter)];\ncableTieDistanceFromEdge = 1.5;\ncableTiePosition1 = [0, cableTieDistanceFromEdge, 0];\ncableTiePosition2 = [0, (rodAttachmentDimensions[1] - cableTieWidth) - cableTieDistanceFromEdge, 0];\nretainerClipThickness = 2;\nretainerClipInnerDimensions = [caseDimensions[0] + retainerClipFitTolerance, 7, caseDimensions[2] + rodFlangeDimensions[2] + + retainerClipFitTolerance ];\nretainerClipOuterDimensions = [retainerClipInnerDimensions[0] + retainerClipThickness * 2,\n\t\t\t\t\t\t\t  retainerClipInnerDimensions[1],\n\t\t\t\t\t\t\t  retainerClipInnerDimensions[2] + retainerClipThickness * 2];\nretainerClip1PositionAll = [0, - (caseDimensions[1] - retainerClipOuterDimensions[1] ) / 2, (retainerClipOuterDimensions[2] - retainerClipInnerDimensions[2]) / 2];\nretainerClip2PositionAll = [retainerClip1PositionAll[0], -retainerClip1PositionAll[1], retainerClip1PositionAll[2]];\nretainerClip1PositionPlate = [- caseDimensions[0] / 2 + retainerClipOuterDimensions[1] / 2,\n\t\t\t\t\t\t\t (caseDimensions[1] + retainerClipOuterDimensions[0] ) / 2 + distanceBetweenLeftRightAndRetainerClip,\n\t\t\t\t\t\t\t distanceBetweenLeftRightAndRetainerClip / 2];\nretainerClip2PositionPlate = [ retainerClip1PositionPlate[0],\n\t\t\t\t\t\t\t  retainerClip1PositionPlate[1],\n\t\t\t\t\t\t\t  -(retainerClip1PositionPlate[2] + retainerClipOuterDimensions[2])];\ncenterTranslation = [ 0, -caseDimensions[1] / 2, 0];\nchannel1Dimensions = [4, 22, 10];\nchannel1Position = [-channel1Dimensions[0] / 2, 23.1, -2];\nchannel2Dimensions = [4, 6, 2];\nchannel2Position = [-channel1Dimensions[0] / 2, 4.1, 13];\nchannel3Dimensions = [4, 23, 2];\nchannel3Position = [-channel1Dimensions[0] / 2, 4, 10];\nchannel4Dimensions = [4, 3, 10];\nchannel4Position = [-channel1Dimensions[0] / 2, 23.9, 4];\nchannel5Dimensions = [4, 34, 7];\nchannel5Position = [-channel1Dimensions[0] / 2, 45, -3];\nchannel6Dimensions = [4, 10, 2];\nchannel6Position = [-channel1Dimensions[0] / 2, 75, -3];\nchannel7Dimensions = [4, 2, 10];\nchannel7Position = [-channel1Dimensions[0] / 2, 83, -3];\ncenteredOnPlatformCorrectionRotation = [0, -90, -90];\ncenteredOnPlatformCorrectionTranslation = [0, caseDimensions[2] / 2 + distanceBetweenLeftRightHolder / 2, caseDimensions[0] / 2];\n$fn = 80;\ntranslate( centeredOnPlatformCorrectionTranslation )\n\trotate( centeredOnPlatformCorrectionRotation )\n\t\tfishAlert();\nmodule fishAlert()\n{\n\tif ( part == \"plate\" || part == \"assembled\" || part == \"left\" )\n\t\tleftHolder();\n\tif ( part == \"plate\" || part == \"assembled\" || part == \"right\" )\n\t{\n\t\tif\t    ( part == \"plate\" )\t\trightHolder( translateZ = -caseDimensions[2] - distanceBetweenLeftRightHolder, rotateZ = 180 );\n\t\telse if ( part == \"assembled\" )\trightHolder( translateZ = 0, rotateZ = 0 );\n\t\telse\t\t\t\t\t    \t\t\trightHolder( translateZ = 0, rotateZ = 180 );\n\t}\n\tif ( part == \"plate\" || part == \"assembled\" || part == \"rodAttachment\" )\n\t{\n\t\tif ( part == \"plate\" || part == \"rodAttachment\" )\n\t\t{\n\t\t\ttranslate( rodAttachmentPositionPlate )\n\t\t\t\trotate( [90, 0, -90 ] )\n\t\t\t\t\trodAttachment();\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttranslate( rodAttachmentPositionAll )\n\t\t\t\trodAttachment();\n\t\t}\n\t}\n\tif ( part == \"plate\" || part == \"assembled\" || part == \"clips\" )\n\t{\n\t\tif ( part == \"assembled\" )\n\t\t{\n\t\t\ttranslate( retainerClip1PositionAll )\n\t\t\t\tretainerClip();\n\t\t\ttranslate( retainerClip2PositionAll )\n\t\t\t\tretainerClip();\n\t\t}\n\t\telse if ( part == \"plate\" || part == \"clips\" )\n\t\t{\n\t\t\ttranslate( retainerClip1PositionPlate )\n\t\t\t\trotate( [0, 0, 90] )\n\t\t\t\t\tretainerClip();\n\t\t\ttranslate( retainerClip2PositionPlate )\n\t\t\t\trotate( [0, 0, 90] )\n\t\t\t\t\tretainerClip();\n\t\t}\n\t}\n}\nmodule leftHolder()\n{\n\tdifference()\n\t{\n\t\tholder();\n\t\ttranslate( [manifoldCorrection, -caseDimensions[1], -caseDimensions[2]] )\n\t\t\tcube( [caseDimensions[0] / 2 , caseDimensions[1] * 2, caseDimensions[2] * 2] );\n\t}\n}\nmodule rightHolder()\n{\n\ttranslate( [0, 0, translateZ] )\n\t\trotate( [0, rotateZ, 0] )\n\t\t\tdifference()\n\t\t\t{\n\t\t\t\tholder();\n\t\t\t\ttranslate( [-caseDimensions[0] / 2 - manifoldCorrection, -caseDimensions[1], -caseDimensions[2] ] )\n\t\t\t\t\tcube( [caseDimensions[0] / 2, caseDimensions[1] * 2, caseDimensions[2] * 2] );\n\t\t\t}\n}\nmodule holder()\n{\n\ttranslate( centerTranslation )\n\t{\n\t\tdifference()\n\t\t{\n\t\t\ttranslate( caseTranslation )\n\t\t\t\tcube( caseDimensions );\n\t\t\tcomponents();\n\t\t\tchannels();\n\t\t}\n\t}\n}\nmodule channels()\n{\n\ttranslate( channel1Position )\n\t\tcube( channel1Dimensions );\n\ttranslate( channel2Position )\n\t\tcube( channel2Dimensions );\n\ttranslate( channel3Position )\n\t\tcube( channel3Dimensions );\n\ttranslate( channel4Position )\n\t\tcube( channel4Dimensions );\n\ttranslate( channel5Position )\n\t\tcube( channel5Dimensions );\n\ttranslate( channel6Position )\n\t\tcube( channel6Dimensions );\n\ttranslate( channel7Position )\n\t\tcube( channel7Dimensions );\n}\nmodule components()\n{\n\ttranslate( buzzerPosition )\n\t\tbuzzer();\n\ttranslate( ledPosition )\n\t\tled();\n\ttranslate( resistorPosition )\n\t\tresistor();\n\ttranslate( tiltSwitchPosition )\n\t\ttiltSwitch();\n\ttranslate( onOffSwitchPosition )\n\t\tonOffSwitch();\n\ttranslate( batteryPosition )\n\t\tbattery();\n}\nmodule retainerClip()\n{\n\tdifference()\n\t{\n\t\tcube( retainerClipOuterDimensions, center = true );\n\t\tcube( retainerClipInnerDimensions + manifoldCorrectionVect, center = true );\n\t}\n}\nmodule rodAttachment()\n{\n\tdifference()\n\t{\n\t\tunion()\n\t\t{\n\t\t\ttranslate(  [ -rodFlangeDimensions[0] / 2, - (rodFlangeDimensions[1] - rodAttachmentDimensions[1]) / 2, rodAttachmentDimensions[2] ] )\n\t\t\t\tcube( rodFlangeDimensions );\n\t\t\ttranslate(  [ -rodAttachmentDimensions[0] / 2, 0, 0 ] )\n\t\t\t\tcube( rodAttachmentDimensions );\n\t\t}\n\t\ttranslate( [0, -manifoldCorrection, 0] )\n\t\t\trotate( [-90, 0, 0] )\n\t\t\t\tcylinder( r = rodDiameter / 2, h = rodAttachmentDimensions[1] + 2 * manifoldCorrection );\n\t\ttranslate( cableTiePosition1 )\n\t\t\tcableTieCutOut();\n\t\ttranslate( cableTiePosition2 )\n\t\t\tcableTieCutOut();\n\t}\n}\nmodule cableTieCutOut()\n{\n\ttranslate( [-(rodAttachmentDimensions[0] / 2 + manifoldCorrection), 0, rodAttachmentDimensions[2] - cableTieHeight] )\n\t\tcube( [rodAttachmentDimensions[0] + manifoldCorrection * 2, cableTieWidth, cableTieHeight] );\n}\nmodule onOffSwitch()\n{\n\ttranslate( [ 0, onOffSwitchDimensions[1] / 2, 0 ] )\n\t{\n\t\trotate( [-180, 0, 0 ] )\n\t\t{\n\t\t\ttranslate( [ -onOffSwitchSwitchDimensions[0] / 2, -onOffSwitchSwitchDimensions[1] / 2, -manifoldCorrection ] )\n\t\t\t\tcube( onOffSwitchSwitchDimensions + manifoldCorrectionVect * 2);\n\t\t\ttranslate( [ -onOffSwitchDimensions[0] / 2, -onOffSwitchDimensions[1] / 2, onOffSwitchSwitchDimensions[2] ] )\n\t\t\t\tcube( onOffSwitchDimensions + manifoldCorrectionVect * 2);\n\t\t\ttranslate( [-onOffSwitchRetainerDimensions[0] / 2, -onOffSwitchRetainerDimensions[1] / 2, onOffSwitchDimensions[2] + onOffSwitchSwitchDimensions[2]] )\n\t\t\t\tcube( onOffSwitchRetainerDimensions + manifoldCorrectionVect * 2 );\n\t\t\ttranslate( [ -onOffSwitchFlangeDimensions[0] / 2, -onOffSwitchFlangeDimensions[1] / 2, onOffSwitchSwitchDimensions[2] ] )\n\t\t\t\tcube( onOffSwitchFlangeDimensions );\n\t\t}\n\t}\n}\nmodule resistor()\n{\n\trotate( [-90, 0, 0] )\n\t\tcylinder( r = resistorDiameter / 2, h = resistorLength );\n}\nmodule tiltSwitch()\n{\n\trotate( [-90, 0, 0] )\n\t\tcylinder( r = tiltSwitchDiameter / 2, h = tiltSwitchLength );\n}\nmodule led()\n{\n\ttranslate( [ 0, -manifoldCorrection, 0 ] )\n\t{\n\t\trotate( [-90, 0, 0] )\n\t\t{\n\t\t\tcylinder( r = ledDiameter / 2, h = ledHoleLength );\n\t\t\ttranslate( [ 0, 0, ledHoleLength - manifoldCorrection] )\n\t\t\t\tcylinder( r = ledLipDiameter / 2, h = ledLipThickness );\n\t\t\ttranslate( [ 0, 0, ledHoleLength + ledLipThickness - manifoldCorrection * 2] )\n\t\t\t\tcylinder( r = ledDiameter / 2, h = ledRetainerLength );\n\t\t}\n\t}\n}\nmodule buzzer()\n{\n\trotate( [-90, 0, 0] )\n\t{\n\t\ttranslate( [0, 0, -manifoldCorrection] )\n\t\t\tcylinder( r = buzzerLipDiameter / 2, h = buzzerLipLength + manifoldCorrection );\n\t\ttranslate( [ 0, 0, buzzerLipLength - manifoldCorrection ] )\n\t\t\tcylinder( r = buzzerDiameter / 2, h = buzzerLength - buzzerLipLength );\n\t\ttranslate( [ 0, 0, buzzerLength - manifoldCorrection * 2 ] )\n\t\t\tcylinder( r = buzzerRetainerDiameter / 2, h = buzzerRetainerLength) ;\n\t}\n}\nmodule battery()\n{\n\trotate( [-90, 0, 0] )\n\t{\n\t\tbatteryPositiveTerminal();\n\t\ttranslate( [0, 0, batteryPositiveTerminalThickness] )\n\t\t\tcylinder( r = batteryDiameter / 2, h = batteryPositiveLength + 2 * manifoldCorrection);\n\t\ttranslate( [ 0, 0, batteryPositiveLength + batteryPositiveTerminalThickness - manifoldCorrection ] )\n\t\t\tcylinder( r = batteryDiameter / 2, h = (batteryLength) + 2 * manifoldCorrection );\n\t\ttranslate( [ 0, 0, batteryPositiveLength + batteryPositiveTerminalThickness + batteryLength - manifoldCorrection ] )\n\t\t\tcylinder( r = batterySpringRetainerDiameter / 2, h = batterySpringRetainerLength + 2 * manifoldCorrection);\n\t}\n}\nmodule batteryPositiveTerminal()\n{\n\t$fn = 6;\n\tcylinder( r = batteryPositiveTerminalDiameter / 2, h = batteryPositiveTerminalThickness + 2 * manifoldCorrection );\n}",
    "description": "Okay, I'm looking for help designing a device for ice fishing, something that will alert me when a tip-up flag goes off. I've got a basic design in mind, but I need it to be parametric in OpenSCAD so I can easily adjust it for different components and tip-up sizes.\n\nHere's the basic idea: It's a small enclosure that attaches to the tip-up's rod. Inside the enclosure, there's a buzzer, an LED, an on/off switch, a tilt switch (mercury switch), a resistor, and a battery. When the tip-up flag is triggered, the device tilts, activating the tilt switch, which then triggers the buzzer and LED. It needs to be loud enough to hear during the day and bright enough to see at night.\n\nHere are the specific components I'm working with, with some dimensions:\n\n**Buzzer:**\n*   Diameter: 17.5mm\n*   Lip Diameter: 14.5mm\n*   Lip Length: 2mm\n*   Total Length (including lip): 14.5mm\n*   Retainer Diameter: 13.5mm\n*   Retainer Length: 10mm\n\n**LED:**\n*   Diameter: 5.75mm\n*   Lip Diameter: 7.5mm\n*   Lip Thickness: 1.4mm\n*   Hole Length (depth for LED): 1.5mm\n*   Retainer Length: 2.0mm\n\n**Resistor (1/4W):**\n*   Diameter: 3.5mm\n*   Length: 15mm\n\n**Tilt Switch:**\n*   Diameter: 6mm\n*   Length: 24mm\n\n**On/Off Switch:**\n*   Dimensions (body): 6mm x 12mm x 8mm\n*   Switch Dimensions (the moving part): 3mm x 6mm x 1.0mm\n*   Retainer Dimensions: 6mm x 8mm x 2mm\n*   Flange Dimensions: 5mm x 20mm x 1mm\n\n**Battery (A23):**\n*   Diameter: 10.35mm\n*   Length: 27mm + 1mm (variance) + 2mm (spring) = 30mm total\n*   Positive Terminal Diameter: 5.5mm\n*   Positive Terminal Length: 1mm\n*   Positive Terminal Base Diameter: 8.25mm\n*   Positive Terminal Base Thickness: 3.25mm\n*   Spring Retainer Length: 6mm\n*   Spring Retainer Diameter: 6mm\n\nI need the OpenSCAD design to include:\n\n*   **Enclosure:** A box that holds all these components. The dimensions should be derived from the components themselves, with a small border around them, maybe 1mm. It needs to have two parts, a left side and a right side that fit together.\n*  **Rod Attachment:**  A part to attach the enclosure to the fishing rod, using cable ties (zip ties). The rod diameter needs to be parametric, as does the cable tie width and height.\n*   **Retainer Clips:** Clips to hold the left and right enclosure parts together\n*  **Channels for wiring:**  A means of routing the wiring between components inside the enclosure.\n*   **Parametric dimensions:**  All dimensions of the components, enclosure, cable tie slot, and rod attachment need to be parametric and easily adjustable.\n*   **Preview Option:**  I'd like a way to select different \"parts\" to display. Options would be the assembled device, just the left side of the enclosure, just the right side of the enclosure, just the rod attachment, and just the retainer clips. A preview view of the assembled device will be useful too.\n\nI'd like the code to make use of the `utils/build_plate.scad` library to display a visual build plate for size reference. I'd like to have the option to select some pre-defined build plates or input them manually.\n\nFinally, I'd like the final design to be centered in the OpenSCAD platform, and able to show a preview using a south facing view with a top diagonal tilt. I'd also like for the model to be easily exported for 3D printing.\n\nCan you generate the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Spoked Wheel Too",
    "scad": "$fn = 40;\nOuterRadius = 25;\nInnerRadius = 22;\nRimThickness = 4;\nHubRadius =8;\nHubThickness =4;\nAxleRadius = 1;\nSpokeRadius = 1.2;\nSpokeAngel =0;\nSpokeTenonHeight = 3;\nSpokeTenonWidth =2;\nSpokeStyle = 3;\nWheelType = 0;\nAxle = 1;\nSpokeNumber = 14;\nAngeledRim =0;\nSqrRound = .3;\nif (WheelType == 0 ) {\n\tWheel();\n\t}\nif (WheelType == 1 ) {\n\t HalfWheel();\n\t}\nif (WheelType == 2 ) {\n\t SplitWheel();\n\t}\nmodule Rim(){\n\tif ( AngeledRim == 1)\t{\n\t\ttranslate ([0 ,0,-RimThickness /2])\n\t\trotate_extrude($fn=100)\n\t\ttranslate ([HubRadius ,0,0])\n\t\trotate ([0,0, SpokeAngel])\n\t\ttranslate ([InnerRadius - HubRadius ,0,0])\n\t\t\tsquare([OuterRadius - InnerRadius,RimThickness]);\n\t\t} else {\n\t\ttranslate ([0,0,(InnerRadius - HubRadius) * sin(SpokeAngel)])\n\t\ttranslate ([0 ,0,-RimThickness /2])\n\t\trotate_extrude($fn=100)\n\t\ttranslate ([HubRadius ,0,0])\n\t\ttranslate ([InnerRadius - HubRadius ,0,0])\n\t\t\tsquare([OuterRadius - InnerRadius,RimThickness]);\n\t\t}\n}\nmodule Hub(HubR,HubW,AxleDesired,AxleR){\n\tdifference(){\n\t\ttranslate([0,0,-HubW/2])\n\t\t\tcylinder(HubW,HubR,HubR);\n\t\tif(AxleDesired==1){translate([0,0,-HubW/2 -0.5]) cylinder(HubW + 1,AxleR,AxleR);}\n\t}\n}\nmodule Spokes(AxleR,RimR,SpokeN,SpokeR){\necho( sin(SpokeAngel));\nfor(i=[0:SpokeN-1]){\n\t\trotate([i*360/SpokeN,90 ,0])\n\t\tif (SpokeStyle == 1) {\n\t\t\ttranslate([0,0, HubRadius - ((SpokeR/2) * sin(SpokeAngel) )])\n\t\t\trotate ([0,-SpokeAngel,0])\n\t\t\tcylinder (h =  (  InnerRadius + ( (SpokeTenonHeight  ) * sin(SpokeAngel)) - HubRadius) ,r1 =SpokeR,r2=SpokeR);\n\t\t} else { if (SpokeStyle == 2) {\n\t\t\ttranslate([0,0, HubRadius - ((SpokeR/2) * sin(SpokeAngel) )])\n\t\t\trotate ([0,-SpokeAngel,0])\n\t\t\ttranslate ([ - SpokeTenonHeight/2 / cos(SpokeAngel),-SpokeTenonWidth/2,0])\n\t\t\tcube ([ SpokeTenonHeight,\n\t\t\t\t\tSpokeTenonWidth,\n\t\t\t\t\t( InnerRadius + ( (SpokeTenonHeight  ) * sin(SpokeAngel)) - HubRadius) ]);\n\t\t} else { if (SpokeStyle == 3) {\n\t\t\ttranslate([0,0, HubRadius -1 - ((SpokeTenonHeight / 2 ) * sin(SpokeAngel) )])\n\t\t\trotate ([0,-SpokeAngel,0])\n\t\t\thull () {\n\t\t\t\thull () {\n \t\t\t\ttranslate ([ - SpokeTenonHeight/2 ,-SpokeTenonWidth/2,0])\n\t\t\t\t\t\tcube ([SpokeTenonHeight ,\n\t\t\t\t\t\t\tSpokeTenonWidth,\n\t\t\t\t\t\t\t.1 + SpokeTenonHeight / 2 * ( sin(SpokeAngel)) ]);\n\t\t\t\ttranslate ([0,0,( RimR / cos(SpokeAngel)  - AxleR ) * SqrRound])\n\t\t\t\thull (){\n\t\t\t\t\ttranslate ([-(SpokeTenonHeight /2 - SpokeR  ),0,0])cylinder (h=.1,r=SpokeR);\n\t\t\t\t\ttranslate ([(SpokeTenonHeight /2 - SpokeR  ),0,0])cylinder (h=.1,r=SpokeR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( AngeledRim == 1)\t{\n\t\t\t\t\ttranslate ([0,0,( InnerRadius + ( (SpokeTenonHeight  ) * sin(SpokeAngel)) - HubRadius )])\n\t\t\t\t\t\tcylinder (h=.1,r=SpokeR);\n\t\t\t\t} else {\n\t\t\t\t\ttranslate ([0,0,( (InnerRadius  / cos(SpokeAngel)) + ( (SpokeRadius * 2  ) * sin(SpokeAngel)) - HubRadius + 1 )])\n\t\t\t\t\t\tcylinder (h=.1,r=SpokeR);\n\t\t\t\t}\n\t\t\t}\n\t\t}}}\n\t}\n}\nmodule Wheel() {\nunion(){\ncolor (\"blue\") Hub(HubRadius,HubThickness,Axle,AxleRadius);\ncolor (\"red\") Rim(RimThickness,OuterRadius,InnerRadius);\nSpokes(AxleRadius,InnerRadius,SpokeNumber,SpokeRadius);\n}\n}\nmodule HalfWheel() {\ndifference () {\n\tunion(){\n\t\tWheel();\n\t\t}\n\t\ttranslate ([-(1 + OuterRadius * 2) /2, -(1 + OuterRadius * 2)/2 ,  -(1 + OuterRadius * 2) ])\n\t\tcube ( [1 + OuterRadius * 2, 1 + OuterRadius * 2, 1 + OuterRadius * 2 ]);\n\t}\n}\nmodule SplitWheel() {\ndifference () {\n\tunion(){\n\t\tWheel();\n\t\t}\n\tif (SpokeStyle == 1) \t{\n\t\ttranslate ([0, 0 ,  - SpokeRadius ])\n\t\ttranslate ([-(1 + OuterRadius * 2) /2, -(1 + OuterRadius * 2)/2 ,  -(1 + OuterRadius * 2) ])\n\t\tcube ( [1 + OuterRadius * 2, 1 + OuterRadius * 2, 1 + OuterRadius * 2 ]);\n\t} else { if (SpokeStyle == 2) {\n\t\t\ttranslate ([0, 0 ,  - SpokeTenonHeight /2 ])\n\t\t\ttranslate ([-(1 + OuterRadius * 2) /2, -(1 + OuterRadius * 2)/2 ,  -(1 + OuterRadius * 2) ])\n\t\t\tcube ( [1 + OuterRadius * 2, 1 + OuterRadius * 2, 1 + OuterRadius * 2 ]);\n\t\t\t}\n\t} \tif (SpokeStyle == 3) \t{\n\t\ttranslate ([0, 0 ,  - SpokeRadius ])\n\t\ttranslate ([-(1 + OuterRadius * 2) /2, -(1 + OuterRadius * 2)/2 ,  -(1 + OuterRadius * 2) ])\n\t\tcube ( [1 + OuterRadius * 2, 1 + OuterRadius * 2, 1 + OuterRadius * 2 ]);\n\t}\n\t}\n}",
    "description": "Okay, I'm trying to design some wagon wheels for a project, and I've been playing around with an existing OpenSCAD script that was originally based on Cathal Garvey's parametric spoked wheel. I've modified it quite a bit to get different looks.  I'm hoping you can help me expand on this and make the design even more flexible and robust.\n\nHere's what I'm looking for in a parametric wheel generator:\n\n**Core Functionality**\n\n*   **Wheel Dimensions:** I need to be able to control the following:\n    *   `OuterRadius`: The overall radius of the wheel.\n    *   `InnerRadius`: The radius of the inner edge of the rim.\n    *   `RimThickness`: The thickness of the wheel rim.\n    *   `HubRadius`: The radius of the central hub.\n    *   `HubThickness`: The thickness of the hub.\n*   **Axle Hole:** An option to include an axle hole, controlled by a boolean `Axle`.\n    *   `AxleRadius`:  The radius of the axle hole.\n*   **Spokes:** I need to be able to control the number and shape of the spokes.\n    *   `SpokeNumber`: The number of spokes.\n    *   `SpokeAngle`:  The angle of the spokes relative to the wheel plane (for dished wheels).\n*   **Spoke Style:**\n    *   `SpokeStyle`: An integer selector with the following options:\n        *   `1`: Round spokes, using `SpokeRadius`.\n        *   `2`: Square spokes, using `SpokeTenonHeight` and `SpokeTenonWidth`.\n        *   `3`: Spokes that transition from square (near the hub) to round (near the rim), using `SpokeTenonHeight`, `SpokeTenonWidth`, `SpokeRadius` and `SqrRound`.\n\t*   `SpokeRadius`: The radius of round spokes.\n    *   `SpokeTenonHeight`: Height of the square tenon on the spoke.\n    *   `SpokeTenonWidth`: Width of the square tenon on the spoke.\n\t*   `SqrRound`: A value between 0 and 1. A value closer to 0 makes the square part of the square-to-round spoke shorter, a value closer to 1, makes the round part of the square-to-round spoke shorter.\n*   **Wheel Type**:\n\t*   `WheelType`: An integer selector with the following options:\n\t\t*   `0`: A full wheel.\n\t\t*   `1`: A half wheel (useful for printing two halves and joining them). This type would be sliced along the Y axis.\n\t\t*   `2`: A split wheel. The wheel is split at its base, creating a flat surface for printing without supports. This would be sliced along the Z axis.\n\t\t* Note: Wheel Types 1 and 2 should _not_ work with angled spokes ( `SpokeAngle` not equal to `0`).\n\n*   **Angled Rim:** An option to make the rim angled to match the `SpokeAngle`, controlled by the boolean `AngeledRim`. This would ideally keep the inner wheel surface perpendicular to the spokes, but with `AngeledRim = 0` then the rim's faces will be parallel to the Z axis.\n\n**Improvements and additions I'd like to see:**\n\n1.  **More robust angled spoke and angled rim handling:**  Currently, I'm seeing some issues with angled spokes and my `WheelType` selections. I'd really appreciate it if you could make that work correctly (especially the SplitWheel and HalfWheel types).\n2.  **Better parameterization of the square-to-round spoke transition:** The `SqrRound` variable is ok, but it feels a little arbitrary. I'd like a more intuitive way to control how much of the spoke is square versus round.\n3. **Hub shape options:** Currently the hub is just a simple cylinder. I'd like the option to add some decorative shapes and to control the radius of different parts of a hub profile.\n4. **Rim profile options:** Similarly I would like to have options for how the rim is shaped including the use of a profile to create more complex shapes (eg semi circles) and also to change the profile of the edge of the rim and use a chamfer.\n5. **Ability to add patterns to the spokes or rim:** It would be great to add simple shapes to the spokes or the rim. For example a triangle or circle pattern on the spokes. It would be great if the pattern could be parameterized.\n\n**General Requirements**\n\n*   Use `$fn` for circle/curve resolution.\n*   Make the code as clear and modular as possible. I think the use of named modules will help make it more understandable, and easier to modify and reuse in other projects.\n*   I'm not using any external libraries, so the code should be self-contained.\n* Please make use of descriptive variable names.\n\nI'm primarily focused on the functionality described above, so please prioritize those core requirements.\n\nThank you!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Modular Blocks",
    "scad": "use <utils/build_plate.scad>\n1_type = \"4 Way Connector\";\n2_square_size = 50;\n3_wall_thickness = 2;\n4_depth = 50;\n5_back_wall = \"no\";\n6_bevel = \"yes\";\n7_connector_clearance = .25;\ntype =1_type;\nsquare_size =2_square_size;\nwall_thickness = 3_wall_thickness;\ndepth = 4_depth;\nback_wall = 5_back_wall;\nbevel = 6_bevel;\nconnector_clearance = 7_connector_clearance;\ngrid_size = square_size;\nCC = connector_clearance;\noff = wall_thickness/grid_size;\nbackWallOffset = back_wall == \"yes\" ? 1 : -1;\nshape = type;\ngrid_pattern = bevel;\ndif = connector_clearance/grid_size/4;\nadif = dif*1.70710678118;\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nmakeShape(shape);\nmodule makeShape(shape){\n\tcolor(\"Blue\")\n\tdifference(){\n\t\tdifference(){\n\t\t\tlinear_extrude(height=depth, convexity = 10)\n\t\t\tscale([grid_size,grid_size,1])\n\t\t\tif (shape == \"1 Way Connector B\") square1B();\n\t\t\telse if (shape == \"1 Way Connector A\") square1A();\n\t\t\telse if (shape == \"2 Way Connector D\") square2D();\n\t\t\telse if (shape == \"2 Way Connector C\") square2C();\n\t\t\telse if (shape == \"2 Way Connector B\") square2B();\n\t\t\telse if (shape == \"2 Way Connector A\") square2A();\n\t\t\telse if (shape == \"3 Way Connector B\") square3B();\n\t\t\telse if (shape == \"3 Way Connector A\") square3A();\n\t\t\telse if (shape == \"4 Way Connector\") square();\n\t\t\telse if (shape == \"No Connectors\") square0();\n\t\t\tcuttingGrid();\n\t\t}\n\t\tdifference(){\n\t\t\ttranslate([0,0,backWallOffset*wall_thickness])\n\t\t\tlinear_extrude(height=depth*2, convexity = 10)\n\t\t\tscale([grid_size,grid_size,1])\n\t\t\tif (shape == \"1 Way Connector B\") offSquare1B();\n\t\t\telse if (shape == \"1 Way Connector A\") offSquare1A();\n\t\t\telse if (shape == \"2 Way Connector D\") offSquare2D();\n\t\t\telse if (shape == \"2 Way Connector C\") offSquare2C();\n\t\t\telse if (shape == \"2 Way Connector B\") offSquare2B();\n\t\t\telse if (shape == \"2 Way Connector A\") offSquare2A();\n\t\t\telse if (shape == \"3 Way Connector B\") offSquare3B();\n\t\t\telse if (shape == \"3 Way Connector A\") offSquare3A();\n\t\t\telse if (shape == \"4 Way Connector\") offSquare();\n\t\t\telse if (shape == \"No Connectors\") offSquare0();\n\t\t\tif (grid_pattern == \"yes\"){\n\t\t\t\ttranslate([0,0,wall_thickness])\n\t\t\t\tcuttingGrid();\n\t\t\t}\n\t\t}\n\t\tif (grid_pattern == \"yes\") cuttingGrid();\n\t}\n}\nmodule cuttingGrid(){\n\trotate([0,0,90])\n\trotate([90,0,0])\n\ttranslate([0,0,-grid_size*1.05])\n\tlinear_extrude(height=grid_size*2.1, convexity = 10)\n\tscale([grid_size,grid_size,1])\n\tpolygon(points = [ [-1,-1],[-1,.65],[0,-.35],[1,.65],[1,-1]],paths = [[0,1,2,3,4]]);\n\trotate([90,0,0])\n\ttranslate([0,0,-grid_size*1.05])\n\tlinear_extrude(height=grid_size*2.1, convexity = 10)\n\tscale([grid_size,grid_size,1])\n\tpolygon(points = [ [-1,-1],[-1,.65],[0,-.35],[1,.65],[1,-1]],paths = [[0,1,2,3,4]]);\n}\nmodule square0() {\n\tpolygon(points = [ [-.5,-.5],\n\t\t\t\t\t\t[.5,-.5],\n\t\t\t\t\t\t[.5,.5],\n\t\t\t\t\t\t[-.5,.5]],paths = [[0,1,2,3]]);\n}\nmodule offSquare0() {\n\tpolygon(points = [ [-.5+off,-.5+off],\n\t\t\t\t\t\t[.5-off,-.5+off],\n\t\t\t\t\t\t[.5-off,.5-off],\n\t\t\t\t\t\t[-.5+off,.5-off]],paths = [[0,1,2,3]]);\n}\nmodule square1B() {\n\tpolygon(points = [ [-.5,-.5],[-.1-dif,-.5],[-.2-adif,-.4+dif],[.2+adif,-.4+dif],[.1+dif,-.5],\n\t\t\t\t\t\t[.5,-.5],\n\t\t\t\t\t\t[.5,.5],\n\t\t\t\t\t\t[-.5,.5]],paths = [[0,1,2,3,4,5,6,7]]);\n}\nmodule offSquare1B() {\n\tpolygon(points = [ [-.5+off,-.4+off],\n\t\t\t\t\t\t[.5-off,-.4+off],\n\t\t\t\t\t\t[.5-off,.5-off],\n\t\t\t\t\t\t[-.5+off,.5-off]],paths = [[0,1,2,3]]);\n}\nmodule square1A() {\n\tpolygon(points = [ [-.5,-.5],\n\t\t\t\t\t\t[.5,-.5],\n\t\t\t\t\t\t[.5,.5],\n\t\t\t\t\t\t[-.5,.5],[-.5,.1-dif],[-.6+dif,.2-adif],[-.6+dif,-.2+adif],[-.5,-.1+dif]],paths = [[0,1,2,3,4,5,6,7]]);\n}\nmodule offSquare1A() {\n\tpolygon(points = [ [-.5+off,-.5+off],\n\t\t\t\t\t\t[.5-off,-.5+off],\n\t\t\t\t\t\t[.5-off,.5-off],\n\t\t\t\t\t\t[-.5+off,.5-off]],paths = [[0,1,2,3]]);\n}\nmodule square2D() {\n\tpolygon(points = [ [-.5,-.5],[-.1-dif,-.5],[-.2-adif,-.4+dif],[.2+adif,-.4+dif],[.1+dif,-.5],\n\t\t\t\t\t\t[.5,-.5],\n\t\t\t\t\t\t[.5,.5],\n\t\t\t\t\t\t[-.5,.5],[-.5,.1-dif],[-.6+dif,.2-adif],[-.6+dif,-.2+adif],[-.5,-.1+dif]],paths = [[0,1,2,3,4,5,6,7,8,9,10,11]]);\n}\nmodule offSquare2D() {\n\tpolygon(points = [ [-.5+off,-.4+off],\n\t\t\t\t\t\t[.5-off,-.4+off],\n\t\t\t\t\t\t[.5-off,.5-off],\n\t\t\t\t\t\t[-.5+off,.5-off]],paths = [[0,1,2,3]]);\n}\nmodule square2C() {\n\tpolygon(points = [ [-.5,-.5],[-.1-dif,-.5],[-.2-adif,-.4+dif],[.2+adif,-.4+dif],[.1+dif,-.5],\n\t\t\t\t\t\t[.5,-.5],\n\t\t\t\t\t\t[.5,.5],[.1+dif,.5],[.2+adif,.4-dif],[-.2-adif,.4-dif],[-.1-dif,.5],\n\t\t\t\t\t\t[-.5,.5]],paths = [[0,1,2,3,4,5,6,7,8,9,10,11]]);\n}\nmodule offSquare2C() {\n\tpolygon(points = [ [-.5+off,-.4+off],\n\t\t\t\t\t\t[.5-off,-.4+off],\n\t\t\t\t\t\t[.5-off,.4-off],\n\t\t\t\t\t\t[-.5+off,.4-off]],paths = [[0,1,2,3]]);\n}\nmodule square2B() {\n\tpolygon(points = [ [-.5,-.5],\n\t\t\t\t\t\t[.5,-.5],[.5,-.1+dif],[.6-dif,-.2+adif],[.6-dif,.2-adif],[.5,.1-dif],\n\t\t\t\t\t\t[.5,.5],\n\t\t\t\t\t\t[-.5,.5],[-.5,.1-dif],[-.6+dif,.2-adif],[-.6+dif,-.2+adif],[-.5,-.1+dif]],paths = [[0,1,2,3,4,5,6,7,8,9,10,11]]);\n}\nmodule offSquare2B() {\n\tpolygon(points = [ [-.5+off,-.5+off],\n\t\t\t\t\t\t[.5-off,-.5+off],\n\t\t\t\t\t\t[.5-off,.5-off],\n\t\t\t\t\t\t[-.5+off,.5-off]],paths = [[0,1,2,3]]);\n}\nmodule square2A() {\n\tpolygon(points = [ [-.5,-.5],\n\t\t\t\t\t\t[.5,-.5],\n\t\t\t\t\t\t[.5,.5],[.1+dif,.5],[.2+adif,.4-dif],[-.2-adif,.4-dif],[-.1-dif,.5],\n\t\t\t\t\t\t[-.5,.5],[-.5,.1-dif],[-.6+dif,.2-adif],[-.6+dif,-.2+adif],[-.5,-.1+dif]],paths = [[0,1,2,3,4,5,6,7,8,9,10,11]]);\n}\nmodule offSquare2A() {\n\tpolygon(points = [ [-.5+off,-.5+off],\n\t\t\t\t\t\t[.5-off,-.5+off],\n\t\t\t\t\t\t[.5-off,.4-off],\n\t\t\t\t\t\t[-.5+off,.4-off]],paths = [[0,1,2,3]]);\n}\nmodule square3B() {\n\tpolygon(points = [ [-.5,-.5],[-.1-dif,-.5],[-.2-adif,-.4+dif],[.2+adif,-.4+dif],[.1+dif,-.5],\n\t\t\t\t\t\t[.5,-.5],\n\t\t\t\t\t\t[.5,.5],[.1+dif,.5],[.2+adif,.4-dif],[-.2-adif,.4-dif],[-.1-dif,.5],\n\t\t\t\t\t\t[-.5,.5],[-.5,.1-dif],[-.6+dif,.2-adif],[-.6+dif,-.2+adif],[-.5,-.1+dif]],paths = [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]]);\n}\nmodule offSquare3B() {\n\tpolygon(points = [ [-.5+off,-.4+off],\n\t\t\t\t\t\t[.5-off,-.4+off],\n\t\t\t\t\t\t[.5-off,.4-off],\n\t\t\t\t\t\t[-.5+off,.4-off]],paths = [[0,1,2,3]]);\n}\nmodule square3A() {\n\tpolygon(points = [ [-.5,-.5],\n\t\t\t\t\t\t[.5,-.5],[.5,-.1+dif],[.6-dif,-.2+adif],[.6-dif,.2-adif],[.5,.1-dif],\n\t\t\t\t\t\t[.5,.5],[.1+dif,.5],[.2+adif,.4-dif],[-.2-adif,.4-dif],[-.1-dif,.5],\n\t\t\t\t\t\t[-.5,.5],[-.5,.1-dif],[-.6+dif,.2-adif],[-.6+dif,-.2+adif],[-.5,-.1+dif]],paths = [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]]);\n}\nmodule offSquare3A() {\n\tpolygon(points = [ [-.5+off,-.5+off],\n\t\t\t\t\t\t[.5-off,-.5+off],\n\t\t\t\t\t\t[.5-off,.4-off],\n\t\t\t\t\t\t[-.5+off,.4-off]],paths = [[0,1,2,3]]);\n}\nmodule square() {\n\tpolygon(points = [ [-.5,-.5],[-.1-dif,-.5],[-.2-adif,-.4+dif],[.2+adif,-.4+dif],[.1+dif,-.5],\n\t\t\t\t\t\t[.5,-.5],[.5,-.1+dif],[.6-dif,-.2+adif],[.6-dif,.2-adif],[.5,.1-dif],\n\t\t\t\t\t\t[.5,.5],[.1+dif,.5],[.2+adif,.4-dif],[-.2-adif,.4-dif],[-.1-dif,.5],\n\t\t\t\t\t\t[-.5,.5],[-.5,.1-dif],[-.6+dif,.2-adif],[-.6+dif,-.2+adif],[-.5,-.1+dif]],paths = [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]]);\n}\nmodule offSquare() {\n\tpolygon(points = [ [-.5+off,-.4+off],\n\t\t\t\t\t\t[.5-off,-.4+off],\n\t\t\t\t\t\t[.5-off,.4-off],\n\t\t\t\t\t\t[-.5+off,.4-off]],paths = [[0,1,2,3]]);\n}\nmodule backSquare() {\n\tpolygon(points = [ [-.5,-.5],[.5,-.5],[.5,.5],[-.5,.5]],paths = [[0,1,2,3]]);\n}",
    "description": "Okay, I'd like to design a modular block system for 3D printing, and I'm thinking of using OpenSCAD. I want to be able to print individual blocks that can connect together with dovetail joints, so I can build shelves or other structures. I've already got the basic idea of how the connections should work, but I need a flexible parametric design.\n\nHere's what I envision:\n\n*   **Block Types:** I need to be able to choose from a variety of block types, controlling which sides have dovetail connectors:\n    *   \"4 Way Connector\": Connectors on all four sides.\n    *   \"3 Way Connector A\": Connectors on three sides (e.g., top, left, and right).\n    *   \"3 Way Connector B\": Connectors on three different sides (e.g., bottom, left, and right).\n    *   \"2 Way Connector A\": Connectors on two opposite sides (e.g., left and right).\n    *   \"2 Way Connector B\": Connectors on two adjacent sides (e.g., top and left).\n\t*   \"2 Way Connector C\": Connectors on two adjacent sides (e.g., bottom and left).\n\t*    \"2 Way Connector D\": Connectors on two adjacent sides (e.g., bottom and right).\n    *   \"1 Way Connector A\": Connector on one side (e.g., left).\n\t*   \"1 Way Connector B\": Connector on one side (e.g., top)\n    *   \"No Connectors\": No connectors on any side.\n*   **Parameters:** I need to be able to customize these aspects of the block:\n    *   `square_size`:  The length of a side of the main square block (in mm).\n    *   `wall_thickness`: The thickness of the block's walls (in mm). This will be constant regardless of which sides have connectors.\n    *   `depth`: The depth of the block (in mm).\n    *   `back_wall`: A boolean option for whether or not the block has a back wall (\"yes\" or \"no\").\n    *   `bevel`: A boolean option for whether or not the back of the block has a bevel (\"yes\" or \"no\"). The dovetail connectors should also have a bevel on the back, regardless of the back_wall setting.\n    *   `connector_clearance`: The clearance between the connectors of adjacent blocks. Increasing this will make the connection looser; decreasing it will make the connection tighter.\n\n*   **Dovetail Connectors:** The connectors should be dovetailed. The female side should be created by subtracting from a base block shape, and the male side should be created by also subtracting from a slightly larger block shape.\n*   **Printability:** The maximum overhang of the dovetail should be 45 degrees so the blocks can be printed without support.\n*   **Visual Aids:** Include a build plate visual using the `build_plate` module from the `utils` library to help see the blocks in the context of a print bed. I'll handle adding that library to my project separately, don't include it in the main response. I'll also want to see the default output in a southeast view and a top tilt.\n\nCould you write an OpenSCAD file that implements all of this? I think I've covered all of my requirements for now. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable food roller",
    "scad": "wide_noodle_teeth=1;\nnarrow_noodle_teeth=1;\ntranslate ([-25,70,40]) rotate ([90,18.3,0])\nunion () {union () {\ndifference (){cylinder (140,40,40);translate ([0,0,-1])cylinder (162,20,20);}\nscale ([wide_noodle_teeth,wide_noodle_teeth,1]) difference (){cylinder (4,40,40);translate ([0,0,-1])cylinder (162,30,30);}\nscale ([wide_noodle_teeth,wide_noodle_teeth,1]) translate ([0,0,40])difference (){cylinder (2,40,40);translate ([0,0,-1])cylinder (162,30,30);}\nscale ([wide_noodle_teeth,wide_noodle_teeth,1]) translate ([0,0,60])difference (){cylinder (2,40,40);translate ([0,0,-1])cylinder (162,30,30);}\nscale ([wide_noodle_teeth,wide_noodle_teeth,1]) translate ([0,0,80])difference (){cylinder (2,40,40);translate ([0,0,-1])cylinder (162,30,30);}\nscale ([wide_noodle_teeth,wide_noodle_teeth,1]) translate ([0,0,100])difference (){cylinder (2,40,40);translate ([0,0,-1])cylinder (162,30,30);}\nscale ([wide_noodle_teeth,wide_noodle_teeth,1]) translate ([0,0,120])difference (){cylinder (2,40,40);translate ([0,0,-1])cylinder (162,30,30);}\nscale ([wide_noodle_teeth,wide_noodle_teeth,1]) translate ([0,0,136])difference (){cylinder (4,40,40);translate ([0,0,-1])cylinder (162,30,30);}\nscale ([wide_noodle_teeth,wide_noodle_teeth,1]) translate ([0,0,20])difference (){cylinder (2,40,40);translate ([0,0,-1])cylinder (162,30,30);}\nscale ([narrow_noodle_teeth,narrow_noodle_teeth,1]) translate ([0,0,10])difference (){cylinder (2,40,40);translate ([0,0,-1])cylinder (162,30,30);}\nscale ([narrow_noodle_teeth,narrow_noodle_teeth,1]) translate ([0,0,30])difference (){cylinder (2,40,40);translate ([0,0,-1])cylinder (162,30,30);}\nscale ([narrow_noodle_teeth,narrow_noodle_teeth,1]) translate ([0,0,50])difference (){cylinder (2,40,40);translate ([0,0,-1])cylinder (162,30,30);}\nscale ([narrow_noodle_teeth,narrow_noodle_teeth,1]) translate ([0,0,70])difference (){cylinder (2,40,40);translate ([0,0,-1])cylinder (162,30,30);}\nscale ([narrow_noodle_teeth,narrow_noodle_teeth,1]) translate ([0,0,90])difference (){cylinder (2,40,40);translate ([0,0,-1])cylinder (162,30,30);}\nscale ([narrow_noodle_teeth,narrow_noodle_teeth,1]) translate ([0,0,110])difference (){cylinder (2,40,40);translate ([0,0,-1])cylinder (162,30,30);}\nscale ([narrow_noodle_teeth,narrow_noodle_teeth,1]) translate ([0,0,133])difference (){cylinder (4,40,40);translate ([0,0,-1])cylinder (162,30,30);}\ntranslate ([0,0,-15]) cylinder (170,18,18);\ntranslate ([0,0,-15]) sphere(18);\ntranslate ([0,0,155]) sphere(18);\nrotate ([0,0,60]) union (){translate ([0,-7.5,-15]) cube ([70,15,10]);\ntranslate ([70,0,-15]) cylinder (30,18,18);\ntranslate ([70,0,-15]) sphere(18);\ntranslate ([70,0,15]) sphere(18);}\ntranslate ([0,-7.5,150]) cube ([70,15,10]);\ntranslate ([70,0,120]) cylinder (30,18,18);\ntranslate ([70,0,150]) sphere(18);\ntranslate ([70,0,120]) sphere(18);\n}\n}",
    "description": "Okay, I'm looking to create a parametric noodle roller/cutter in OpenSCAD. I have a basic design in mind that I've been working on, and I'd like to make it more flexible using parameters.\n\nThe core idea is a central cylinder that acts as the base, similar to a rolling pin. On this cylinder, I want to be able to add cutting teeth for noodles. There should be two types of teeth: wider ones for thick noodles and narrower ones for thinner noodles. Importantly, I want to be able to independently control whether the wide teeth and narrow teeth are included, and how many of each there are.\n\nHere are the specific features and parameters I want to control:\n\n*   **Roller Diameter:** The diameter of the central cylindrical base.\n*   **Roller Length:** The length of the central cylindrical base.\n*   **Axle Diameter:** The diameter of the axle that runs through the roller.\n*   **Axle Length:** The length of the axle.\n*   **Handle Diameter:** The diameter of the cylindrical portion of the handle, where it attaches to the axle.\n*   **Handle Length:** The length of the handle, before the sphere at its end.\n*  **Handle Offset:** The offset of the handle from the end of the roller.\n*   **Handle Sphere Diameter:** The diameter of the sphere at the end of each handle.\n*   **Wide Teeth Enabled:** A boolean parameter (true/false) to enable or disable wide teeth.\n*   **Number of Wide Teeth:**  An integer that represents the number of wide teeth. The teeth are evenly spaced along the roller. \n*   **Wide Teeth Depth:** The radial depth of the wide teeth; that is, how far inward from the central roller the inner cylinder cuts.\n*  **Wide Teeth Width:** The radial width of the wide teeth; that is, the width of the circle used to cut, if we are subtracting.\n*   **Narrow Teeth Enabled:** A boolean parameter (true/false) to enable or disable narrow teeth.\n*   **Number of Narrow Teeth:** An integer that represents the number of narrow teeth. The teeth are evenly spaced along the roller and staggered relative to the wide teeth.\n*   **Narrow Teeth Depth:** The radial depth of the narrow teeth.\n*   **Narrow Teeth Width:** The radial width of the narrow teeth.\n\nI'd like to have the handles oriented so that they would be above the roller when in normal use, with one handle at each end of the roller. For this project, I do not need the ability to adjust the angle of the handles relative to the roller.\n\nIdeally, I'd also like the generated code to be well-commented, explaining each step and the purpose of the parameters. Please include a default value for all of the parameters. I'm not looking for a complex library; just the ability to easily modify the design based on the parameters I mentioned.\n\nI'm not using any specific libraries, but if you think using one would dramatically simplify the design, let me know which one you're planning on using and why.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Coat hook, customizable",
    "scad": "thickness=25;\nwall_distance=25;\nroundness=25;\nDiameter=80;\nDiameter2=36;\nscrew_distance=20;\nscrew_hole_size=8;\n$fn=100;\ns=screw_hole_size*1.53;\nr1=Diameter/2;\ntranslate([0,0,thickness/2])\ncylinder(h=thickness,r=r1-roundness,center=true);\ntranslate([0,0,thickness/2])\nrotate_extrude(convexity=10)\ntranslate([r1-roundness,0,0])\nscale([roundness/thickness,1,1])\ncircle(thickness/2,center=true);\ndifference(){\ntranslate([0,0,thickness+wall_distance/2])\ncylinder(h=wall_distance,r=Diameter2/2,center=true);\ntranslate([-s,-screw_distance/2,thickness+wall_distance-s/4])\npolyhedron(\n\tpoints=[[s,s,0],[s,-s,0],[-s,0,0],[s,0,s/2]],\n\ttriangles=[[0,2,1],[0,1,3],[2,0,3],[1,2,3]]);\ntranslate([-s,screw_distance/2,thickness+wall_distance-s/4])\npolyhedron(\n\tpoints=[[s,s,0],[s,-s,0],[-s,0,0],[s,0,s/2]],\n\ttriangles=[[0,2,1],[0,1,3],[2,0,3],[1,2,3]]);\n}\ndifference(){\ntranslate([0,0,thickness+wall_distance/2])\ncylinder(h=wall_distance,r=Diameter2/2,center=true);\ntranslate([0,0,thickness+wall_distance/2])\ncylinder(h=wall_distance+1,r=Diameter2/2-1,center=true);}",
    "description": "Okay, I'd like a parametric OpenSCAD file for a wall-mounted hook, inspired by the Muuto Dots coat hooks but with a few specific design choices and adjustable parameters. \n\nHere's the general idea:\n\nThe hook should have a rounded, disk-like outer part connected to a cylindrical shaft that goes to the wall. The outer disk has a smooth, rounded edge, almost like a flattened doughnut. I'd like to adjust the following:\n\n*   **`thickness`**: The thickness of the outer disk part. I'm thinking a range between 10mm and 40mm.\n*   **`wall_distance`**: The distance the back of the outer disk sits from the wall.  Also, a range of 10mm to 40mm.\n*   **`roundness`**: How much the outer edge of the disk is rounded. Range from 0mm (a sharp edge) to 50mm.\n*   **`Diameter`**: The overall diameter of the outer disk. Let's make the range from 70mm to 150mm.\n*   **`Diameter2`**: The diameter of the cylindrical shaft that goes back to the wall. This should be smaller than the main diameter minus the roundness and needs to account for screws too. I'll need a minimum of 36mm and going up to 100mm.\n*  **`screw_distance`**: The distance between the center of the screw holes. I'll specify this to 20mm initially.\n* **`screw_hole_size`**: The diameter of the screw head I want to be recessed inside a hole. Let's use 8mm initially.\n*  **`$fn`**: The number of segments for circles, currently I use `$fn=100`.\n\nI want the back part of the hook to be a simple cylinder. The connection between the main disk and the cylinder should be a smooth transition.\n\nFor mounting, I need two countersunk screw holes in the back cylinder. The current design uses `polyhedron` with `points` and `triangles` and it works, but its really not elegant. It would be great if we could make the screw holes more refined, but still allow for adjustment using `screw_distance` and `screw_hole_size`. Perhaps using a more standard OpenSCAD technique for creating countersunk screw holes?\n\nIdeally, I'd like to avoid using libraries like BOSL or similar if thats reasonably possible given the requirements. If it's really necessary, please let me know why and which library you are using.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Marble Run",
    "scad": "l1=100;\nmr=6.25;\nmd=2;\nod=10;\nwithMagnets=\"no\";\npinDia=3;\npinHoleDepth=5;\npinLength=15;\nperpendicular=\"false\";\nbackAngle=60;\nplaceOnBuildPlatform=\"true\";\n$fn=100;\nmodule track(){\n\tdifference(){\n\t\trotate([0,90,0]) translate([-od,od/2,0])\n\t\tcylinder(r=od,h=l1);\n\t\trotate([backAngle,0,0]) translate([-1,-od,-od])\n\t\tcube([l1+2,od*2,od*3]);\n\t\ttranslate([-1,od+2.5,0])\n\t\tcube([l1+2,od*2,od*3]);\n\t\trotate([0,90,0]) translate([-18,4.5,-1])\n\t\tcylinder(r=7,h=l1+2);\n\t\tif(withMagnets==\"yes\" || withMagnets==\"other\"){\n\t\t\trotate([90,0,0]) translate([l1/5,mr*2,-15+md])\n\t\t\tcylinder(r=mr/2,h=md);\n\t\t\trotate([90,0,0]) translate([l1/5*2.5,mr*1.5,-15+md])\n\t\t\tcylinder(r=mr/2,h=md);\n\t\t\trotate([90,0,0]) translate([l1/5*4,mr*2,-15+md])\n\t\t\tcylinder(r=mr/2,h=md);\n\t\t}\n\t\tif(withMagnets==\"no\" || withMagnets==\"other\"){\n\t\t\tif(perpendicular==\"true\"){\n\t\t\t\trotate([90,0,0])\n\t\t\t\ttranslate([l1/5,od,-pinLength-pinHoleDepth-1])\n#\t\t\t\tcylinder(r=pinDia/2,h=pinLength);\n\t\t\t\trotate([90,0,0])\n\t\t\t\ttranslate([l1/5*4,od,-pinLength-pinHoleDepth-1])\n#\t\t\t\tcylinder(r=pinDia/2,h=pinLength);\n\t\t\t}else{\n\t\t\t\trotate([backAngle,0,0])\n\t\t\t\ttranslate([l1/5,od+pinDia,-pinLength-1])\n#\t\t\t\tcylinder(r=pinDia/2,h=pinLength);\n\t\t\t\trotate([backAngle,0,0])\n\t\t\t\ttranslate([l1/5*4,od+pinDia,-pinLength-1])\n#\t\t\t\tcylinder(r=pinDia/2,h=pinLength);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule main(){\n  if(placeOnBuildPlatform==\"true\"){\n\ttranslate([-l1/2,0,-od])\n\trotate([90-backAngle,0,0])\n\ttrack();\n  } else {\n\ttrack();\n  }\n}\nmain();",
    "description": "Okay, I'm trying to design a parametric marble run track that I can 3D print and attach to a flat surface, like a piece of plywood. I've seen a design by mattjoyce that I've modified a bit, but I'd really like something more flexible and easier to customize. \n\nHere's what I'm envisioning:\n\n**Basic Track Shape:**\n\n*   The track should be a trough, shaped like a quarter-cylinder, with flat sections on the back and bottom for mounting.\n*   I need to be able to adjust the length of the track.\n*   I want to have some control over the round edges where the track transitions into the flat areas  like how the current example uses a larger cylinder subtracted from a cube.\n*   The marble trough itself should be easily adjusted, in terms of the radius.\n\n**Mounting Options:**\n\n*   I'd like to have options for both magnets and pins for mounting. I'll be mostly using pins for attaching to non-magnetic surfaces, but maybe someday I'll use magnets on a fridge or something.\n*   **Magnets:** If using magnets, I'd need to be able to specify the magnet diameter and the depth of the magnet holes. I need to control the number and position of the holes on the back side of the track.\n*   **Pins:** For pins, I want to use lengths of filament.\n    *   The pins should be able to be either perpendicular to the flat back or angled at the same angle as the back. I need to set an angle parameter for that back and the corresponding pins.\n    *   I need to control pin diameter, pin hole depth, and pin length.\n    *   I need to control the number and position of the pin holes.\n\n**Other Considerations:**\n\n*   The ability to orient the track so that the flat back sits flush on the build plate would be great. So a boolean flag to set whether to export the part in the upright position, or flat on the build platform.\n*   I'd like to use the BOSL2 library for any helper functions you might use. I'm a bit new to some of this, so I'd be grateful if the code is commented.\n\n**Specific Parameters I'd Like to Control:**\n\n*   `trackLength`:  The overall length of the track.\n*   `troughRadius`: The radius of the marble trough itself.\n*    `edgeRadius`: Radius of the cylinder used for the round edges.\n*    `backAngle`: Angle of the back of the track, used for positioning the back flat to a surface.\n*   `magnetDiameter`: Diameter of the magnets.\n*   `magnetDepth`: Depth of the magnet holes.\n*   `numMagnets`: Number of magnets.\n*  `magnetPositions`: Position of the magnets.\n*   `pinDiameter`: Diameter of the pins (filament).\n*   `pinDepth`: Depth of the pin holes.\n*   `pinLength`: Length of the pins.\n*   `numPins`: Number of pins.\n*   `pinPositions`: Position of the pins.\n*    `pinPerpendicular`: Boolean: True for pins at 90 degrees to the back, false for pins angled at the same angle of the back.\n*   `mountType`: An enum that allows me to choose between \"magnets\", \"pins\", or \"both\".\n*    `placeOnBuildPlatform`: Boolean: True for laying the flat base on the build platform, false for oriented according to `backAngle`\n\nCould you generate an OpenSCAD file that is parametric based on these specifications?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parameterized Knob",
    "scad": "HoleDiameter = 6.275;\nHoleDepth = 25;\nHoleFlatThickness = 1.25;\nKnobHeight = 20;\nKnobDiameter = 60;\nCapType = 2;\nTimerKnob=0;\nPointer1 = 20;\nDivotDepth = 0;\nFlatSide = 2;\nDRotate = 45;\nRecessDepth = 10;\nRecessInnerRadius = 12;\nRecessOuterRadius = 20;\nPointer2 = 1;\nKnurled = 0;\nTaperPercentage = 0;\nRingWidth = 0;\nRingMarkings = 10;\nScrewHoleDiameter = 3;\nShaftLength = 15;\nShaftDiameter = 12;\nNotchedShaft = 80;\nRingThickness = 5*1;\nDivotDepth = 1.5*1;\nMarkingWidth = 1.5*1;\nDistanceBetweenKnurls = 3*1;\nTimerKnobConst = 1.8*1;\nPI=3.14159265*1;\nKnobMajorRadius = KnobDiameter/2;\nKnobMinorRadius = KnobDiameter/2 * (1 - TaperPercentage/100);\nKnobRadius = KnobMinorRadius + (KnobMajorRadius-KnobMinorRadius)/2;\nKnobCircumference = PI*KnobDiameter;\nKnurls = round(KnobCircumference/DistanceBetweenKnurls);\nDivot=CapType;\nTaperAngle=asin(KnobHeight / (sqrt(pow(KnobHeight, 2) +\n\t\tpow(KnobMajorRadius-KnobMinorRadius,2)))) - 90;\nDivotRadius = KnobMinorRadius*.3;\ndifference() {\nunion() {\n    translate([0, 0, (ShaftLength==0)? 0 : ShaftLength-0.001])\n    difference() {\n\tunion() {\n\t    cylinder(h=KnobHeight, r1=KnobMajorRadius, r2=KnobMinorRadius,\n\t\t$fn=50);\n\t    if (Knurled)\n\t    for (i=[0 : Knurls-1])\n\t    rotate([0, 0, i * (360/Knurls)])\n\t    translate([KnobRadius, 0, KnobHeight/2])\n\t    rotate([0, TaperAngle, 0]) rotate([0, 0, 45])\n\t    cube([2, 2, KnobHeight+.001], center=true);\n \t    if (RingMarkings>0)\n\t    for (i=[0 : RingMarkings-1])\n\t    rotate([0, 0, i * (360/RingMarkings)])\n\t    translate([KnobMajorRadius + RingWidth/2, 0, 1])\n\t    cube([RingWidth*.5, MarkingWidth, 2], center=true);\n\t    if (Pointer2==1)\n\t    translate([KnobRadius, 0, KnobHeight/2-2])\n\t    rotate([0, TaperAngle, 0])\n\t    cube([8, 3, KnobHeight], center=true);\n\t    if (RingWidth>0)\n\t    translate([0, 0, RingThickness/2])\n\t    cylinder(r1=KnobMajorRadius + RingWidth, r2=KnobMinorRadius,\n\t\th=RingThickness, $fn=50, center=true);\n\t    if (Divot==2)\n\t    translate([0, 0, KnobHeight])\n\t    difference()\n\t    {\n\t\tscale([1, 1, 0.5])\n\t\tsphere(r=KnobMinorRadius, $fn=50, center=true);\n\t\ttranslate([0, 0, 0-(KnobMinorRadius+.001)])\n\t\tcube([KnobMinorRadius*2.5, KnobMinorRadius*2.5,\n\t\t\tKnobMinorRadius*2], center=true);\n\t    }\n\t    if (TimerKnob==1) intersection()\n\t    {\n\t\ttranslate([0, 0, 0-(KnobDiameter*TimerKnobConst) + KnobHeight])\n\t\tsphere(r=KnobDiameter*TimerKnobConst, $fn=50, center=true);\n\t\ttranslate([0-(KnobDiameter*TimerKnobConst)*0.1, 0,\n\t\t\tKnobHeight/2])\n\t\tscale([1, 0.5, 1])\n\t\tcylinder(h=KnobHeight, r=(KnobDiameter*TimerKnobConst) *\n\t\t    0.8, $fn=3, center=true);\n\t    }\n\t}\n\tif (Pointer1 > 0)\n\ttranslate([KnobMinorRadius*.55, 0, KnobHeight + DivotRadius*((100.0 - Pointer1)/100)])\n\tsphere(r=DivotRadius, $fn=40);\n\tif (TimerKnob == 0 && FlatSide > 0)\n\ttranslate([-KnobMajorRadius+FlatSide-50, 0, KnobHeight / 2.0])\n\tcube([100,100,KnobHeight*2], center=true, $fn=40);\n\tif (Divot==1)\n\ttranslate([0, 0, KnobHeight])\n\tcylinder(h=DivotDepth*2, r=KnobMinorRadius-1.5, $fn=50,\n\t    center=true);\n\tif (RecessDepth > 0)\n\tdifference()\n\t{\n\t    cylinder(h=RecessDepth*2, r=RecessOuterRadius,\n\t\t$fn=50,center=true);\n\t    cylinder(h=RecessDepth*2, r=RecessInnerRadius);\n\t}\n\ttranslate([0, 0, -10])\n\tcube([(KnobMajorRadius+RingWidth) * 3,\n\t\t(KnobMajorRadius+RingWidth) * 3, 20], center=true);\n\t}\n\trotate([0,0,DRotate])\n\tif (ShaftLength>0)\n\tdifference() {\n\t    translate([0, 0, ShaftLength/2])\n\t    cylinder(h=ShaftLength, r=ShaftDiameter/2, $fn=20,\n\t\tcenter=true);\n\t    if (NotchedShaft > 0) {\n\t\tcube([HoleDiameter/2, ShaftDiameter*2, ShaftLength*2*(NotchedShaft/100.0)],\n\t\t    center=true);\n\t    }\n\t}\n    }\n    rotate([0,0,DRotate])\n    translate([0, 0, HoleDepth/2 - 0.001])\n    difference()\n    {\n\tcylinder(r=HoleDiameter/2, h=HoleDepth, $fn=20,\n\t    center=true);\n\ttranslate([(0-HoleDiameter)+HoleFlatThickness, 0, 0])\n\tcube([HoleDiameter, HoleDiameter, HoleDepth+.001],\n\t    center=true);\n    }\n    if (ScrewHoleDiameter>0)\n    rotate([0,0,DRotate])\n    translate([0 - (KnobMajorRadius+RingWidth+1)/2, 0,\n\t    HoleDepth/2])\n    rotate([0, 90, 0])\n    cylinder(h=(KnobMajorRadius+RingWidth+1),\n\tr=ScrewHoleDiameter/2, $fn=20, center=true);\n}",
    "description": "Okay, I'm looking for an OpenSCAD design for a highly customizable knob. I've seen some examples, and I have a pretty good idea of what I want, but I need a design that's easy to tweak.\n\nHere are the key features and parameters I'd like:\n\n**General Shape and Size:**\n\n*   **Knob Height:**  I need to be able to set the overall height of the knob body, excluding any shaft or dome on top.\n*   **Knob Diameter:** I need to set the diameter of the round part of the knob. I'm imagining a cylindrical or tapered body and would like the diameter of the largest circle to be adjustable.\n*   **Taper:**  It would be great to taper the knob from a larger diameter at the bottom to a smaller one at the top. I'd like to be able to specify the taper percentage. A 0% taper should produce a cylinder.\n*   **Top Cap Shape:** I want to be able to select between a flat top, a recessed top (like a small dish), or a dome-shaped top. The dome should not affect the overall knob height.\n*  **Ring Width:** A ring around the base of the cylinder, with adjustable width.\n*   **Ring Thickness:**  The thickness of the ring.\n*   **Ring Markings:** If there's a ring, I want to be able to specify the number of tick marks around it, or choose to have none.\n\n**Hole for Mounting:**\n\n*   **Hole Diameter:** I need to set the diameter of the hole in the bottom to fit a shaft.\n*   **Hole Depth:**  I need to specify how deep the hole goes. This should be able to go all the way through.\n*   **D-Shaped Hole:** I also need the option for a D-shaped hole. This means there should be a flat part on one side. I'd need to specify the thickness of the flat part. It should be adjustable to make the flat larger or smaller.\n*  **D Hole Rotation**: I need to be able to adjust the rotation of the D-shaped hole to align the flat.\n\n**Shaft Option:**\n*   **Shaft Length:** I need the option to add a cylindrical shaft that protrudes from the bottom of the knob. I need to set the length of the shaft.\n*   **Shaft Diameter:** I need to set the diameter of the shaft.\n*   **Notched Shaft:** I also need the ability to notch a percentage of the shaft for a press fit.\n\n**Pointer/Directional Features:**\n\n*   **Timer Knob Pointer:** I'd like an option to add a large pointer that extends from the side of the top like a timer knob. \n*  **Divot Pointer:** The option for a divot on the top surface to indicate direction. I need to set the percentage of the divot from the center, and depth.\n*   **Flat Side:** The ability to flatten one side of the knob opposite the directional divot pointer.\n*   **Line Pointer:** I'd like an option to include a raised line (a pointer) on the side of the knob to indicate direction.\n\n**Knurling/Grip:**\n*   **Knurled Surface:** I'd like an option to add finger ridges (knurling) around the side of the knob for better grip.  \n\n**Setscrew:**\n*   **Setscrew Hole:** The ability to include a hole for a setscrew, with adjustable diameter.\n\n**Recess:**\n*  **Bottom Recess**: Option for a circular recess in the bottom of the knob, with inner and outer radius, and depth all adjustable.\n\n**Advanced Settings (I'm including these but you can assume they'll have default reasonable values):**\n\n*   **Ring Thickness:** The thickness of the ring.\n*   **Divot Depth:**  How deep the divot should be.\n*   **Marking Width:**  The width of the tick marks on the ring.\n*   **Distance Between Knurls:** The distance between the finger ridges.\n*   **TimerKnobConst:** A multiplier on the size of the timer knob.\n\nI'd prefer if this was all in one file, and I'd rather not use any libraries if possible. I'm looking for something clean and easy to understand, so I can quickly modify these parameters and create a knob with all the specs I need. I think that covers everything! Thank you!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Dualstrusion Bracelet",
    "scad": "link_diameter = 25;\nbracelet_diameter = 84;\nextruder_colour = \"BothColours\";\noverhang=40*1;\nthick=link_diameter/7;\nrad = bracelet_diameter/2;\noangle = 45*1;\nrings = 4 * floor(((rad*2*3.14159)/(sin(45)*thick*7))/2);\nangle = 360/rings;\ncorner=0.9*1;\nif(( extruder_colour == \"BothColours\" ) || ( extruder_colour == \"Colour1\" ))\n{\nfor(i=[0:angle*4:359])\n{\n\trotate([0,0,i])\n\ttranslate([0,rad,0])\n\trotate([0,0,oangle])\n\trotate([0,90,0])\n\t{\n\t\tminkowski()\n\t\t{\n\t\t\toct_tube( thick*5+(2*corner), thick-(2*corner), thick-(2*corner) );\n\t\t\tdiamond(corner);\n\t\t}\n\t}\n\trotate([0,0,i+angle*3])\n\ttranslate([0,rad,0])\n\trotate([0,0,oangle])\n\trotate([0,90,0])\n\t{\n\t\tminkowski()\n\t\t{\n\t\t\toct_tube( thick*5+(2*corner), thick-(2*corner), thick-(2*corner) );\n\t\t\tdiamond(corner);\n\t\t}\n\t}\n}\n}\nif(( extruder_colour == \"BothColours\" ) || ( extruder_colour == \"Colour2\" ))\n{\nfor(i=[0:angle*4:359])\n{\n\trotate([0,0,i+(2*angle)])\n\ttranslate([0,rad,0])\n\trotate([0,0,oangle])\n\trotate([0,90,0])\n\t{\n\t\tminkowski()\n\t\t{\n\t\t\toct_tube( thick*5+(2*corner), thick-(2*corner), thick-(2*corner) );\n\t\t\tdiamond(corner);\n\t\t}\n\t}\n\trotate([0,0,i+angle*3+(2*angle)])\n\ttranslate([0,rad,0])\n\trotate([0,0,oangle])\n\trotate([0,90,0])\n\t{\n\t\tminkowski()\n\t\t{\n\t\t\toct_tube( thick*5+(2*corner), thick-(2*corner), thick-(2*corner) );\n\t\t\tdiamond(corner);\n\t\t}\n\t}\n}\n}\nif(( extruder_colour == \"BothColours\" ) || ( extruder_colour == \"Colour1\" ))\n{\n\tfor(i=[0:angle*4:359])\n\t{\n\t\thull()\n\t\t{\n\t\t\trotate([0,0,i])\n\t\t\ttranslate([0,rad,0])\n\t\t\trotate([0,0,oangle])\n\t\t\trotate([0,90,0])\n\t\t\t{\n\t\t\t\ttranslate([0,thick*3,0])\n\t\t\t\tcube([thick,thick,thick*0.25],true);\n\t\t\t}\n\t\t\trotate([0,0,i+(3*angle)])\n\t\t\ttranslate([0,rad,0])\n\t\t\trotate([0,0,oangle])\n\t\t\trotate([0,90,0])\n\t\t\t{\n\t\t\t\ttranslate([0,-thick*3,0])\n\t\t\t\tcube([thick,thick,thick*0.25],true);\n\t\t\t}\n\t\t}\n\t}\n}\nif(( extruder_colour == \"BothColours\" ) || ( extruder_colour == \"Colour2\" ))\n{\n\tfor(i=[0:angle*4:359])\n\t{\n\t\thull()\n\t\t{\n\t\t\trotate([0,0,i+(2*angle)])\n\t\t\ttranslate([0,rad,0])\n\t\t\trotate([0,0,oangle])\n\t\t\trotate([0,90,0])\n\t\t\t{\n\t\t\t\ttranslate([0,thick*3,0])\n\t\t\t\tcube([thick,thick,thick*0.25],true);\n\t\t\t}\n\t\t\trotate([0,0,i+(3*angle)+(2*angle)])\n\t\t\ttranslate([0,rad,0])\n\t\t\trotate([0,0,oangle])\n\t\t\trotate([0,90,0])\n\t\t\t{\n\t\t\t\ttranslate([0,-thick*3,0])\n\t\t\t\tcube([thick,thick,thick*0.25],true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule cutter(dist, overhang)\n{\n\tsize = dist*2;\n\ttranslate([dist,-dist,-dist])\n\tcube([size,size,size]);\n\ttranslate([-dist-size,-dist,-dist])\n\tcube([size,size,size]);\n\ttranslate([dist,-dist,0])\n\trotate([0,-overhang,0])\n\tcube([size,size,size]);\n\ttranslate([-dist,-dist,0])\n\trotate([0,-90+overhang,0])\n\tcube([size,size,size]);\n\ttranslate([dist,-dist,0])\n\trotate([0,90+overhang,0])\n\tcube([size,size,size]);\n\ttranslate([-dist,-dist,0])\n\trotate([0,180-overhang,0])\n\tcube([size,size,size]);\n}\nmodule diamond( rounded )\n{\n\tdist = rounded;\n\tdifference()\n\t{\n\t\tcube([2*rounded,2*rounded,2*rounded], true);\n\t\tfor(i=[0:45:179])\n\t\t{\n\t\t\trotate([0,0,i])\n\t\t\tcutter(dist, overhang);\n\t\t}\n\t}\n}\nmodule oct_hole( diameter, length, thickness )\n{\n\toct_tube( 0, length, diameter*0.5 );\n}\nmodule oct_tube( diameter, length, thickness )\n{\n\tradius = (diameter+thickness)*0.5;\n\toct_side = diameter / (1+(2*sin(45)));\n\toct_side2 = oct_side + thickness*tan(22.5)*2;\n\tunion()\n\t{\n\t\ttranslate( [ radius, 0, 0] )\n\t\tcube( [thickness, oct_side2, length], true );\n\t\trotate( [0,0,45] )\n\t\ttranslate( [ radius, 0, 0] )\n\t\tcube( [thickness, oct_side2, length], true );\n\t\trotate( [0,0,90] )\n\t\ttranslate( [ radius, 0, 0] )\n\t\tcube( [thickness, oct_side2, length], true );\n\t\trotate( [0,0,135] )\n\t\ttranslate( [ radius, 0, 0] )\n\t\tcube( [thickness, oct_side2, length], true );\n\t\trotate( [0,0,180] )\n\t\ttranslate( [ radius, 0, 0] )\n\t\tcube( [thickness, oct_side2, length], true );\n\t\trotate( [0,0,225] )\n\t\ttranslate( [ radius, 0, 0] )\n\t\tcube( [thickness, oct_side2, length], true );\n\t\trotate( [0,0,270] )\n\t\ttranslate( [ radius, 0, 0] )\n\t\tcube( [thickness, oct_side2, length], true );\n\t\trotate( [0,0,315] )\n\t\ttranslate( [ radius, 0, 0] )\n\t\tcube( [thickness, oct_side2, length], true );\n\t}\n}",
    "description": "Okay, I'd like to design a linked bracelet using OpenSCAD, but I want it to be highly customizable. The design I have in mind is based on a \"figure-8\" style link, where the links interlock and repeat around the circumference of the bracelet.\n\nHere are the specific parameters I need to be able to control:\n\n*   **`link_diameter`**: This should control the overall size of each individual link, essentially the \"thickness\" of the bracelet. I'd like to specify this in millimeters.  I'm thinking a range of about 14mm to 32mm should be good.\n\n*   **`bracelet_diameter`**: This determines the overall diameter of the bracelet itself, in millimeters. I'd need to be able to adjust this to fit different wrist sizes, so a range from 30mm to 300mm sounds reasonable.\n\n*   **`extruder_colour`**: I'm planning to print this on a dual extruder printer, so I need an option to choose which \"color\" to output. The options would be \"Colour1\", \"Colour2\", or \"BothColours\" where the links alternate colors. I expect the two colors would be incorporated into two interlocking link structures, and then a hull to connect them.\n\nThe links themselves should have a slightly rounded, octagonal tube cross-section, not just a simple circle. The original code uses a Minkowski sum of an octagonal tube and a diamond to achieve this. The links interlock as in the provided code, rotating a standard module around the circumference of the bracelet.\n\nI'd like the code to calculate the number of links required based on the `bracelet_diameter` so the links interlock properly. I don't need to specify the number of links directly.\n\nThe design should be able to be generated without any additional files or dependencies beyond standard OpenSCAD capabilities.\n\nI think that covers everything. Can you generate an OpenSCAD file that meets these requirements?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Safe / House / Padlock keys",
    "scad": "use <utils/build_plate.scad>\nuse <write/Write.scad>\ndebug_flag = false;\ntype_of_key = 0;\necho( \"type_of_key\" , type_of_key );\nstyle_of_key = 1;\necho ( \"style_of_key\" , style_of_key );\npolygon_count = 6;\necho( \"Print Quality / Polygon Count\" , polygon_count );\nkeycutcode = \"\";\necho ( \"keycutcode\" , keycutcode );\ncustom_key_text =\"\";\necho ( \"custom_key_text\" , custom_key_text );\nprint_layer_thickness = 1;\necho ( \"print_layer_thickness\" , print_layer_thickness );\ncutting_steps = 7;\necho ( \"cutting_steps\" , cutting_steps );\nadjust_height = 0;\necho ( \"adjust_height\" , adjust_height );\nbuild_plate_selector = 2;\nbuild_plate_manual_x = 100 + 0;\nbuild_plate_manual_y = 100 + 0;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\npi_value = 3.14159 *1;\necho ( \"Pi\" , pi_value );\nbelfry_b_logo = str( \"B\", \"\" );\necho ( \"belfry_b_logo\" , belfry_b_logo );\nfudge_factor = 0 + 0.001;\necho ( \"fudge_factor\" , fudge_factor );\nmaxcylindercount = 10+0;\necho( \"maxcylindercount\" , maxcylindercount );\nkeycylindercount = [5,4,7];\necho ( \"keycylindercount\" , keycylindercount );\nnumber_cylinders = keycylindercount[ type_of_key ];\necho ( \"number_cylinders\" , number_cylinders );\nlayerthickness = [0.30,0.29,0.28,0.27,0.26,0.25];\necho ( \"layerthickness\" , layerthickness );\nlayer_thickness = layerthickness[ print_layer_thickness ];\necho ( \"layer_thickness\" , layer_thickness );\nkeybladelength = [29.00,18.50,13.00];\necho ( \"keybladelength\" , keybladelength );\nblade_length = keybladelength[ type_of_key ];\necho ( \"blade_length\" , blade_length );\nkeybladeheight = [8.35,7.25,9.50];\necho ( \"keybladeheight\" , keybladeheight );\nblade_height = keybladeheight[ type_of_key ] + (adjust_height/100);\necho ( \"blade_height\" , blade_height );\n5cylkeybladelayers = [7,7,7,7,8,8];\necho ( \"5cylkeybladelayers\" , 5cylkeybladelayers );\n5cyl_key_blade_layers = 5cylkeybladelayers[ print_layer_thickness ];\necho ( \"5cyl_key_blade_layers\" , 5cyl_key_blade_layers );\nkeybladewidth = [(5cyl_key_blade_layers*layer_thickness),(7*layer_thickness),0];\necho ( \"keybladewidth\" , keybladewidth );\nblade_width = keybladewidth[ type_of_key ];\necho ( \"blade_width\" , blade_width );\ntexthsize = [6.0,4.5,5.0];\necho( \"texthsize\" , texthsize );\ntext_h_size = texthsize[ type_of_key ];\necho ( \"text_h_size\" , text_h_size );\nfrontslotheight = [1.60,0.00,0.00];\necho ( \"frontslotheight\" , frontslotheight );\nfrontslotyoffset = [0.60,0.00,0.00];\necho ( \"frontslotyoffset\" , frontslotyoffset );\n5cylfrontslotlayers = [3,3,3,3,4,4];\necho ( \"5cylfrontslotlayers\" , 5cylfrontslotlayers );\n5cyl_front_slot_layers = 5cylfrontslotlayers[ print_layer_thickness ];\necho ( \"5cyl_front_slot_layers\" , 5cyl_front_slot_layers );\nfrontslotzoffset = [(5cyl_front_slot_layers*layer_thickness),0.00,0.00];\necho ( \"frontslotzoffset\" , frontslotzoffset );\nkey_fslot_height = frontslotheight[ type_of_key ];\necho ( \"key_fslot_height\" , key_fslot_height );\nkey_fslot_yoffset = frontslotyoffset[ type_of_key ];\necho ( \"key_fslot_yoffset\" , key_fslot_yoffset );\nkey_fslot_zoffset = frontslotzoffset[ type_of_key ];\necho ( \"key_fslot_zoffset\" , key_fslot_zoffset );\nbackslotheight = [1.35,1.35,0.00];\necho ( \"backslotheight\" , backslotheight );\nbackslotyoffset = [key_fslot_yoffset+key_fslot_height+0.50,1.00,0.00];\necho ( \"backslotyoffset\" , backslotyoffset );\n5cylbackslotlayers = [2,3,3,3,3,3];\necho ( \"5cylbackslotlayers\" , 5cylbackslotlayers );\n5cyl_back_slot_layers = 5cylbackslotlayers[ print_layer_thickness ];\necho ( \"5cyl_back_slot_layers\" , 5cyl_back_slot_layers );\nbackslotzoffset = [-(5cyl_back_slot_layers*layer_thickness),-(2*layer_thickness),0.00];\necho ( \"backslotzoffset\" , backslotzoffset );\nbackslotangle = [210,210,0.00];\necho ( \"backslotangle\" , backslotangle );\nkey_bslot_height = backslotheight[ type_of_key ];\necho ( \"key_bslot_height\" , key_bslot_height );\nkey_bslot_yoffset = backslotyoffset[ type_of_key ];\necho ( \"key_bslot_yoffset\" , key_bslot_yoffset );\nkey_bslot_zoffset = backslotzoffset[ type_of_key ];\necho ( \"key_bslot_zoffset\" , key_bslot_zoffset );\nkey_bslot_angle = backslotangle[ type_of_key ];\necho ( \"key_bslot_angle\" , key_bslot_angle );\ntopslotheight = [3.25,3.50,0.00];\necho ( \"topslotheight\" , topslotheight );\n5cyltopslotlayers = [4,4,5,5,5,5];\necho ( \"5cyltopslotlayers\" , 5cyltopslotlayers );\n5cyl_top_slot_layers = 5cyltopslotlayers[ print_layer_thickness ];\necho ( \"5cyl_top_slot_layers\" , 5cyl_top_slot_layers );\ntopslotzoffset = [(5cyl_top_slot_layers*layer_thickness),(3*layer_thickness),0.00];\necho ( \"topslotzoffset\" , topslotzoffset );\nkey_tslot_height = topslotheight[ type_of_key ] + (adjust_height/100);\necho ( \"key_tslot_height\" , key_tslot_height );\nkey_tslot_zoffset = topslotzoffset[ type_of_key ];\necho ( \"key_tslot_zoffset\" , key_tslot_zoffset );\ntopslotangle = [30,30,0.00];\necho ( \"topslotangle\" , topslotangle );\nkey_tslot_angle = topslotangle[ type_of_key ];\necho ( \"key_tslot_angle\" , key_tslot_angle );\nkeytiptopangle = [45,50,0.00];\necho ( \"keytiptopangle\" , keytiptopangle );\nkey_tip_topangle = keytiptopangle[ type_of_key ];\necho ( \"key_tip_topangle\" , key_tip_topangle );\nkeytiptopyoffset = [key_fslot_yoffset+key_fslot_height,(blade_height-key_tslot_height),0.00];\necho( \"keytiptopyoffset\" , keytiptopyoffset );\nkey_tip_topyoffset = keytiptopyoffset[ type_of_key ];\necho ( \"key_tip_topyoffset\" , key_tip_topyoffset );\nkeytipbotangle = [225,225,0.00];\necho ( \"keytipbotangle\" , keytipbotangle );\nkey_tip_botangle = keytipbotangle[ type_of_key ];\necho ( \"key_tip_botangle\" , key_tip_botangle );\nkeytipbotyoffset = [key_bslot_yoffset,(blade_height/2),0.00];\necho( \"keytipbotyoffset\" , keytipbotyoffset );\nkey_tip_botyoffset = keytipbotyoffset[ type_of_key ];\necho ( \"key_tip_botyoffset\" , key_tip_botyoffset );\nfirstcyloffset = [6.2738,5.00,0.00];\necho ( \"firstcyloffset\" , firstcyloffset );\nfirst_offset = firstcyloffset[ type_of_key ];\necho ( \"first_offset\" , first_offset );\ncylseparation = [3.81,3.00,0.00];\necho ( \"cylseparation\" , cylseparation );\ncylinder_separation = cylseparation[ type_of_key ];\necho ( \"cylinder_separation\" , cylinder_separation );\ncyldiameter = [2.921,1.00,0.00];\necho ( \"cyldiameter\" , cyldiameter );\nkey_cyl_diameter = cyldiameter[ type_of_key ];\necho ( \"key_cyl_diameter\" , key_cyl_diameter );\ncylpinbotdiameter = [0.5,1.0,1.0];\necho ( \"cylpinbotdiameter\" , cylpinbotdiameter );\ncyl_pin_bot_diameter = cylpinbotdiameter[ type_of_key ];\necho ( \"cyl_pin_bot_diameter\" , cyl_pin_bot_diameter );\ntslot_long_side = (blade_width - key_tslot_zoffset);\necho ( \"tslot_long_side\" , tslot_long_side );\ntslot_short_side = tslot_long_side * tan(30);\necho ( \"tslot_short_side\" , tslot_short_side );\ntslot_hypotenuse_side = sqrt(pow(tslot_long_side,2) + pow(tslot_short_side,2));\necho ( \"tslot_hypotenuse_side\" , tslot_hypotenuse_side );\n7step_cyl_increment_size = 0.5842+0;\necho ( \"7step_cyl_increment_size\" , 7step_cyl_increment_size );\n10step_cyl_increment_size = (( key_tslot_height + tslot_short_side )/9);\necho ( \"10step_cyl_increment_size\" , 10step_cyl_increment_size );\npinstepheight = [ 0,0,0,0,0,0,0,7step_cyl_increment_size ,0,0,10step_cyl_increment_size ];\necho ( \"pinstepheight\" , pinstepheight );\nnumberofsteps = [cutting_steps,10,10];\necho (\"numberofsteps\" , numberofsteps );\nnumber_of_steps = numberofsteps[type_of_key];\necho (\"number_of_steps\" , number_of_steps);\nnumber_lookup = str( \"0123456789\" , \"\" );\necho( \"number_lookup\" ,  number_lookup );\nrandom_key_array = rands( 0 , (number_of_steps - .01), maxcylindercount + 1 );\necho( \"random_key_array\" , random_key_array );\nrandom_key = str( floor( random_key_array[1] ) , floor( random_key_array[2] ) , floor( random_key_array[3] ) , floor( random_key_array[4] ) , floor( random_key_array[5] ) , floor( random_key_array[6] ) , floor( random_key_array[7] ) , floor( random_key_array[8] ) , floor( random_key_array[9] ) , floor( random_key_array[10] ) );\necho ( \"random_key: \" , random_key );\nkey_cut_code = str(keycutcode,random_key);\necho ( \"key_cut_code\" , key_cut_code );\nmaxcutdepth = [(key_tslot_height+tslot_short_side),(key_tslot_height+tslot_short_side),0];\necho ( \"maxcutdepth\" , maxcutdepth );\nmax_cut_depth = maxcutdepth[ type_of_key ];\necho ( \"max_cut_depth\" , max_cut_depth );\npinstep = [ pinstepheight[ cutting_steps ] , (key_tslot_height / 10) ,0.00];\necho ( \"pinstep\" , pinstep );\npin_step = pinstep[ type_of_key ];\necho( \"pin_step\" , pin_step );\nstraightlength = [27,22,0.00];\necho ( \"straightlength\" , straightlength );\nstraight_length = straightlength[ type_of_key ];\necho ( \"straight_length\" , straight_length );\nlayersthick = [3,3,3];\necho ( \"layersthick\" , layersthick );\nlayers_thick = layersthick[ type_of_key ];\necho ( \"layers_thick\" , layers_thick );\ntextseparation = [4.0,3.5,3.8];\necho ( \"textseparation\" , textseparation );\ntext_separation = textseparation[ type_of_key ];\necho ( \"text_separation\" , text_separation );\nkeyringradius = [4.5,4.0,4.0];\necho ( \"keyringradius\" , keyringradius );\nkey_ring_radius = keyringradius[ type_of_key ];\necho ( \"key_ring_radius\" , key_ring_radius );\nkeyheaddiameter = [26,20,0];\necho ( \"keyheaddiameter\" , keyheaddiameter );\nkey_head_diameter = keyheaddiameter[ type_of_key ];\necho ( \"key_head_diameter\" , key_head_diameter );\nsafe_key_polygon_count=(128*1);\necho ( \"safe_key_polygon_count\" , safe_key_polygon_count );\nsafe_key_outer_diameter=(9.95*1);\necho ( \"safe_key_outer_diameter\" , safe_key_outer_diameter );\nsafe_key_inner_diameter=(safe_key_outer_diameter-1.0);\necho ( \"safe_key_inner_diameter\" , safe_key_inner_diameter );\nsafe_key_outer_radius=(safe_key_outer_diameter/2);\necho ( \"safe_key_outer_radius\" , safe_key_outer_radius );\nsafe_key_inner_radius=(safe_key_inner_diameter/2);\necho ( \"safe_key_inner_radius\" , safe_key_inner_radius );\ncylinder_pin_offset=((9.75/2)+0.3);\necho ( \"cylinder_pin_offset\" , cylinder_pin_offset );\nsafe_pin_xoffset = [0,cylinder_pin_offset,cylinder_pin_offset,0,0,-cylinder_pin_offset,-cylinder_pin_offset,0];\necho ( \"safe_pin_xoffset\" , safe_pin_xoffset );\nsafe_pin_yoffset = [0,0,0,-cylinder_pin_offset,-cylinder_pin_offset,0,0,cylinder_pin_offset];\necho ( \"safe_pin_yoffset\" , safe_pin_yoffset );\ncylinder_z_rotation = [0,45,0,45,0,45,0,45];\necho ( \"cylinder_z_rotation\" , cylinder_z_rotation );\nsafe_key_pin_height = 5+0;\necho ( \"safe_key_pin_height\" , safe_key_pin_height );\nsafe_key_pin_radius = 1+0;\necho ( \"safe_key_pin_radius\" , safe_key_pin_radius );\nsafe_key_shoulder_height = 5+0;\necho ( \"safe_key_shoulder_height\" , safe_key_shoulder_height );\necho ( \"start of the program\" );\n{\ndifference()\n{\nunion()\n{\ncreate_key_blade();\n\t\t\tif ( debug_flag == false )\n\t\t\t{\ncreate_key_shoulder();\ncreate_key_header();\n\t\t\t}\n}\n\t\t\tif ( debug_flag == false )\n\t\t\t{\ncreate_key_ringhole();\ncreate_belfry_B();\n\t\t\t}\n}\n}\necho (\"end of program\" );\nmodule cut_slots()\n{\necho ( \"cut the main key slots module\" );\necho ( \"front slot setup\" );\nfront_slot();\necho ( \"back slot setup\" );\nback_slot();\necho ( \"top slot setup\" );\ntop_slot();\n}\nmodule front_slot()\n{\necho ( \"front slot setup module\" );\ntranslate([-1,key_fslot_yoffset,key_fslot_zoffset]) cube( [ blade_length + 2 , key_fslot_height , blade_width ] );\n}\nmodule back_slot()\n{\necho ( \"back slot setup module\" );\nshort_cube = ( blade_width *2 );\necho ( \"short_cube\" , short_cube );\nshort_side_offset = ( short_cube * sin(30) );\necho ( \"short_side_offset\" , short_side_offset );\nlong_side_offset = ( short_cube * cos(30) );\necho ( \"long_side_offset\" , long_side_offset );\ntranslate([-1,key_bslot_yoffset,key_bslot_zoffset])\n{\nunion()\n{\ncube( [ blade_length + 2 , key_bslot_height , blade_width ] );\nif ( key_bslot_angle != 0 )\n{\ntranslate([0,key_bslot_height,blade_width]) rotate( [key_bslot_angle,0,0] ) cube( [ blade_length + 2 , key_bslot_height , short_cube ] );\n}\n}\n}\n}\nmodule top_slot()\n{\necho ( \"top slot setup module\" );\ntranslate( [-1,blade_height-key_tslot_height,key_tslot_zoffset] )\n{\nunion()\n{\nrotate( [key_tslot_angle,0,0] ) cube( [ blade_length + 2 , blade_height , blade_width * 2 ] );\ncube( [ blade_length + 2 , blade_height  , blade_width * 2 ] );\n}\n}\n}\nmodule cut_the_tip()\n{\necho ( \"cut off the tip of the blade module\" );\nunion()\n{\ntranslate( [blade_length,key_tip_topyoffset,-1] ) rotate( [0,0,key_tip_topangle] ) cube( blade_height *1.5 );\ntranslate( [blade_length+1,key_tip_botyoffset+1,-1] ) rotate( [0,0,key_tip_botangle] ) cube( blade_height );\n}\n}\nmodule cut_cylinders( total_cylinders = 1 )\n{\necho ( \"start of cylinder cutting loop for\" , total_cylinders , \"cylinders\" );\nfor ( cyl_loop = [1 : total_cylinders] )\n{\n\techo(str(\"cylinder:\" , cyl_loop , \" - key_cut_code:\" , key_cut_code[cyl_loop-1]));\n\tpin_position( what_str_digit = key_cut_code[cyl_loop-1] , what_cyl = cyl_loop );\n}\n}\nmodule create_master_teeth(tooth_number=1,tooth_step=0)\n{\necho ( \"create_master_teeth\" , tooth_number , tooth_step );\ndifference()\n{\ntranslate([(first_offset) + ((tooth_number-1)*cylinder_separation),blade_height-cylinder_separation,-1]) rotate( [0 , 0 , 45] )cube([blade_height,blade_height,blade_width+2]);\ntranslate([(first_offset) + ((tooth_number-1)*cylinder_separation)-blade_height,-min(tooth_step,max_cut_depth),-1]) cube([blade_height*2,blade_height,blade_width+2]);\n}\n}\nmodule pin_position( what_str_digit = \"0\" , what_cyl = 1 )\n{\necho( \"Cylinder: \" , what_cyl , \"Digit: \" , what_str_digit );\nfor ( value_lookup = [1:9] )\n{\nif ( what_str_digit == number_lookup[value_lookup] )\n{\necho( \"match found: \" , value_lookup , what_str_digit );\ncreate_master_teeth(tooth_number=what_cyl,tooth_step=(value_lookup*pin_step));\n}\n}\n}\nmodule straight_key_header( sheader_length = 25 , sheader_text = \"0123456789\" )\n{\necho ( \"sheader_length\" , sheader_length );\necho ( \"sheader_text\" , sheader_text );\ntranslate([(-1*sheader_length)+fudge_factor,0,0])\n{\nunion()\n{\ncube( [ sheader_length , blade_height  , blade_width ] );\nfor ( sdigit_loop = [0:number_cylinders-1] )\n{\n\techo ( \"sdigit_loop\" , sdigit_loop , \"text\" , sheader_text[sdigit_loop] );\n\ttranslate([(text_separation+(text_separation*sdigit_loop)),1,blade_width-fudge_factor]) write(sheader_text[sdigit_loop],h=text_h_size,t=(layer_thickness*layers_thick));\n}\n}\n}\n}\nmodule round_key_header( rheader_diameter = 25 , rheader_text = \"0123456789\" )\n{\necho ( \"rheader_diameter\" , rheader_diameter );\necho ( \"rheader_text\" , rheader_text );\nif ( type_of_key <= 1 )\n{\ntranslate([(-1*rheader_diameter)+fudge_factor,0,0])\n{\ntranslate([(rheader_diameter/2),(blade_height/2),0]) cylinder( h=blade_width , r=rheader_diameter/2 , center = false , $fn=polygon_count);\nif ( polygon_count > 4 )\n{\nrotate([0,0,90]) union()\n{\nfor ( rdigit_loop = [0:number_cylinders-1] )\n{\n\techo ( \"rdigit_loop\" , rdigit_loop , \"text\" , rheader_text[rdigit_loop] );\ntranslate([(text_separation*rdigit_loop)+(blade_height/2)-(rheader_diameter/2)+(text_h_size/2),-(rheader_diameter/2)-(text_h_size),blade_width-fudge_factor]) write(rheader_text[rdigit_loop],h=text_h_size,t=(layer_thickness*layers_thick));\n}\n}\n}\n}\n}\n}\nmodule create_text( text_to_print=\"Belfry 6050\" )\n{\necho ( \"text_to_print\" , text_to_print );\nwrite(text_to_print,h=text_h_size,t=(layer_thickness*layers_thick));\n}\nmodule five_cyl_housekey_shoulder()\n{\necho ( \"5 cylinder house key shoulder\" );\ntranslate([fudge_factor-blade_height,-(blade_height*0.25),0])\ncube([blade_height,(blade_height*1.5),blade_width]);\n}\nmodule four_cyl_padlock_shoulder()\n{\necho ( \"4 cylinder padlock key shoulder\" );\ntranslate([fudge_factor-blade_height,0,0])\ncube([blade_height,(blade_height*1.25),blade_width]);\n}\nmodule seven_cyl_safe_shoulder()\n{\necho ( \"7 cylinder safe key shoulder\" );\ntranslate([0,0,0])\ncylinder(r1=safe_key_outer_radius*1.5,r2=safe_key_outer_radius,h=safe_key_shoulder_height,$fn=safe_key_polygon_count);\n}\nmodule create_key_blade()\n{\necho ( \"start of the create_key_blade module\" );\nif ( type_of_key <= 1 )\n{\necho ( \"start of the difference function\" );\ndifference()\n{\necho ( \"main blade setup\" );\ncube( [ blade_length , blade_height , blade_width ] );\necho ( \"cut the main key slots\" );\ncut_slots()\necho ( \"cut off the tip of the blade\" );\ncut_the_tip();\necho ( \"start cutting\" , number_cylinders , \"cylinders\" );\ncut_cylinders( total_cylinders = number_cylinders );\n}\n}\nif ( type_of_key == 2 )\n{\nsafe_key_blade();\n}\n}\nmodule create_key_shoulder()\n{\necho ( \"start of create_key_shoulder module\" );\nif ( style_of_key > 0 )\n{\n\tif ( type_of_key == 0 )\n\t\tfive_cyl_housekey_shoulder();\n\tif ( type_of_key == 1 )\n\t\tfour_cyl_padlock_shoulder();\n}\nif ( type_of_key == 2 )\n\tseven_cyl_safe_shoulder();\n}\nmodule create_key_ring_hole()\n{\necho( \"key_ring_radius for cylinder\" , key_ring_radius );\nif ( style_of_key > 0 )\n{\n\tcylinder( h=blade_width*3 , r=key_ring_radius , center = true , $fn=polygon_count);\n}\n}\nmodule create_key_header()\n{\nif ( type_of_key < 2 )\n{\nif ( style_of_key == 0 )\n{\nstraight_key_header(sheader_length=straight_length,sheader_text=str(custom_key_text,key_cut_code));\n}\nif ( style_of_key == 1 )\n{\nround_key_header(rheader_diameter=key_head_diameter,rheader_text=str(custom_key_text,key_cut_code));\n}\n}\nif ( type_of_key == 2 )\n{\nsafe_key_round_header();\n}\n}\nmodule create_key_ringhole()\n{\nif ( style_of_key > 0 )\n{\nif ( polygon_count == 5 )\n{\n\tif ( type_of_key == 0 )\n{\n\ttranslate([(-1*(key_head_diameter))+(key_ring_radius*2)-2,(blade_height/2),0]) create_key_ring_hole();\n}\nelse\n{\n\ttranslate([((-1*(key_head_diameter))+ key_ring_radius + 2 ),(blade_height/2),0]) create_key_ring_hole();\n}\n}\nelse\n{\n\ttranslate([((-1*(key_head_diameter))+ key_ring_radius + 2 ),(blade_height/2),0]) create_key_ring_hole();\n}\n}\n}\nmodule create_belfry_B()\n{\nif ( style_of_key == 0 )\n{\n\ttranslate([-15,0.75,(layer_thickness*3)]) rotate([0,180,270])\n{\n\tif (type_of_key == 0 )\n{\n\t\twrite(belfry_b_logo,h=10,t=layer_thickness*4);\n}\n\tif (type_of_key == 1)\n{\n\t\twrite(belfry_b_logo,h=9,t=layer_thickness*4);\n}\n}\n}\nif ( style_of_key == 1 )\n{\n\tif ( type_of_key == 0 )\n{\n\t\ttranslate([-2.5,7,(layer_thickness*3)]) rotate([0,180,90]) write(belfry_b_logo,h=10,t=(layer_thickness*4));\n}\n\tif ( type_of_key == 1 )\n{\n\t\ttranslate([-0.75,6,(layer_thickness*3)]) rotate([0,180,90]) write(belfry_b_logo,h=8,t=(layer_thickness*4));\n}\n}\nif ( type_of_key == 2 )\n{\n\t\ttranslate([2.5,-5,(layer_thickness*3)]) rotate([180,0,180]) write(belfry_b_logo,h=10,t=(layer_thickness*4));\n\t\ttranslate([-1.5,-3,safe_key_shoulder_height-(layer_thickness*3)]) rotate([0,0,0]) write(belfry_b_logo,h=6.0,t=(layer_thickness*4));\n}\n}\nmodule safe_key_blade()\n{\ntranslate([0,0,(safe_key_shoulder_height-fudge_factor)])\n{\nunion()\n{\ndifference()\n{\ntranslate([0,safe_key_inner_radius+0.50,(blade_length-1)/2]) cube([1.2,2.5,blade_length-1],center=true);\ntranslate([0,safe_key_inner_radius+1.50+fudge_factor,(blade_length-5)]) cube([2,3.0,4.0],center=true);\n}\n}\ndifference()\n{\ncylinder( h=blade_length,r=safe_key_outer_radius,$fn=safe_key_polygon_count);\ntranslate([0,0,-1]) cylinder( h=blade_length+2,r=safe_key_inner_radius,$fn=safe_key_polygon_count);\necho (\"blade_length\" , blade_length );\nfor ( safe_cylinder_count = [1:7] )\n{\necho ( \"safe_cylinder_count\" , safe_cylinder_count );\ncut_safe_key_pin( what_safe_cyl = safe_cylinder_count , what_safe_digit = key_cut_code[safe_cylinder_count-1] );\n}\n}\n}\nif ( custom_key_text == \"\" )\n{\nwritecylinder(h=6.0,text=str(key_cut_code[6],key_cut_code[5],key_cut_code[4],key_cut_code[3],key_cut_code[2],key_cut_code[1],key_cut_code[0]),where=[0,0,9],radius=(safe_key_outer_radius),height=blade_length,rotate=0,center=true,space=1.0);\n}\nelse\n{\nwritecylinder(h=6.0,text=custom_key_text,where=[0,0,9],radius=(safe_key_outer_radius),height=blade_length,rotate=0,center=true,space=1.0);\n}\n}\nmodule cut_safe_key_pin( what_safe_cyl = 1 , what_safe_digit = \"0\" )\n{\necho( \"Safe Cylinder Digit: \" , what_safe_digit );\necho( \"Safe Cylinder:\" , what_safe_cyl , \"Cylinder Digit: \" , what_safe_digit );\nfor ( safe_value_lookup = [1:9] )\n{\nif ( what_safe_digit == number_lookup[safe_value_lookup] )\n{\necho( \"safe key cylinder match found: \" , safe_value_lookup , what_safe_digit , what_safe_cyl );\nrotate([0,0,cylinder_z_rotation[what_safe_cyl]]) translate([safe_pin_xoffset[what_safe_cyl],safe_pin_yoffset[what_safe_cyl],((safe_key_pin_height/2)+blade_length)-(layer_thickness*safe_value_lookup)]) cube( [safe_key_pin_radius*2,safe_key_pin_radius*2,safe_key_pin_height] , center=true);\n}\n}\n}\nmodule safe_key_round_header()\n{\ncylinder( h=(blade_length/6),r=safe_key_outer_radius*2.5,$fn=polygon_count);\n}",
    "description": "Okay, I'm looking to generate some customizable keys, like house keys, padlock keys, and even safe keys, using OpenSCAD. I've seen a design on Thingiverse that does this, and I want to create something similar, but I'd like a clean and robust implementation that is entirely parametric. I'm hoping you can help me design these files.\n\nHere are the key types I need to support, and their basic shapes:\n\n*   **5-Cylinder House Key:** This will have a blade with cuts for the pins, and a head that is either straight or round, and a hole for a keyring. It should have a front slot, a back slot, and a top slot. The blade should also have a slanted tip.\n*   **4-Cylinder Padlock Key:** Similar to the house key, but shorter blade. Again, a straight or round head, a hole for a key ring, and the slots as with the house key.\n*   **7-Cylinder Safe Key:** This one is a little different. It has a cylindrical base, and then has cuts around the side of the cylinder (not on a flat blade). It should also have a small \"shoulder\" where the head transitions into the cylinder.\n\nI need the following elements to be customizable:\n\n*   **Key Type:** Selectable from the three types I listed above.\n*   **Head Style:** Selectable between a straight rectangular header and a round header.\n*   **Print Quality:** This will control the `$fn` parameter for curves. I'd like to be able to specify some reasonable values here, maybe something like 4, 6, 8, 12, 16, 20, 24, 28, or 32. I want the user to be able to select it as a dropdown. I'd also like \"No Text\" to be an option, setting `$fn` to 4.\n*   **Key Cutting Code:** I need to specify a string of digits, 0-9, that represents the cuts on the key. The length should depend on the key type, so 5 digits for the house key, 4 for the padlock, and 7 for the safe key. If no code is specified, a random code for the given number of cylinders should be generated.\n*  **Custom Text:** The user should be able to define some custom text that's printed on the key.\n*   **Print Layer Thickness:** I want to be able to adjust for the layer height of the printer, so I'd like dropdown options for 0.30mm, 0.29mm, 0.28mm, 0.27mm, 0.26mm, and 0.25mm.\n*   **Cutting Steps:** The number of possible cut depths. I'd like options for 7 steps (Kwikset standard) or 10 steps.  The code should automatically use the correct number of steps.\n*   **Adjust Height:**  I need a way to slightly adjust the overall height of the key, I'd say from -0.5mm to +0.5mm, in 0.01mm increments.\n\nI'll also want to include a build plate, using the `build_plate.scad` library. I'd like to include options for common printer types (Replicator 2, Replicator, Thingomatic) and also an option to manually define the build plate dimensions.  I'd like to use the `Write.scad` library to generate text.\n\nI'd like you to make sure all the relevant measurements and parameters are easy to modify for each key type, so I can make further customizations later if I want to. I'm assuming you'll be creating all the files, so you'll need to create one for the main program, and any additional files required for the text and build plate libraries. I don't expect that the code for those libraries would be included here.\n\nTo reiterate, please provide complete code for each file. I'd like to avoid using `include` statements within the main program if possible, but I understand if they are required for the library files.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable chainmail bracelet",
    "scad": "use <utils/build_plate.scad>\nLength= 200;\nWidth= 2;\nRotation=45;\nThickness=2;\nSeparation=0.66;\nbuild_plate_selector = 3;\nbuild_plate_manual_x = 200;\nbuild_plate_manual_y = 200;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nScale=1.1*1;\nmaxx = round(Length/Scale/6.2-1.5);\nmaxy = Width;\nXw=Thickness;\nYw=Thickness;\n Bracelet();\nmodule Bracelet()\n{\n\trotate([0,0,Rotation]) translate([-0.5*Length+3.5,Width*-0.5*(5*Yw+4*Separation),0])  scale([Scale,Scale,Scale])\n\t\tunion()\n\t\t{\n\t\t\tband();\n\t\t\tclasp(\"left\");\n\t\t\ttranslate([(maxx-1)*7+6,maxy*4*(Yw+Separation)+2*Yw+Separation,0])\n\t\t\t\trotate([0,0,180])\n\t\t\t\t\tclasp(\"right\");\n\t\t}\n}\nmodule clasp(Type)\n{\n\tdifference()\n\t{\n\t\ttranslate([-9,Yw+Separation,0])\n\t\t\tcube(size=[11,maxy*4*(Separation+Yw)-Separation,3],center=false);\n\t\tif (Type==\"left\")\n\t\t{\n\t\t\ttranslate([-1.5,Yw+Separation-0.1,-0.1])\n\t\t\t\tscale([1,1,1.1]) rotate([-90,180,0])\n\t\t\t\t\tlinear_extrude(height = (maxy)*(4*Separation+4*Yw)-Separation-3, center = false, convexity = 3)\n\t\t\t\t\t\tpolygon(points=[[-0.5,0],[3,0],[4,1.5],[3,3],[-0.5,3],[0.5,1.5]] );\n\t\t\ttranslate([-1.5,Yw+Separation-0.1,-0.1])\n\t\t\t\tscale([1,1,1.1]) rotate([-90,180,0])\n\t\t\t\t\tlinear_extrude(height = (maxy)*(4*Separation+4*Yw)-Separation-3, center = false, convexity = 3)\n\t\t\t\t\t\tpolygon(points=[[5.2,3],[6.2,1.5],[5.2,0],[8,0],[8,3],[0,3]] );\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttranslate([-1.5,Yw+Separation-0.1,-0.1])\n\t\t\t\tscale([1.2,1,1.1]) rotate([-90,180,0])\n\t\t\t\t\tlinear_extrude(height = (maxy)*(4*Separation+4*Yw)-Separation-3, center = false, convexity = 3)\n\t\t\t\t\t\tpolygon(points=[[0,0],[3,0],[2,1.5],[3,3],[0,3],[-1,1.5]] );\n\t\t\ttranslate([-1.5,Yw+Separation-0.1,-0.1])\n\t\t\t\tscale([1.2,1,1.1]) rotate([-90,180,0])\n\t\t\t\t\tlinear_extrude(height = (maxy)*(4*Separation+4*Yw)-Separation-3, center = false, convexity = 3)\n\t\t\t\t\t\tpolygon(points=[[5,0],[4,1.5],[5,3],[20,3],[20,0]] );\n\t\t}\n\t\ttranslate([-10,0,-0.1])\n\t\t\tcube(size=[10,Yw+Separation-0.1+3+Separation,5],center=false);\n\t}\n}\nmodule band()\n{\n\tfor (y = [0:maxy-1])\n\t{\n\t\tfor (x = [0:maxx-1])\n\t\t{\n\t\t\tif (x!=maxx-1)\n\t\t\t{\n\t\t\t\tif (y!=0)\n\t\t\t\t\ttranslate([x*7,y*(4*Separation+4*Yw),0]) link();\n\t\t\t\telse\n\t\t\t\t\ttranslate([x*7,y*(4*Separation+4*Yw),0]) half_link();\n\t\t\t}\n\t\t\tif (x!=0)\n\t\t\t{\n\t\t\t\tif (y!=maxy-1)\n\t\t\t\t\ttranslate([x*7+6,y*(4*Separation+4*Yw)+(5*Separation+6*Yw),0]) rotate([0,0,180]) link();\n\t\t\t\telse\n\t\t\t\t\ttranslate([x*7+6,y*(4*Separation+4*Yw)+(5*Separation+6*Yw),0]) rotate([0,0,180]) half_link();\n\t\t\t}\n\t\t}\n\t}\n}\nmodule link()\n{\n\tdifference()\n\t{\n\t\ttranslate([2.1,0,0]) rotate([0,-40,0]) translate([-Xw,0,0])\n\t\t\tcube(size=[13,4*Yw+3*Separation,Xw],center=false);\n\t\ttranslate([0,0,0.26]) rotate([0,-40,0]) translate([Yw,Yw,-2.5*Xw])\n\t\t\tcube(size=[8,2*Yw+3*Separation,10],center=false);\n\t\ttranslate([0,Yw,1.2])\n\t\t\tcube(size=[12,2*Yw+3*Separation,5],center=false);\n\t\ttranslate([-1,-1,-4]) cube(size=[10,20,4],center=false);\n\t\ttranslate([-9.75,-1,-1]) cube(size=[10,20,5],center=false);\n\t\ttranslate([-1,-1,7.6]) cube(size=[13,20,4],center=false);\n\t\ttranslate([9.2,-1,-1]) cube(size=[10,20,15],center=false);\n\t}\n}\nmodule half_link()\n{\n\ttranslate([0,Yw+Separation,0]) difference()\n\t{\n\t\ttranslate([2.1,0,0]) rotate([0,-40,0]) translate([-Xw,0,0])\n\t\t\tcube(size=[13,3*Yw+2*Separation,Xw],center=false);\n\t\ttranslate([0,0,0.26]) rotate([0,-40,0]) translate([Yw,Yw,-2.5*Xw])\n\t\t\tcube(size=[8,1*Yw+2*Separation,10],center=false);\n\t\ttranslate([0,Yw,1.2])\n\t\t\tcube(size=[12,1*Yw+2*Separation,5],center=false);\n\t\ttranslate([-1,-1,-4]) cube(size=[10,20,4],center=false);\n\t\ttranslate([-9.75,-1,-1]) cube(size=[10,20,5],center=false);\n\t\ttranslate([-1,-1,7.6]) cube(size=[13,20,4],center=false);\n\t\ttranslate([9.2,-1,-1]) cube(size=[10,20,15],center=false);\n\t}\n}",
    "description": "Okay, I'd like to design a chainmail bracelet, but I need some help with the OpenSCAD code. I'm looking for something that's fully parametric, where I can easily control the length and width, as well as the ring thickness and spacing. \n\nHere's what I have in mind:\n\n*   **Bracelet Structure:** The bracelet should be made of interconnected, slightly angled, rectangular links, like a simplified chainmail. Each link should pass through the adjacent links in a repeating pattern, such as this: \"/ / / \\\\ \\\\ \\\\\"\n\n*   **Parameters:** I need to be able to control the following parameters:\n    *   `Length`: The total length of the bracelet in millimeters.\n    *   `Width`: The number of links across the width of the bracelet.\n    *   `Thickness`: The thickness of the material used for the rings.\n    *   `Separation`: The sideways separation between the rings\n    *   `Rotation`: The number of degrees to rotate the bracelet on the build platform\n    *    `build_plate_selector` and the manual `build_plate_manual_x` and `build_plate_manual_y` for different printer dimensions.\n\n*   **Clasp:** I'd like a simple clasp mechanism at each end of the bracelet. One side should have a protruding tab, and the other side a corresponding slot/opening to fit the tab. The clasp should be easily integrated with the bracelet and adjust to the width parameters.\n\n*   **Build Platform Considerations:** The design should include the `build_plate` function from the `utils/build_plate.scad` file, which allows me to set printer dimensions.\n\n*   **Customizability:** It should be straightforward to change the scale of the entire bracelet if needed.\n\nI'm hoping that the OpenSCAD code would automatically calculate the number of links based on the overall length and the size of individual links. Also I would like the option to rotate the object to make the print longer on smaller print plates.\n\nCould you generate the OpenSCAD code for this? I'd like it to be as clean and easy to understand as possible.\n"
  },
  {
    "object": "Hey cadmonkey, make me a RepRapPro Mendel Lugless Dial Indicator Holder",
    "scad": "Orientation=\"Sideways\";\nClamp=\"True\";\nUnits=1;\nStem_Diameter=8;\nBezel_Diameter=56;\nStem_Radius = Stem_Diameter * Units * 0.5;\nBezel_Radius = Bezel_Diameter * Units * 0.5;\nmodule block(){\n\tunion(){\n\t\ttranslate([-12,0,0])\n\t\tcube([30,15,15]);\n\t\ttranslate([-12,-17,0])\n\t\tcube([22,18,15]);\n\t\trotate(30,[1,0,0])\n\t\ttranslate([-12,-20,0])\n\t\tcube([22,20,15]);\n\t\ttranslate([-12,-42,-17])\n\t\tcube([22,25,17]);\n\t}\n}\nmodule mill(){\n\ttranslate([7.5,5,-2])\n\tcylinder(r=1.5,h=25,$fn=20);\n\ttranslate([-7.5,5,-2])\n\tcylinder(r=1.5,h=25,$fn=20);\n\ttranslate([-1,-30,-20])\n\tcylinder(r=Stem_Radius,h=40,$fn=20);\n\trotate(90,[0,1,0])\n\ttranslate([30-(2*Bezel_Radius),-30,0])\n\tcylinder(r=Bezel_Radius,h=25, center=true,$fn=30);\n\tif(Clamp==\"True\"){\n\t\ttranslate([-2,-54,-20])\n\t\tcube([2,25,25]);\n\t\trotate(90,[0,1,0])\n\t\ttranslate([10,-38,-20])\n\t\tcylinder(r=1.5,h=40,$fn=20);\n\t}else{\n\t\trotate(90,[0,1,0])\n\t\ttranslate([10,-30,-20])\n\t\tcylinder(r=1.5,h=40,$fn=20);\n\t}\n}\nmodule dialholder(){\n\tdifference(){\n\t\tblock();\n\t\tmill();\n\t}\n}\nif(Orientation==\"Sideways\"){\n\trotate(-90,[0,1,0])\n\ttranslate([12,0,0])\n\tdialholder();\n}else{\n\ttranslate([0,0,17])\n\tdialholder();\n}",
    "description": "Okay, I'm looking to design a holder for a dial indicator, specifically one without lugs, that I can attach to my RepRapPro Mendel Mono 3D printer. I need it to be parametric so I can adjust it for different dial sizes. I have a design in mind, but I need help putting it into a usable OpenSCAD file.\n\nHere's what I'm envisioning:\n\n*   **Overall Structure:** The holder should have a kind of 'block' base with a 'mill' that cuts out spaces for the dial and its stem. The block will be kind of stepped, with a base, a middle section, and then an angled part, finally ending with another base that supports the dial. This will be mostly rectangular prism shapes combined using the `union()` module.\n\n*   **Dial and Stem Mounting:** I need a hole for the stem to pass through. This hole will be a cylinder. I also need a larger cylindrical cutout for the bezel of the dial indicator to sit in. These will be created with the `cylinder()` module.\n\n*   **Clamp Option:**  I want the option to include a small clamp to secure the dial indicator in place. This clamp, if enabled, should be a small cube that intersects with the side of the stem hole and have an additional cylindrical hole for a small screw. If the clamp is not enabled there will be an additional cylindrical hole for a screw for the same purpose but without the block.\n\n*   **Parametric Design:**  I need parameters to control the following:\n    *   **`Orientation`:** To choose between \"Upright\" and \"Sideways\".  This affects how the main body is rotated.\n    *   **`Clamp`:** A boolean to enable or disable the clamp (it looks like true/false is good).\n    *   **`Units`:** To use either millimeters or inches (specifically 1 for mm, 25.4 for inches).\n    *   **`Stem_Diameter`:**  The diameter of the dial indicator's stem (where it goes into the hole.)\n    *   **`Bezel_Diameter`:** The diameter of the dial indicator's bezel (the outer ring).\n\n*   **Positioning:** I need the basic position and dimensions of the block to be similar to the example .scad I provided (I can give you more context if needed), such as the base shapes being at offsets of approximately [-12,0,0], [-12,-17,0], [-12,-20,0], and [-12,-42,-17] with the mill cutouts appropriately placed to interact. I'd like the 'block' and 'mill' modules to be defined, then combined in a `dialholder` module using a `difference()`. The rotation for the Sideways orientation should be -90 deg around the y axis and translate of [12,0,0]\n\n*   **Library:** I'm expecting this to be written in standard OpenSCAD; I am not expecting any external libraries.\n\nBasically, I need an OpenSCAD file that replicates the functionality and structure of my example file, but with all the correct parameterization I specified. Can you please provide the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Pill cutting base",
    "scad": "pd=9.6;\npt=4.2;\npt2=2.6;\npart=\"top\";\npc=(pt-pt2)/2;\nsp=pd/(tan(2*atan(2*pc/pd))*2)+pd;\nbh=pt/2+1;\nmodule pill()\n{\nrotate([0,0,0])intersection(){\ncylinder(h=10,r=pd/2+0.5,center=true,$fn=48);\ntranslate([0,0,-sp+(pt2-0.5)])sphere(r=sp+0.5,center=true,$fn=96);\ntranslate([0,0,sp-(pt2-0.5)])sphere(r=sp+0.5,center=true,$fn=96);\n\t\t\t\t\t\t\t\t}\n}\nmodule post()\n{\ntranslate([21,21,bh/2])cube(size=[5,5,bh*2], center=true);\ntranslate([-21,21,bh/2])cube(size=[5,5,bh*2], center=true);\ntranslate([-21,-21,bh/2])cube(size=[5,5,bh*2], center=true);\ntranslate([21,-21,bh/2])cube(size=[5,5,bh*2], center=true);\n}\nunion(){\nif(part==\"pill\") {\n\t\ttranslate([0,0,0])pill();\n\t\t\t\t }\n\t\telse if (part==\"bottom\"){\nunion(){\ndifference(){\ncube(size=[46,46,bh], center=true);\ntranslate([0,0,pt/2])pill();\ntranslate([-0.4,-20.5,-1])cube(size=[0.8,41,20], center=false);\ntranslate([-20.5,-0.4,-1])cube(size=[41,0.8,20], center=false);\n\t\t\t}\npost();\n\t\t}\n\t\t\t\t\t}\n\t\t\t\telse if (part==\"top\"){\ntranslate([0,0,0]){\ndifference(){\n\t\tcube(size=[44,44,bh], center=true);\n\t\ttranslate([0,0,pt/2])pill();\n\t\ttranslate([-0.4,-20.5,-10])cube(size=[0.8,41,20], center=false);\n\t\ttranslate([-20.5,-0.4,-10])cube(size=[41,0.8,20], center=false);\n\t\ttranslate([0,0,-4])rotate([0,45,0])cube(size=[5,41,5], center=true);\n\t\ttranslate([0,0,-4])rotate([45,0,0])cube(size=[41,5,5], center=true);\n\t\ttranslate([0,0,-pt])scale([0.95,0.95,2])post();\n\t\t\t}\n\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t}",
    "description": "Okay, so I'm trying to design a pill cutter in OpenSCAD, and I'm running into some issues with the current design. I've got a basic structure working, but it's not quite cutting the pill properly, and I'd really like a more robust, parametric design.\n\nHere's a breakdown of what I need, and some of the issues I'm having:\n\n**Core Functionality:**\n\n*   **Pill Cavity:** The design needs a cavity to hold the pill. This cavity should accommodate pills of varying sizes. I need to define the pill diameter (`pd`), the total pill height which includes convex curve (`pt`), and the cylindrical height of the pill, which doesn't include convex curve (`pt2`). The design should calculate the size of the convex curve from these.\n\n*   **Cutting Mechanism:** The cutting action is achieved by pressing the pill into a sharp edge in a \"top\" part, which is mirrored in the bottom part to hold pill. Currently it uses some cubes for this which is not perfect. I need a proper cutting edge shape, perhaps a rounded edge.\n\n*   **Two-Part Design:** The cutter is composed of a top and bottom part. Both have similar outer shape, and both have a cavity for pill. The top part has an extrusion to press on pill, and bottom is just a simple flat base that support the pill.\n\n*   **Parametric:** I want the design to be completely parametric, meaning I can easily adjust pill size parameters and the whole cutter scales automatically.\n\n**Specific Parameters I Need:**\n\n*   `pd`: Pill diameter.\n*   `pt`: Total pill height which includes convex curve.\n*    `pt2`: Cylindrical pill height (without convex curve).\n\n*   `bh`: Base height of each part. It could be linked to `pt` value somehow.\n*   Possibly the size of the cutting edge.\n\n**Problems with my current design:**\n\n*   **Convex curve calculation:** I'm not sure if my current calculation for the sphere sizes for the pill cavity is correct. It looks okay but the geometry can be improved.\n*   **Cutting edge**: The cutting edge implemented with cubes is not very smooth, and the shape could be better.\n*   **Parametric scaling**: The size of the posts are not scaling with other parameters.\n*   **Overall robustness**: The model doesn't feel very solid. I'd like some nice, chamfered edges on the outside and the model needs to hold tightly.\n\n**Desired Improvements:**\n\n*   **Proper Spherical Cavity:** Create a smooth, mathematically accurate spherical cavity for the pill based on the `pd`, `pt`, and `pt2` parameters.\n*   **Clean Cutting Edge:** Implement a better cutting edge that is not just cubes. \n*   **Robust Design:** Ensure the overall design is solid and fits together nicely, perhaps with registration features to keep the top and bottom aligned.\n*   **Chamfers/Fillets:** Add chamfers to the exterior edges to make the model look and feel nicer.\n*   **Parametric Posts/Alignment Features**: Make the posts or other alignment features scale with the overall size of the cutter.\n*   **Optional Locking Feature**: Include or have option to include a simple locking mechanism to keep it closed during storage, perhaps using pegs.\n*   **Clearance** Add a clearance between the top and bottom for easy assembling.\n\n**Specific OpenSCAD Library:**\n*    I want the code to utilize the `BOSL2` library for things like parametric shapes, chamfers, and registration features. If there is a better option please use that.\n\nCould you please provide me with an OpenSCAD file that implements this? I'm looking for something well-structured and easy to customize. Also, I'm okay with not having a locking mechanism initially, and can always add one later.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Roller bearing",
    "scad": "OuterDiameter=60;\nInnerDiameter=10;\nInnerCorners=6;\nNumberOfPlanets=7;\nThickness=10;\nTolerance=.15;\ndifference(){\nMakeWheel((OuterDiameter-InnerDiameter)*0.2+InnerDiameter-Tolerance*2,-Thickness,Thickness);\ncylinder(r=InnerDiameter/2+Tolerance,h=Thickness,$fn=InnerCorners);\n}\ndifference(){\ncylinder(r=OuterDiameter/2-Tolerance,h=Thickness);\nMakeWheel((OuterDiameter-InnerDiameter)*0.8+InnerDiameter+Tolerance*2,Thickness,Thickness);\n}\nfor(i=[1:NumberOfPlanets]){\nrotate([0,0,i*360/NumberOfPlanets])\ntranslate([((OuterDiameter-InnerDiameter)*0.5+InnerDiameter)/2,0,0]) MakeWheel((OuterDiameter-InnerDiameter)*0.3-Tolerance*2,Thickness,Thickness);\n}\nmodule MakeWheel(Diameter,Rim,Thickness)\n{\n$fn=60;\nunion(){\ncylinder(r1=Diameter/2-Rim*0.1,r2=Diameter/2,h=Thickness*0.1);\ntranslate([0,0,0.1*Thickness]) cylinder(r=Diameter/2,h=Thickness*0.8);\ntranslate([0,0,0.9*Thickness]) cylinder(r2=Diameter/2-Rim*0.1,r1=Diameter/2,h=Thickness*0.1);\n}\n}",
    "description": "Okay, so I've been playing around with making a roller bearing in OpenSCAD, and I've got a decent start, but it's got a significant issue. I found this gear bearing on Thingiverse (http://www.thingiverse.com/thing:53451) and wanted to try a roller version. The current design uses a central sun gear, an outer ring, and a number of cylindrical rollers (planets) in between. It's basically three concentric parts: the inner gear with a hexagonal core, an outer ring that's a simple cylinder, and the rollers in between. I've got it mostly working but the rollers tend to spin around their own axes when the bearing turns, which isn't ideal.\n\nI've included my current OpenSCAD code below:\n\n```\n//Roller Bearing\n// (C) 2013 Wouter Robers \n\nOuterDiameter=60;\nInnerDiameter=10;\nInnerCorners=6;\nNumberOfPlanets=7;\nThickness=10;\nTolerance=.15;\n\n//Sun\n\ndifference(){\nMakeWheel((OuterDiameter-InnerDiameter)*0.2+InnerDiameter-Tolerance*2,-Thickness,Thickness);\ncylinder(r=InnerDiameter/2+Tolerance,h=Thickness,$fn=InnerCorners);\n}\n\n\n//Outer Ring\n\ndifference(){\ncylinder(r=OuterDiameter/2-Tolerance,h=Thickness);\nMakeWheel((OuterDiameter-InnerDiameter)*0.8+InnerDiameter+Tolerance*2,Thickness,Thickness);\n}\n\n\n// Planets\n\nfor(i=[1:NumberOfPlanets]){\nrotate([0,0,i*360/NumberOfPlanets])\ntranslate([((OuterDiameter-InnerDiameter)*0.5+InnerDiameter)/2,0,0]) MakeWheel((OuterDiameter-InnerDiameter)*0.3-Tolerance*2,Thickness,Thickness);\n}\n\n\n\n\nmodule MakeWheel(Diameter,Rim,Thickness)\n{\n$fn=60;\nunion(){\ncylinder(r1=Diameter/2-Rim*0.1,r2=Diameter/2,h=Thickness*0.1);\ntranslate([0,0,0.1*Thickness]) cylinder(r=Diameter/2,h=Thickness*0.8);\ntranslate([0,0,0.9*Thickness]) cylinder(r2=Diameter/2-Rim*0.1,r1=Diameter/2,h=Thickness*0.1);\n}\n}\n```\n\nThe *MakeWheel* module makes the sun, the outer ring, and the rollers. Its basically a fancy cylinder with slightly different radii at the top and bottom, almost like a spool.\n\n**Here's what I'd like help with**:\n\nI want a more robust and parametric roller bearing design, specifically:\n\n1.  **Roller Stability:** I need a way to keep the rollers from turning on their own axis and make them only revolve around the center. Maybe some sort of cage system? I'm open to suggestions on the best way to do that.\n2.  **Parametric Design:**\n    *   I need to be able to easily adjust the Outer Diameter, Inner Diameter, Number of Rollers, Thickness of the bearing, and a general Tolerance value for all parts.\n    *   Id also like to make the rim height in the MakeWheel function parametric.\n    *   Id like to be able to control the core shape of the inner race (sun), currently I have a hexagon, but I would like to be able to choose how many sides, or perhaps have a circular core (or even a custom shape).\n3.  **Modular Construction:** It would be great if the design is easily modifiable and if the parts (sun, rollers, cage, outer race) are defined by their own modules, rather than being included in one large module. That would make it easier to modify, and it might make using the design with different kinds of rollers easier.\n4. **Clearance for Cage:** If we are going to be adding a cage, there will need to be added clearance. All tolerances need to be easily adjusted.\n5. **Clear Variable Names:** In my code, the variables arent always super clear, I need clear names to make things easier.\n\nI'm not sure which OpenSCAD libraries to use, but I am open to using them if they will make this easier. It looks like BOSL2 has features that would be helpful, though if there are other libraries or methods that are easier, I am open to that as well. I dont mind a lot of detail, as I am here to learn.\n\nCan you generate a parametric OpenSCAD file that incorporates these changes and provides a stable roller bearing design? I am not sure what the best method for implementing a cage system is, so please give that some thought.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable LCD Box",
    "scad": "box_length = 160;\nbox_width = 80;\nscreen_length = 100;\nscreen_width = 40;\nwall_thickness = 5;\nwall_height = 30;\ngenerate_top = \"yes\";\nwall_offset = wall_thickness / 2;\nscreen_offset_y = (box_length - screen_length) / 2;\nscreen_offset_x = (box_width - screen_width) / 2;\nmodule lcdbox()\n{\n\tmodule screen()\n\t{\n\t\ttranslate([screen_offset_x,screen_offset_y,-5])\n\t\tcube([screen_width,screen_length,30]);\n\t}\n\tmodule holder()\n\t{\n\t\tcube([box_width,box_length,wall_thickness]);\n\t}\n\tmodule sidewalls()\n\t{\n\t\tdifference()\n\t\t{\n\t\t\ttranslate([0,0,wall_thickness]) cube([box_width,box_length,wall_height]);\n\t\t\ttranslate([wall_offset,wall_offset,-5]) cube([box_width-wall_thickness,box_length-wall_thickness,wall_height+20]);\n\t\t}\n\t}\n\tunion()\n\t{\n\t\tsidewalls();\n\t\tdifference()\n\t\t{\n\t\t\tholder();\n\t\t\tscreen();\n\t\t}\n\t}\n}\nmodule lcdbottom()\n{\n\ttranslate([-100,0,0])\n\tcube([box_width, box_length,wall_thickness]);\n\ttranslate([-100+wall_offset,wall_offset,wall_thickness])\n\tcube([box_width-wall_thickness,box_length-wall_thickness,wall_thickness]);\n}\nlcdbox();\nif (generate_top == \"Yes\")\n{\n\tlcdbottom();\n}",
    "description": "Okay, I need help creating a parametric LCD enclosure in OpenSCAD. I'm aiming for a simple box design, with a cutout to fit an LCD screen, and an optional lid. I'd like to be able to adjust several key dimensions, like the overall box size, the size and position of the screen cutout, the wall thickness, and the height of the box. \n\nHere's a more specific breakdown of the features I want:\n\n*   **Box Dimensions:** I need to be able to set the overall length and width of the box. Let's call these `box_length` and `box_width`. These should define the *outer* dimensions of the box.\n*   **Screen Cutout:**  The box needs a rectangular cutout for the LCD screen. I want to specify the length and width of this cutout ( `screen_length` and `screen_width`).  I also want to be able to control its position within the box. Let's use `screen_offset_x` and `screen_offset_y` to control the position, measured from the *inner* edge of the box. \n*   **Wall Thickness:** The thickness of the box walls should be adjustable. Let's call this `wall_thickness`. This should apply to all walls (front, back, sides).\n*   **Wall Height:** I need to be able to set the height of the sidewalls, let's call this `wall_height`.\n*   **Optional Lid:** I'd like an option to generate a lid for the box. This should be a flat piece that matches the box's outer dimensions, and will also have a matching cutout. I'd prefer a variable to enable and disable this, such as `generate_top`, with the options \"yes\" or \"no\".\n\nI would like the final code to be self-contained, without requiring any external .scad files or libraries.\n\nCould you generate the OpenSCAD code for me? I'm not looking for anything super complex, just a good starting point for a simple and customizable box.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Thumb Piano",
    "scad": "use <utils/build_plate.scad>;\nprint_sound_board=\"no\";\nprint_sound_box=\"no\";\nprint_sound_box_socket=\"no\";\nprint_tines=\"yes\";\ntine_length=75;\ntine_width=4;\ntine_gap=1.5;\ntine_number=8*1;\nbuild_plate(3,230,200);\nif (print_tines==\"yes\") {\ntranslate([-((tine_number+1)*(tine_width+tine_gap))/2,0,0]) cube([(tine_number+1)*(tine_width+tine_gap),6,6]);\ntranslate([-20,0,6]) cube([40,4,4]);\nlinear_extrude(height=2) {\ntranslate([0,6,0]) square([tine_width/2,tine_length]);\ntranslate([tine_width/2+tine_gap,6,0]) square([tine_width,tine_length*sqrt(8/9)]);\ntranslate([tine_width/2+tine_width+2*tine_gap,6,0]) square([tine_width,tine_length*sqrt(3/4)]);\ntranslate([tine_width/2+2*tine_width+3*tine_gap,6,0]) square([tine_width,tine_length*sqrt(3/5)]);\ntranslate([tine_width/2+3*tine_width+4*tine_gap,6,0]) square([tine_width,tine_length*sqrt(1/2)]);\nmirror([1,0,0]) {\ntranslate([0,6,0]) square([tine_width/2,tine_length]);\ntranslate([tine_width/2+tine_gap,6,0]) square([tine_width,tine_length*sqrt(4/5)]);\ntranslate([tine_width/2+tine_width+2*tine_gap,6,0]) square([tine_width,tine_length*sqrt(2/3)]);\ntranslate([tine_width/2+2*tine_width+3*tine_gap,6,0]) square([tine_width,tine_length*sqrt(8/15)]);\n}\n}\n}\nif (print_sound_board==\"yes\") {\ndifference() {\ntranslate([1,-85,0])\ncube([100,80,3]);\nunion() {\ntranslate([15,-66,0])\ncube([4,40,4]);\ntranslate ([75,-45,0]) cylinder(4,15,15);\n}\n}\ntranslate([3,-83,3]) linear_extrude(height=3) difference() {\nsquare([96,76]);\ntranslate([1.5,1.5,0]) square([93,73]);\n}\n}\nif (print_sound_box==\"yes\") {\ntranslate([-101,-85,0])\ndifference() {\ncube([100,80,40]);\nunion() {\ntranslate([2,2,2]) cube([96,76,50]);\nif (print_sound_box_socket==\"yes\") {\ntranslate([-4,20,20]) rotate([0,90,0]) cylinder(8,5.5,5.5);\n}\n}\n}\n}",
    "description": "Okay, so I've got this OpenSCAD file for a thumb piano, and I'd like to make it more customizable and easier to understand. I'm thinking it needs a complete overhaul, but I want to keep the same basic idea.\n\nHere's what I have (and some of my thoughts on what I'd like to change):\n\nThe original design has these parts that can be printed: the tines (the metal bits that you pluck), a sound board, and a sound box, and a socket on the soundbox for an amplifier jack, but they're all optional.  I like being able to choose which parts to print but the code is a bit hard to follow.\n\nThe tines are generated using a `linear_extrude` with carefully calculated lengths, but it's all kind of buried in there with `translate` calls. I'd like a more parametric approach, maybe using modules, so I could easily change the number of tines, spacing, and so on. And I'd really like to be able to specify the notes and not just rely on the current scale math built in there, including changing tunings and scales. I want to be able to enter the desired frequency for each tine or the tuning interval, instead of the relative length.\n\nThe sound board and sound box are basic shapes that could be easily customized and it would be nice to have some options for the style (e.g. rounded corners, a more stylized shape).\n\nHere's what I'm looking for in the new parametric OpenSCAD file:\n\n1.  **Clear Module Structure:** I want well-defined modules for the tines, the sound board, and the sound box.\n2.  **Tine Customization:**\n    *   A module to create a single tine, taking length, width, and position as parameters, and ideally frequency or the interval from a base note.\n    *   A parameter to determine how many tines there are.\n    *   A parameter to control the gap between tines.\n    *   A parameter for the base tine length.\n    *   An option to define the frequency, note name, or interval of each tine explicitly.\n    *   Option for using a standard tuning (e.g. 12-TET) for frequency math\n    *   Option to define tuning in cents or interval\n    *   Option to set a global tuning frequency (A4 = 440Hz, for example)\n    *   Option to define which note each tine should be\n3.  **Sound Board Customization:**\n    *   Parameters for the sound board's width, length, and thickness.\n    *   Options for mounting/attachment points, maybe with a parameter to specify the size and position.\n    *   Option for corner radius\n4.  **Sound Box Customization:**\n    *   Parameters for the sound box's overall dimensions and wall thickness.\n    *   An option to include the socket hole for an amplifier plug, with size and position parameters, and options for different socket sizes (e.g. 3.5mm).\n    *   Option for rounding corners\n5.  **Print Options:**\n    *   I'd like to keep the ability to easily choose which parts to print, using variables or parameters for each component (tines, sound board, sound box).\n6.  **Libraries:**\n    *  I know there is a build_plate module in this design, so make sure to include that.\n    *  I am okay with any libraries that seem reasonable. (but not too many, I want to keep the core parametric). I know there are many math libraries for OpenSCAD, I am okay with using one of those. Please let me know which libraries you will use in the response.\n7.  **Comments:** I would like all of the code to be well commented to explain the function of different parts of the design.\n\nEssentially, I want to be able to easily create different thumb pianos by changing a few parameters, including the notes, shape and overall dimensions. I would also appreciate a good explanation of the provided code.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Half Letter/A5 bookbinding",
    "scad": "use<Write.scad>\ninclude <write/Write.scad>\na4m = 32.02;\nx_m = 15;\nxsu=x_m-1.6;\nlt=x_m-9.6;\nlta=lt/2;\nmessage = \"Volume I\";\nrotate([0,0,90])translate([-50,-50,0])\n{\n\tdifference()\n\t{\n\t\tcube([24,2*a4m+83.95,3]);\n\t\ttranslate([11.13,a4m,-1])cube([1.74,4.9,5]);\n\t\ttranslate([10.03,a4m,1.5])cube([3.94,3.85,2]);\n\t\ttranslate([10.03,a4m+4.85,-1])cube([3.94,3.75,5]);\n\t\ttranslate([10.03,a4m+4.85,1.5]) rotate([79,0,0]) cube([3.94,3.75,4]);\n\t\ttranslate([11.13,a4m+80.11,-1])cube([1.74,4.9,5]);\n\t\ttranslate([10.03,a4m+80.11,1.5])cube([3.94,3.85,2]);\n\t\ttranslate([10.03,a4m+4.85+80.11,-1])cube([3.94,3.75,5]);\n\t\ttranslate([10.03,a4m+4.85+80.11,1.5]) rotate([79,0,0]) cube([3.94,3.75,4]);\n\t}\n\ttranslate([30,0,0])\n\t{\n\t\tdifference()\n\t\t{\n\t\tcube([24,2*a4m+83.95,3]);\n\t\ttranslate([7.9,a4m,1.5])cube([8.2,3.85,2]);\n\t\ttranslate([10.03,a4m,-1])cube([3.95,3.85,5]);\n\t\ttranslate([7.9,a4m+80.11,1.5])cube([8.2,3.85,2]);\n\t\ttranslate([10.03,a4m+80.11,-1])cube([3.95,3.85,5]);\n\t\t}\n\t\tdifference()\n\t\t{\n\t\ttranslate([24,0,0])cube([lt+6,2*a4m+83.95,1]);\n\t\ttranslate([24,-1,0.6]) rotate([0,-8,0]) cube([4,2*a4m+85.95,4]);\n\t\ttranslate([24+lt+6,-1,0.6]) rotate([0,-82,0]) cube([4,2*a4m+85.95,4]);\n\t\ttranslate([27,3,0.6]) cube([lt,2*a4m+77.95,4]);\n\t\t}\n\t\tdifference()\n\t\t{\n\t\ttranslate([30+lt,0,0]) cube([24,2*a4m+83.95,0.6]);\n\t\ttranslate([40.03+lt,a4m,-1]) cube([3.85,3.95,2]);\n\t\ttranslate([40.03+lt,a4m+80.11,-1]) cube([3.85,3.95,2]);\n\t\t}\n\t\tunion() {\n\t\ttranslate([29.5+lta,4.5,.5]) rotate([0,0,90]) write(message,h=5,t=.6,space=1.5);\n\t\t}\n\t}\n}\nrotate([0,0,90])translate([-50,-100,0])\n{\n\t\tdifference()\n\t\t{\n\t\tcube([x_m,8,3.74]);\n\t\ttranslate([-.01,-.01,-.01])cube([xsu,2.14,4]);\n\t\ttranslate([-.01,5.87,-.01])cube([xsu,2.14,4]);\n\t\ttranslate([1.5,2.09,-.01])cube([1.73,1.1,4]);\n\t\ttranslate([1.5,4.87,-.01])cube([1.73,1.01,4]);\n\t\t}\n\t\ttranslate([0,20,0])difference()\n\t\t{\n\t\tcube([x_m,8,3.74]);\n\t\ttranslate([-.01,-.01,-.01])cube([xsu,2.14,4]);\n\t\ttranslate([-.01,5.87,-.01])cube([xsu,2.14,4]);\n\t\ttranslate([1.5,2.09,-.01])cube([1.73,1.1,4]);\n\t\ttranslate([1.5,4.87,-.01])cube([1.73,1.01,4]);\n\t\t}\n}",
    "description": "Okay, I'm looking to create a customizable bookbinding for either A5 or half-letter sized paper, and I need an OpenSCAD file to do this. The design is based on a model I found, but I want to make it fully parametric so I can easily adjust it for different paper thicknesses and potentially other sizes in the future.\n\nHere's what I need:\n\n**Overall Design:**\n\n*   The binding should consist of two main parts: a \"key\" that locks the binding and a flexible back piece that holds the pages.\n*   The binding should accommodate standard hole spacing of 80mm.\n*   The design should include holes for the paper, with appropriate clearance for the pins and a way to lock the paper in place.\n*  There should be space on the spine of the flexible back piece for a text label.\n\n**Parametric Requirements:**\n\n1.  **Paper Size:**\n    *   I need a parameter, let's call it `paper_type`, to switch between A5 and Half Letter paper sizes. A5 is 148mm x 210mm and half letter is 140 x 216 mm, and the code should use the height of the paper in its design.\n    * The `paper_type` parameter should automatically set the correct value for a variable that defines the paper's height. I think the original code used a variable called `a4m`.\n\n2.  **Paper Thickness:**\n    *   I need a parameter to define the thickness of the paper stack, which will determine the width of the spine. I'll call this parameter `paper_thickness_mm` .\n    *   I need parameters, based on `paper_thickness_mm`, to set the width of both the axes and the flexible back (like the variables xsu, and lt in the example code) .\n\n3.  **Text on the Spine:**\n    *   I need a parameter to define the text string that is written on the spine. Let's call it `spine_text`.\n    *   I need to be able to set the size and thickness of the text, and its vertical offset.\n    *   I'd like to use the \"Write.scad\" library for text, so the design should work with that library, including the `h` and `t` parameters to control text size and thickness.\n\n4.  **General Dimensions:**\n\n    *   The overall length of the key and back piece should be determined based on the `a4m` variable.\n    *   The positions of the holes should be relative to the center of the paper's height, and should remain 80mm apart.\n\n5.  **Text Position**\n     *  The text should be placed centrally on the spine, horizontally (between the edges of the spine), and offset vertically from the bottom edge of the spine piece.\n\n6. **Hole Clearance**\n    * The code should expose parameters to adjust the diameter of the holes in the binding to accommodate different types of locking mechanism.\n\n**Libraries:**\n\n*   The design should use the `Write.scad` library, but I don't need you to create the library file.\n\n**Output:**\n\n*   I need a single OpenSCAD file that incorporates all of these parametric features.\n\nCan you generate an OpenSCAD file based on these requirements?\n"
  },
  {
    "object": "Hey cadmonkey, make me a DIY melody strips creator",
    "scad": "$fn=10*1;\nSongPicker = \"Star-Spangled Banner\";\nNoteString = \"c101|d102|e103|f104|g105|a106|b107|c208|d209|e210|f211|g212|a213|b214|c315|\";\nLayerThickness = 0.4;\nStripeWidth = 42;\nStripeLength = 90;\nMarginLeft = 5;\nBeatDistance = 3.5;\nToneDistance = 2;\nStart( );\nmodule Start()\n{\nNoteString_AmericanAnthem = \"a101|f103|d104|f106|d106|a108|e108|d210|d110|f113|f214|f114|e215|f115|d216|f116|f118|d118|g120|d120|a122|c122|\";\nif( SongPicker == \"Star-Spangled Banner\")\n\tBuildStripe(NoteString_AmericanAnthem);\nelse if (SongPicker == \"Note-String\")\n\tBuildStripe(NoteString);\n}\nmodule BuildStripe(NoteStringLocal){\n\ttakte=search(\"|\",NoteStringLocal,1000)[0];\n\tdifference()\n\t{\n\t\tBuildBase();\n\t\tfor(i=[0:len(takte)-1])\n\t\t{\n\t\t\tprintNote(str(NoteStringLocal[takte[i]-2],NoteStringLocal[takte[i]-1]), str(NoteStringLocal[takte[i]-4],NoteStringLocal[takte[i]-3]));\n\t\t}\n\t}\n}\nmodule printNote(takt,note)\n{\n\tif (takt == \"01\")\n\t\tprintNote2(1,note);\n\telse if (takt == \"02\")\n\t\tprintNote2(2,note);\n\telse if (takt == \"03\")\n\t\tprintNote2(3,note);\n\telse if (takt == \"04\")\n\t\tprintNote2(4,note);\n\telse if (takt == \"05\")\n\t\tprintNote2(5,note);\n\telse if (takt == \"06\")\n\t\tprintNote2(6,note);\n\telse if (takt == \"07\")\n\t\tprintNote2(7,note);\n\telse if (takt == \"08\")\n\t\tprintNote2(8,note);\n\telse if (takt == \"09\")\n\t\tprintNote2(9,note);\n\telse if (takt == \"10\")\n\t\tprintNote2(10,note);\n\telse if (takt == \"11\")\n\t\tprintNote2(11,note);\n\telse if (takt == \"12\")\n\t\tprintNote2(12,note);\n\telse if (takt == \"13\")\n\t\tprintNote2(13,note);\n\telse if (takt == \"14\")\n\t\tprintNote2(14,note);\n\telse if (takt == \"15\")\n\t\tprintNote2(15,note);\n\telse if (takt == \"16\")\n\t\tprintNote2(16,note);\n\telse if (takt == \"17\")\n\t\tprintNote2(17,note);\n\telse if (takt == \"18\")\n\t\tprintNote2(18,note);\n\telse if (takt == \"19\")\n\t\tprintNote2(19,note);\n\telse if (takt == \"20\")\n\t\tprintNote2(20,note);\n\telse if (takt == \"21\")\n\t\tprintNote2(21,note);\n\telse if (takt == \"22\")\n\t\tprintNote2(22,note);\n\telse if (takt == \"23\")\n\t\tprintNote2(23,note);\n\telse if (takt == \"24\")\n\t\tprintNote2(24,note);\n\telse if (takt == \"25\")\n\t\tprintNote2(25,note);\n\telse if (takt == \"26\")\n\t\tprintNote2(26,note);\n\telse if (takt == \"27\")\n\t\tprintNote2(27,note);\n\telse if (takt == \"28\")\n\t\tprintNote2(28,note);\n\telse if (takt == \"29\")\n\t\tprintNote2(29,note);\n\telse if (takt == \"30\")\n\t\tprintNote2(30,note);\n\telse if (takt == \"31\")\n\t\tprintNote2(31,note);\n\telse if (takt == \"32\")\n\t\tprintNote2(32,note);\n\telse if (takt == \"33\")\n\t\tprintNote2(33,note);\n\telse if (takt == \"34\")\n\t\tprintNote2(34,note);\n\telse if (takt == \"35\")\n\t\tprintNote2(35,note);\n\telse if (takt == \"36\")\n\t\tprintNote2(36,note);\n\telse if (takt == \"37\")\n\t\tprintNote2(37,note);\n\telse if (takt == \"38\")\n\t\tprintNote2(38,note);\n\telse if (takt == \"39\")\n\t\tprintNote2(39,note);\n\telse if (takt == \"40\")\n\t\tprintNote2(40,note);\n\telse if (takt == \"41\")\n\t\tprintNote2(41,note);\n\telse if (takt == \"42\")\n\t\tprintNote2(42,note);\n\telse if (takt == \"43\")\n\t\tprintNote2(43,note);\n\telse if (takt == \"44\")\n\t\tprintNote2(44,note);\n\telse if (takt == \"45\")\n\t\tprintNote2(45,note);\n\telse if (takt == \"46\")\n\t\tprintNote2(46,note);\n\telse if (takt == \"47\")\n\t\tprintNote2(47,note);\n\telse if (takt == \"48\")\n\t\tprintNote2(48,note);\n\telse if (takt == \"49\")\n\t\tprintNote2(49,note);\n\telse if (takt == \"50\")\n\t\tprintNote2(50,note);\n\telse\n\t\tprintNote2(10,note);\n}\nmodule printNote2(takt,note)\n{\n\tif (note == \"c1\")\n\t\tMakeHole(takt,1);\n\telse if (note == \"d1\")\n\t\tMakeHole(takt,2);\n\telse if (note == \"e1\")\n\t\tMakeHole(takt,3);\n\telse if (note == \"f1\")\n\t\tMakeHole(takt,4);\n\telse if (note == \"g1\")\n\t\tMakeHole(takt,5);\n\telse if (note == \"a1\")\n\t\tMakeHole(takt,6);\n\telse if (note == \"b1\")\n\t\tMakeHole(takt,7);\n\telse if (note == \"c2\")\n\t\tMakeHole(takt,8);\n\telse if (note == \"d2\")\n\t\tMakeHole(takt,9);\n\telse if (note == \"e2\")\n\t\tMakeHole(takt,10);\n\telse if (note == \"f2\")\n\t\tMakeHole(takt,11);\n\telse if (note == \"g2\")\n\t\tMakeHole(takt,12);\n\telse if (note == \"a2\")\n\t\tMakeHole(takt,13);\n\telse if (note == \"b2\")\n\t\tMakeHole(takt,14);\n\telse if (note == \"c3\")\n\t\tMakeHole(takt,15);\n}\nmodule BuildBase(){\n\tcube([StripeWidth,StripeLength,LayerThickness]);\n}\nmodule MakeHole(beatNumber,pitchNumber){\n\tY = MarginLeft + (beatNumber * BeatDistance);\n\tX = StripeWidth - MarginLeft - (pitchNumber * ToneDistance) + 1;\n\ttranslate([X,Y,-1]) cylinder(h=LayerThickness*20,r=1);\n}",
    "description": "Okay, I'd like to create a parametric OpenSCAD model for a music box strip, similar to the one described in the provided code. The idea is to generate a strip with holes that correspond to musical notes and their timings, which can then be used with a DIY music box mechanism.\n\nHere's what I'm looking for in the parametric design:\n\n**Core Functionality:**\n\n1.  **Note Input:** The design should accept a string input that defines the notes and their timing. This string would be structured as: `notebeat|notebeat|...`, where `note` is a two-character code representing the musical note (e.g., c1, d1, e1...b1,c2...c3) and `beat` is a two-digit number representing the beat at which the note should occur (e.g., 01, 02, 03...). So, for example, `c101|d102|e103|` would mean a C1 on beat 1, a D1 on beat 2 and an E1 on beat 3.\n2.  **Predefined Songs:** It should also be possible to select from pre-defined note strings for common songs like the \"Star-Spangled Banner\" (Note: I can give you the specific note string later if needed). It should default to the user defined Note-String if no song is selected.\n3. **Note String Helper:** The design should include instructions for using a note string helper like the one linked in the description.\n\n**Parameters:**\n\n*   **`LayerThickness`:**  The thickness of the strip. Should have a default of 0.4mm, with the understanding that it shouldn't exceed 0.4mm for compatibility with music boxes, and should likely be created with at least two layers from a slicer.\n*   **`StripeWidth`:** The width of the strip. I'd like a default of 42mm, and would like the option to change it between 30 and 50mm.\n*   **`StripeLength`:** The total length of the strip, allowing for variable song lengths. A default of 90mm would be good, with the option to choose between 10 and 200mm.\n*   **`MarginLeft`:** The distance of the lowest note (c1) from the left edge of the strip. A default of 5mm, and should be adjustable between 2 and 10mm.\n*   **`BeatDistance`:** The distance between each beat along the length of the strip.  A default of 3.5mm, but I'd like to change this as well.\n*   **`ToneDistance`:** The distance between each of the notes in pitch, across the width of the strip. A default of 2mm would be good.\n*   **`SongPicker`:** To select between \"Note-String\" for a user-provided string, or \"Star-Spangled Banner\" for the pre-defined note string for that song.\n\n**Output:**\n\n*   The design should output a 3D printable model of the music box strip, with cutouts (holes) in the correct locations, corresponding to notes and their timings based on the input parameters.\n\n**OpenSCAD Implementation Specifics:**\n\n* I don't need any external libraries.\n\n**Additional Notes:**\n\n* The hole diameter should be 1mm, and should extrude beyond the base layer so that the hole is created properly.\n\nCould you please create an OpenSCAD model based on these requirements? Let me know if you need any clarification.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Sand Scoop",
    "scad": "include<write/Write.scad>\nhandle = 80;\nhrad = 20;\nsrad =60;\nscoop = 60;\nwall = 2;\nbpt = \"yes\" ;\ngrade =35;\nskew = 0;\ntext = \"This is a handle\";\nasize=5;\ntsize=asize/4;\nistaper = bpt == \"yes\" ? 2 : 1;\nrotate([0,90,0]){\n  cylinder(h=handle,r=hrad);\n  writecylinder(text,[0,0,0],hrad,handle,rotate=-90,west=90,h=5*tsize,t=tsize);\n}\ntranslate([handle,0,0])sphere(r=hrad);\ntranslate([-scoop/2,0,srad-hrad])\n  rotate([0,90,0])\n    difference(){\n      cylinder(h=scoop,r=srad,center=true);\n      translate([-wall,0,-wall])\n        union(){\n          cylinder(h=scoop,r=srad-wall,center=true);\n          translate([-srad/2,0,0])cube([srad,2*istaper*(srad-wall),scoop*istaper],true);\n        }\n     translate([sin(grade)*(srad+scoop)/2,0,wall*2-scoop]){\n        rotate([0,-grade,0])cube([scoop/2+srad/2,scoop*2+srad*2,scoop*4],true);\n      }\n    }",
    "description": "Okay, I need a parametric design for a sand scoop, something like a small shovel. I've got a basic idea, but I want to make sure it's easy to customize.\n\nHere are the key features I need:\n\n*   **Handle:** The handle should be a cylinder, and I need to be able to adjust its length (`handle`) and radius (`hrad`).\n*   **Scoop:** The scoop part should be based on a cylinder as well. I need to control the scoop's radius (`srad`) and length (`scoop`). The scoop needs to be hollow, so I need a parameter for the wall thickness (`wall`).\n*   **Truncation:** I want the option to truncate the back and sides of the scoop to give it more of a shovel shape. I need a boolean parameter `bpt` where \"yes\" truncates and \"no\" leaves it as a cylinder. When truncated, the sides of the scooped are flattened by a distance of `srad` / 2, and extend into the part a distance of `2*(srad-wall)` if `bpt` is yes, and a distance of `srad - wall` if `bpt` is no. The part should extend along the length of the scoop based on a value of `scoop`.\n*   **Scoop Angle:** I also need a way to adjust how much the scoop is angled relative to the handle. This should be an angle parameter `grade`, which controls the angle of a cut through the scoop. The angle of this cut should always be from behind the scoop, so should always cut down and forwards (positive on the x axis in the code). The code should work from angles of 35 degrees to 65 degrees.\n*   **Skew:** I'd also like to be able to skew the scoop a bit rotationally, along the handle axis, so a parameter `skew` would be ideal.\n*   **Handle Text:** It would be great if I could add some text to the handle. I'd need a parameter for the text string (`text`), and a way to control the font size (`asize`) of the text.\n*   **Libraries:** Finally, I'd like to use the `write` library from the write.scad file to render the text on the cylinder, so that will need to be included. The handle text should be on the handle so that it's oriented so the text is readable when you are holding the handle upright.\n\nTo summarize, I'd like to be able to control these parameters: `handle`, `hrad`, `srad`, `scoop`, `wall`, `bpt`, `grade`, `skew`, `text`, and `asize`.\n\nCould you generate the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Pill cutting board",
    "scad": "pd=9.6;\npt=4.2;\npt2=2.6;\nbg=0.8;\ngto=2.2;\npart=\"base\";\npc=(pt-pt2)/2;\nsp=pd/(tan(2*atan(2*pc/pd))*2)+pd;\nbh=pt2+(pt-pt2)/2+1;\necho(sp);\necho(pd+0.4);\nmodule pill()\n{\nrotate([0,0,0])intersection(){\ncylinder(h=20,r=pd/2+0.15,center=true,$fn=48);\ntranslate([0,0,-sp+(pt2/2+0.2)])sphere(r=sp+0.2,center=true,$fn=48);\ntranslate([0,0,sp-(pt2/2+0.2)])sphere(r=sp+0.2,center=true,$fn=48);\n\t\t\t\t\t\t\t\t}\n}\nmodule post2()\n{\ntranslate([0,pd*2.2,bh])cylinder(h=bh*1.5,r=pd*0.45 ,center=true,$fn=12);\ntranslate([0,-pd*2.2,bh])cylinder(h=bh*1.5,r=pd*0.45 ,center=true,$fn=12);\ntranslate([-pd*2.2,0,bh])cylinder(h=bh*1.5,r=pd*0.45 ,center=true,$fn=12);\ntranslate([pd*2.2,0,bh])cylinder(h=bh*1.5,r=pd*0.45 ,center=true,$fn=12);\n}\nmodule post3()\n{\ntranslate([0,18,bh])cylinder(h=bh*2,r=pd*0.45 ,center=true,$fn=12);\ntranslate([0,-18,bh])cylinder(h=bh*2,r=pd*0.45 ,center=true,$fn=12);\ntranslate([-18,0,bh])cylinder(h=bh*2,r=pd*0.45 ,center=true,$fn=12);\ntranslate([18,0,bh])cylinder(h=bh*2,r=pd*0.45 ,center=true,$fn=12);\n}\nif(part==\"pill\") {\n\t\ttranslate([0,0,0])pill();\n\t\t\t\t }\nelse if (part==\"base\"){\n\tdifference(){\n\t\t\tunion(){\n\t\t\t\t\ttranslate([0,0,bh/2])cylinder(h=bh,r=pd*2.7 ,center=true,$fn=48);\n\t\t\t\t\ttranslate([0,0,0])post2();\n\t\t\t\t\t}\n\ttranslate([0,0,bh/2+1])pill();\n\ttranslate([0,0,bh])pill();\n\ttranslate([-bg/2,-21,1])cube(size=[bg,42,20], center=false);\n\ttranslate([-21,-bg/2,1])cube(size=[42,bg,20], center=false);\n\ttranslate([0,0,bh*gto])rotate([0,45,0])cube(size=[5,42,5], center=true);\n\ttranslate([0,0,bh*gto])rotate([45,0,0])cube(size=[42,5,5], center=true);\n\t\t\t\t}\n\t\t\t\t\t\t}",
    "description": "Okay, I need to design a parametric pill cutter that can cut a pill into four equal pieces. I've got some specific dimensions for the pill I'm currently working with, but I want the design to be easily adjustable for different sized pills.\n\nHere's what I'm looking for:\n\n**Overall Functionality:**\n\nThe pill cutter should have a base and a cutting mechanism. The base should securely hold the pill in place while the cutting mechanism applies pressure to divide it. I want to design it so I can cut a pill in quarters.\n\n**Specific Design Elements:**\n\n*   **Pill Holder:** The pill holder needs to have a concave shape that closely matches the profile of a pill. I've got a pill here with a diameter of 9.6mm and a total height of 4.2mm. However, the pill isn't a perfect cylinder - the top and bottom are slightly curved, and the center height is 2.6mm. The concave shape in the base needs to accommodate this.\n*   **Blade/Cutting Mechanism:** The design should incorporate a mechanism to apply cutting force to the pill.  For simplicity, I'm imagining using the edge of the structure to cut, rather than a physical blade. There needs to be a gap for the pill to sit in and a cutting edge, which should be 0.8mm wide.\n*   **Base:** The base should be stable and include supports to allow for easy removal of the pill.\n*   **Taper:** The cutting edge should taper inward at an offset 2.2 times the base height.\n\n**Parametric Design Needs:**\n\nI need to be able to adjust the following parameters:\n\n*   `pd`: Pill diameter (currently 9.6mm)\n*   `pt`: Total pill height (currently 4.2mm)\n*   `pt2`: Pill height at the center (currently 2.6mm)\n*   `bg`: Cutting gap width (currently 0.8mm)\n*  `gto`: Gap Taper Offset (currently 2.2)\n\n**Output:**\n\nI'm looking for an OpenSCAD file that I can use to generate an STL file for 3D printing.\n\n**Library:**\n\nI'm not using any libraries, so please ensure the design is done with only standard OpenSCAD primitives and operations.\n\n**Desired Output:**\n\nI should have two parts: a 'pill' object and a 'base' object, both selectable by a parameter.\n\nI've also included my current .scad file in case you want to use that as a starting point.  I'm not happy with how it looks, though, and I'd like a more refined, robust design.\n"
  },
  {
    "object": "Hey cadmonkey, make me a RubyMotion Logo (upper)",
    "scad": "size = 80;\nengrave_depth = .8;\nheight = size/10;\nradius = size/10;\nouter_size = size + 2*radius;\nengrave_thickness = outer_size / 19.2;\nl_a = outer_size/3.25;\nl_b = outer_size/2.65;\nl_c = outer_size/2.375;\na_a = 59.5 * 1;\na_b = 122 * 1;\na_c = 0 * 1;\ndifference() {\n    color(\"lightgray\") translate([radius,radius,-height]) difference() {\n        translate([0,0,height]) {\n            hull() {\n                sphere(r=radius);\n                translate([size,0,0]) sphere(r=radius);\n                translate([size,size,0]) sphere(r=radius);\n                translate([0,size,0]) sphere(r=radius);\n            }\n        }\n        translate([-radius,-radius,0]) cube([size+radius*2,size+radius*2,height]);\n    }\n    color(\"gray\") union() {\n        translate([outer_size*0.335,outer_size*0.37,height-engrave_depth])\n            rotate([0,0,a_a])\n                cube([l_a, engrave_thickness, engrave_depth]);\n        translate([outer_size*0.71,outer_size*0.39,height-engrave_depth])\n            rotate([0,0,a_b])\n                cube([l_b, engrave_thickness, engrave_depth]);\n        translate([(outer_size-l_c)/2,outer_size*0.49,height-engrave_depth])\n            rotate([0,0,a_c])\n                cube([l_c, engrave_thickness, engrave_depth]);\n    }\n}",
    "description": "Okay, I'd like to create a parametric 3D model of the RubyMotion logo, specifically the upper part. I'm looking for an OpenSCAD file that will let me adjust the overall size of the logo, and the depth of the engraved \"A\" symbol. \n\nHere's the breakdown of the design I have in mind:\n\n1.  **Base Shape:** The base should be a rounded cube or a \"pillow\" shape. Think of a cube with rounded edges. The size of this cube, both width and height/depth, should be controllable with a variable. Let's call that variable `size`. The overall height of this pillow is a smaller fraction of that size, perhaps 1/10. The radius of the rounding on the cube's edges should also be a function of the size, maybe also 1/10.\n2.  **Engraved \"A\":** On the top face of the rounded cube, we'll have an \"A\" symbol engraved. This \"A\" is made up of three bars. \n    *   The first bar is angled up to the right, at about 60 degrees from horizontal, located toward the left of the logo. Its length should be a fraction of `size`.\n    *   The second bar is angled up to the left, at approximately 120 degrees from horizontal, located towards the right of the logo. This bar is also a fraction of `size`.\n    *   The third bar is horizontal, placed near the middle of the other two, and it should be a shorter length.\n    *   All three bars should have the same thickness, which can be derived from the overall size.\n    *   The depth of the engraving should be controlled with another variable, lets call that `engrave_depth`.\n3.  **Parametric Variables:** I need at least two primary customizable variables:\n    *   `size`: This controls the overall dimensions of the rounded cube (width and height).\n    *   `engrave_depth`: This controls the depth at which the \"A\" is engraved into the base.\n\nI don't need it to be a perfect replica, but as close as possible to the example.\n\nI'd like the final result to be an OpenSCAD file that makes it easy for me to adjust these two variables. The file should be well commented and structured logically. It should use only basic OpenSCAD primitives; I don't want to use any external libraries for this one.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Bayonet Container",
    "scad": "use <utils/build_plate.scad>\n_part = \"base\";\n_insideDiameter = 16;\n_interiorHeight = 16;\n_style = \"round thin\";\n_numberOfSides = 9;\n_minimumWallThickness = 1.0;\n_topBottomThickness = 1.0;\n_lipHeight = 3.0;\n_bayonetDepth = 0.4;\n_partGap = 0.08;\n_resolution = 60;\nbuild_plate(0);\nmake();\nmodule make($fn=_resolution) {\n\ttwistAngle = 60;\n\tbayonetAngle = 30;\n\toutsideDiameter = _insideDiameter + 2*(_minimumWallThickness*2 + _partGap + _bayonetDepth);\n\tbaseHeight = _interiorHeight + _topBottomThickness - _lipHeight;\n\tseparatorHeight = _interiorHeight + _topBottomThickness;\n\tlidHeight = _interiorHeight + _topBottomThickness + _lipHeight;\n\tif (_part == \"base\") {\n\t\tmakeBase( _style, outsideDiameter, baseHeight,\n\t\t\t\t\t_minimumWallThickness, _topBottomThickness,\n\t\t\t\t\t_lipHeight, _bayonetDepth, bayonetAngle, _partGap,\n\t\t\t\t\t_numberOfSides);\n\t} else if (_part == \"separator\") {\n\t\tmakeSeparator(\t_style, outsideDiameter, separatorHeight,\n\t\t\t\t\t\t\t_minimumWallThickness, _topBottomThickness,\n\t\t\t\t\t\t\t_lipHeight, _bayonetDepth, bayonetAngle, _partGap,\n\t\t\t\t\t\t\t_numberOfSides, twistAngle);\n\t} else if (_part == \"lid\") {\n\t\tmakeLid(\t_style, outsideDiameter, lidHeight,\n\t\t\t\t\t_minimumWallThickness, _topBottomThickness,\n\t\t\t\t\t_lipHeight, _bayonetDepth, bayonetAngle,\n\t\t\t\t\t_numberOfSides, twistAngle);\n\t}\n}\nmodule makeStylizedCylinder(type, diameter, height, rounding, polygonSides) {\n\tradius = diameter/2;\n\tif (type == \"crown\") {\n\t\tcrownCylinder(polygonSides, radius, height, rounding);\n\t} else if (type == \"flipped crown\") {\n\t\ttranslate([0,0,height])\n\t\tmirror([0,0,1]) {\n\t\t\tcrownCylinder(polygonSides, radius, height, rounding);\n\t\t}\n\t} else if (type == \"polygon\") {\n\t\tpolyCylinder(polygonSides, radius, height, rounding);\n\t} else {\n\t\troundCylinder(radius, height, rounding);\n\t}\n}\nmodule thread(r1, r2, angle, height, yoffset, rotation, chamfer=0, r3=0, r4=0) {\n\tfor(a=[0,120,240])\n\trotate([0,0,a + rotation])\n\ttranslate([0,0,yoffset]) {\n\t\thull() {\n\t\t\tsmallArc(r1, r2, angle, height);\n\t\t\tif (chamfer != 0) {\n\t\t\t\ttranslate([0,0,chamfer]) {\n\t\t\t\t\tsmallArc(r3, r4, angle, height);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule makeBase(style, diameter, height, wall, base, lipHeight, bayonetDepth, bayonetAngle, partGap, sides) {\n\theight = max(height, base+lipHeight);\n\tradius = diameter/2;\n\tinnerRadius = radius - wall*2 - bayonetDepth - partGap;\n\tfullHeight = height + lipHeight;\n\trounding = 1.0;\n\tchamfer = bayonetDepth;\n\tbayonetHeight = (lipHeight-chamfer)/2;\n\teps = 0.1;\n\tdifference() {\n\t\tunion() {\n\t\t\tif (style == \"tapered\") {\n\t\t\t\ttaperedCylinder(radius, innerRadius+wall, height, rounding);\n\t\t\t} else {\n\t\t\t\tmakeStylizedCylinder(style, diameter, height, rounding, sides);\n\t\t\t}\n\t\t\ttranslate([0,0,rounding+eps]) {\n\t\t\t\tcylinder(r=innerRadius+wall, h=fullHeight-rounding-eps);\n\t\t\t}\n\t\t\tthread(innerRadius+wall-eps, innerRadius+wall+bayonetDepth,\n\t\t\t\t\tbayonetAngle, bayonetHeight, fullHeight - bayonetHeight/2, 0,\n\t\t\t\t\t-chamfer, innerRadius, innerRadius+wall);\n\t\t}\n\t\ttranslate([0,0,base]) {\n\t\t\tcylinder(r=innerRadius, h=fullHeight);\n\t\t\tif (style == \"round thin\") {\n\t\t\t\thull() {\n\t\t\t\t\tcylinder(r=radius-wall, h=height-base*2 - (radius-innerRadius));\n\t\t\t\t\tcylinder(r=innerRadius, h=height-base*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule makeLid(style, diameter, height, wall, base, lipHeight, bayonetDepth, bayonetAngle, sides, twistAngle) {\n\theight = max(height, base+lipHeight);\n\tbayonetAngle = bayonetAngle+2;\n\tradius = diameter/2;\n\tinnerRadius = radius - wall - bayonetDepth;\n\trounding = 1.0;\n\tchamfer = bayonetDepth;\n\tbayonetHeight = (lipHeight-chamfer)/2;\n\teps = 0.1;\n\tdifference() {\n\t\tif (style == \"tapered\" || style == \"thin\") {\n\t\t\ttaperedCylinder(radius, innerRadius+wall, height, rounding);\n\t\t} else {\n\t\t\tmakeStylizedCylinder(style, diameter, height, rounding, sides);\n\t\t}\n\t\ttranslate([0,0,base]) {\n\t\t\tcylinder(r=innerRadius, h=height+eps);\n\t\t\tif (style == \"round thin\") {\n\t\t\t\thull() {\n\t\t\t\t\tcylinder(r=radius-wall, h=height-lipHeight-base*2 - (radius-innerRadius));\n\t\t\t\t\tcylinder(r=innerRadius, h=height-lipHeight-base*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthread(innerRadius-eps, innerRadius+bayonetDepth,\n\t\t\t\tbayonetAngle, lipHeight + eps, height - lipHeight/2 + eps/2, twistAngle + bayonetAngle);\n\t\tthread(innerRadius-eps, innerRadius+bayonetDepth,\n\t\t\t\tbayonetAngle+twistAngle, bayonetHeight + eps, height - (lipHeight - bayonetHeight/2) + eps/2,\n\t\t\t\ttwistAngle + bayonetAngle,\n\t\t\t\tchamfer, innerRadius-eps, innerRadius);\n\t}\n}\nmodule makeSeparator(style, diameter, height, wall, base, lipHeight, bayonetDepth, bayonetAngle, partGap, sides, twistAngle) {\n\theight = max(height, base+lipHeight);\n\tradius = diameter/2;\n\tinnerRadius = radius - wall*2 - bayonetDepth - partGap;\n\tmiddleRadius = radius - wall - bayonetDepth;\n\twallThickness = radius - innerRadius;\n\tfullHeight = height + lipHeight;\n\trounding = 0;\n\ttopBayonetAngle = bayonetAngle+2;\n\tchamfer = bayonetDepth;\n\tbayonetHeight = (lipHeight-chamfer)/2;\n\teps = 0.1;\n\tdifference() {\n\t\tunion() {\n\t\t\tcylinder(r=innerRadius+wall, h=fullHeight);\n\t\t\ttranslate([0,0,lipHeight]) {\n\t\t\t\tmakeStylizedCylinder(style, diameter, height, rounding, sides);\n\t\t\t}\n\t\t\tthread(innerRadius+wall-eps, innerRadius+wall+bayonetDepth,\n\t\t\t\t\tbayonetAngle, bayonetHeight, bayonetHeight/2, 0,\n\t\t\t\t\tchamfer, innerRadius, innerRadius+wall);\n\t\t}\n\t\ttranslate([0,0,base]) {\n\t\t\tcylinder(r=innerRadius, h=fullHeight);\n\t\t}\n\t\ttranslate([0,0,lipHeight+max(wall,base)]) {\n\t\t\tcylinder(r=middleRadius, h=fullHeight);\n\t\t}\n\t\tif (style == \"round thin\") {\n\t\t\tassign(cutHeight = height-lipHeight-base*2 - wallThickness*2) {\n\t\t\t\tif (cutHeight > 0)\n\t\t\t\ttranslate([0,0,lipHeight+base])\n\t\t\t\thull() {\n\t\t\t\t\ttranslate([0,0,wallThickness])\n\t\t\t\t\tcylinder(r=radius-wall, h=cutHeight);\n\t\t\t\t\tcylinder(r=innerRadius, h=cutHeight + wallThickness*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate([0,0,fullHeight-lipHeight-partGap]) {\n\t\t\tcylinder(r=middleRadius, h=lipHeight+partGap+eps);\n\t\t}\n\t\tthread(middleRadius-eps, middleRadius+bayonetDepth,\n\t\t\t\ttopBayonetAngle, lipHeight+eps, fullHeight - lipHeight/2 + eps/2, twistAngle + topBayonetAngle);\n\t\tthread(middleRadius-eps, middleRadius+bayonetDepth,\n\t\t\t\ttopBayonetAngle+twistAngle, bayonetHeight + eps,\n\t\t\t\tfullHeight - lipHeight + bayonetHeight/2 + eps/2,\n\t\t\t\ttwistAngle + topBayonetAngle,\n\t\t\t\tchamfer, middleRadius-eps, middleRadius);\n\t}\n}\nmodule smallArc(radius0, radius1, angle, depth) {\n\tthickness = radius1 - radius0;\n\teps = 0.01;\n\tunion() {\n\t\tdifference() {\n\t\t\tcylinder(r=radius1, h=depth, center=true);\n\t\t\tcylinder(r=radius0, h=depth+2*eps, center=true);\n\t\t\tfor(z=[0, 180 - angle]) {\n\t\t\t\trotate([0,0,z])\n\t\t\t\ttranslate([-radius1,0,0])\n\t\t\t\tcube(size = [radius1*2, radius1*2, depth+eps], center=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule torus(r1, r2) {\n\trotate_extrude(convexity = 4)\n\ttranslate([r1, 0, 0])\n\tcircle(r = r2);\n}\nmodule roundCylinder(radius, height, rounding) {\n\tif (rounding == 0) {\n\t\tcylinder(r=radius, h=height);\n\t} else {\n\t\thull() {\n\t\t\ttranslate([0,0,height-rounding]) {\n\t\t\t\tcylinder(r=radius, h=rounding);\n\t\t\t}\n\t\t\ttranslate([0,0,rounding]) {\n\t\t\t\ttorus(radius-rounding, rounding);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule taperedCylinder(radius1, radius2, height, rounding) {\n\teps = 0.1;\n\thull() {\n\t\ttranslate([0,0,height-eps]) {\n\t\t\tcylinder(r=radius1, h=eps);\n\t\t}\n\t\tif (rounding == 0) {\n\t\t\tcylinder(r=radius2, h=eps);\n\t\t} else {\n\t\t\ttranslate([0,0,rounding]) {\n\t\t\t\ttorus(radius2-rounding, rounding);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule crownCylinder(sides, radius, height, rounding) {\n\teps = 0.1;\n\tangle = 360/sides;\n\thull() {\n\t\ttranslate([0,0,height-eps]) {\n\t\t\tcylinder(r=radius, h=eps);\n\t\t}\n\t\ttranslate([0,0,rounding])\n\t\thull() {\n\t\t\tfor (a=[0:angle:360])\n\t\t\trotate([0,0,a])\n\t\t\ttranslate([0,(radius-rounding) / cos(angle/2),0]) {\n\t\t\t\tif (rounding == 0) {\n\t\t\t\t\tcylinder(r=1, h=eps);\n\t\t\t\t} else {\n\t\t\t\t\tsphere(r=rounding, $fn=30);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule polyCylinder(sides, radius, height, rounding) {\n\tangle = 360/sides;\n\tif (rounding == 0) {\n\t\thull() {\n\t\t\tfor (a=[0:angle:360])\n\t\t\trotate([0,0,a])\n\t\t\ttranslate([0,(radius - rounding)/cos(angle/2),0]) {\n\t\t\t\tcylinder(r=1, h=height, $fn=30);\n\t\t\t}\n\t\t}\n\t} else {\n\t\thull() {\n\t\t\ttranslate([0,0,height-rounding]) {\n\t\t\t\thull() {\n\t\t\t\t\tfor (a=[0:angle:360])\n\t\t\t\t\trotate([0,0,a])\n\t\t\t\t\ttranslate([0,(radius - rounding)/cos(angle/2),0]) {\n\t\t\t\t\t\tcylinder(r=rounding, h=rounding, $fn=30);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([0,0,rounding])\n\t\t\thull() {\n\t\t\t\tfor (a=[0:angle:360])\n\t\t\t\trotate([0,0,a])\n\t\t\t\ttranslate([0,(radius - rounding) / cos(angle/2),0]) {\n\t\t\t\t\tsphere(r=rounding, $fn=30);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "description": "Okay, I'm looking to create a set of interlocking cylindrical containers with a twist-lock mechanism, similar to a pill bottle but more customizable. I want to be able to generate a base, a lid, and an optional separator that fits inside the base to create multiple compartments.\n\nHere's what I need the design to be able to do, with parameters I can change:\n\n**Overall Structure:**\n\n*   **Part Selection:** I need to be able to generate either a \"base\", a \"lid\", or a \"separator\" independently using a variable.\n*   **Interior Diameter:** The main parameter controlling the size of the container is the *inside* diameter.  I'd like to specify that as a variable.\n*   **Interior Height:**  I also want to specify the *inside* height of the container.\n*   **Exterior Style:** The outside of the container can be stylized with a variable. I want a few options here:\n    *   \"round\": A simple cylinder.\n    *   \"round thin\": A cylinder with a thin wall section near the base and lid, which may have to be a hull or some other technique to implement.\n    *   \"tapered\":  A cylinder that tapers slightly from the base to the top.\n    *   \"polygon\": A cylinder with a polygonal outer shape defined by a variable for the number of sides.\n    *   \"crown\": A cylinder where the sides are convex or crown-shaped with a variable for the number of sides.\n    *   \"flipped crown\":  The inverse of \"crown,\" with concave edges.\n*   **Polygon/Crown Sides:** If I choose the \"polygon\", \"crown\" or \"flipped crown\" styles, I'll need to set the number of sides as a parameter.\n*   **Minimum Wall Thickness:**  I need a variable to set the minimum thickness of the container walls.\n*   **Top/Bottom Thickness:**  I need a variable to control the thickness of the flat top of the lid and the flat bottom of the base.\n*   **Lip Height:** The lip between the lid and base needs to be a variable.\n*   **Bayonet Depth:** I need a variable for how much the bayonets protrude from the inner walls.\n*  **Part Gap:**  I also need a variable for the gap between parts so that I can adjust how tightly the fit is.\n*   **Resolution:**  I'd like to set the resolution using `$fn` for testing and high-res rendering. I should be able to chose from High, Medium, and Low using a variable, with the numbers 30, 60, and 120.\n\n**Interlocking Mechanism:**\n\n*   **Twist Angle:** The angle that the lid needs to be rotated to lock in place should be a fixed 60 degrees.\n*   **Bayonet Angle:** The angular size of the bayonets should be fixed at 30 degrees.\n\n**Additional Considerations**\n\n*   The design should automatically calculate the exterior diameter, base height, lid height, and separator height based on the other parameters.\n*   The separator should have a thinner inner wall to create multiple interior spaces within the base.\n*   I'm using OpenSCAD, and I'm trying to keep the code clear and understandable with modules for each part, where feasible. I'm aware that `hull()` and `difference()` will likely be used here.\n*   I'm using the `build_plate` module from the utils library.\n\nCan you help me generate a parametric OpenSCAD file based on these parameters and rules?\n"
  },
  {
    "object": "Hey cadmonkey, make me a A Customized Magic Wand",
    "scad": "tip_length = 50;\nwand_center = 230;\ntranslate([0,32.5,0])\nrotate([90,0,0]) {\nrotate([0,0,22.5]) {\nunion() {\ncylinder(r=6,tip_length,$fn=8);\ntranslate([0,0,tip_length])\ncylinder(r=3,h=15,$fn=50);\n      }\ntranslate([20,-8,0])\nunion() {\ncylinder(r=6,tip_length,$fn=8);\ntranslate([0,0,tip_length])\ncylinder(r=3,h=15,$fn=50);\n      }\n   }\n}\ntranslate([0,50,0])\ntranslate([-115,0,0])\nrotate([0,90,0])\ndifference() {\ntranslate([0,0,10])\ncylinder(r=6,wand_center,$fn=8);\ncylinder(r=3.5,h=250,$fn=50);\n}",
    "description": "Okay, I'd like to design a customizable magic wand, building off of the concept I've already got, but I need it to be much more flexible. I've been using the attached SCAD file, but I want to add more options.\n\nHere's what I want in the final design:\n\n**Core Structure:**\n\n*   **Wand Center:** The main body of the wand should be a cylinder with a customizable length. The code I have right now uses `wand_center`, but I need to be able to adjust its diameter as well. I'd like to refer to diameter as `wand_diameter`.\n*   **Hollow Core:** It should have a hollow core through the length of the wand so I can add a dowel or something to increase rigidity. I should be able to control the diameter of that core, which will be referred to as `core_diameter`. This `core_diameter` should be smaller than the `wand_diameter`.\n*   **Material and Fit:** I'd like to control the tolerances via a `tolerance` variable, which means that when the `core_diameter` is used for subtraction, it should add the `tolerance` value.\n*   **Taper Option:** I'd like an option to taper the main cylinder of the wand. Tapering should start at the base and go up to the tip. This taper should be defined by `taper_amount` with the base diameter remaining `wand_diameter`, and the tip diameter being the result of the taper. If `taper_amount` is zero, it should be a regular cylinder. If its not, it should use a `linear_extrude` function (or equivalent). The taper should begin at the beginning of the `wand_center` section.\n\n**Wand Tips:**\n\n*   **Dual Tips:** The wand should have two tips, attached on opposite sides. Each tip should be identical, but should be positioned symmetrically to each other from the center of the main wand cylinder.\n*   **Tip Length:** I want to control the length of each tip with `tip_length`.\n*  **Tip Diameter:** I want to control the widest diameter of the tip, referred to as `tip_diameter`.\n*   **Tip Inner Diameter:** The tip should have an inner diameter for mounting the wand. This inner diameter should be referred to as `tip_inner_diameter` and I want to be able to control this. The tips should be attached with a dowel hole. The dowel hole should be controlled by the `dowel_diameter` variable. There should be an additional `dowel_length` variable to control how much the `dowel_diameter` goes through the tip.\n*  **Tip Angled:** The tips in my example are angled. I want to be able to control that angle and make it zero if I prefer. I should be able to control that angle with a `tip_angle` variable. The `tip_angle` variable would also control how many of these angled portions there are (e.g. 120 degrees would create 3 segments)\n\n**Overall:**\n\n*   **Parametric Design:** All the dimensions mentioned should be controlled by variables to easily customize the design.\n*   **Modular Design:** I'd like it to be modular if possible, to make it easy to understand or modify later.\n*   **Units:** All measurements should be in millimeters.\n\n**Libraries:**\n\n*   I'm not using any libraries right now, but feel free to add any that would be helpful!\n\nCould you create a parametric OpenSCAD file based on these requirements? Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Makeup Holder",
    "scad": "HEIGHT_SLOTS = 5;\nWIDTH_SLOTS = 2;\nDIAMETER = 38;\nITEM_HEIGHT = 25;\nWALLS = 2;\nBACKSTOP_WIDTH=5;\nWALL_NIBBLE_HEIGHT=5;\nWALL_NIBBLE_RECT_WIDTH=7.5;\nWIDTH = DIAMETER + 1;\nHEIGHT = ITEM_HEIGHT + 1;\nOVERALL_WIDTH = (WIDTH + WALLS) * WIDTH_SLOTS + WALLS;\nOVERALL_HEIGHT = (HEIGHT + WALLS) * HEIGHT_SLOTS + WALLS;\nOVERALL_DEPTH = DIAMETER + WALLS;\necho(str(\"Dimensions are \", OVERALL_WIDTH, \"x\", OVERALL_HEIGHT, \"x\", OVERALL_DEPTH));\nunion() {\n   cube([OVERALL_WIDTH, DIAMETER + WALLS, WALLS]);\n   for (level = [1 : HEIGHT_SLOTS]) {\n     translate([0, 0, level * (HEIGHT + WALLS)]) {\n       cube([(WIDTH + WALLS) * WIDTH_SLOTS + WALLS,\n             DIAMETER/2 + WALLS,\n             WALLS]);\n     }\n     if (level < HEIGHT_SLOTS) {\n       for (x = [0 : WIDTH_SLOTS -1]) {\n         translate([WALLS + (x + .5) * (WIDTH + WALLS), WALLS + DIAMETER/2, (HEIGHT + WALLS) * level]) {\n           difference() {\n             cylinder(r=DIAMETER/2, h=WALLS);\n             translate([0, DIAMETER/2, -1]) {\n               scale([1,2,1]) cylinder(r=DIAMETER/4, h=WALLS+2);\n             }\n           }\n         }\n       }\n     }\n   }\n   for (x = [0 : WIDTH_SLOTS - 1]) {\n     translate([WALLS + (x) * (WIDTH + WALLS) + WIDTH / 2.0 - BACKSTOP_WIDTH/2.0, 0, 0]) {\n       cube([BACKSTOP_WIDTH, WALLS, OVERALL_HEIGHT]);\n     }\n   }\n   for (z = [0 : HEIGHT_SLOTS]) {\n     for (x = [0 : WIDTH_SLOTS]) {\n       intersection() {\n         translate([x * (WALLS+WIDTH) + WALLS/2, WALLS/2, z * (WALLS+HEIGHT) + WALLS/2]) {\n           rotate(45, [0,1,0]) cube([10, WALLS, 10],center=true);\n         }\n         translate([-.01,-.01,-.01]) cube([OVERALL_WIDTH, WALLS+2, OVERALL_HEIGHT]);\n       }\n       intersection() {\n         translate([(WALLS + x * (WALLS+WIDTH) + WIDTH / 2.0 + BACKSTOP_WIDTH / 2), WALLS/2, z * (WALLS+HEIGHT) + WALLS/2]) {\n           rotate(45, [0,1,0]) cube([10, WALLS, 10],center=true);\n         }\n         translate([-.01,-.01,-.01]) cube([OVERALL_WIDTH, WALLS+2, OVERALL_HEIGHT]);\n       }\n       intersection() {\n         translate([(WALLS + x * (WALLS+WIDTH) + WIDTH / 2.0 - BACKSTOP_WIDTH / 2.0), WALLS/2, z * (WALLS+HEIGHT) + WALLS/2]) {\n           rotate(45, [0,1,0]) cube([10, WALLS, 10],center=true);\n         }\n         translate([-.01,-.01,-.01]) cube([OVERALL_WIDTH, WALLS+2, OVERALL_HEIGHT]);\n       }\n     }\n   }\n   difference() {\n     for (wall = [0 : WIDTH_SLOTS]) {\n       translate([wall * (WIDTH + WALLS), 0, 0]) {\n         cube([WALLS,\n               DIAMETER / 2+WALLS,\n               (HEIGHT + WALLS) * HEIGHT_SLOTS + WALLS]);\n       }\n     }\n     union() {\n       for (level = [0 : HEIGHT_SLOTS]) {\n         translate([-1, DIAMETER/2-WALL_NIBBLE_RECT_WIDTH + WALLS, (level+0.5) * (HEIGHT + WALLS)]) {\n           rotate(90, [0,1,0]) cylinder(h=OVERALL_WIDTH+2, r=WALL_NIBBLE_HEIGHT/2);\n           translate([0, 0, -WALL_NIBBLE_HEIGHT/2]) cube([OVERALL_WIDTH+2,WALL_NIBBLE_RECT_WIDTH+1,WALL_NIBBLE_HEIGHT]);\n         }\n       }\n     }\n   }\n}",
    "description": "Okay, I'm looking for an OpenSCAD script to generate a customizable makeup holder. I've already got a basic design, but I'd like to make it more flexible and robust.\n\nEssentially, I need a multi-slot holder for things like eyeshadow palettes, eyeliners, and blushes. The current script I'm using is a bit clunky and hard to adjust. I'm looking for something that lets me define these parameters:\n\n*   **Number of Rows (Height Slots):**  I want to be able to easily specify how many shelves/rows the holder has. I'd like to be able to adjust this between 1 and 10.\n*   **Number of Columns (Width Slots):** The same as above, but to control how many items are side-by-side, also adjustable between 1 and 10.\n*   **Item Diameter:**  I need to be able to specify the diameter of the items that will be stored. Right now, I'm using 38mm but I need to be able to adjust this from 15mm to 75mm.\n*   **Item Height:** And their height. I've got this at 25mm now, but it should be adjustable between 15 and 50.\n*   **Wall Width:** The thickness of the walls between the slots - I'm good with this being 1 or 2.\n*  **Backstop Width:**  The thickness of the vertical support in the middle of each slot.  Adjustable between 2 and 5, as it currently is.\n*   **Side Wall Nibble:** The cutout on the side walls to make it easier to grab items out, this is currently a rectangle and partial cylinder. I'd like to be able to adjust the height and width of the rectangle, and the radius of the cylinder. I'd also like the cylinder to be optional.\n    *   **Nibble Height:** Currently at 5, and I'd like this to be adjustable between 5 and 15.\n    *   **Nibble Rectangle Width:** Currently 7.5, adjustable between 5 and 15.\n\nI'd also like the script to:\n\n*   Clearly label all the parameters so they are easy to find and understand.\n*   Calculate and print out the overall dimensions of the finished object as a message when it renders so I don't have to calculate this by hand.\n*   Include the support diamonds on the backstop, these help keep it together and prevent damage.\n*   Be well-structured, and easy to modify if I need to add something later on.\n* I don't need anything fancy; the rendering does not need to look perfect, I'm just using the script to generate STLs for printing.\n\nI'm not currently using any specific libraries, but if one would make this significantly easier, I am open to it. I also don't have a preference for modules or functions, either is fine, whatever makes sense for the program.\n\nCould you please create a new script, based on these requirements, that I can use to do this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Spool Holder",
    "scad": "Render = 2;\nMin_Spool_Hole_Diameter = 27;\nMax_Spool_Hole_Diameter = 37;\nSpool_Diameter = 160;\nUnder_Spool_Clearance = 20;\nAxle_Diameter = 8;\nAxle_Clearance = 1;\nNut_Size = 14.62;\nNut_width = 6.26;\nFlange_Width = 10;\nBearing_Outer_Diameter = 22;\nBearing_Width = 7;\nif(Render == 0)\n    centering_pulley(Min_Spool_Hole_Diameter, Max_Spool_Hole_Diameter, Axle_Diameter, Nut_Size, Nut_width, Flange_Width);\nelse if(Render == 1)\n    leg(Spool_Diameter, Axle_Diameter, Bearing_Outer_Diameter, Bearing_Width);\nelse {\n    rotate([0, -90, 45]) {\n        color(\"grey\")\n        union() {\n            cylinder(h = Spool_Diameter / 2, r = Spool_Diameter / 2, center = true);\n            cylinder(h = Spool_Diameter * 1.5, r = Axle_Diameter / 2, center = true);\n            translate([0, 0, (-Spool_Diameter / 3.5) - (Max_Spool_Hole_Diameter - Min_Spool_Hole_Diameter + Flange_Width - Nut_width) / 2])\n                rotate([0, 0, 45])\n                    cylinder(h = Nut_width + 0.1, r = Nut_Size / 2, center = true, $fn = 6);\n            translate([0, 0, (Spool_Diameter / 3.5) + (Max_Spool_Hole_Diameter - Min_Spool_Hole_Diameter + Flange_Width - Nut_width) / 2])\n                rotate([0, 0, 30])\n                    cylinder(h = Nut_width + 0.1, r = Nut_Size / 2, center = true, $fn = 6);\n            translate([0, 0, Spool_Diameter / 2])\n                cylinder(h = Bearing_Width + 0.1, r = Bearing_Outer_Diameter / 2, center = true);\n            translate([0, 0, -Spool_Diameter / 2])\n                cylinder(h = Bearing_Width + 0.1, r = Bearing_Outer_Diameter / 2, center = true);\n        }\n        translate([0, 0, -Spool_Diameter / 3.5])\n            rotate([0, 0, 45])\n                centering_pulley(Min_Spool_Hole_Diameter, Max_Spool_Hole_Diameter, Axle_Diameter, Nut_Size, Nut_width, Flange_Width);\n        translate([0, 0, Spool_Diameter / 3.5])\n            rotate([180, 0, 30])\n                centering_pulley(Min_Spool_Hole_Diameter, Max_Spool_Hole_Diameter, Axle_Diameter, Nut_Size, Nut_width, Flange_Width);\n        translate([-((Spool_Diameter / 2) + Under_Spool_Clearance) / 2, 0, Spool_Diameter / 2])\n            leg(Spool_Diameter, Axle_Diameter, Bearing_Outer_Diameter, Bearing_Width);\n        translate([-((Spool_Diameter / 2) + Under_Spool_Clearance) / 2, 0, -Spool_Diameter / 2])\n            leg(Spool_Diameter, Axle_Diameter, Bearing_Outer_Diameter, Bearing_Width);\n    }\n}\nmodule leg(Spool_Diameter, Axle_Diameter, Bearing_Outer_Diameter, Bearing_Width) {\n    leg_height = (Spool_Diameter / 2) + Under_Spool_Clearance;\n    bearing_holder_radius = (Bearing_Outer_Diameter / 2) + Bearing_Width;\n    difference() {\n        union() {\n            difference() {\n                cube([leg_height, bearing_holder_radius * 2, Bearing_Width], center = true);\n                cube([leg_height - 2 * Bearing_Width, (bearing_holder_radius  - Bearing_Width) * 2, Bearing_Width + 1], center = true);\n            }\n            translate([leg_height / 2, 0, 0])\n                cylinder(h = Bearing_Width, r = (Bearing_Outer_Diameter / 2) + Bearing_Width, center = true, $fn = 100);\n            translate([-leg_height / 4, bearing_holder_radius * 1.9, 0])\n                foot(leg_height / 2, bearing_holder_radius * 2, Bearing_Width);\n            translate([-leg_height / 4, -bearing_holder_radius * 1.9, 0])\n                rotate([180, 0, 0])\n                    foot(leg_height / 2, bearing_holder_radius * 2, Bearing_Width);\n        }\n        translate([leg_height / 2, 0, 0])\n            cylinder(h = Bearing_Width + 1, r = Bearing_Outer_Diameter / 2, center = true, $fn = 100);\n    }\n}\nmodule foot(x, y, z) {\n    inner_radius = x - z;\n    scale([1, y / x, 1])\n    difference() {\n        difference() {\n            translate([-x / 2, -x / 2, 0])\n                 cylinder(h = z, r = x, center = true, $fn = 100);\n            translate([-x - x / 2, -x / 2, 0])\n                cube([x * 2, x *  2, z + 1], center = true);\n            translate([-x / 2, -x - x / 2, 0])\n                cube([x * 2, x *  2, z + 1], center = true);\n        }\n    scale([1, 1, 1.1])\n        difference() {\n            translate([-x / 2, -x / 2, 0])\n                 cylinder(h = z, r = inner_radius, center = true, $fn = 100);\n            translate([-inner_radius - x / 2 + z, -x / 2, 0])\n                cube([inner_radius * 2, inner_radius *  2, z + 1], center = true);\n            translate([-x / 2, -inner_radius - x / 2, 0])\n                cube([inner_radius * 2, inner_radius *  2, z + 1], center = true);\n        }\n    }\n}\nmodule centering_pulley(Min_Spool_Hole_Diameter, Max_Spool_Hole_Diameter, Axle_Diameter, Nut_Size, Nut_width) {\n    centering_pulley_width = Max_Spool_Hole_Diameter - Min_Spool_Hole_Diameter;\n    flange_radius = (Max_Spool_Hole_Diameter + Flange_Width) / 2;\n    hole_extension = 1;\n    difference() {\n        translate([0, 0, Flange_Width / 2])\n            union() {\n                cylinder(h = centering_pulley_width, r1 = Max_Spool_Hole_Diameter / 2, r2 = Min_Spool_Hole_Diameter / 2, center = true, $fn = 100);\n                translate([0, 0, -(centering_pulley_width + Flange_Width) / 2])\n                    cylinder(h = Flange_Width, r = flange_radius, center = true, $fn = 6);\n            }\n        translate([0, 0, -(centering_pulley_width + Flange_Width - Nut_width + hole_extension) / 2])\n            cylinder(h = Nut_width + hole_extension, r = Nut_Size / 2, center = true, $fn = 6);\n        cylinder(h = centering_pulley_width + Flange_Width + hole_extension, r = (Axle_Diameter + Axle_Clearance) / 2, center = true, $fn = 100);\n    }\n}",
    "description": "Okay, I need a parametric spool holder designed in OpenSCAD. I'm tired of my filament getting tangled and causing failed prints! I've got some specific requirements and a basic idea of what I'm after, so hopefully you can help.\n\nEssentially, the design should consist of four printable parts: two legs and two centering pulleys that hold the spool. The legs will support the spool and have bearing holders. The centering pulleys will fit into the spool's center hole and keep it aligned, they should also accommodate different sized spool holes to some extent. The whole thing should be assembled using a threaded rod and nuts.\n\nHere are the main parameters I need to be able to adjust:\n\n*   **Spool Dimensions:**\n    *   `Min_Spool_Hole_Diameter`: The smallest diameter of the spool's center hole. I need this to be able to grip spools that have a small center.\n    *   `Max_Spool_Hole_Diameter`: The largest diameter of the spool's center hole. This lets us accommodate variations in spools.\n    *   `Spool_Diameter`: The overall diameter of the spool. This is used mainly for leg spacing, so it doesn't have to be *that* precise.\n    *   `Under_Spool_Clearance`: The amount of space under the spool so it doesn't hit the table.\n\n*   **Axle and Fasteners:**\n    *   `Axle_Diameter`: The diameter of the threaded rod. I'm using M8, so this should be set accordingly.\n    *   `Axle_Clearance`: The amount of extra space around the axle to ensure it moves freely.\n    *   `Nut_Size`: The outer diameter (across flats) of the nut.\n    *   `Nut_width`: The thickness of the nut.\n\n*   **Flanges:**\n    *   `Flange_Width`: The thickness of the flange on the centering pulley.\n\n*   **Bearings:**\n    *   `Bearing_Outer_Diameter`: The outer diameter of the bearing that will fit into the leg.\n    *   `Bearing_Width`: The thickness of the bearing.\n\nThe design should use a difference operation to make a nut-shaped hole in each of the centering pulleys. The legs should have a cutout to fit the bearings. And the legs should include feet that can be printed without needing supports.\n\nI'd like the design to use the `rotate` and `translate` transformation modules for positioning things, and I'd like to use named variables throughout to make it easier to read and modify. Please make sure to use comments in the OpenSCAD code so I can understand what's going on.\n\nI think that's everything... Let me know if you need more info. Thanks! Oh, and I don't need any libraries other than OpenSCAD's built-in modules for now.\n"
  },
  {
    "object": "Hey cadmonkey, make me a customizable gear thing",
    "scad": "_Radius_1 = 20;\n_Radius_center = 5;\n_Teeth_1 = 40;\n_Height_1 = 5;\n_Radius_2 = 10;\n_Teeth_2 = 20;\n_Height_2 = 5;\nr = _Radius_1*1;\nrc = _Radius_center * 1;\nt = _Teeth_1*1;\nh = _Height_1*1;\nr2 = _Radius_2*1;\nt2 = _Teeth_2*1;\nh2 = _Height_2*1;\nmodule gear()\n{\n  q = 360/t;\n  w = q/2;\ndifference()\n{\n  circle(r-.9);\n  circle(rc);\n}\n  for(i=[0:t])\n  {\n    polygon([[sin(i*q)*(r-1.1),cos(i*q)*(r-1.1)],[sin((i*q)+w)*(r),cos((i*q)+w)*(r)],[sin((i+1)*q)*(r-1.1),cos((i+1)*q)*(r-1.1)]]);\n  }\n}\nmodule gear2()\n{\n  q2 = 360/t2;\n  w2 = q2/2;\ndifference()\n{\n  circle(r2-.9);\n  circle(rc);\n}\n  for(i=[0:t2])\n  {\n    polygon([[sin(i*q2)*(r2-1.1),cos(i*q2)*(r2-1.1)],[sin((i*q2)+w2)*(r2),cos((i*q2)+w2)*(r2)],[sin((i+1)*q2)*(r2-1.1),cos((i+1)*q2)*(r2-1.1)]]);\n  }\n}\nmodule final()\n{\nunion(){\n  linear_extrude(height=h)\n    gear();\n  translate([0,0,h])\n  linear_extrude(height=h2)\n    gear2();\n  }\n}\nfinal();",
    "description": "Okay, I'd like to create a parametric design for a set of two gears that mesh together, suitable for 3D printing. I've been experimenting, but I need something more robust and easier to customize.\n\nHere's what I'm looking for:\n\n**General Requirements:**\n\n*   The design should consist of two gears: a \"bottom\" gear and a \"top\" gear, positioned one above the other (vertically).\n*   Both gears should have a circular profile with teeth.\n*   Both gears should have a center hole for mounting.\n*   The design should be fully parametric, allowing me to easily change key dimensions.\n\n**Specific Parameters (and suggested names for the variables):**\n\n*   **Bottom Gear:**\n    *   `_Radius_1`: Radius of the bottom gear to the edge of the teeth. (e.g., default 20, range of approximately 6-50).\n    *   `_Radius_center`: Radius of the center hole (e.g., default 5, range of approximately 0-20).\n    *   `_Teeth_1`: Number of teeth on the bottom gear (e.g., default 40, range of approximately 6-60).\n    *   `_Height_1`: Height/thickness of the bottom gear (e.g., default 5, range of approximately 1-10).\n*   **Top Gear:**\n    *   `_Radius_2`: Radius of the top gear to the edge of the teeth. (e.g., default 10, range of approximately 6-50).\n    *   `_Teeth_2`: Number of teeth on the top gear (e.g., default 20, range of approximately 6-60).\n    *   `_Height_2`: Height/thickness of the top gear (e.g., default 5, range of approximately 1-10).\n    \n*   The teeth should be shaped to mesh with each other, so that the number of teeth and the radii are related. I don't want to worry about whether the gear teeth are interfering with each other so it should automatically calculate their interaction so that they mesh well.\n\n**Output:**\n\n*   The code should generate a 3D model of the two gears in their proper alignment. They should be vertically stacked.\n*   The output should be an STL that I can 3D print.\n*   The code should be well-commented and easy to understand.\n\n**Libraries:**\n* If possible, please utilize BOSL2 for any gear-related code for better precision and easy of mesh.\n\n**Additional Notes:**\n* I'd also like to be able to easily adjust the center hole size, though the center holes of both gears should be the same size.\n* I'm mostly interested in a basic spur gear, I don't need anything overly complicated.\n\nEssentially, I'd like a flexible starting point for creating gear pairs in OpenSCAD. Please provide the OpenSCAD code as your response.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Cable Label",
    "scad": "include <write/Write.scad>\nlabel = \"Printer\";\ncable_diameter = 10;\nthickness = 1.2;\nFont = \"write/orbitron.dxf\";\nlabel_orientation = 2;\ncable_radius = cable_diameter/2;\nfont_size = cable_diameter*0.8;\nwidth = cable_diameter+thickness*2;\nlength = font_size*len(label)*.8+thickness*2;\nsnap_ring_width = width;\nmodule labelfx() {\nif (length < width) {\nif (label_orientation == 1) translate ([0,-thickness,width/2]) rotate ([90,0,0])\nlabel(width,width,thickness);\nif (label_orientation == 2) translate ([0,-thickness,width/2]) rotate ([90,-90,0])\nlabel(width,width,thickness);\n} else {\nif (label_orientation == 1) translate ([0,-thickness,width/2]) rotate ([90,0,0])\n label(length,width,thickness);\nif (label_orientation == 2) translate ([0,-thickness,length/2]) rotate ([90,-90,0])\n label(length,width,thickness);\n}\n}\nmodule label(l,w,t) {\nunion() {\ntranslate ([0,0,t/2])\nwrite(label,t=t, h=font_size, center = true, font = Font);\ntranslate ([0,0,-t/2])\nunion () {\ncube ([l,w,t],center=true);\ntranslate ([0,w/2-t/2,t]) cube ([l,t,t],center=true);\ntranslate ([0,-w/2+t/2,t]) cube ([l,t,t],center=true);\ntranslate ([l/2-t/2,0,t]) cube ([t,w,t],center=true);\ntranslate ([-l/2+t/2,0,t]) cube ([t,w,t],center=true);\n}\n}\n}\nmodule snapring() {\nlinear_extrude(height = snap_ring_width, center = true)\nunion () {\ndifference () {\nunion() {\ncircle (r=cable_radius+thickness);\ntranslate ([-(cable_radius+thickness),0,0])\nsquare ((cable_radius+thickness));\n}\ncircle (r=cable_radius);\nsquare (cable_radius*2);\n}\ntranslate ([cable_radius/2+thickness+cable_radius,0,0])\ndifference() {\ncircle (r=cable_radius/2+thickness);\ncircle (r=cable_radius/2);\ntranslate ([0,-cable_radius,0]) square (cable_radius*2,center=true);\n}\n}\n}\ntranslate ([0,cable_radius,snap_ring_width/2])\nrotate ([180,0,0])\nsnapring();\nlabelfx();",
    "description": "Okay, I'm looking to create a parametric cable label, something that can snap onto a cable and be labeled with text. I have an existing example, but it's a bit inflexible. \n\nThe label should consist of two main parts: a snap-on ring that clamps around the cable and a label portion that protrudes from that ring, with the text embossed (or debossed, I'm not fussy) onto the label.\n\nHere's what I'd like to control with parameters:\n\n*   **`cable_diameter`**: The diameter of the cable the label is intended for.\n*   **`label_text`**: The text that will be printed on the label.\n*   **`label_thickness`**: The thickness of the label and the snap ring.\n*   **`font_size`**: The height of the letters of the text. Should probably default to be relative to the cable diameter.\n*   **`label_orientation`**: Whether the label is oriented vertically (perpendicular to the cable) or horizontally (parallel to the cable).  Perhaps a numeric option like 1 for horizontal, 2 for vertical?\n*   **`font`**: Ideally, I'd like to select the font from the `write/` folder of the Write.scad library.  I'm interested in \"Letters.dxf\" (which appears to be a basic font), \"orbitron.dxf\" (a more futuristic font), and \"braille.dxf\" (for braille), but I need a way to select these programmatically. I expect it to be a string.\n\nI want the snap ring to work similar to the provided example, using a cut-out and a small hook to allow it to be snapped on to the cable. The label itself should be a rectangular prism with the text engraved on one face. If the label would be shorter than its width, I want it to have the dimensions of a square instead.\n\nCould you generate an OpenSCAD file that implements this, using the `Write.scad` library for text generation?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable dual flexible name bracelet",
    "scad": "part = \"bracelet\";\ninner_radius = 28;\nouter_radius = 33;\nlength = 15;\nnozzlediam = 0.4;\nsections = 25;\ntext = \"Ingegno.be\";\ntext_thickness = 4;\nuse <MCAD/fonts.scad>\nmodule test(){\n  echo(\"test\");\n}\nnozzle = 2*nozzlediam;\nbaseheight = 0.8;\nr1 = inner_radius;\nr2 = outer_radius;\nn = sections;\ngapin=2*nozzle;\ngapout = 3*nozzle;\nalpha = 2*PI/sections;\nalpha_1 = alpha - gapin/r1;\nbeta = 2*PI/sections;\nbeta_1 = alpha - gapout/r2;\nalpha_2 = gapin/r1;\nbeta_2 = gapout/r2;\nalpha_3 = nozzle/r1;\nbeta_3 = nozzle/r2;\nfudge = 0.01;\nthisFont=8bit_polyfont();\nx_shift=thisFont[0][0];\ny_shift=thisFont[0][1];\ntheseIndicies=search(text,thisFont[2],1,1);\nwordlength = (len(theseIndicies));\nfactorygap = 3;\nscale_x = (beta_1-beta_2) * r2 / x_shift;\nscale_y = (length - factorygap*gapout) / y_shift;\nthicknessword = text_thickness * nozzlediam;\nmodule alltext() {\n    for( j=[0:(len(theseIndicies)-1)] )\n      rotate([0, 0, (3/2*beta_2 + (beta_1-beta_2)/2 + j* beta)*180/PI])\n      translate([r2 -1.5* nozzle, -(beta_1-beta_2) * r2 /2 , factorygap/2*gapout])\n      rotate([90,0,90])\n        {\n        scale([scale_x,scale_y,1]){\n          linear_extrude(height=thicknessword)\n            polygon(points=thisFont[2][theseIndicies[j]][6][0],paths=thisFont[2][theseIndicies[j]][6][1]);\n        }\n      }\n}\nmodule innerholes() {\n  union() {\n    for (i = [0:n-1]){\n      rotate([0,0,(-alpha_1/2 + i* alpha)*180/PI])\n        translate([r1,0,0])\n          cube(size=[3*nozzle,r1*(alpha_2+alpha_3), 3*length], center=true);\n    }\n  }\n}\nmodule spikes() {\n  linear_extrude(height=length) { union(){\n    for (i = [0:n-1]){\n      polygon(points = [ [r1*cos((-alpha_1/2 + i* alpha-alpha_2/2)*180/PI),\n                          r1*sin((-alpha_1/2 + i* alpha-alpha_2/2)*180/PI)],\n                         [r2*cos((2*beta_2/2 + (i-1)* beta)*180/PI),\n                          r2*sin((2*beta_2/2 + (i-1)* beta)*180/PI)],\n                         [r2*cos((2*beta_2/2 + (i-1)* beta-beta_3)*180/PI),\n                          r2*sin((2*beta_2/2 + (i-1)* beta-beta_3)*180/PI)],\n                         [r1*cos((-alpha_1/2 + i* alpha-alpha_2/2-alpha_3)*180/PI),\n                          r1*sin((-alpha_1/2 + i* alpha-alpha_2/2-alpha_3)*180/PI)]\n                         ],\n                   paths = [ [0,1,2,3]]);\n    }\n  }}\n  linear_extrude(height=length) { union(){\n    for (i = [0:n-1]){\n      polygon(points = [ [r1*cos((-alpha_1/2 + i* alpha+alpha_2/2+alpha_3)*180/PI),\n                          r1*sin((-alpha_1/2 + i* alpha+alpha_2/2+alpha_3)*180/PI)],\n                         [r2*cos(((i)* beta+beta_3)*180/PI),\n                          r2*sin(( (i)* beta+beta_3)*180/PI)],\n                         [r2*cos(( (i)* beta)*180/PI),\n                          r2*sin(( (i)* beta)*180/PI)],\n                         [r1*cos((-alpha_1/2 + i* alpha+alpha_2/2)*180/PI),\n                          r1*sin((-alpha_1/2 + i* alpha+alpha_2/2)*180/PI)]\n                         ],\n                   paths = [ [0,1,2,3]]);\n    }\n  }}\n}\nmodule outerholes() {\n  union() {\n    for (i = [0:n-1]){\n      rotate([0,0,(beta_2/2 + i* beta)*180/PI])\n        translate([r2-nozzle,0,0])\n          cube(size=[3*nozzle, gapout, 3*length], center=true);\n    }\n  }\n}\nmodule outercirc(){\n  difference(){\n    cylinder(h=length, r=r2, $fn=100);\n    translate([0,0,-fudge]) cylinder(h=length+2*fudge, r=r2-nozzle, $fn=100);\n    outerholes();\n  }\n}\nmodule innercirc(){\n  difference(){\n    cylinder(h=length, r=r1+nozzle, $fn=100);\n    translate([0,0,-fudge]) cylinder(h=length+2*fudge, r=r1, $fn=100);\n    innerholes();\n  }\n}\nmodule baseform(){\n  union(){\n    outercirc();\n    innercirc();\n    spikes();\n  }\n}\nrotate([0,0,-90]){\n  if (part == \"together\") {\n    union(){\n      color(\"DarkSalmon\")\n      baseform();\n      color(\"Orange\")\n      alltext();\n      }\n    }\n  if (part == \"bracelet\") {\n    color(\"DarkSalmon\")\n    difference(){\n      baseform();\n      alltext();\n      }\n    }\n  if (part == \"text\") {\n    color(\"Orange\")\n    alltext();\n    }\n}",
    "description": "Okay, I'm looking for help designing a customizable bracelet for dual-extrusion 3D printers. I've seen some similar designs, but I need it to be parametric so I can easily adjust the size and customize it with text.\n\nHeres what I need:\n\n*   **Basic Shape:** The bracelet should be a flexible, segmented ring. It will be made of two rings: an inner and an outer ring connected by flexible sections or \"spikes.\" The segments should leave gaps between sections.\n*   **Inner and Outer Radius:** I need to be able to set the inner and outer radii of the bracelet in millimeters.\n*   **Length (Height):** The bracelet should have a height (thickness), which I'd also like to be able to define in millimeters.\n*   **Number of Segments:** The number of flexible segments connecting the inner and outer rings needs to be adjustable.\n*   **Nozzle Diameter:** I need to be able to input my 3D printer's nozzle diameter (in mm). This should affect the widths of the flexible sections and the spacing between parts.\n*   **Custom Text:** I want to be able to add custom text to the *outside* of the bracelet.\n*   **Text Thickness:** I need to set how thick the text is (as a multiple of the nozzle diameter).\n*   **Dual Extrusion:** The bracelet should be designed for dual extrusion. I want to have the option to generate three STL files:\n    1.  One for the \"base\" bracelet (the inner and outer rings with connecting segments).\n    2.  One for the text.\n    3.  One for both together.\n*   **OpenSCAD:** I need the design in OpenSCAD.\n*   **Libraries:** I'll be using the `MCAD/fonts.scad` library for text generation\n\nCan you help me create an OpenSCAD file that can do all of this? The existing code I have defines a variable called 'part' that takes the values \"bracelet\", \"text\", or \"together\" to define which of the three STLs will be generated. I'd like to maintain this functionality.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Openstock Classics",
    "scad": "Which_Foot = \"first\";\nNumber_of_Straps = \"second\";\nsandal_size =  \"fifth\";\nmodule print_Number_of_Straps() {\n\tif (Number_of_Straps == \"first\") {\n\t\tsingle();\n\t} else if (Number_of_Straps == \"second\") {\n\t\tdouble();\n\t}\n}\nmodule sandal(){print_Number_of_Straps(); print_foot();};\nprint_sandal_size();\nmodule print_sandal_size() {\n\tif (sandal_size == \"first\") {\n\t\tscale([2.5,2.825,3.275])sandal();\n\t} else if (sandal_size == \"second\") {\n\t\tscale([2.55,2.8815,3.3405])sandal();\n\t} else if (sandal_size == \"third\") {\n\t\tscale([2.58,2.9154,3.3798])sandal();\n\t} else if (sandal_size == \"fourth\") {\n\t\tscale([2.6,2.938,3.406])sandal();\n\t} else if (sandal_size == \"fifth\") {\n\t\tscale([2.65,2.9945,3.4715])sandal();\n\t} else if (sandal_size == \"sixth\") {\n\t\tscale([2.7,3.051,3.537])sandal();\n\t} else if (sandal_size == \"seventh\") {\n\t\tscale([2.75,3.1075,3.6025])sandal();\n\t} else if (sandal_size == \"eighth\") {\n\t\tscale([2.8,3.164,3.668])sandal();\n\t} else if (sandal_size == \"nineth\") {\n\t\tscale([2.85,3.2205,3.7335])sandal();\n\t} else if (sandal_size == \"tenth\") {\n\t\tscale([2.9,3.277,3.799])sandal();\n\t} else if (sandal_size == \"eleventh\") {\n\t\tscale([2.95,3.3335,3.8645])sandal();\n\t} else if (sandal_size == \"twelveth\") {\n\t\tscale([3,3.39,3.93])sandal();\n\t}\n}\nmodule single(){\nrotate([0,0,-3]){\ntranslate([14,2.8,0])scale([2.7,1,1])Strap();\n}}\nmodule double(){rotate([0,0,-3])translate([18,2.8,0])scale([1,1,0.98])Strap();rotate([0,0,-1])translate([30,1.6,0])scale([1,1,1.1])Strap();}\nmodule print_foot() {\n\tif (Which_Foot == \"first\") {\n\t\tBase1();\n\t} else if (Which_Foot == \"second\") {\n\t\tBase2();\n\t}\n}\nmodule Base(){rotate([180,0,-6])translate([0,-40.5,0])Base1();}\nfunction Base1_dimX() = 95.26;\nfunction Base1_dimY() = 37.88;\nfunction Base1_dimZ() = 2.00;\nfunction Base1_triangles() = [\n[2,1,0],[3,1,2],[5,0,4],[2,0,5],[8,7,6],[9,7,8],[10,9,8],[11,10,8],[12,11,8],[13,12,8],[5,13,8],[2,5,8],[3,2,8],[14,3,8],[15,14,8],[16,15,8],[17,16,8],[18,17,8],[19,18,8],[20,19,8],[21,20,8],[22,21,8],[8,23,22],[8,24,23],[8,25,24],[8,26,25],[8,27,26],[28,27,8],[29,28,8],[30,29,8],[31,30,8],[32,31,8],[33,32,8],[34,33,8],[35,34,8],[36,35,8],[37,36,8],[38,37,8],[39,38,8],[40,39,8],[41,40,8],[42,41,8],[43,42,8],[44,43,8],[45,44,8],[46,45,8],[47,46,8],[48,47,8],[49,48,8],[50,49,8],[51,50,8],[52,51,8],[53,52,8],[54,53,8],[55,54,8],[56,55,8],[57,56,8],[58,57,8],[59,58,8],[60,59,8],[8,61,60],[8,62,61],[63,62,8],[64,63,8],[65,64,8],[66,65,8],[67,66,8],[68,67,8],[69,68,8],[70,69,8],[71,70,8],[72,71,8],[73,72,8],[74,73,8],[75,74,8],[76,75,8],[77,76,8],[78,77,8],[79,78,8],[80,79,8],[81,80,8],[82,81,8],[3,83,1],[14,83,3],[86,85,84],[88,84,87],[86,84,88],[87,84,89],[89,84,90],[90,84,91],[91,84,92],[92,84,93],[93,84,94],[94,84,95],[95,84,96],[96,84,97],[97,84,98],[98,84,99],[99,84,100],[100,84,101],[101,84,102],[102,84,103],[103,84,104],[104,84,105],[105,84,106],[106,84,107],[107,84,108],[108,84,109],[109,84,110],[110,84,111],[111,84,112],[112,84,113],[113,84,114],[114,84,115],[115,84,116],[116,84,117],[117,84,118],[118,84,119],[119,84,120],[120,84,121],[121,84,122],[122,84,123],[123,84,124],[124,84,125],[125,84,126],[126,84,127],[127,84,128],[128,84,129],[129,84,130],[130,84,131],[131,84,132],[132,84,133],[133,84,134],[134,84,135],[135,84,136],[136,84,137],[137,84,138],[138,84,139],[139,84,140],[140,84,141],[141,84,142],[142,84,143],[143,84,144],[144,84,145],[145,84,146],[146,84,147],[147,84,148],[148,84,149],[149,84,150],[150,84,151],[151,84,152],[152,84,83],[83,84,1],[1,84,0],[0,84,4],[4,84,153],[153,84,154],[154,84,155],[155,84,156],[156,84,157],[157,84,158],[158,84,159],[13,4,153],[5,4,13],[8,85,82],[84,85,8],[8,159,84],[6,159,8],[82,86,81],[85,86,82],[81,88,80],[86,88,81],[80,87,79],[88,87,80],[79,89,78],[87,89,79],[78,90,77],[89,90,78],[77,91,76],[90,91,77],[76,92,75],[91,92,76],[75,93,74],[92,93,75],[94,73,74],[94,74,93],[95,72,73],[95,73,94],[96,71,72],[96,72,95],[97,70,71],[97,71,96],[98,69,70],[98,70,97],[99,68,69],[99,69,98],[100,67,68],[100,68,99],[101,66,67],[101,67,100],[102,65,66],[102,66,101],[103,64,65],[103,65,102],[104,63,64],[104,64,103],[105,62,63],[105,63,104],[106,61,62],[106,62,105],[107,60,61],[107,61,106],[108,59,60],[108,60,107],[109,58,59],[109,59,108],[110,57,58],[110,58,109],[111,56,57],[111,57,110],[112,55,56],[112,56,111],[113,54,55],[113,55,112],[114,53,54],[114,54,113],[115,52,53],[115,53,114],[116,51,52],[116,52,115],[117,50,51],[117,51,116],[118,49,50],[118,50,117],[119,48,49],[119,49,118],[120,47,48],[120,48,119],[121,46,47],[121,47,120],[122,45,46],[122,46,121],[123,44,45],[123,45,122],[124,43,44],[124,44,123],[125,42,43],[125,43,124],[125,126,41],[125,41,42],[126,127,40],[126,40,41],[127,128,39],[127,39,40],[128,129,38],[128,38,39],[129,130,37],[129,37,38],[36,130,131],[37,130,36],[35,131,132],[36,131,35],[34,132,133],[35,132,34],[33,133,134],[34,133,33],[32,134,135],[33,134,32],[31,135,136],[32,135,31],[30,136,137],[31,136,30],[29,137,138],[30,137,29],[28,138,139],[29,138,28],[27,139,140],[28,139,27],[26,140,141],[27,140,26],[25,141,142],[26,141,25],[24,142,143],[25,142,24],[23,143,144],[24,143,23],[22,144,145],[23,144,22],[21,145,146],[22,145,21],[20,146,147],[21,146,20],[19,147,148],[20,147,19],[18,148,149],[19,148,18],[17,149,150],[18,149,17],[16,150,151],[17,150,16],[15,151,152],[16,151,15],[14,152,83],[15,152,14],[12,153,154],[13,153,12],[11,154,155],[12,154,11],[10,155,156],[11,155,10],[9,156,157],[10,156,9],[7,157,158],[9,157,7],[6,158,159],[7,158,6]];\nfunction Base1_points() = [\n[8.220000,36.610001,2.000000],[10.430000,37.230000,2.000000],[8.220000,36.610001,0.000000],[10.430000,37.230000,0.000000],[6.330000,35.799999,2.000000],[6.330000,35.799999,0.000000],[0.130000,25.459999,0.000000],[0.370000,27.400000,0.000000],[0.070000,23.370001,0.000000],[0.790000,29.200001,0.000000],[1.430000,30.840000,0.000000],[2.280000,32.330002,0.000000],[3.370000,33.650002,0.000000],[4.710000,34.810001,0.000000],[12.950000,37.669998,0.000000],[15.800000,37.919998,0.000000],[19.010000,37.970001,0.000000],[22.580000,37.820000,0.000000],[26.530001,37.459999,0.000000],[31.490000,36.810001,0.000000],[36.540001,36.009998,0.000000],[41.700001,35.189999,0.000000],[46.980000,34.439999,0.000000],[52.380001,33.880001,0.000000],[57.900002,33.610001,0.000000],[63.570000,33.740002,0.000000],[69.379997,34.369999,0.000000],[71.559998,34.650002,0.000000],[73.779999,34.810001,0.000000],[76.019997,34.849998,0.000000],[78.260002,34.759998,0.000000],[80.459999,34.529999,0.000000],[82.610001,34.160000,0.000000],[84.669998,33.639999,0.000000],[86.629997,32.970001,0.000000],[88.449997,32.130001,0.000000],[90.110001,31.129999,0.000000],[91.589996,29.959999,0.000000],[92.860001,28.610001,0.000000],[93.900002,27.070000,0.000000],[94.669998,25.340000,0.000000],[95.160004,23.410000,0.000000],[95.330002,21.280001,0.000000],[95.239998,18.830000,0.000000],[94.949997,16.510000,0.000000],[94.440002,14.340000,0.000000],[93.709999,12.310000,0.000000],[92.760002,10.430000,0.000000],[91.580002,8.710000,0.000000],[90.169998,7.150000,0.000000],[88.510002,5.750000,0.000000],[86.599998,4.530000,0.000000],[84.449997,3.470000,0.000000],[82.029999,2.600000,0.000000],[79.349998,1.900000,0.000000],[76.400002,1.400000,0.000000],[73.169998,1.080000,0.000000],[69.669998,0.960000,0.000000],[65.870003,1.040000,0.000000],[60.290001,1.160000,0.000000],[54.660000,1.070000,0.000000],[49.020000,0.830000,0.000000],[43.430000,0.540000,0.000000],[37.919998,0.270000,0.000000],[32.549999,0.090000,0.000000],[27.370001,0.100000,0.000000],[22.420000,0.370000,0.000000],[20.059999,0.690000,0.000000],[17.799999,1.210000,0.000000],[15.650000,1.910000,0.000000],[13.620000,2.790000,0.000000],[11.700000,3.830000,0.000000],[9.910000,5.010000,0.000000],[8.250000,6.310000,0.000000],[6.730000,7.720000,0.000000],[5.350000,9.230000,0.000000],[4.120000,10.820000,0.000000],[3.040000,12.470000,0.000000],[2.120000,14.170000,0.000000],[1.370000,15.900000,0.000000],[0.790000,17.650000,0.000000],[0.380000,19.410000,0.000000],[0.160000,21.150000,0.000000],[12.950000,37.669998,2.000000],[0.070000,23.370001,2.000000],[0.160000,21.150000,2.000000],[0.380000,19.410000,2.000000],[1.370000,15.900000,2.000000],[0.790000,17.650000,2.000000],[2.120000,14.170000,2.000000],[3.040000,12.470000,2.000000],[4.120000,10.820000,2.000000],[5.350000,9.230000,2.000000],[6.730000,7.720000,2.000000],[8.250000,6.310000,2.000000],[9.910000,5.010000,2.000000],[11.700000,3.830000,2.000000],[13.620000,2.790000,2.000000],[15.650000,1.910000,2.000000],[17.799999,1.210000,2.000000],[20.059999,0.690000,2.000000],[22.420000,0.370000,2.000000],[27.370001,0.100000,2.000000],[32.549999,0.090000,2.000000],[37.919998,0.270000,2.000000],[43.430000,0.540000,2.000000],[49.020000,0.830000,2.000000],[54.660000,1.070000,2.000000],[60.290001,1.160000,2.000000],[65.870003,1.040000,2.000000],[69.669998,0.960000,2.000000],[73.169998,1.080000,2.000000],[76.400002,1.400000,2.000000],[79.349998,1.900000,2.000000],[82.029999,2.600000,2.000000],[84.449997,3.470000,2.000000],[86.599998,4.530000,2.000000],[88.510002,5.750000,2.000000],[90.169998,7.150000,2.000000],[91.580002,8.710000,2.000000],[92.760002,10.430000,2.000000],[93.709999,12.310000,2.000000],[94.440002,14.340000,2.000000],[94.949997,16.510000,2.000000],[95.239998,18.830000,2.000000],[95.330002,21.280001,2.000000],[95.160004,23.410000,2.000000],[94.669998,25.340000,2.000000],[93.900002,27.070000,2.000000],[92.860001,28.610001,2.000000],[91.589996,29.959999,2.000000],[90.110001,31.129999,2.000000],[88.449997,32.130001,2.000000],[86.629997,32.970001,2.000000],[84.669998,33.639999,2.000000],[82.610001,34.160000,2.000000],[80.459999,34.529999,2.000000],[78.260002,34.759998,2.000000],[76.019997,34.849998,2.000000],[73.779999,34.810001,2.000000],[71.559998,34.650002,2.000000],[69.379997,34.369999,2.000000],[63.570000,33.740002,2.000000],[57.900002,33.610001,2.000000],[52.380001,33.880001,2.000000],[46.980000,34.439999,2.000000],[41.700001,35.189999,2.000000],[36.540001,36.009998,2.000000],[31.490000,36.810001,2.000000],[26.530001,37.459999,2.000000],[22.580000,37.820000,2.000000],[19.010000,37.970001,2.000000],[15.800000,37.919998,2.000000],[4.710000,34.810001,2.000000],[3.370000,33.650002,2.000000],[2.280000,32.330002,2.000000],[1.430000,30.840000,2.000000],[0.790000,29.200001,2.000000],[0.370000,27.400000,2.000000],[0.130000,25.459999,2.000000]];module Base1() {\n  polyhedron(triangles = Base1_triangles(), points = Base1_points(), convexity=10);\n};\nfunction Strap_dimX() = 9.06;\nfunction Strap_dimY() = 36.07;\nfunction Strap_dimZ() = 19.91;\nfunction Strap_triangles() = [\n[2,1,0],[3,1,2],[6,5,4],[7,5,6],[8,7,6],[9,8,6],[10,9,6],[12,10,11],[14,12,13],[16,14,15],[18,16,17],[20,18,19],[22,20,21],[24,22,23],[26,24,25],[2,26,27],[3,2,28],[28,2,27],[27,26,25],[25,24,23],[23,22,21],[21,20,19],[19,18,29],[29,18,17],[17,16,15],[15,14,13],[13,12,30],[30,12,11],[11,10,31],[31,6,32],[31,10,6],[32,6,33],[33,6,34],[35,34,6],[6,36,35],[6,37,36],[6,38,37],[41,40,39],[44,43,42],[45,44,42],[46,44,45],[47,46,45],[40,46,47],[39,40,47],[48,40,41],[49,48,41],[50,48,49],[51,50,49],[52,50,51],[53,52,51],[54,52,53],[55,54,53],[56,54,55],[57,56,55],[58,56,57],[59,58,57],[60,58,59],[61,60,59],[38,60,61],[37,38,61],[62,38,6],[63,62,6],[64,63,6],[65,64,6],[66,65,6],[67,3,28],[67,1,3],[68,1,67],[26,0,69],[2,0,26],[72,71,70],[74,70,73],[72,70,74],[73,70,75],[75,70,76],[76,70,77],[80,79,78],[83,82,81],[85,81,84],[87,84,86],[90,89,88],[92,88,91],[94,91,93],[96,93,95],[98,95,97],[98,97,99],[96,95,98],[94,93,96],[92,91,94],[90,88,92],[87,89,90],[87,86,89],[85,84,87],[83,81,85],[80,82,83],[80,78,82],[76,79,80],[76,77,79],[101,70,100],[100,70,102],[102,70,103],[103,70,104],[105,103,104],[107,105,106],[109,107,108],[111,109,110],[113,111,112],[115,113,114],[117,115,116],[119,117,118],[120,119,69],[121,120,69],[122,121,0],[123,122,1],[68,123,1],[1,122,0],[0,121,69],[69,119,118],[118,117,116],[116,115,114],[114,113,112],[112,111,110],[110,109,108],[108,107,106],[106,105,104],[104,70,124],[124,70,125],[125,70,126],[126,70,127],[127,70,128],[99,97,129],[70,130,77],[70,131,130],[70,101,131],[71,66,6],[71,6,70],[128,70,6],[128,6,4],[72,65,66],[72,66,71],[74,64,65],[74,65,72],[73,63,64],[73,64,74],[75,62,63],[75,63,73],[76,38,62],[76,62,75],[80,60,38],[80,38,76],[83,58,60],[83,60,80],[85,56,58],[85,58,83],[87,54,56],[87,56,85],[90,52,54],[90,54,87],[92,50,52],[92,52,90],[94,48,50],[94,50,92],[96,40,48],[96,48,94],[98,46,40],[98,40,96],[99,44,46],[99,46,98],[44,129,43],[99,129,44],[42,129,97],[43,129,42],[45,97,95],[42,97,45],[47,95,93],[45,95,47],[39,93,91],[47,93,39],[41,91,88],[39,91,41],[49,88,89],[41,88,49],[51,89,86],[49,89,51],[53,86,84],[51,86,53],[55,84,81],[53,84,55],[57,81,82],[55,81,57],[59,82,78],[57,82,59],[61,78,79],[59,78,61],[37,79,77],[61,79,37],[36,77,130],[37,77,36],[35,130,131],[36,130,35],[34,131,101],[35,131,34],[34,100,33],[101,100,34],[33,102,32],[100,102,33],[32,103,31],[102,103,32],[31,105,11],[103,105,31],[11,107,30],[105,107,11],[30,109,13],[107,109,30],[13,111,15],[109,111,13],[15,113,17],[111,113,15],[115,29,17],[115,17,113],[117,19,29],[117,29,115],[119,21,19],[119,19,117],[120,23,21],[120,21,119],[121,25,23],[121,23,120],[122,27,25],[122,25,121],[123,28,27],[123,27,122],[68,67,28],[68,28,123],[24,69,118],[26,69,24],[22,118,116],[24,118,22],[20,116,114],[22,116,20],[18,114,112],[20,114,18],[16,112,110],[18,112,16],[14,110,108],[16,110,14],[12,108,106],[14,108,12],[106,104,10],[106,10,12],[104,124,9],[104,9,10],[124,125,8],[124,8,9],[125,126,7],[125,7,8],[126,127,5],[126,5,7],[127,128,4],[127,4,5]];\nfunction Strap_points() = [\n[9.061710,34.584900,2.266600],[9.064440,34.674500,0.233500],[1.072680,35.307098,2.266600],[1.075400,35.396702,0.233500],[0.593490,19.534700,20.038000],[0.646663,21.284901,19.738300],[0.538432,17.722500,20.143299],[0.698162,22.980000,19.252300],[0.747567,24.606100,18.580000],[0.794460,26.149599,17.737600],[0.838631,27.603500,16.741301],[0.739193,24.330500,17.648500],[0.880081,28.967800,15.599200],[0.827117,27.224501,15.915100],[0.918182,30.221901,14.311300],[0.867102,28.540600,14.829700],[0.952933,31.365801,12.893800],[0.903947,29.753401,13.614700],[0.983707,32.378700,11.362900],[0.968006,31.861900,10.820200],[1.010710,33.267502,9.718600],[0.994383,32.730099,9.256900],[1.033320,34.011700,7.985200],[1.016780,33.467400,7.604500],[1.051320,34.604301,6.154600],[1.035000,34.066799,5.871100],[1.064510,35.038399,4.243000],[1.048810,34.521599,4.056700],[1.057810,34.817902,2.169400],[0.937651,30.862700,12.270100],[0.784411,25.818899,16.862801],[0.691881,22.773199,18.288401],[0.642267,21.140200,18.750099],[0.591187,19.458900,19.033600],[0.538432,17.722500,19.130800],[0.485887,15.993000,19.033600],[0.434598,14.304800,18.750099],[0.385193,12.678600,18.288401],[0.238233,7.841440,16.741301],[0.060082,1.977590,7.604500],[0.012351,0.406542,4.243000],[0.082482,2.714870,9.256900],[0.019260,0.633930,2.169400],[0.015282,0.503010,0.233500],[0.001465,0.048234,0.233500],[0.028261,0.930223,4.056700],[0.004187,0.137811,2.266600],[0.041869,1.378110,5.871100],[0.025540,0.840646,6.154600],[0.109068,3.589970,10.820200],[0.043753,1.440120,7.985200],[0.139214,4.582210,12.270100],[0.066362,2.184300,9.718600],[0.172918,5.691590,13.614700],[0.093158,3.066290,11.362900],[0.209763,6.904320,14.829700],[0.124141,4.086090,12.893800],[0.249747,8.220420,15.915100],[0.158683,5.223030,14.311300],[0.292453,9.626090,16.862801],[0.196783,6.477110,15.599200],[0.337672,11.114400,17.648500],[0.282405,9.295340,17.737600],[0.329507,10.845700,18.580000],[0.378703,12.465000,19.252300],[0.430202,14.160100,19.738300],[0.483584,15.917200,20.038000],[1.061580,34.941898,0.233500],[9.050620,34.219700,0.233500],[9.053550,34.316200,4.243000],[8.527470,17.000200,20.143299],[8.472620,15.194900,20.038000],[8.419240,13.437800,19.738300],[8.318540,10.123500,18.580000],[8.367740,11.742800,19.252300],[8.271440,8.573110,17.737600],[8.227270,7.119200,16.741301],[8.374230,11.956400,18.288401],[8.281490,8.903850,16.862801],[8.326710,10.392200,17.648500],[8.185820,5.754870,15.599200],[8.198800,6.182090,14.829700],[8.238780,7.498180,15.915100],[8.147720,4.500800,14.311300],[8.161950,4.969350,13.614700],[8.113180,3.363860,12.893800],[8.128250,3.859980,12.270100],[8.082190,2.344060,11.362900],[8.071520,1.992640,9.256900],[8.098100,2.867740,10.820200],[8.055400,1.462070,9.718600],[8.049120,1.255350,7.604500],[8.032790,0.717887,7.985200],[8.030910,0.655873,5.871100],[8.014580,0.118410,6.154600],[8.017300,0.207987,4.056700],[8.001390,-0.315694,4.243000],[8.008300,-0.088306,2.169400],[7.993220,-0.584425,2.266600],[7.990500,-0.674002,0.233500],[8.580220,18.736700,19.033600],[8.527470,17.000200,19.130800],[8.631300,20.417999,18.750099],[8.680920,22.051001,18.288401],[8.827670,26.881300,16.741301],[8.728230,23.608299,17.648500],[8.869120,28.245600,15.599200],[8.773450,25.096600,16.862801],[8.907220,29.499701,14.311300],[8.816150,26.502300,15.915100],[8.941970,30.643499,12.893800],[8.856140,27.818399,14.829700],[8.972740,31.656401,11.362900],[8.892980,29.031099,13.614700],[8.999750,32.545300,9.718600],[8.926690,30.140499,12.270100],[9.022360,33.289501,7.985200],[8.957040,31.139601,10.820200],[9.040360,33.882099,6.154600],[8.983420,32.007801,9.256900],[9.005820,32.745098,7.604500],[9.024030,33.344601,5.871100],[9.037850,33.799400,4.056700],[9.046850,34.095699,2.169400],[8.783500,25.427401,17.737600],[8.736600,23.883900,18.580000],[8.687200,22.257700,19.252300],[8.635700,20.562700,19.738300],[8.582530,18.812500,20.038000],[8.004320,-0.219226,0.233500],[8.423630,13.582500,18.750099],[8.474920,15.270700,19.033600]];module Strap() {\n  polyhedron(triangles = Strap_triangles(), points = Strap_points(), convexity=10);\n};\nmodule Base2(){rotate([180,0,-6])translate([0,-40.5,0])Base1();};",
    "description": "Okay, I'd like to design a parametric sandal, something like the \"Openstock\" project I saw online, but I want a bit more flexibility.\n\nHeres what I'm thinking:\n\n**Core Design:** I need a sandal that's built from a base (the part your foot rests on) and straps. I need it to be parametric, meaning I can adjust the size and various features.\n\n**Base:** The base should have an overall foot shape. I need the ability to define this shape with a series of points and then have the script generate a smooth profile that can also be scaled to various shoe sizes. I also want to be able to specify the thickness of the base. I think I like how Openstock handles the base with a large number of points which are then used to generate triangles. I want to be able to adjust the position of these points via a series of parameters and calculations.\n\n**Straps:** The straps will attach to the base. I need options for either a single wide strap or two thinner straps (like in the Openstock example). I need the ability to easily change the width, thickness, and position of the straps. The existing Openstock solution has the straps attached toward the front and center of the foot. I want to be able to easily adjust where these straps attach. \n\n**Parametric Controls:**\n\n*   **Shoe Size:** I need a parameter to adjust the overall size of the sandal, similar to how Openstock uses 'sandal_size' but I need it to scale more smoothly based on a single number for shoe size. I prefer US sizing. I also want to be able to specify a difference for men's and women's sizes.\n*   **Foot:** I would like to be able to specify whether the sandal is for the left or right foot.\n*   **Strap Type:** A parameter to choose between a single wide strap or a double strap configuration.\n*   **Strap Width:** Parameters to adjust the width of the single strap or each strap in the double configuration.\n*   **Strap Thickness:** A parameter for the thickness of the strap.\n*   **Strap Angle:** A parameter to define the angle at which the strap curves towards the base.\n*  **Strap Attachment Position:** I would like to specify the X,Y location where the straps attach to the foot.\n*   **Base Thickness:** A parameter to control the thickness of the base.\n* **Foot Shape Adjustment:** I would like to be able to adjust parameters which affect the series of points which form the foot such as the toe width, heel width, and overall length.\n\n**OpenSCAD Requirements:**\n\n*   The design should use `polyhedron` for the base and straps, just like Openstock.\n*   I want to make sure I can easily adjust parameters which affect the various x,y,z coordinates of all the points for both the base and straps.\n*   I'd like a clean way to define the point arrays which are then used in the `polyhedron` functions.\n*  I would like to be able to easily adjust the position of each strap via a translate function.\n*  I would also like to be able to rotate the entire sandal by a specified number of degrees.\n\n**Libraries:** I am not using any libraries for this project.\n\nEssentially, I want a highly customizable, parametric sandal design in OpenSCAD that I can easily modify for different foot sizes and strap preferences, and base shapes using a well-defined set of parameters. Could you help me generate an OpenSCAD file to achieve this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Headset hook",
    "scad": "desk_size = 25;\ncradle_width = 5;\ncradle_height = 3;\nwall_size = 3;\nclamp_width = 10;\nclamp_depth = 20;\ntightinator_offset = .5;\ntightinator_width = .55;\ntightinator_height = .65;\ncutout = .9;\nhook_width = 10;\nhook_position = \"centre\";\nleft = clamp_width-hook_width;\ncentre = clamp_width/2-hook_width/2;\nright = 1 * 0;\nif (hook_position == \"centre\") {\n\tthing(centre);\n} else if (hook_position == \"right\") {\n\tthing(right);\n} else {\n\tthing(left);\n}\nmodule thing(hookpos)\n{\n    render()\n\tunion() {\n\t\tclamp();\n\t\thook(hookpos);\n\t}\n}\nmodule clamp() {\n\tunion(){\n\tdifference() {\n\t\tcube([desk_size+2*wall_size,clamp_depth+wall_size,clamp_width]);\n\t\ttranslate([desk_size+wall_size+.001,0,0])\n\t\t  #clamp_angle();\n\t\ttranslate([wall_size, 0, 0])\n\t\t  cube([desk_size,clamp_depth,clamp_width]);\n\t\ttranslate([desk_size+wall_size, (1-tightinator_height)/2*(clamp_depth-wall_size), (1-tightinator_width)/2*clamp_width])\n\t  \t  difference() {\n\t\t\tcube([wall_size,clamp_depth*tightinator_height,clamp_width*tightinator_width]);\n\t\t\ttranslate([0, cutout+.001, cutout])\n\t\t  \tcube([wall_size,(clamp_depth*tightinator_height)-cutout,(clamp_width*tightinator_width)-2*cutout]);\n\t      }\n\t}\n\ttranslate([desk_size,0,0])\n\t  clamp_angle();\n\t}\n}\nmodule clamp_angle() {\n\ta = ((1-tightinator_height)/2*(clamp_depth-wall_size))+cutout-.001;\n\tb = a + ((clamp_depth*tightinator_height)-cutout);\n\ttranslate([0,0,(1-tightinator_width)/2*clamp_width+cutout-.001])\n\tlinear_extrude(height=(clamp_width*tightinator_width+.001)-2*cutout+.001) polygon([[wall_size,a],[wall_size,b],[wall_size-tightinator_offset,a]]);\n}\nmodule hook(hookpos) {\n$fn=30;\ntranslate([wall_size/2, clamp_depth+wall_size-0.001, hookpos])\n\tminkowski(){\n\t\tdifference() {\n\t\t\tlinear_extrude(height=hook_width) polygon([[cradle_height,0],[cradle_height,cradle_width+wall_size/2],[0,cradle_width+wall_size/2],[0,cradle_width+wall_size],[cradle_height+wall_size,cradle_width+wall_size],[desk_size+wall_size,0]]);\n\t\t}\n\t\tcylinder(h = 0.0001, r = wall_size/2);\n\t}\n}",
    "description": "Okay, I need a parametric OpenSCAD file for a headphone hook that clamps onto a desk. I've already got a basic design, but it's got a few issues I'd like addressed, and I'd like it to be a bit more customizable.\n\nHere's what I need:\n\n**Basic Functionality:**\n\n*   **Desk Clamp:** The main function is to clamp onto the edge of a desk. The design needs to include a clamp mechanism that uses a tightener, it should not be overly aggressive.\n*   **Headphone Cradle:** There needs to be a curved section (a cradle) to hold the headphone headband securely. The cradle should protrude from the clamp and be sturdy enough to hold the headphones.\n*   **Parametric Design:** I need to be able to easily adjust all the critical dimensions and locations.\n\n**Specific Parameters I Need to Control:**\n\n*   **`desk_size`**: The thickness of the desk the clamp is attached to.\n*   **`cradle_width`**: The width of the cradle where the headphone sits.\n*   **`cradle_height`**: The thickness/height of the cradle where the headphone sits.\n*   **`wall_size`**: The thickness of the walls of the clamp. This should be consistent throughout the entire design including the hook.\n*   **`clamp_width`**: The overall width of the clamp part that sits under the desk.\n*   **`clamp_depth`**: The overall depth of the clamp part that sits under the desk.\n*   **`tightinator_offset`**: How much the \"tightener\" part of the clamp is offset to provide the clamping action.\n*   **`tightinator_width`**:  The relative width of the tightener (as a fraction of the clamp width).\n*   **`tightinator_height`**: The relative height of the tightener (as a fraction of the clamp depth).\n*   **`cutout`**:  The amount of space removed from the tightener to give a smoother fit.\n*   **`hook_width`**: The total width of the hook part where the headphone will hang.\n*  **`hook_position`**:  The location of the hook in relation to the clamp on the x-axis. Should support left, center, and right.\n*   **`$fn`**: The number of facets to use when rendering round surfaces.\n\n**Issues With My Current Design:**\n\n1.  The current design uses a combination of linear extrusions and differences to create the cradle which causes issues when changing parameters. The cradle should use minkowski to create a smoother, more robust shape.\n\n2. The angles generated by the tightener/clamp mechanism are not working correctly. They should be made using a linear extrude on a polygon. This ensures that the angles have the correct cutouts.\n\n3.  The tightener mechanism is not very customizable. The shape and size of the cutout should be able to be changed.\n\n4.  The overall design feels a bit clunky. I'm looking for a more refined look.\n\n**Additional Requirements:**\n\n*   The design should be easy to understand and modify. Please avoid overly complicated code.\n*   I'm using the vanilla OpenSCAD, so no external libraries.\n*   The hook should have rounded edges.\n*   The code should be well-commented so I can understand what each part is doing.\n\nI think that covers everything. I'm looking forward to seeing what you come up with. Let me know if you need any further clarification.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Light Dimmer knob and plate",
    "scad": "Knob=\"yes\";\nKnobDiameter=38;\nKnopHoleDiameter=4;\nPlate=\"yes\";\nPlateSize=66;\nPlateRoundEdge=4;\nPlateHoleDiameter=11;\nPlateThickness=8;\nRack=\"yes\";\nRackSize=80;\nRackRoundEdge=8;\nRackThickness=PlateThickness;\nSmoothness=8;\n$fa=180/Smoothness;\n$fs=30/Smoothness;\nif(Rack==\"yes\"){\ntranslate([-RackSize,0,0])\ndifference(){\ntranslate([0,0,RackThickness/2]) scale([RackRoundEdge/2,RackRoundEdge/2,1]) rcube([RackSize/(RackRoundEdge/2),RackSize/(RackRoundEdge/2),RackThickness],2);\ntranslate([0,0,PlateThickness/2+2]) scale([PlateRoundEdge/2,PlateRoundEdge/2,1]) rcube([(PlateSize+0.3)/(PlateRoundEdge/2),(PlateSize+0.3)/(PlateRoundEdge/2),PlateThickness+2],2);\ncube(PlateSize-20,center=true);\n}\n}\nif(Plate==\"yes\"){\ndifference(){\ntranslate([0,0,PlateThickness/2]) scale([PlateRoundEdge/2,PlateRoundEdge/2,1]) rcube([PlateSize/(PlateRoundEdge/2),PlateSize/(PlateRoundEdge/2),PlateThickness],2);\ntranslate([0,0,2]) cylinder(r=KnobDiameter/2+1,h=PlateThickness);\ntranslate([0,0,-2]) cylinder(r=PlateHoleDiameter/2,h=PlateThickness);\ntranslate([9,9,-2]) cylinder(r=4,h=PlateThickness);\n}\n}\nif(Knob==\"yes\"){\ntranslate([60,0,14]) rotate([180,0,0])\ndifference(){\ntranslate([0,0,7]) rcylinder(KnobDiameter/2,KnobDiameter/2,h=14);\ntranslate([0,0,-1]) cylinder(r=KnobDiameter/2-2,h=6);\ntranslate([0,0,4]) cylinder(r1=KnopHoleDiameter/2*1.1,r2=KnopHoleDiameter/2,h=8);\n}\n}\nmodule rcube(Size=[20,20,20],b=2)\n{hull(){for(x=[-(Size[0]/2-b),(Size[0]/2-b)]){for(y=[-(Size[1]/2-b),(Size[1]/2-b)]){for(z=[-(Size[2]/2-b),(Size[2]/2-b)]){ translate([x,y,z]) sphere(b);}}}}}\nmodule rcylinder(r1=10,r2=10,h=10,b=2)\n{translate([0,0,-h/2]) hull(){rotate_extrude() translate([r1-b,b,0]) circle(r = b); rotate_extrude() translate([r2-b, h-b, 0]) circle(r = b);}}",
    "description": "Okay, I'm looking to design a light dimmer switch plate and knob, and I'd like it to be customizable so I can tweak it if needed. I've been using OpenSCAD and found an existing design, but it needs a few things adjusted.\n\nEssentially, I need the following elements:\n\n*   **A Knob:** I'd like a cylindrical knob with a hole for the dimmer shaft. The diameter of the knob and the hole should be configurable. Id like the knob to have rounded edges for a more comfortable feel.\n\n*   **A Switch Plate:** This should be a rectangular plate with rounded edges, designed to mount on the wall. It needs a central hole to allow the dimmer shaft to pass through, as well as mounting holes (e.g. for screws) I need to be able to control the size, the edge radius, the mounting hole diameter, and the thickness of the plate.\n\n*   **Optional Mounting Rack:** I want an option to include a mounting \"rack\" or backplate behind the switch plate. This would be similar to the plate in shape, but slightly larger and would serve as a mounting surface. It also should be customizable with the option to turn it on and off and the size, edge radius, and thickness should all be configurable.\n\nHere's a breakdown of the parameters I want to be able to control:\n\n*   **`Knob`:** A boolean switch to enable or disable the knob object entirely (values \"yes\" or \"no\").\n*   **`KnobDiameter`:**  The diameter of the knob cylinder.\n*   **`KnopHoleDiameter`:** The diameter of the hole in the knob for the dimmer shaft.\n*    **`Plate`:** A boolean switch to enable or disable the plate object entirely (values \"yes\" or \"no\").\n*   **`PlateSize`:**  The side length of the square plate.\n*   **`PlateRoundEdge`:** The radius of the rounded edges of the plate.\n*   **`PlateHoleDiameter`:** The diameter of the central hole in the plate.\n*   **`PlateThickness`:** The thickness of the plate.\n*   **`Rack`:** A boolean switch to enable or disable the rack object entirely (values \"yes\" or \"no\").\n*   **`RackSize`:** The side length of the square rack.\n*  **`RackRoundEdge`:** The radius of the rounded edges of the rack.\n*  **`RackThickness`:** The thickness of the rack (this should default to the `PlateThickness`).\n*   **`Smoothness`**: A value to control the smoothness of the rounded edges. I'd like to use the same mechanism as the code I provided that adjusts the `$fa` and `$fs` variables. Lower values for rougher, higher values for smoother.\n\nAlso, I'd prefer to avoid using the `hull()` method directly, but use the `rcube()` and `rcylinder()` modules provided in the previous code for rounding shapes. It's a nice effect and easier to adjust.\n\nCould you please create an OpenSCAD file that implements this functionality using these parameters? I dont have any specific preference for which OpenSCAD library to use beyond that I'd like to use custom rounded shapes with the logic of rcube and rcylinder as provided in the existing code, and that I'd like to use all of the specified parameters.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Overhang Test Print (Customizable)",
    "scad": "use <write/Write.scad>\n_type = \"both\";\n_start = 15;\n_end = 45;\n_increment = 5;\n_width = 7.0;\n_height = 6.0;\n_fontSizePercent = 65;\n_spineWidth = 2;\nfunction getLength(height,angle) = height/tan(angle);\nmodule overhangTest(bridged, start, end, increment, width, height, spine, gap, fontSize, showLabels = true, offsetLabels = true) {\n\tnum = (end-start)/increment + 1;\n\tlength = width * num + gap * (num+1);\n\tfontFraction = fontSize/100;\n\tfontDepth = 0.5;\n\tstep = width+gap;\n\teps = 0.1;\n\tdifference() {\n\t\tunion() {\n\t\t\ttranslate([spine/2, -length/2, height/2]) {\n\t\t\t\tcube(size=[spine+eps,length,height], center=true);\n\t\t\t}\n\t\t\tfor (angle = [start:increment:end]) {\n\t\t\t\tassign(index = (angle-start)/increment + 1) {\n\t\t\t\t\ttranslate([spine,-(step*index - width/2),0])\n\t\t\t\t\trotate([90,0,0])\n\t\t\t\t\tlinear_extrude(height = bridged ? width+eps : width, center = true, convexity = 2) {\n\t\t\t\t\t\tpolygon(points=[[0,0],[getLength(height,angle),height],[0,height]], paths=[[0,1,2]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bridged) {\n\t\t\t\tfor (index = [0:num]) {\n\t\t\t\t\ttranslate([0,-step*(index) - gap,0]) {\n\t\t\t\t\t\tcube(size=[getLength(height,start + increment * max(0,(index-1))) + spine, gap, height]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (showLabels) {\n\t\t\tfor (angle = [start:increment:end]) {\n\t\t\t\tassign(y=step * ((angle-start)/increment +1)) {\n\t\t\t\t\ttranslate([offsetLabels ? width/4 : 0,-(y - width/2 + width * fontFraction/2),height-fontDepth]) {\n\t\t\t\t\t\twrite(str(angle), t=fontDepth+eps, h=width*fontFraction, font=\"write/orbitron.dxf\", space=1.2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule make(type, start, end, increment, width, height, fontSize, spineWidth) {\n\tgap = 1.0;\n\tif (_type == \"floating\") {\n\t\toverhangTest(false, start, end, increment, width, height, spineWidth, gap, fontSize);\n\t} else if (_type == \"bridged\") {\n\t\toverhangTest(true, start, end, increment, width, height, spineWidth, gap, fontSize);\n\t} else {\n\t\toverhangTest(true, start, end, increment, width, height, spineWidth, gap, fontSize, true, false);\n\t\tmirror([1,0,0]) {\n\t\t\toverhangTest(false, start, end, increment, width, height, spineWidth, gap, fontSize, false);\n\t\t}\n\t}\n}\nmake(_type, _start, _end, _increment, _width, _height, _fontSizePercent, _spineWidth);",
    "description": "Okay, I'm looking to create a customizable test print for evaluating overhang performance. I've seen some existing designs, but I need something a bit more flexible.\n\nEssentially, I want to generate a series of angled overhangs, either supported on both sides (bridged) or unsupported (free floating), or both. I need to be able to control the following parameters:\n\n*   **Test Type:** I need to be able to choose whether the test consists of \"bridged\" overhangs, \"floating\" overhangs, or \"both\". If I choose \"both\", I want a mirrored print, one side bridged, one side floating.\n*   **Start Angle:**  The angle of the first overhang in the series, relative to the horizontal plane.\n*   **End Angle:** The angle of the last overhang in the series.\n*   **Angle Increment:** The angular difference between each consecutive overhang in the test series.\n*   **Overhang Width:**  The width of each individual overhang.\n*   **Overhang Height:** The height of each individual overhang.\n*   **Font Size Percentage:** The size of the label numbers as a percentage of the width.\n*   **Spine Width:**  The width of the spine that supports the overhangs. This is in the y-direction when viewing the model in a default view in OpenSCAD.\n\nThe design should consist of a spine, onto which the angled overhangs are printed, incrementing from the start angle to the end angle. For bridged overhangs, there will be a support beam across each of the angles. The overhangs themselves should be triangular, with the angled side providing the overhang being tested. I'd like to also be able to print the test with angle labels. I'd like the font to be 'orbitron.dxf' which should be a file within the Write.scad library. If the label placement is set to offset, the numbers should be placed on the overhang itself otherwise, on the spine.\n\nCan you write me a parametric OpenSCAD file that does this? I'd prefer to keep the parametric definitions at the top of the file, the modules separate, and the main module that handles the parametric values and calls the other modules to build the test to be at the bottom of the file. The label generation should use the `Write.scad` library. I want it to import the `Write.scad` library using `use <write/Write.scad>`.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customisable Spirograph Vase Generator",
    "scad": "isHypotrochoid = 1;\nRadius_of_fixed_ring = 16;\nRadius_of_rotating_ring = 2;\nDistance = 8;\nturns = 1;\nwallWidth = 0.8;\nSegments = 300;\ntwistCycles = 0.4;\nheight = 50;\nlayerHeight = 2;\nbaseThickness = 1;\n$fa = 0.01+0;\n$fs = 0.5+0;\nR1=Radius_of_fixed_ring;\nR2=Radius_of_rotating_ring;\nd=Distance;\nN=Segments;\npi = 3.14159+0;\nnEnd = turns*2*pi;\nradToDeg = 360/(2*pi);\nnLayers = height/layerHeight;\nfunction hypotrochoidX(r1,r2,a,d) = (r1-r2)*cos(a*radToDeg)+d*cos((r1-r2)*a*radToDeg/r2);\nfunction hypotrochoidY(r1,r2,a,d) = (r1-r2)*sin(a*radToDeg)-d*sin((r1-r2)*a*radToDeg/r2);\nfunction epitrochoidX(r1,r2,a,d) = (r1+r2)*cos(a*radToDeg)-d*cos((r1+r2)*a*radToDeg/r2);\nfunction epitrochoidY(r1,r2,a,d) = (r1+r2)*sin(a*radToDeg)-d*sin((r1+r2)*a*radToDeg/r2);\nmodule hypotrochoidSpirographSegment(theta1, theta2)\n{\n\tassign(\n\t\tx1=hypotrochoidX(R1,R2,theta1,d),\n\t\tx2=hypotrochoidX(R1,R2,theta2,d),\n\t\ty1=hypotrochoidY(R1,R2,theta1,d),\n\t\ty2=hypotrochoidY(R1,R2,theta2,d)\n\t\t)\n\tassign(\n\t\tphi1 = atan2(y1,x1),\n\t\tphi2 = atan2(y2,x2)\n\t)\n\t{\n\t\thull()\n\t\t{\n\t\t\ttranslate([x1,y1,0])\n\t\t\t\tcircle(r=wallWidth/2, center=true);\n\t\t\ttranslate([x2,y2,0])\n\t\t\t\tcircle(r=wallWidth/2, center=true);\n\t\t}\n\t}\n}\nmodule epitrochoidSpirographSegment(theta1, theta2)\n{\n\tassign(\n\t\tx1=epitrochoidX(R1,R2,theta1,d),\n\t\tx2=epitrochoidX(R1,R2,theta2,d),\n\t\ty1=epitrochoidY(R1,R2,theta1,d),\n\t\ty2=epitrochoidY(R1,R2,theta2,d)\n\t\t)\n\tassign(\n\t\tphi1 = atan2(y1,x1),\n\t\tphi2 = atan2(y2,x2)\n\t)\n\t{\n\t\thull()\n\t\t{\n\t\t\ttranslate([x1,y1,0])\n\t\t\t\tcircle(r=wallWidth/2, center=true);\n\t\t\ttranslate([x2,y2,0])\n\t\t\t\tcircle(r=wallWidth/2, center=true);\n\t\t}\n\t}\n}\nmodule hypotrochoidSpirograph()\n{\n\tunion() for (n=[0:N-1])\n\t{\n\t\tassign(a=n*nEnd/N, a2=(n+1)*nEnd/N)\n\t\thypotrochoidSpirographSegment(a,a2);\n\t}\n}\nmodule epitrochoidSpirograph()\n{\n\tunion() for (n=[0:N-1])\n\t{\n\t\tassign(a=n*nEnd/N, a2=(n+1)*nEnd/N)\n\t\tepitrochoidSpirographSegment(a,a2);\n\t}\n}\nmodule spirographBase()\n{\n\thull() for (n=[0:N-1])\n\t{\n\t\tassign(a=n*nEnd/N, a2=(n+1)*nEnd/N)\n\t\tspirographSegment(a,a2);\n\t}\n}\nunion()\n{\n\tif (isHypotrochoid==1)\n\t{\n\t\tlinear_extrude(height=height,center=false,convexity=10,twist=twistCycles*2*pi*radToDeg, slices=nLayers)\n\t\t\thypotrochoidSpirograph();\n\t\tcylinder(h=baseThickness, r1=R1-R2+d, r2=R1-R2+d);\n\t}\n\telse\n\t{\n\t\tlinear_extrude(height=height,center=false,convexity=10,twist=twistCycles*2*pi*radToDeg, slices=nLayers)\n\t\t\tepitrochoidSpirograph();\n\t\tcylinder(h=baseThickness, r1=R1+R2+d, r2=R1+R2+d);\n\t}\n}",
    "description": "Okay, I'd like to design a 3D printable vase based on the spirograph principle, but I want a lot more control and flexibility than what the example code provides.\n\nI'm looking for a parametric OpenSCAD file that allows me to create a variety of spirograph vases. The basic principle should still be there: a rotating circle (or cog) moving around a fixed circle (or cog), with a 'pen' at a certain distance tracing the design. The design will be then extruded to create a vase with an optional twist, plus a base.\n\nHere are the specific parameters I want to be able to control:\n\n*   **Spirograph Type:** A boolean or enum to choose between hypotrochoid (rotating inside) and epitrochoid (rotating outside). The current code uses `isHypotrochoid = 1;`, but a more descriptive name or enum would be useful.\n*   **Fixed Radius (R1):** The radius of the fixed circle.\n*   **Rotating Radius (R2):** The radius of the rotating circle.\n*   **Pen Distance (D):** The distance of the \"pen\" from the center of the rotating circle.\n*   **Number of Rotations (turns):**  How many times the rotating circle completes a revolution around the fixed circle. This is important for complex patterns. The current code uses `turns`, which is good.\n*   **Wall Width:** Thickness of the vase walls.\n*   **Number of Segments (N):**  The number of line segments used to approximate the spirograph curve. The example code uses `Segments`.\n*   **Twist Cycles:** How many cycles of twist are applied over the height. The example uses `twistCycles`.\n*   **Vase Height:** The overall height of the vase. The example uses `height`.\n*  **Layer Height**: The vertical layer thickness for linear extrusion. The example uses `layerHeight`.\n*   **Base Thickness:** The thickness of the base.\n*   **Base Shape:** The base is currently a cylinder, but I'd like to be able to change this:\n    *   **Option 1: None:** No base at all.\n    *   **Option 2: Cylinder:** Like the current code, a simple cylinder.\n\t*   **Option 3: Spirograph Extrusion:** Instead of a cylinder, the base is a flat, un-twisted extrusion of the spirograph itself, with its shape matching the bottom of the vase.\n*   **Top Type:** I need the ability to control the top.\n    *   **Option 1: Flat:** The current vase has a flat top.\n\t*   **Option 2: Closed Top:** I want the option to close the top with a flat surface that matches the top of the vase.\n*   **Smoothing:** Add optional smoothing or interpolation to the spirograph curve using Bezier curves or similar to get smoother contours. This could use a smoothing factor. This is important for larger values of N, where the segmentation lines might be too obvious.\n*   **Customizable Extrusion Profile:** Rather than a simple `linear_extrude` with a circular cross-section, I would like to be able to define an extrusion profile, such as a rectangle, ellipse, or even a custom shape using a 2D polygon. This will allow for different visual effects for the wall, such as thicker or thinner sections, or a decorative profile. The current code uses `wallWidth` which is essentially a diameter and the extrusion uses a circle, so this requires more flexibility.\n*   **Preview mode:** I would like to generate a 2d preview of the spirograph pattern using `projection()` before creating the 3d model. I think it would be useful to easily test out the spirograph pattern without generating the complex 3d geometry.\n*   **Units:** The units should be in millimeters (mm), and the design should be suitable for 3D printing.\n\nEssentially, I want to take the spirograph concept and make it very customizable, and not be limited to the example I have provided.\n\nI anticipate that this will use OpenSCAD's built-in functions and maybe some simple math functions. I would also like to make use of the `BOSL2` library for vector and path handling as well as the smoother `linear_extrude`.\n"
  },
  {
    "object": "Hey cadmonkey, make me a 8Bit Message Keychain",
    "scad": "use <MCAD/fonts.scad>\nmessage = \"allenZ\";\nfont_size = 10;\nfont_spacing = -1.8;\ntolerance = 0.4;\nthisFont=8bit_polyfont();\nx_shift=thisFont[0][0];\ny_shift=thisFont[0][1];\nscale = font_size/y_shift;\nstick_radius = font_size/2*0.8;\nstick_length = (font_size+font_spacing*scale)*len(message)+4;\nhanger_radius = stick_radius;\nhead_radius = hanger_radius-1.2;\nz_ratio = (2+tolerance*2)/2;\necho (len(message));\necho (x_shift);\necho (y_shift);\n$fn=50;\ntheseIndicies=search(message,thisFont[2],1,1);\ntranslate ([-stick_length/2-tolerance,0,0])\nrotate ([0,-90,0]) hanger();\nstickwithconnect();\nmodule stickwithconnect() {\nunion () {\nstick();\ntranslate ([-stick_length/2-2-tolerance,0,0])\nrotate ([0,-90,0])\nconnecthead();\n}\n}\nmodule connecthead() {\nunion() {\ncylinder(r=head_radius,h=2);\ntranslate ([0,0,-2-tolerance]) cylinder(r=head_radius-0.6,h=2+tolerance*2);\n}\n}\nmodule stick() {\nunion () {\nintersection() {\nscale ([scale,scale,scale])\ntranslate ([-len(message)*(x_shift+font_spacing)/2,-y_shift/2,0])\nlinear_extrude(height = y_shift, center=true)\nfor (i=[0:len(message)-1]) {\ntranslate ([i*(x_shift+font_spacing),0,0])\npolygon(points=thisFont[2][theseIndicies[i]][6][0],paths=thisFont[2][theseIndicies[i]][6][1]);\n}\nrotate ([0,90,0]) cylinder (r=font_size/2,h=stick_length,center=true);\n}\nrotate ([0,90,0]) cylinder (r=stick_radius,h=stick_length,center=true);\n}\n}\nmodule hanger() {\ntranslate ([0,0,+2-tolerance])\ndifference () {\ntranslate ([0,0,-2+tolerance])\ndifference () {\nunion() {\ncylinder (r=hanger_radius,h=6);\ntranslate ([0,0,6]) sphere (r=hanger_radius);\n}\ntranslate ([0,0,6]) rotate ([0,90,0]) cylinder (r=2,h=hanger_radius*2,center=true);\n}\nscale ([(head_radius+tolerance)/head_radius,(head_radius+tolerance)/head_radius,z_ratio])\nconnecthead();\n}\n}",
    "description": "Okay, I have this OpenSCAD file, `8bit_msgKeychain.scad`, that creates a keychain with a text message on it, extruded from a cylinder. It uses the `MCAD/fonts.scad` library. It's kind of neat, but it has a few limitations I'd like to address, and I'd like it to be fully parametric, so I can customize it more easily in the future.\n\nCurrently, the keychain consists of a cylindrical stick with text extruded from it, and a rotating hanger at one end. The text is hardcoded (\"allenZ\"), and I have to tweak things manually to get different messages to fit. Also, the text is just extruded along the length of the stick  I want to be able to adjust the extrusion height, and possibly even emboss or engrave the text instead.\n\nHere's what I'm looking for in a redesigned, parametric OpenSCAD file:\n\n1.  **Message Parameter:** I need a string parameter to set the message. It should handle spaces and ideally be able to handle some basic punctuation as well. If it doesn't handle all possible characters, that's okay, I just want to be able to change the message easily.\n2.  **Font Size Parameter:** I need a parameter to set the overall size of the font (character height).\n3.  **Font Spacing Parameter:** A parameter to adjust the spacing between characters.\n4.  **Stick Radius Parameter:** A parameter to control the radius of the cylindrical stick part.\n5.  **Stick Length Parameter:** A parameter to control the overall length of the stick. I also need an option to automatically size the stick length to fit the message, plus some extra length on either side.\n6.  **Text Extrusion Height Parameter:** A parameter to control the height of the extruded text. This should allow me to make it more or less pronounced. Maybe also add a boolean parameter to switch between extruding text and embossing it (making it recessed)\n7.  **Hanger Radius Parameter:** A parameter for the radius of the rotating hanger part.\n8.  **Hanger Height Parameter:** A parameter to control the overall height of the hanger.\n9. **Head Radius Parameter:** A parameter for the head radius.\n10. **Rotational Top:** The top should be designed to rotate freely, similar to the original, with a slight tolerance and an ability to adjust that tolerance. I want to adjust a tolerance parameter, rather than a static variable inside the modules.\n11. **Font Selection:** Instead of hardcoding to 8bit, I'd like to use an actual font that I specify using font name and style.\n12. **Auto-Centering Text:** The text should always be centered along the length of the stick, regardless of the message length. This may mean re-implementing how the message is drawn relative to stick's geometry.\n\nFinally, can you please use the `MCAD/fonts.scad` library, which the original code uses?\n\nEssentially, I want a fully customizable keychain that lets me easily change the message, font size, stick size, and other key dimensions. The ability to emboss text would also be a nice touch.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Word Glasses",
    "scad": "use <write/Write.scad>\nword=\"IZZY\";\npart = \"frame\";\nletter_1_shift = 0;\nletter_2_shift = 0;\nletter_3_shift = 0;\nletter_4_shift = 0;\nhinge_diameter = 1.77;\nprint_part();\nwordlength = len(word);\nmodule print_part() {\n\tif (part == \"frame\") {\n\t\tonly_frame();\n\t} else if (part == \"arms\") {\n\t\tonly_arms();\n\t} else if (part == \"both\") {\n\t\tbuild_print();\n\t} else {\n\t\tbuild_print();\n\t}\n}\nmodule only_arms() {\n\ttranslate([0,4,0]) arm();\n\ttranslate([0,-4,0]) mirror([0,1,0]) arm();\n}\nmodule only_frame() {\n\tunion() {\n\t\tplace_frame();\n\t\tplace_words();\n\t}\n}\nmodule build_print() {\n\tonly_frame();\n\ttranslate([0,35,0]) arm();\n\ttranslate([0,-50,0]) mirror([0,1,0]) arm();\n}\nmodule quarter_arc(radius) {\nintersection() {\n\tsquare([radius,radius]);\n\tcircle(r = radius, $fn=50);\n}\n}\nmodule eye_shape(size) {\n\thull() {\n\t\ttranslate([size*15, 0, 0]) circle(r = size*15, $fn=50);\n\t\ttranslate([size*53, 0, 0]) circle(r = size*15, $fn=50);\n\t\ttranslate([size*23, size*-9.5, 0]) rotate(a=[0,0,180]) quarter_arc(size*23);\n\t\ttranslate([size*43, size*-9.5, 0]) rotate(a=[0,0,270]) quarter_arc(size*23);\n\t}\n}\nmodule nose_piece() {\n\tlinear_extrude(height=3) {\n\t\thull() {\n\t\tquarter_arc(6, $fn=50);\n\t\trotate([0,0,300]) quarter_arc(6, $fn=50);\n\t\ttranslate([0, -12, 0]) rotate([0,0,270]) quarter_arc(3, $fn=50);\n\t\t}\n\t}\n}\nmodule words(l_ltr1, l_ltr2, r_ltr1, r_ltr2, l_trns1, l_trns2, r_trns1, r_trns2) {\n\tunion() {\n\ttranslate([155,1.5,0]) mirror([1,0,0]) {\n\t\ttranslate([l_trns1,-32,0]) scale([0.82,1,1]) write(l_ltr1,t=3,h=43);\n\t\ttranslate([l_trns2,-32,0]) scale([0.82,1,1]) write(l_ltr2,t=3,h=43);\n\t\ttranslate([r_trns1,-32,0]) scale([0.82,1,1]) write(r_ltr1,t=3,h=43);\n\t\ttranslate([r_trns2,-32,0]) scale([0.82,1,1]) write(r_ltr2,t=3,h=43);\n\t}\n\t}\n}\nmodule place_words() {\n\ts1 = letter_1_shift;\n\ts2 = letter_2_shift;\n\ts3 = letter_3_shift;\n\ts4 = letter_4_shift;\n\tintersection() {\n\t\ttranslate([0,0,-1]) linear_extrude(height=5) {\n\t\t\tunion() {\n\t\t\t\teye_shape(0.97);\n\t\t\t\ttranslate([150,0,0]) mirror([1, 0, 0])\teye_shape(0.97);\n\t\t\t}\n\t\t}\n\t\tif (wordlength == 1) {\n\t\t\twords(word[0],\"\",\"\",\"\",25+s1,0,0,0);\n\t\t} else if (wordlength == 2) {\n\t\t\twords(word[0],word[1],\"\",\"\",25+s1,109+s2,0,0);\n\t\t} else if (wordlength == 3) {\n\t\t\twords(word[0],word[1],word[2],\"\",15+s1,40+s2,109+s3,0);\n\t\t} else if (wordlength == 4) {\n\t\t\twords(word[0],word[1],word[2], word[3],15+s1,40+s2,98+s3,123+s4);\n\t\t} else {\n\t\t\twords(\"F\",\"A\",\"I\",\"L\", 15, 40, 98, 123);\n\t\t}\n\t}\n}\nmodule place_frame() {\n\tunion() {\n\t\tframe_half();\n\t\ttranslate([150,0,0]) mirror([1, 0, 0]) frame_half();\n\t}\n}\nmodule frame_half() {\n\tdifference() {\n\t\tunion() {\n\t\t\tlinear_extrude(height=3) {\n\t\t\t\tdifference() {\n\t\t\t\t\tunion() {\n\t\t\t\t\t\teye_shape(1);\n\t\t\t\t\t\ttranslate([50, -1, 0]) square([25, 15.5]);\n\t\t\t\t\t\ttranslate([-5, -8, 0]) square([9, 10]);\n\t\t\t\t\t}\n\t\t\t\t\ttranslate([4.5,-1 ,0]) eye_shape(0.88);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([68,-3,3]) rotate(a=[0, 270, 347]) nose_piece();\n\t\t\ttranslate([-5,-5.5,2.99]) frame_hinge_recep();\n\t\t}\n\t\tlinear_extrude(height=20) {\n\t\t\tunion() {\n\t\t\t\ttranslate([74.5, 72, 10]) circle(r = 60);\n\t\t\t\ttranslate([74.5, -3.4, 10]) {\n\t\t\t\t\thull() {\n\t\t\t\t\t\trotate([0,0,45]) quarter_arc(8);\n\t\t\t\t\t\ttranslate([-4.5,-16,0]) circle(5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule arm_body() {\nunion() {\nlinear_extrude(height=3) union() {\n\thull() {\n\t\tsquare([2,10]);\n\t\ttranslate([5,0,0]) square([2,10]);\n\t}\n\thull() {\n\t\ttranslate([5,0,0]) square([2,10]);\n\t\ttranslate([92,7,0]) square([2,8]);\n\t}\n\thull() {\n\t\ttranslate([92,7,0]) square([2,8]);\n\t\ttranslate([130,22,0]) square([2,8]);\n\t}\n}\n}\n}\nmodule frame_hinge_recep() {\n\trotate([90,0,0]) {\n\t\ttranslate([0,0,0]) hinge_support(hinge_diameter);\n\t\ttranslate([0,0,-7.5]) hinge_support(hinge_diameter);\n\t}\n}\nmodule hinge_support(hinge_size) {\n\tlinear_extrude(height=2.5) {\n\tdifference() {\n\tunion() {\n\t\tsquare([4,8]);\n\t\tsquare([9,4.5]);\n\t\ttranslate([5.5,4.5]) circle(r=3.5,$fn=50);\n\t\tpolygon(points=[[0,8],[4,8],[0,8.75]], paths=[[0,1,2]]);\n\t}\n\ttranslate([5.5,4.5]) union() {\n\t\tcircle(r=hinge_size/2, $fn=50);\n\t\trotate([0,0,30]) intersection() {\n\t\t\t\tquarter_arc(6);\n\t\t\t\trotate([0,0,26]) quarter_arc(6);\n\t\t\t}\n\t}\n\t}\n\t}\n}\nmodule arm_hinge(hinge_size) {\n\tlinear_extrude(height=4.5) {\n\t\tdifference() {\n\t\t\tunion() {\n\t\t\t\tsquare([8,5.5]);\n\t\t\t\ttranslate([4.5,5.5]) circle(r=3.5,$fn=50);\n\t\t\t}\n\t\t\ttranslate([4.5,5.5]) union() {\n\t\t\t\tcircle(r=hinge_size/2, $fn=50);\n\t\t\t\trotate([0,0,32]) intersection() {\n\t\t\t\trotate([0,0,0]) quarter_arc(6);\n\t\t\t\trotate([0,0,25]) quarter_arc(6);\n\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule arm() {\n\tunion() {\n\t\tarm_body();\n\t\ttranslate([0.05,2.75,0]) rotate([270,180,0]) arm_hinge(hinge_diameter);\n\t}\n}",
    "description": "Okay, I'm looking to create some custom word glasses, like the ones described here. I want a design that I can easily customize with different words, and that uses a filament hinge. \n\nHere are my specific requirements:\n\n**Word Customization:**\n\n*   The design should allow for a word of 1 to 4 letters to be displayed on the lenses.\n*   I need to be able to specify the word as a parameter in the OpenSCAD file.\n*   Each letter should be individually horizontally adjustable by a parameter. These shift values could be positive or negative. This needs to be independent for each letter. \n\n**Part Selection:**\n\n*   I need to be able to choose to print only the frame, only the arms, or both the frame and arms. This should also be a configurable parameter.\n\n**Hinge:**\n\n*   The hinge should be designed to use standard filament as a pin.\n*   The diameter of the filament used should be a configurable parameter, so I can adjust it to match the filament I'm using.\n\n**General Geometry:**\n\n*   The overall style should match the provided example: rounded eye pieces, with a connected bridge, and arms.\n*   The shape of the frame itself should be parameterised; I want to be able to adjust the size of the lenses and their relative positions.\n*   The frame should have a nose piece.\n*   The design should include a hinge receiver on the frame and a hinge on the arms that works as a simple pin join.\n\n**Libraries:**\n\n*   The design should use the `Write.scad` library for creating the text, and I would like this to be an attached file as part of this response.\n\n**Output:**\n\n*   The final output should be an OpenSCAD file, including the `Write.scad` library, that I can open, customize, and generate a 3D printable file from.\n\nEssentially, I want to take the design from the provided description, but make it fully configurable and parametric. I want to be able to change the word, the letter positions, the hinge size, the eye piece size and position, and choose which parts to print. Is this something you can help me with?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Initialed Heart Ornament",
    "scad": "initials = \"AJ\";\nheight = 3;\nletter_height = 1;\nheartAngle = 90*1;\nsize = 14*1;\nratio = 48/28;\nelipseSize = [size * ratio,size,height];\nmodule spiffsans_puts(letters, count, offsets)\n{\n  for(i=[0:count-1])\n  {\n    translate([offsets[i],0,0])\n    {\n      spiffsans_lookup_draw(letters[i]);\n    }\n  }\n}\nmodule spiffsans_lookup_draw(char)\n{\n  if(char==\" \") {}\n  else if(char ==\"!\") spiffsans_exclaim();\n  else if(char ==\"-\") spiffsans_hyphen();\n  else if(char ==\".\") spiffsans_period();\n  else if(char ==\"0\") spiffsans_digit_0();\n  else if(char ==\"1\") spiffsans_digit_1();\n  else if(char ==\"2\") spiffsans_digit_2();\n  else if(char ==\"3\") spiffsans_digit_3();\n  else if(char ==\"4\") spiffsans_digit_4();\n  else if(char ==\"5\") spiffsans_digit_5();\n  else if(char ==\"6\") spiffsans_digit_6();\n  else if(char ==\"7\") spiffsans_digit_7();\n  else if(char ==\"8\") spiffsans_digit_8();\n  else if(char ==\"9\") spiffsans_digit_9();\n  else if(char ==\":\") spiffsans_colon();\n  else if(char ==\"?\") spiffsans_question();\n  else if(char ==\"A\" || char == \"a\") spiffsans_capital_a();\n  else if(char ==\"B\" || char == \"b\") spiffsans_capital_b();\n  else if(char ==\"C\" || char == \"c\") spiffsans_capital_c();\n  else if(char ==\"D\" || char == \"d\") spiffsans_capital_d();\n  else if(char ==\"E\" || char == \"e\") spiffsans_capital_e();\n  else if(char ==\"F\" || char == \"f\") spiffsans_capital_f();\n  else if(char ==\"G\" || char == \"g\") spiffsans_capital_g();\n  else if(char ==\"H\" || char == \"h\") spiffsans_capital_h();\n  else if(char ==\"I\" || char == \"i\") spiffsans_capital_i();\n  else if(char ==\"J\" || char == \"j\") spiffsans_capital_j();\n  else if(char ==\"K\" || char == \"k\") spiffsans_capital_k();\n  else if(char ==\"L\" || char == \"l\") spiffsans_capital_l();\n  else if(char ==\"M\" || char == \"m\") spiffsans_capital_m();\n  else if(char ==\"N\" || char == \"n\") spiffsans_capital_n();\n  else if(char ==\"O\" || char == \"o\") spiffsans_capital_o();\n  else if(char ==\"P\" || char == \"p\") spiffsans_capital_p();\n  else if(char ==\"Q\" || char == \"q\") spiffsans_capital_q();\n  else if(char ==\"R\" || char == \"r\") spiffsans_capital_r();\n  else if(char ==\"S\" || char == \"s\") spiffsans_capital_s();\n  else if(char ==\"T\" || char == \"t\") spiffsans_capital_t();\n  else if(char ==\"U\" || char == \"u\") spiffsans_capital_u();\n  else if(char ==\"V\" || char == \"v\") spiffsans_capital_v();\n  else if(char ==\"W\" || char == \"w\") spiffsans_capital_w();\n  else if(char ==\"X\" || char == \"x\") spiffsans_capital_x();\n  else if(char ==\"Y\" || char == \"y\") spiffsans_capital_y();\n  else if(char ==\"Z\" || char == \"z\") spiffsans_capital_z();\n  else echo(str(\"Unknown character: \", char));\n}\nmodule spiffsans_exclaim()\n{\n  polygon(points=[[0,3],[0,10],[2,10],[2,3],[0,0],[0,2],[2,2],[2,0]],paths=[[0,1,2,3],[4,5,6,7]]);\n}\nmodule spiffsans_hyphen()\n{\n  polygon(points=[[0,4],[0,6],[4,6],[4,4]],paths=[[0,1,2,3]]);\n}\nmodule spiffsans_period()\n{\n  polygon(points=[[0,0],[0,2],[2,2],[2,0]],paths=[[0,1,2,3]]);\n}\nmodule spiffsans_digit_0()\n{\n  polygon(points=[[5,0],[1,0],[0,2],[0,8],[1,10],[5,10],[6,8],[6,2],[2,8],[4,8],[2,5],[2,2],[4,5],[4,2]],paths=[[0,1,2,3,4,5,6,7],[8,9,10],[11,12,13]]);\n}\nmodule spiffsans_digit_1()\n{\n  polygon(points=[[0,0],[0,2],[2,2],[2,7],[0,7],[2,10],[4,10],[4,2],[5,2],[5,0]],paths=[[0,1,2,3,4,5,6,7,8,9]]);\n}\nmodule spiffsans_digit_2()\n{\n  polygon(points=[[0,0],[0,2],[4,6],[4,8],[2,8],[2,6],[0,6],[0,8],[1,10],[5,10],[6,8],[6,5.5],[2.5,2],[6,2],[6,0]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]]);\n}\nmodule spiffsans_digit_3()\n{\n  polygon(points=[[1,0],[0,2],[0,4],[2,4],[2,2],[4,2],[4,4],[3,4],[3,6],[4,6],[4,8],[2,8],[2,6],[0,6],[0,8],[1,10],[5,10],[6,8],[6,6],[5.5,5],[6,4],[6,2],[5,0]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]]);\n}\nmodule spiffsans_digit_4()\n{\n  polygon(points=[[4,0],[4,4],[0,4],[0,10],[2,10],[2,6],[4,6],[4,10],[6,10],[6,0]],paths=[[0,1,2,3,4,5,6,7,8,9]]);\n}\nmodule spiffsans_digit_5()\n{\n  polygon(points=[[0,0],[0,2],[4,2],[4.5,3],[4,4],[0,4],[0,10],[6,10],[6,8],[2,8],[2,6],[5,6],[6,4],[6,2],[5,0]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]]);\n}\nmodule spiffsans_digit_6()\n{\n  polygon(points=[[1,0],[0,2],[0,8],[1,10],[5,10],[5.5,8],[2,8],[2,6],[5,6],[6,4],[6,2],[5,0],[2,2],[2,4],[4,4],[4,2]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11],[12,13,14,15]]);\n}\nmodule spiffsans_digit_7()\n{\n  polygon(points=[[1,0],[1,3],[3,8],[0,8],[0,10],[5,10],[5,8],[3,3],[3,0]],paths=[[0,1,2,3,4,5,6,7,8]]);\n}\nmodule spiffsans_digit_8()\n{\n  polygon(points=[[1,0],[0,2],[0,4],[0.5,5],[0,6],[0,8],[1,10],[5,10],[6,8],[6,6],[5.5,5],[6,4],[6,2],[5,0],[2,6],[2,8],[4,8],[4,6],[2,2],[2,4],[4,4],[4,2]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11,12,13],[14,15,16,17],[18,19,20,21]]);\n}\nmodule spiffsans_digit_9()\n{\n  polygon(points=[[1,0],[0,2],[4,2],[4,4],[1,4],[0,6],[0,8],[1,10],[5,10],[6,8],[6,2],[5,0],[2,6],[2,8],[4,8],[4,6]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11],[12,13,14,15]]);\n}\nmodule spiffsans_colon()\n{\n  polygon(points=[[0,6],[0,8],[2,8],[2,6],[0,2],[0,4],[2,4],[2,2]],paths=[[0,1,2,3],[4,5,6,7]]);\n}\nmodule spiffsans_question()\n{\n  polygon(points=[[2,3],[4,6],[4,8],[2,8],[2,6],[0,6],[0,8],[2,10],[4,10],[6,8],[6,6],[4,3],[2,0],[2,2],[4,2],[4,0]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11],[12,13,14,15]]);\n}\nmodule spiffsans_capital_a()\n{\n  polygon(points=[[0,0],[0,8],[1,10],[5,10],[6,8],[6,0],[4,0],[4,4],[2,4],[2,0],[2,6],[2,8],[4,8],[4,6]],paths=[[0,1,2,3,4,5,6,7,8,9],[10,11,12,13]]);\n}\nmodule spiffsans_capital_b()\n{\n  polygon(points=[[0,0],[0,10],[5,10],[6,8],[6,6],[5.5,5],[6,4],[6,2],[5,0],[2,6],[2,8],[4,8],[4,6],[2,2],[2,4],[4,4],[4,2]],paths=[[0,1,2,3,4,5,6,7,8],[9,10,11,12],[13,14,15,16]]);\n}\nmodule spiffsans_capital_c()\n{\n  polygon(points=[[6,0],[1,0],[0,2],[0,8],[1,10],[6,10],[6,8],[2,8],[2,2],[6,2]],paths=[[0,1,2,3,4,5,6,7,8,9]]);\n}\nmodule spiffsans_capital_d()\n{\n  polygon(points=[[0,0],[0,10],[5,10],[6,8],[6,2],[5,0],[2,2],[2,8],[4,8],[4,2]],paths=[[0,1,2,3,4,5],[6,7,8,9]]);\n}\nmodule spiffsans_capital_e()\n{\n  polygon(points=[[0,0],[0,10],[5,10],[5,8],[2,8],[2,6],[4,6],[4,4],[2,4],[2,2],[5,2],[5,0]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11]]);\n}\nmodule spiffsans_capital_f()\n{\n  polygon(points=[[0,0],[0,10],[5,10],[5,8],[2,8],[2,6],[4,6],[4,4],[2,4],[2,0]],paths=[[0,1,2,3,4,5,6,7,8,9]]);\n}\nmodule spiffsans_capital_g()\n{\n  polygon(points=[[6,0],[1,0],[0,2],[0,8],[1,10],[5.5,10],[6,8],[2,8],[2,2],[4,2],[4,6],[6,6]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11]]);\n}\nmodule spiffsans_capital_h()\n{\n  polygon(points=[[0,0],[0,10],[2,10],[2,6],[4,6],[4,10],[6,10],[6,0],[4,0],[4,4],[2,4],[2,0]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11]]);\n}\nmodule spiffsans_capital_i()\n{\n  polygon(points=[[0,0],[0,2],[1.5,2],[1.5,8],[0,8],[0,10],[5,10],[5,8],[3.5,8],[3.5,2],[5,2],[5,0]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11]]);\n}\nmodule spiffsans_capital_j()\n{\n  polygon(points=[[0.5,0],[0,1],[0,4],[2,4],[2,2],[4,2],[4,8],[0,8],[0,10],[6,10],[6,1],[5.5,0]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11]]);\n}\nmodule spiffsans_capital_k()\n{\n  polygon(points=[[0,0],[0,10],[2,10],[2,6],[4,6],[4,10],[6,10],[6,6],[5,5],[6,4],[6,0],[4,0],[4,4],[2,4],[2,0]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]]);\n}\nmodule spiffsans_capital_l()\n{\n  polygon(points=[[0,0],[0,10],[2,10],[2,2],[5,2],[5,0]],paths=[[0,1,2,3,4,5]]);\n}\nmodule spiffsans_capital_m()\n{\n  polygon(points=[[0,0],[0,8],[1,10],[9,10],[10,8],[10,0],[8,0],[8,8],[6,8],[6,0],[4,0],[4,8],[2,8],[2,0]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11,12,13]]);\n}\nmodule spiffsans_capital_n()\n{\n  polygon(points=[[0,0],[0,8],[1,10],[5,10],[6,8],[6,0],[4,0],[4,8],[2,8],[2,0]],paths=[[0,1,2,3,4,5,6,7,8,9]]);\n}\nmodule spiffsans_capital_o()\n{\n  polygon(points=[[5,0],[1,0],[0,2],[0,8],[1,10],[5,10],[6,8],[6,2],[2,2],[2,8],[4,8],[4,2]],paths=[[0,1,2,3,4,5,6,7],[8,9,10,11]]);\n}\nmodule spiffsans_capital_p()\n{\n  polygon(points=[[0,0],[0,10],[5,10],[6,8],[6,6],[5,4],[2,4],[2,0],[2,6],[2,8],[4,8],[4,6]],paths=[[0,1,2,3,4,5,6,7],[8,9,10,11]]);\n}\nmodule spiffsans_capital_q()\n{\n  polygon(points=[[1,0],[0,2],[0,8],[1,10],[5,10],[6,8],[6,0],[2,2],[2,8],[4,8],[4,2]],paths=[[0,1,2,3,4,5,6],[7,8,9,10]]);\n}\nmodule spiffsans_capital_r()\n{\n  polygon(points=[[0,0],[0,10],[5,10],[6,8],[6,6],[5.5,5],[6,4],[6,0],[4,0],[4,4],[2,4],[2,0],[2,6],[2,8],[4,8],[4,6]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11],[12,13,14,15]]);\n}\nmodule spiffsans_capital_s()\n{\n  polygon(points=[[1,0],[0,2],[0,3],[2,3],[2,2],[4,2],[4,4],[1,4],[0,5],[0,8],[1,10],[5,10],[6,8],[6,7],[4,7],[4,8],[2,8],[2,6],[5,6],[6,5],[6,2],[5,0]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]]);\n}\nmodule spiffsans_capital_t()\n{\n  polygon(points=[[2,0],[2,8],[0,8],[0,10],[6,10],[6,8],[4,8],[4,0]],paths=[[0,1,2,3,4,5,6,7]]);\n}\nmodule spiffsans_capital_u()\n{\n  polygon(points=[[1,0],[0,2],[0,10],[2,10],[2,2],[4,2],[4,10],[6,10],[6,2],[5,0]],paths=[[0,1,2,3,4,5,6,7,8,9]]);\n}\nmodule spiffsans_capital_v()\n{\n  polygon(points=[[2,0],[0,4],[0,10],[2,10],[2,4],[4,4],[4,10],[6,10],[6,4],[4,0]],paths=[[0,1,2,3,4,5,6,7,8,9]]);\n}\nmodule spiffsans_capital_w()\n{\n  polygon(points=[[9,0],[1,0],[0,2],[0,10],[2,10],[2,2],[4,2],[4,10],[6,10],[6,2],[8,2],[8,10],[10,10],[10,2]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11,12,13]]);\n}\nmodule spiffsans_capital_x()\n{\n  polygon(points=[[0,0],[0,4],[1,5],[0,6],[0,10],[2,10],[2,6],[4,6],[4,10],[6,10],[6,6],[5,5],[6,4],[6,0],[4,0],[4,4],[2,4],[2,0]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]]);\n}\nmodule spiffsans_capital_y()\n{\n  polygon(points=[[2,0],[2,4],[1,4],[0,6],[0,10],[2,10],[2,6],[4,6],[4,10],[6,10],[6,6],[5,4],[4,4],[4,0]],paths=[[0,1,2,3,4,5,6,7,8,9,10,11,12,13]]);\n}\nmodule spiffsans_capital_z()\n{\n  polygon(points=[[0,0],[0,2],[3,8],[0,8],[0,10],[5,10],[5,8],[2,2],[5,2],[5,0]],paths=[[0,1,2,3,4,5,6,7,8,9]]);\n}\nunion()\n{\ntranslate([0,0,height])\nscale([size/10,size/10,1])\nlinear_extrude(height=letter_height)\nrotate(heartAngle+(90-heartAngle)/2+45)\ntranslate([-2.0*(size/10)-5, -size/20,0])\nspiffsans_puts(initials, 2, [0,10]);\nunion(){\nintersection(){\nunion(){\nscale(elipseSize)\ncylinder(h = 1, r = 1,$fn=60);\nrotate(heartAngle)\nscale(elipseSize)\ncylinder(h = 1, r = 1,$fn=60);\n}\nrotate(heartAngle+(90-heartAngle)/2+45)\ntranslate([-elipseSize.x,0,-height/2])\ncube(size = elipseSize*2);\n}\nintersection(){\nintersection(){\nscale(elipseSize)\ncylinder(h = 1, r = 1,$fn=60);\nrotate(heartAngle)\nscale(elipseSize)\ncylinder(h = 1, r = 1,$fn=60);\n}\nrotate(heartAngle+(90-heartAngle)/2+45)\ntranslate([-elipseSize.x,-elipseSize.x,-height/2])\ncube(size = elipseSize*2);\n}\n}\n}",
    "description": "Okay, I want to make a personalized heart ornament, like a tag or something. I'd like to be able to set the initials, the height of the heart, and the height of the letters. The heart itself should be made up of two intersecting cylinders. The letters should be extruded on top of the heart. \n\nI need it all to be parametric, so I can easily change the size later. The letters should be a specific font  it's called \"Spiff Sans\"  and I've included the code for that, so it doesn't need to be generated.\n\nSpecifically:\n\n*   **Initials:** A text input field where I can enter two letters.\n*   **Heart Height:** A number input field, defaulting to 3mm, allowing values from 3mm to 10mm.\n*   **Letter Height:** A number input field, defaulting to 1mm, allowing values from 1mm to 5mm.\n*   **Heart Shape:** The base heart shape should be created by the intersection of two cylinders that are scaled to be eliptical, with one rotated by a variable that is set to 90 degrees.\n*   **Letter Placement:** The letters should be placed on top of the heart, rotated 135 degrees and a translation along the x-axis\n*   **Font:** I'm providing all of the code for the \"Spiff Sans\" font as a series of `spiffsans_` modules; I don't need you to generate that.\n\nCould you generate an OpenSCAD file for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable petal screw box",
    "scad": "thickness = 3;\ndiam = 40;\nheight = 45;\nscrewh = 45;\nscrew_twist = 100;\nscrewpetals = 3;\nlogotext = \"Ingegno.be\";\nletterheight = 12;\npart = \"box\";\nreinforce = \"yes\";\nclockwise = \"no\";\nbaseh = 3;\nres = 80;\nclearance = 0;\nuse <utils/build_plate.scad>;\nuse <MCAD/fonts.scad>\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nmodule test(){\n  echo(\"test\");\n}\nthisFont=8bit_polyfont();\nx_shift=thisFont[0][0];\ny_shift=thisFont[0][1];\ntheseIndicies=search(logotext,thisFont[2],1,1);\nwordlength = (len(theseIndicies));\nfactorygap = 3;\nlettersize_x = (diam-4)/(wordlength+2);\nscale_x =  lettersize_x / x_shift;\nscale_y = letterheight / y_shift;\ntextheight = thickness/3;\nmodule logo(){\n  mirror([-1,0,0])\n  translate([-diam/2+1.5*lettersize_x,-letterheight/2,-0.01])\n    for( j=[0:(len(theseIndicies)-1)] )\n      translate([j*lettersize_x, 0 , 0])\n        {\n        scale([scale_x,scale_y,1]){\n          linear_extrude(height=textheight)\n            polygon(points=thisFont[2][theseIndicies[j]][6][0],paths=thisFont[2][theseIndicies[j]][6][1]);\n        }\n      }\n}\nmodule base() {\n  cylinder(r=diam/2, h=baseh, $fn=res);\n}\nrealheight = height+baseh;\nscrewstart = height+baseh-screwh;\nmodule box() {\n  difference() {\n    cylinder(r=diam/2, h=screwstart, $fn=res);\n    translate([0,0,-0.01]) cylinder(r=diam/2-thickness, h=screwstart+0.02, $fn=res);\n  }\n}\nstopperheight = 4;\nstoppergap = 0.2;\nstopperthickness = 2;\nmodule stopper(){\n  union() {\n  translate([0,0,screwstart])\n   difference() {\n    cylinder(r=diam/2-thickness-stoppergap, h=stopperheight, $fn=res);\n    translate([0,0,-0.01]) cylinder(r=diam/2-thickness-stopperthickness, h=stopperheight+0.02, $fn=res);\n    }\n  translate([0,0,screwstart-2*thickness/3])\n   difference() {\n    cylinder(r=diam/2-thickness+0.2, h=2*thickness/3, $fn=res);\n    translate([0,0,-0.01]) cylinder(r1=diam/2-thickness-0.01,r2=diam/2-thickness-stopperthickness, h=2*thickness/3+0.02, $fn=res);\n    }\n  }\n}\nmodule wedge_180(r, d)\n{\n\trotate(d) difference()\n\t{\n\t\trotate(180-d) difference()\n\t\t{\n\t\t\tcircle(r = r, $fn=res);\n\t\t\ttranslate([-(r+1), 0, 0]) square([r*2+2, r+1]);\n\t\t}\n\t\ttranslate([-(r+1), 0, 0]) square([r*2+2, r+1]);\n\t}\n}\nmodule wedge(r, d)\n{\n\tif(d <= 180)\n\t\twedge_180(r, d);\n\telse\n\t\trotate(d) difference()\n\t\t{\n\t\t\tcircle(r = r, $fn=res);\n\t\t\twedge_180(r+1, 360-d);\n\t\t}\n}\nmodule screwprofile(r, count) {\n\tangle = 360/count;\n\tunion() {\n\t\tfor (i=[1:count]) {\n\t\t\trotate([0,0,angle * i+clearance/2]) difference(){\n           wedge(r = r, d=angle/2-clearance-0.01);\n           rotate([0,0,-0.005]) wedge(r=r-thickness, d=angle/2-clearance);\n           }\n\t\t}\n\t}\n}\nreinf_thick = 3;\nmodule reinforceprofile(r, count) {\n\tangle = 360/count;\n   anglereinf = 360/12;\n\tunion() {\n\t\tfor (i=[1:count]) {\n\t\t\trotate([0,0,angle * i+angle/4-anglereinf/4]) difference(){\n           wedge(r = r-thickness+0.01, d=anglereinf/2-0.01);\n           rotate([0,0,-0.005])wedge(r=r-thickness-reinf_thick, d=anglereinf/2);\n           }\n\t\t}\n\t}\n}\nmodule petals(){\n  union() {\n  translate([0,0,screwstart-0.01])\n  if (clockwise == \"no\") {\n    linear_extrude(height = screwh, twist=screw_twist*-1, convexity = 10, $fn=res){\n      screwprofile(diam/2, screwpetals);\n      }\n  } else {\n    linear_extrude(height = screwh, twist=screw_twist, convexity = 10, $fn=res){\n      screwprofile(diam/2, screwpetals);\n      }\n  }\n  if (reinforce == \"yes\") {\n   translate([0,0,screwstart-0.01]) {\n    difference() {\n     if (clockwise == \"no\") {\n      linear_extrude(height = screwh, twist=screw_twist*-1,\n                     convexity = 10){\n        reinforceprofile(diam/2, screwpetals);\n        }\n     } else {\n      linear_extrude(height = screwh, twist=screw_twist,\n                     convexity = 10){\n        reinforceprofile(diam/2, screwpetals);\n        }\n     }\n     translate([0,0,screwh-stopperheight-0.2])\n       cylinder(r=diam/2-thickness, h=stopperheight+0.2+0.02);\n     translate([0,0,-2/3*thickness]) cylinder(r1=diam/2-thickness-0.01,r2=diam/2-thickness-2*stopperthickness, h=2*2*thickness/3+0.02, $fn=res);\n    }\n   }\n  }\n  }\n}\nmodule sharpedgetop(r, count) {\n  angle = 360/count;\n  unsharp = angle/20;\n  translate([0,0,realheight-4])\n   linear_extrude(height = 4+0.01, convexity = 10)\n   union() {\n     for (i=[1:count]) {\n       if (clockwise == \"no\") {\n\t\t\trotate([0,0,angle * i+screw_twist+angle/2-unsharp])\n           difference(){\n             wedge(r=r+1, d=angle/4);\n             rotate([0,0,-0.1]) wedge(r=r/2, d=angle/4+0.2);\n           }\n       } else {\n\t\t\trotate([0,0,angle * i-screw_twist-angle/2+angle/4+unsharp])\n           difference(){\n             wedge(r=r+1, d=angle/4);\n             rotate([0,0,-0.1]) wedge(r=r/2, d=angle/4+0.2);\n           }\n       }\n     }\n   }\n}\nmodule sharpedgebase(r, count) {\n  angle = 360/count;\n  unsharp = angle/20;\n  translate([0,0,screwstart-0.01])\n   linear_extrude(height = 4+0.01, convexity = 10)\n   union() {\n     for (i=[1:count]) {\n       if (clockwise == \"no\") {\n\t\t\trotate([0,0,angle * i+angle/4+unsharp])\n           difference(){\n             wedge(r=r, d=angle/4);\n             rotate([0,0,-0.005]) wedge(r=r-thickness, d=angle/4+0.01);\n           }\n       } else {\n\t\t\trotate([0,0,angle * i-unsharp])\n           difference(){\n             wedge(r=r, d=angle/4);\n             rotate([0,0,-0.005]) wedge(r=r-thickness, d=angle/4+0.01);\n           }\n       }\n     }\n   }\n}\nif (part == \"box\") {\nunion() {\n  difference() {\n    base();\n    logo();\n  }\n  stopper();\n  box();\n  difference() {\n    petals();\n    sharpedgetop(r=diam/2, count=screwpetals);\n    }\n  sharpedgebase(r=diam/2, count=screwpetals);\n}\n} else {\n  logo();\n}",
    "description": "Okay, I'd like to design a screw-top box, similar to the one I found on Thingiverse, but I want a bit more control over the design.\n\nEssentially, its a cylindrical box with a screw-on lid. The key features are:\n\n*   **Cylindrical Body & Lid:**  The main shape is a cylinder, with the top portion acting as the screw-on lid and the bottom portion as the base.\n*   **Screw Mechanism:** The lid attaches to the base using a screw-thread mechanism formed by petals. These petals are a key design feature.\n*   **Customizable Text/Logo:**  I need the ability to add text (or a simple logo) to the bottom of the box, recessed into the base. The text should be rendered using a font provided in the MCAD library.\n*   **Clearance:** It should be possible to add a small amount of clearance between the screw threads to make sure that the box is printable with less variation needed from the printer's calibration.\n\nHeres a breakdown of the parameters Id like to control, along with some initial ideas:\n\n*   **`thickness`**: The thickness of the box walls. (e.g., 3mm)\n*   **`diam`**: The overall diameter of the box. (e.g., 40mm)\n*   **`height`**: The height of the inside of the box (the usable space). (e.g., 45mm)\n*   **`screwh`**: The height of the screw part (the petals). This should be less than `height`. (e.g., 45mm)\n*   **`screw_twist`**: The amount of twist applied to the screw petals over their height, in degrees (e.g., 100 degrees).\n*   **`screwpetals`**: The number of petals forming the screw thread. (e.g., 3)\n*   **`logotext`**: The text to place on the bottom of the box. (e.g., \"Ingegno.be\")\n*   **`letterheight`**: Height of the letters in the text. (e.g. 12mm)\n*   **`reinforce`**: A yes/no option for adding reinforcement to the petals.\n*   **`clockwise`**: A yes/no option to control the direction of the screw thread.\n*   **`baseh`**: The height of the base of the box. (e.g., 3mm). The sum `height - screwh + baseh` should be at least 5mm.\n*   **`res`**: The resolution for the cylinders and other curves, in other words, number of facets in a cylinder. (e.g., 80)\n*   **`clearance`**: The clearance between petals, measured in degrees. (e.g., 0)\n\n**Key Design Details:**\n\n*   The text/logo should be inset into the base of the box.\n*   The screw threads should transition smoothly at the base and top.\n*   If `reinforce` is set to \"yes\", the petals should have small, triangular reinforcement structures.\n\n**Libraries to use:**\n*   The MCAD library (specifically the `fonts.scad` file)\n*  The utils/build_plate.scad for the build plate helper\n\nCould you provide an OpenSCAD file that allows me to customize all of these parameters? I'd like the generated file to be fully parametric. The way that this is done in the provided code is sufficient and ideal.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Hat Band Clip",
    "scad": "use <write/Write.scad>\nhat_band_width = 45;\nclip_width = 60;\nnumber_of_feathers = 1;\ntext = \"MAKER\";\ntext_size = 10;\nfeather_diameter = 2.1*1;\nnegative_cylinder_diameter = 8*1;\npositive_cylinder_diameter = 4*1;\nclip_strengths = 5*1;\nclip_border = 2*1;\nclip_height = hat_band_width + 2*clip_border;\nunion() {\n\tdifference() {\n\t\ttranslate([0, 0, 0]) cube([clip_width,clip_height,clip_strengths], center=true);\n\t\trotate([90,0,0]) {\n\t\t\ttranslate([clip_width/2-10, -(clip_strengths/2)], 0) cylinder(r=negative_cylinder_diameter/2, $fn=50, h=hat_band_width, center=true);\n\t\t\ttranslate([-(clip_width/2-10), -(clip_strengths/2)], 0) cylinder(r=negative_cylinder_diameter/2, $fn=50, h=hat_band_width, center=true);\n\t\t\ttranslate([clip_width/2, -(clip_strengths/2)], 0) scale([1.25,1,1]) cylinder(r=negative_cylinder_diameter/2, $fn=50, h=hat_band_width, center=true);\n\t\t\ttranslate([-(clip_width/2), -(clip_strengths/2)], 0) scale([1.25,1,1]) cylinder(r=negative_cylinder_diameter/2, $fn=50, h=hat_band_width, center=true);\n\t\t\tif(number_of_feathers == 1) {\n\t\t\t\ttranslate([0, -0.5, -clip_height/2]) rotate([0,-17.5,0]) cylinder(r=feather_diameter/2, $fn=20, h=clip_height, center=true);\n\t\t\t}\n\t\t\tif(number_of_feathers == 2) {\n\t\t\t\tfor(i = [0:number_of_feathers-1]) {\n\t\t\t\t\ttranslate([-5+i*10, -0.5, -clip_height/2]) rotate([0,-17.5,0]) cylinder(r=feather_diameter/2, $fn=20, h=clip_height, center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(number_of_feathers == 3) {\n\t\t\t\tfor(i = [0:number_of_feathers-1]) {\n\t\t\t\t\ttranslate([-5+i*5, -0.5, -clip_height/2]) rotate([0,-17.5,0]) cylinder(r=feather_diameter/2, $fn=20, h=clip_height, center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(number_of_feathers == 4) {\n\t\t\t\tfor(i = [0:number_of_feathers-1]) {\n\t\t\t\t\ttranslate([-4+i*5, -0.5, -clip_height/2]) rotate([0,-17.5,0]) cylinder(r=feather_diameter/2, $fn=20, h=clip_height, center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(number_of_feathers == 5) {\n\t\t\t\tfor(i = [0:number_of_feathers-1]) {\n\t\t\t\t\ttranslate([-5.5+i*5, -0.5, -clip_height/2]) rotate([0,-17.5,0]) cylinder(r=feather_diameter/2, $fn=20, h=clip_height, center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate([0,-(hat_band_width/4),3]) write(text, h=text_size, t=2, center=true);\n\t}\n\tdifference() {\n\t\trotate([90,0,0]) {\n\t\t\ttranslate([clip_width/2-10, -(clip_strengths/2)], 0) cylinder(r=positive_cylinder_diameter/2, $fn=40, h=hat_band_width, center=true);\n\t\t\ttranslate([-(clip_width/2-10), -(clip_strengths/2)], 0) cylinder(r=positive_cylinder_diameter/2, $fn=40, h=hat_band_width, center=true);\n\t\t\ttranslate([clip_width/2-1.5, -(clip_strengths/2)], 0) scale([.75,1,1]) cylinder(r=positive_cylinder_diameter/2, $fn=40, h=hat_band_width, center=true);\n\t\t\ttranslate([-(clip_width/2-1.5), -(clip_strengths/2)], 0) scale([.75,1,1]) cylinder(r=positive_cylinder_diameter/2, $fn=40, h=hat_band_width, center=true);\n\t\t}\n\t\ttranslate([0, 0, -clip_strengths]) cube([clip_width,clip_height,clip_strengths], center=true);\n\t}\n}",
    "description": "Okay, I've been playing around with OpenSCAD and made a hat band clip, but I think I could make it a lot better with some help. I'm looking for a parametric OpenSCAD file for a hat band clip that can be customized in several ways. \n\nHere's what I have in mind:\n\n**Core Shape and Function:**\n*   The clip should be a rectangular block that wraps around a hat band, like in the design of hatBandClip.scad. It should have a specific width and height, plus a thickness that determines how strong it will be.\n*   The clip should have two main cutouts on each side to help it grip the hat band. They should be rounded, forming a kind of \"C\" shape on each side, and positioned symmetrically on the sides.\n*   It should also have two raised parts that meet the cutouts, so it grips the hat band firmly. \n\n**Customization Parameters:**\n*   `hat_band_width`: The width of the hat band the clip is designed for.\n*   `clip_width`: The overall width of the clip.\n*   `clip_strengths`: The thickness of the clip.\n*  `clip_border`: Space between the edge of the clip and the C cutouts\n*   `number_of_feathers`: An integer value controlling the number of holes for decorative filaments (or \"feathers\"). This should be able to be from 0 to 5. The holes need to be slightly angled.\n*   `text`: The text to be displayed on the clip. \n*   `text_size`: The height of the displayed text.\n*   `feather_diameter`: The diameter of the \"feather\" holes. \n*  `negative_cylinder_diameter`: The diameter of the cutouts.\n*  `positive_cylinder_diameter`: The diameter of the raised parts that grip the hatband.\n\n**Text and Feather Holes:**\n*   The text should be centered horizontally on the clip and placed vertically towards the front of the clip.\n*   The feather holes should be centered horizontally on the clip, just above the text. The number and spacing should change when the `number_of_feathers` is changed. These holes should be angled slightly backwards, like in the previous design.\n*   If `number_of_feathers` is 0, there shouldn't be any holes.\n\n**Libraries:**\n*   I'd like to use the `Write.scad` library for handling the text.\n\n**Overall Goal:**\nI want a design that is easily customizable and that I can 3D print. It should have a functional design and look good with \"filament feathers\" inserted into the holes and with different text. I want to be able to make different clips for different hats, teams, events, etc.\n\nCould you generate an OpenSCAD file for me with these specifications?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Golf Ball Marker",
    "scad": "include <write/Write.scad>\nmarker_diameter = 15;\nspike_height = 5;\ninitials = \"ABC\";\nletter_height = 12;\nletter_type = \"fancy\";\nflip_model_to = 180;\nrotate(a=[0,flip_model_to,flip_model_to])\ndifference() {\n\tunion() {\n\t\tcylinder(h = 1, r1 = (marker_diameter - 1), r2 = marker_diameter, center = false, $fs = 0.01);\n\t\tcylinder(h = spike_height, r1 = 2, r2 = .25, center = false, $fs = 0.01);\n\t}\n\tmirror([ 0, 1, 0 ])\n\tif (letter_type == \"fancy\") {\n\t\ttranslate([0, 0.35, 0])\n\t\twrite(initials,t=.25,h=letter_height,font=\"write/BlackRose.dxf\",center=true,space=0.9);\n\t}\n\telse\n\t{\n\t\twrite(initials,t=.25,h=letter_height,font=\"write/Letters.dxf\",center=true,space=0.9);\n\t}\n}",
    "description": "Okay, I need a customizable golf ball marker. I want to be able to change a few things like the size, the height of the little spike that goes into the green, and what letters are on it.\n\nHere's the breakdown:\n\n*   **Overall Shape:** It should be a flat, circular disc with a small spike coming out of the bottom, kind of like a tiny mushroom.\n\n*   **Diameter:** I need to be able to set the main diameter of the disc, say from 10 to 20 mm. Id like to call the variable `marker_diameter`.\n\n*   **Spike Height:** I also need to adjust how long the spike is, maybe between 5 and 8 mm. This variable should be `spike_height`.\n\n*   **Initials:** I want to put my initials on the marker, and the letters should be engraved *into* the top of the disc. I should be able to type whatever letters I want; let's call this variable `initials`.\n\n*   **Letter Height:** I need to specify the height of the letters as well. Let's start with a range of 9 to 13 mm, with the variable name `letter_height`.\n\n*   **Letter Style:** Itd be great if I could choose between two letter styles: \"fancy\" and \"plain\", the variable should be called `letter_type`.\n\n*   **View/Print:** I need to flip the model so I can view and customize the text on the top surface, and flip back for printing. I think a value of 180 degrees on the X or Y axis will work. The variable should be named `flip_model_to`, and use 180 for viewing and 0 for printing.\n\n*   **Libraries:** It should use the `Write.scad` library for generating the text. That file has an included folder called `write`, so it should refer to `write/BlackRose.dxf` and `write/Letters.dxf` for the fonts.\n\nCould you generate the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Configurable Terminal Block",
    "scad": "NoTerminals = 3;\nTerminalHoleSize = 4;\nTerminalHeight = 8;\nTerminalWidth = 12;\nBlockWidth = 14;\nTerminalDivider = 2.4;\nNutThickness = 4;\nReqTabs = \"Yes\";\nMountTabLength = 8;\nMountTabHeight = 8;\nMountHole = 4;\nClearence = 0.5;\nEnclose =1;\nNutHeight = Enclose > 1 ? NutThickness : TerminalHeight - 2;\nfor (i =[ 0:NoTerminals - 1]) {\n\ttranslate ([0,(TerminalWidth + TerminalDivider) * i ,0])\n\t\tterminal() ;\n\t}\ntranslate ([- TerminalDivider ,- TerminalDivider , 0])\n\t\tcube([BlockWidth + TerminalDivider * 2,\n\t\t\t\tTerminalDivider ,\n\t\t\t\tTerminalHeight + TerminalDivider]);\nif (ReqTabs == \"Yes\") {\n\ttranslate ([0,-TerminalDivider,0]) mirror ([0,1,0]) tab() ;\n\ttranslate ([0,(TerminalWidth + TerminalDivider) * NoTerminals,0]) tab() ;\n\t}\nmodule tab() {\n\tdifference () {\n\t\ttranslate ([MountHole /2, 0,0])\n\t\t\tminkowski() {\n\t\t\t\tcube([BlockWidth - MountHole,\n\t\t\t\t\tMountTabLength ,\n\t\t\t\t\tMountTabHeight ]);\n\t\t\t\tcylinder ( r= (MountHole + Clearence )/2 , h =.01 , $fn=50);\n\t\t\t}\n\t\ttranslate ([BlockWidth /2, MountTabLength /2, -1]) cylinder ( r= (MountHole + Clearence )/2 , h = MountTabHeight + 2, $fn=50);\n\t}\n}\nmodule terminal() {\ndifference() {\n\tunion() {\n\t\tcube([BlockWidth,TerminalWidth,TerminalHeight]);\n\t\ttranslate ([- TerminalDivider , TerminalWidth , 0])\n\t\t\t\tcube([BlockWidth + (TerminalDivider * 2),\n\t\t\t\t\tTerminalDivider + 0.01 ,\n\t\t\t\t\tTerminalHeight + TerminalDivider]);\n\t}\n\ttranslate ([BlockWidth / 2,\n\t\t\t\tTerminalWidth / 2,\n\t\t\t\tNutHeight  + .5])\n\t\t\tcylinder ( r= (TerminalHoleSize + Clearence )/2 ,\n\t\t\t\th = TerminalHeight, $fn=50);\n\ttranslate ([BlockWidth /2,\n\t\tTerminalWidth /2,  -1])\n\t\tcylinder ( r= ( TerminalHoleSize + Clearence ) / 2 ,\n\t\th = NutHeight - (NutThickness / 2) + 1, $fn=50);\n\ttranslate ([BlockWidth /2,\n\t\t\t\tTerminalWidth /2,\n\t\t\t\tNutHeight - NutThickness ])\n\t\t\tcylinder ( r= TerminalHoleSize + ( Clearence ) , h = NutThickness , $fn=6);\n\tif (Enclose == 0) {\n\t\ttranslate ([BlockWidth /2 + .1,\n\t\t\t\t\t(TerminalWidth  - (TerminalHoleSize + Clearence) * 1.8) / 2 ,\n\t\t\t\t\tNutHeight - NutThickness  ])\n\t\t\tcube([ BlockWidth /2\t, (TerminalHoleSize + Clearence) * 1.8, NutThickness]);\n\t\t}\n\t}\n}",
    "description": "Okay, I need a parametric terminal block generator in OpenSCAD. I'd like it to be configurable for the number of terminals, the screw size for each terminal, and the overall dimensions of the block. Here are the details:\n\n**Basic Terminal Block:**\n\n*   **Number of Terminals:** This should be a configurable integer.\n*   **Terminal Screw Hole:** This should have a configurable diameter, and should be a hole right through the block.\n*   **Terminal Height:** The height of each terminal block, should be configurable.\n*   **Terminal Width:** The width of each individual terminal, should be configurable.\n*   **Block Width:** The width of the main block, should be configurable.\n*   **Terminal Divider:** The width of the space/divider between the terminals, should be configurable.\n*   **Nut Thickness:** The thickness of the nut that the screw will thread into, should be configurable.\n*   **Clearance:** A configurable clearance value, for nut holes and screw holes, to account for printing tolerances.\n\n**Mounting Tabs:**\n\n*   **Mounting Tabs:** A boolean (yes/no) option to include mounting tabs on either end of the block.\n*   **Mount Tab Length:** Configurable length of the mounting tabs.\n*   **Mount Tab Height:** Configurable height of the mounting tabs.\n*  **Mount Hole Diameter:** Configurable diameter for the mounting holes in the tabs.\n\n**Nut/Bolt Options:**\n\n*   **Nut/Bolt Type:** This should be a selection between three options:\n    *   **Enclosed Nuts:** The design will include recessed hex pockets for nuts to be inserted *during* the print (so the print has to be paused to insert them). The nuts will be captive in the print.\n    *   **Slotted Nuts:** The design will include a slot so a nut can be inserted *after* the print. These would be a recessed hole for the nut, and a channel wide enough to slide the nut into place.\n    *   **Bolted:** The design should include a larger recessed hole and clearance for a bolt head to be inserted from below *after* the print, the bolt will thread into the printed plastic.\n\n**Additional Considerations:**\n\n*   The nut height will be calculated automatically based on whether enclosed, slotted, or bolted is selected, based on the `TerminalHeight` and `NutThickness` parameters. For Enclosed, the nut height should sit 2mm from the top. For slotted it should sit 2mm from the top and for bolted it should be the same as the nut thickness.\n*  All cylinders for holes should be made with `$fn=50`. All nut hexes should be made with `$fn=6`.\n*  The clearance should be applied to all appropriate holes.\n*   The design should be generated using loops so multiple terminals are created automatically.\n*   The code should be well-commented and easy to understand.\n*   I am not using any libraries for this code (BOSL, MCAD, etc.).\n\nCould you generate an OpenSCAD file based on these requirements?\n"
  },
  {
    "object": "Hey cadmonkey, make me a St Patrick's Day Chain",
    "scad": "Type=1;\nLinks=11;\nT=1;\nScale=30;\nmodule Shamrock(h){\n  scale([25.4/90, -25.4/90, 1]) union()\n  {\n    linear_extrude(height=h)\n      polygon([[-3.057506,16.708888],[-3.553250,34.685854],[-3.204347,47.940543],[-2.123063,57.100584],[-1.342863,60.341246],[-0.421667,62.793608],[1.725876,59.570553],[3.901054,56.637945],[6.157715,54.561744],[7.333428,54.021657],[8.549705,53.907908],[3.738222,29.682176],[2.234131,20.065375],[2.086113,16.929117],[2.485014,15.306908],[6.235771,22.631579],[10.413383,28.738632],[14.905644,33.677575],[19.600348,37.497912],[24.385287,40.249148],[29.148257,41.980790],[33.777050,42.742344],[38.159460,42.583314],[42.183281,41.553207],[45.736306,39.701527],[48.706329,37.077782],[50.981144,33.731476],[52.448544,29.712115],[52.996323,25.069204],[52.512275,19.852250],[50.884193,14.110758],[54.098436,11.997054],[56.770070,9.379290],[58.873755,6.366319],[60.384149,3.066995],[61.275912,-0.409829],[61.523703,-3.955299],[61.102182,-7.460562],[59.986009,-10.816765],[58.149842,-13.915053],[55.568341,-16.646575],[52.216166,-18.902475],[48.067976,-20.573901],[43.098430,-21.551999],[37.282188,-21.727916],[30.593909,-20.992798],[23.008253,-19.237792],[26.914246,-23.340867],[29.862537,-27.730794],[31.906566,-32.295076],[33.099776,-36.921215],[33.495611,-41.496713],[33.147510,-45.909073],[32.108918,-50.045796],[30.433277,-53.794385],[28.174027,-57.042342],[25.384613,-59.677170],[22.118476,-61.586370],[18.429058,-62.657446],[14.369802,-62.777898],[9.994149,-61.835231],[5.355543,-59.716944],[0.507426,-56.310542],[-3.222046,-59.335469],[-7.094410,-61.387173],[-11.013628,-62.521329],[-14.883659,-62.793608],[-18.608461,-62.259682],[-22.091995,-60.975224],[-25.238221,-58.995907],[-27.951096,-56.377402],[-30.134582,-53.175383],[-31.692638,-49.445520],[-32.529222,-45.243488],[-32.548295,-40.624957],[-31.653817,-35.645601],[-29.749746,-30.361091],[-26.740042,-24.827101],[-22.528664,-19.099302],[-29.897165,-21.451402],[-36.467612,-22.578327],[-42.250192,-22.617615],[-47.255093,-21.706803],[-51.492501,-19.983426],[-54.972604,-17.585022],[-57.705588,-14.649128],[-59.701642,-11.313280],[-60.970951,-7.715014],[-61.523703,-3.991868],[-61.370085,-0.281378],[-60.520285,3.278919],[-58.984488,6.551487],[-56.772883,9.398789],[-53.895657,11.683288],[-50.362995,13.267448],[-52.094096,17.674549],[-52.854572,22.043268],[-52.718478,26.262058],[-51.759873,30.219371],[-50.052814,33.803661],[-47.671358,36.903381],[-44.689561,39.406984],[-41.181482,41.202923],[-37.221177,42.179650],[-32.882703,42.225620],[-28.240118,41.229285],[-23.367479,39.079099],[-18.338842,35.663514],[-13.228266,30.870983],[-8.109806,24.589960],[-3.057521,16.708898]]);\n  }\n}\nmodule PrintLink1(){\n\tdifference(){\n\t\ttranslate([3.5,0,0]) rotate([0,0,35]) Shamrock(T/SC);\n\t\ttranslate([0,12.5,0]) cylinder(r=4,h=(T*3)/SC,$fn=50,center=true);\n\t\ttranslate([0,-10.75,0]) cylinder(r=4,h=(T*3)/SC,$fn=50,center=true);\n\t\ttranslate([-20,-20,-T/SC]) cube([20,40,(T*4)/SC]);\n\t}\n\trotate([0,60,0]) difference(){\n\t\ttranslate([3.5,0,0]) rotate([0,0,35]) Shamrock(T/SC);\n\t\ttranslate([0,12.5,0]) cylinder(r=4,h=(T*3)/SC,$fn=50,center=true);\n\t\ttranslate([0,-10.75,0]) cylinder(r=4,h=(T*3)/SC,$fn=50,center=true);\n\t\ttranslate([0,-20,-T/SC]) cube([40,40,(T*3)/SC]);\n\t}\n}\nmodule StraightChain(){\n\tfor (i=[1:Links]){\n\t\tif (i%2==1){\n\t\t\ttranslate([0,28*(i-1),0]) PrintLink1();\n\t\t} else {\n\t\t\ttranslate([1,28*(i-1),0]) mirror([1,0,0]) PrintLink1();\n\t\t}\n\t}\n}\nmodule LoopChain(){\n\tfor (i=[1:Links]){\n\t\trotate([0,0,i*Seg]) translate([Rad,0,0])\n\t\tif (i%2==1){\n\t\t\tPrintLink1();\n\t\t} else {\n\t\t\ttranslate([0,0,0]) mirror([1,0,0]) PrintLink1();\n\t\t}\n\t}\n}\nPi=3.1415926535897;\nSeg=360/Links;\nRad=(Links*28)/(2*Pi);\nSC=Scale/30;\nfudge=0.1;\nif (Type==0){\n\tscale([SC,SC,SC]) StraightChain();\n} else {\n\tscale([SC,SC,SC]) LoopChain();\n}",
    "description": "Okay, I'm looking to make a St. Patrick's Day chain, kind of like a necklace or maybe something I could hang up. I've got a basic idea in mind, and I'd like to have it generated as an OpenSCAD file.\n\nHere's what I need:\n\n1.  **Shamrock Links:** The chain should be made of interconnected shamrock-shaped links. I'd like to be able to adjust the scale of these shamrocks and the thickness of the material, so they look right.\n\n2.  **Chain Type:** I want to be able to choose between making a straight chain or a closed loop. A closed loop would work better for a necklace, while a straight one might work better as a banner.\n\n3. **Chain Length:** I want to control the number of links used to make up the chain. More links should mean a longer chain.\n\n4.  **Parametric Design:** The design needs to be parametric so I can adjust the following properties:\n    *   `Links`:  The total number of links in the chain.\n    *   `T`: The thickness of the material (how thick the shamrock links are).\n    *   `Scale`: The size of the shamrock link, approximately how wide it is from end to end.\n    *   `Type`:  A switch, probably `0` for a straight chain and `1` for a closed loop.\n\n5.  **OpenSCAD file:** I need the result to be a single OpenSCAD file I can directly open in the OpenSCAD program and modify myself if needed.\n\n6.  **Link Structure:** The links should connect to each other with a simple pin and hole mechanism for easy assembly (or printing). I want each link to be identical except that every other link is flipped to correctly attach to the next. \n\n7.  **No Library Dependencies:** I don't want to rely on any external libraries. Please keep everything self-contained in a single OpenSCAD file.\n\nI think that covers it. Let me know if you need any more information, but it seems fairly straightforward.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Heel Lift",
    "scad": "heel_width =80;\nl=70;\nh=5;\nwedge_angle=10;\nr=heel_width/2;\ntotal_l = r+l;\nfoot_wedge();\nmodule foot_wedge(){\ndifference(){\nunion(){\ntranslate([r,l,0])cylinder(h*2+l*tan(wedge_angle),r,r, $fs=1);\ntranslate([0,0,0])cube([r*2,l,h*2+l*tan(wedge_angle)]);\n}\ntranslate([-1,0,h])rotate([wedge_angle,0,0])cube([r*2+10,total_l*2,h*2+l*tan(wedge_angle)]);\ntranslate([0,-total_l,-1])cube([r*2,total_l,(h*2+l*tan(wedge_angle))+2]);\n}\n}",
    "description": "Okay, I need some help designing a customizable heel lift for my shoes. I'm looking to make something that I can adjust for different needs and that I can 3D print. I've seen some designs out there, but I'd like something a bit more parametric so I can tweak it to fit perfectly.\n\nHere's the basic idea: I need a wedge-shaped piece that fits under the heel. The width of the heel area will be a key variable, which I'll need to adjust to fit different shoes. The length of the wedge extending past the heel will also be adjustable, as will the height at the front of the wedge, and the overall angle of the wedge, because some people need more of a lift than others.\n\nId like the design to be based on a few specific parameters.  I need to be able to specify the heel width, the length of the wedge past the heel, the height at the front of the wedge, and the wedge angle. This should be a pretty standard wedge, and I don't anticipate needing to do anything too fancy like rounded corners in the first iteration. \n\nTo be clear, I need the following to be *parameters*:\n\n*   `heel_width`: The width of the heel in millimeters. Im assuming this will be for a flat footbed, and that the radius of the circle that forms the back of the wedge will be calculated from this value by dividing it in half.\n*   `l`: The length of the wedge extension past the heel in millimeters.\n*   `h`: The height at the front of the wedge in millimeters.\n*   `wedge_angle`: The angle of the wedge in degrees.\n\nThe design should be in OpenSCAD and should be easy to modify using these parameters, so please avoid any hard coded values other than for very minor and specific offset needs.\n\nI would prefer if the OpenSCAD file is clear and well-commented so that I can understand how the code works, and how to change it if needed later. Im not interested in any libraries other than the basic capabilities of OpenSCAD.\n\nCan you help me generate this OpenSCAD file?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Gasket",
    "scad": "gasket_thickness=1;\ngasket_outer_diameter=2;\ngasket_inner_diameter=1;\nmodule gasket()\n{\n\tdifference()\n\t{\n\tcylinder(h=gasket_thickness, r=gasket_outer_diameter*2, center=true, $fn=100);\n\tcylinder(h=gasket_thickness, r=gasket_inner_diameter*2, center=true, $fn=100);\n\t}\n}\ngasket();",
    "description": "Okay, I'm looking to design a more flexible gasket generator in OpenSCAD, but I need some help making it more powerful and easier to use. I really like the existing \"gasket.scad\" example, and it gets me most of the way there, but it's missing some features and flexibility.\n\nHere's what I want the new gasket generator to be able to do:\n\n1.  **Variable Thickness:** Like the existing file, I need to be able to set the gasket thickness as a variable, say `gasket_thickness`.\n\n2.  **Inner and Outer Diameters:** I also need to specify the inner and outer diameters, `gasket_inner_diameter` and `gasket_outer_diameter` respectively, just like the original.\n\n3.  **Variable Bolt Holes:** I want to add the ability to generate bolt holes around the perimeter of the gasket.\n    *   The number of bolt holes should be variable, say `num_bolt_holes`.\n    *   The bolt hole diameter should also be variable, `bolt_hole_diameter`.\n    *   The distance of the bolt holes from the center should be variable, `bolt_hole_radius`, and this value should be larger than the `gasket_inner_diameter` and smaller than the `gasket_outer_diameter`\n    *   The placement of the first bolt hole should be set with a rotation angle, `bolt_hole_start_angle`. This will allow easy alignment of bolt holes to external parts.\n\n4.  **Rounded Edges (Fillet):** I'd like to add a fillet to the top and bottom edges of the gasket. The fillet radius should be variable, `fillet_radius`. I think this will be a cosmetic improvement as well as improve the seal\n\n5.  **Cutout Shapes:** Ideally, I would be able to add cutout shapes anywhere on the surface of the gasket, using basic 2D shapes like squares or circles. This would allow for complex seal patterns or accommodate obstructions. The cutout shapes would have their own customizable dimensions and positions.  This will probably require some kind of `cutout_shapes` array or something like that.\n\n6.  **Parametric Cutout Placement:** I want to be able to place these cutout shapes parametrically.  I should be able to define the cutout shapes and a number, an angle offset (like how we did the bolt holes), a radius offset, and a repeat count. This will allow me to create circular repeating patterns like for the bolt holes.\n\n7.  **Support for `$fn`:** The generated part should support the global `$fn` variable to control the smoothness of circles and curves.\n\nI'm not looking for anything super advanced in the cutout shapes for now (just circles and squares); I can expand on that later. The most important thing for me is that this generator be easy to use and allow me to quickly create custom gasket designs with different sizes, bolt holes, and a few custom cutouts. The idea is that I'll ultimately use a caulkstruder to make these. \n\nCan you generate an OpenSCAD file for this? I would also prefer if it uses the BOSL2 library.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable stick bowl art XL",
    "scad": "add_bottom = \"no\";\nbottom_height = 2;\nbase_form = \"beam\";\nsize = 4;\nscale_second_dir = 1;\ndual_pat = \"even_odd\";\npart = \"both\";\nscalefirst = 1.005;\nshowcolor = \"no\";\nr0 = 5;\nnrsticks = 18;\ngrad_per_stick = 360 / nrsticks;\n01_radius = 50;\n01_height = 0;\n01_extend = 1;\n01_skew = 0;\n02_radius = 50;\n02_height = 120;\n02_extend = 1;\n02_skew = 0;\n03_radius = 60;\n03_height = 40;\n03_extend = 1;\n03_skew = 0;\n04_radius = 30;\n04_height = 1;\n04_extend = 1;\n04_skew = 0;\n05_radius = 0;\n05_height = 20;\n05_extend = 2;\n05_skew = -27;\n06_radius = 0;\n06_height = 40;\n06_extend = 5;\n06_skew = 90;\n07_radius = 0;\n07_height = 40;\n07_extend = 5;\n07_skew = 90;\n08_radius = 0;\n08_height = 40;\n08_extend = 5;\n08_skew = 90;\n09_radius = 0;\n09_height = 40;\n09_extend = 5;\n09_skew = 90;\n10_radius = 0;\n10_height = 40;\n10_extend = 5;\n10_skew = 90;\n11_radius = 0;\n11_height = 40;\n11_extend = 5;\n11_skew = 90;\n12_radius = 0;\n12_height = 40;\n12_extend = 5;\n12_skew = 90;\nmax_height = 150;\nmax_width = 145;\nuse <MCAD/regular_shapes.scad>;\nuse <utils/build_plate.scad>;\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nbottomstart = -bottom_height;\nmodule baseform(length){\n  scale([1,scale_second_dir,1]){\n  if (base_form == \"beam\") {\n    translate([-size/2, -size/2, 0]) cube(size=[size, size, length]);\n  }\n  if (base_form == \"cylinder\") {\n    cylinder(r=size, h=length, $fn=20);\n  }\n  if (base_form == \"hexagon\") {\n    linear_extrude(height=length) hexagon(size);\n  }\n  if (base_form == \"triangle\") {\n    linear_extrude(height=length) triangle(size);\n  }\n  }\n}\nmodule ringbaseform(r1, h1, skew1, r2, h2, skew2, extend){\n  rotate([0,0,skew1])\n  translate([r1, 0, h1])\n  help_ringbaseform(r2*cos(-skew2)-r1, r2*sin(-skew2), h2-h1, extend);\n}\nmodule help_ringbaseform(a, b, c, extend)\n{\n  rotate([atan2(b/sqrt(pow(a, 2) + pow(b, 2) + pow(c, 2)),\n                c/sqrt(pow(a, 2) + pow(b, 2) + pow(c, 2))), 0, 0])\n  rotate([0, atan2(a/sqrt(pow(a, 2) + pow(b, 2) + pow(c, 2)),\n     sqrt(b*b/(pow(a, 2) + pow(b, 2) + pow(c, 2))\n          +c*c/(pow(a, 2) + pow(b, 2) + pow(c, 2)))), 0])\n  translate([0,0,-extend])\n  baseform(sqrt(pow(a, 2) + pow(b, 2)\n                    + pow(c, 2)) + 2*extend);\n}\nmodule ring(ringnr, curpart){\nif (curpart == \"both\" || (dual_pat == \"ring\" && curpart == \"first\" && ringnr%2 == 0)\n   ||  (dual_pat == \"ring\" && curpart == \"second\" && ringnr%2 == 1)\n   ||  (dual_pat == \"even_odd\"))\n{\n  union() {\n    for (i = [0:nrsticks]) {\n     if (curpart == \"both\" || dual_pat == \"ring\" ||\n         (dual_pat == \"even_odd\" && curpart == \"first\" && i%2 == 0) ||\n         (dual_pat == \"even_odd\" && curpart == \"second\" && i%2 == 1)\n        ) {\n      rotate([0,0,i*grad_per_stick]) {\n        if (ringnr == 1) {\n          ringbaseform(r0, 0, 0, 01_radius, 01_height,\n                       01_skew,  01_extend);}\n        if (ringnr == 2){\n          ringbaseform(01_radius, 01_height, 01_skew,\n                       02_radius, 02_height, 02_skew,\n\t\t\t\t\t\t\t  02_extend);}\n        if (ringnr == 3)\n          ringbaseform(02_radius, 02_height,\n                       01_skew + 02_skew,\n                       03_radius, 03_height, 03_skew,\n\t\t\t\t\t\t\t  03_extend);\n        if (ringnr == 4)\n          ringbaseform(03_radius, 03_height,\n\t\t\t\t\t\t\t  01_skew + 02_skew + 03_skew,\n                       04_radius, 04_height, 04_skew,\n\t\t\t\t\t\t\t  04_extend);\n        if (ringnr == 5)\n          ringbaseform(04_radius, 04_height,\n  01_skew + 02_skew + 03_skew + 04_skew,\n                       05_radius, 05_height, 05_skew,\n\t\t\t\t\t\t\t  05_extend);\n        if (ringnr == 6)\n          ringbaseform(05_radius, 05_height,\n  01_skew + 02_skew + 03_skew + 04_skew + 05_skew,\n                       06_radius, 06_height, 06_skew,\n\t\t\t\t\t\t\t  06_extend);\n        if (ringnr == 7)\n          ringbaseform(06_radius, 06_height,\n  01_skew + 02_skew + 03_skew + 04_skew + 05_skew + 06_skew,\n                       07_radius, 07_height, 07_skew,\n\t\t\t\t\t\t\t  07_extend);\n        if (ringnr == 8)\n          ringbaseform(07_radius, 07_height,\n  01_skew + 02_skew + 03_skew + 04_skew + 05_skew + 06_skew + 07_skew,\n                       08_radius, 08_height, 08_skew,\n\t\t\t\t\t\t\t  08_extend);\n        if (ringnr == 9)\n          ringbaseform(08_radius, 08_height,\n  01_skew + 02_skew + 03_skew + 04_skew + 05_skew + 06_skew + 07_skew + 08_skew,\n                       09_radius, 09_height, 09_skew,\n\t\t\t\t\t\t\t  09_extend);\n        if (ringnr == 10)\n          ringbaseform(09_radius, 09_height,\n  01_skew + 02_skew + 03_skew + 04_skew + 05_skew + 06_skew + 07_skew + 08_skew + 09_skew,\n                       10_radius, 10_height, 10_skew,\n\t\t\t\t\t\t\t  10_extend);\n        if (ringnr == 11)\n          ringbaseform(10_radius, 10_height,\n  01_skew + 02_skew + 03_skew + 04_skew + 05_skew + 06_skew + 07_skew + 08_skew + 09_skew + 10_skew,\n                       11_radius, 11_height, 11_skew,\n\t\t\t\t\t\t\t  11_extend);\n        if (ringnr == 12)\n          ringbaseform(11_radius, 11_height,\n  01_skew + 02_skew + 03_skew + 04_skew + 05_skew + 06_skew + 07_skew + 08_skew + 09_skew + 10_skew + 11_skew,\n                       12_radius, 12_height, 12_skew,\n\t\t\t\t\t\t\t  12_extend);\n       }\n      }\n    }\n  }\n}\n}\nmodule bottom(){\n  if (add_bottom == \"yes\") {\n    translate([0,0,bottomstart])\n      cylinder(r = r0+size, h=bottom_height);\n  }\n}\nmodule bowl(curpart){\nunion() {\n  if (curpart == \"both\" || curpart == \"first\") {\n    bottom();\n    }\n  ring(1, curpart);\n  if (02_radius > 0) {\n    ring(2, curpart);}\n  if (03_radius > 0) {\n    ring(3, curpart);}\n  if (04_radius > 0) {\n    ring(4, curpart);}\n  if (05_radius > 0) {\n    ring(5, curpart);}\n  if (06_radius > 0) {\n    ring(6, curpart);}\n  if (07_radius > 0) {\n    ring(7, curpart);}\n  if (08_radius > 0) {\n    ring(8, curpart);}\n  if (09_radius > 0) {\n    ring(9, curpart);}\n  if (10_radius > 0) {\n    ring(10, curpart);}\n  if (11_radius > 0) {\n    ring(11, curpart);}\n  if (12_radius > 0) {\n    ring(12, curpart);}\n}\n}\nintersection(){\n  translate([0,0,-bottomstart]) {\n    if (part == \"bothorig\") {\n      if (showcolor == \"no\") {\n        bowl(part);\n        } else {\n        color(\"DarkSalmon\")\n        difference() {\n          bowl(\"second\");\n          bowl(\"first\");\n          }\n        color(\"Orange\")\n        bowl(\"first\");\n        }\n      }\n    if (part == \"both\") {\n      if (showcolor == \"no\") {\n          scale([scalefirst,scalefirst,scalefirst]) bowl(\"first\");\n          bowl(\"second\");\n        } else {\n        color(\"DarkSalmon\")\n        difference() {\n          bowl(\"second\");\n          scale([scalefirst,scalefirst,scalefirst]) bowl(\"first\");\n          }\n        color(\"Orange\")\n        scale([scalefirst,scalefirst,scalefirst]) bowl(\"first\");\n        }\n      }\n    if (part == \"first\") {\n      color(\"Orange\")\n      scale([scalefirst,scalefirst,scalefirst]) bowl(part);\n      }\n    if (part == \"second\") {\n      color(\"DarkSalmon\")\n      difference() {\n        bowl(\"second\");\n        render()\n        scale([scalefirst,scalefirst,scalefirst]) bowl(\"first\");\n        }\n      }\n    }\n  translate([-max_width/2,-max_width/2,0])\n    cube(size=[max_width,max_width,max_height]);\n}",
    "description": "Okay, I'd like to create a customized stick bowl design, but much larger and more complex than the basic one I've seen. I'd like to be able to control a lot of parameters, so I need a parametric OpenSCAD file that can handle it.\n\nHere's what I'm thinking for features and parameters:\n\n**Basic Structure:**\n\n*   **Stick Shape:** I want to be able to choose the basic form of the sticks used to construct the bowl, with options for `beam`, `cylinder`, `hexagon`, and `triangle`.\n*   **Stick Size:**  A parameter called `size` to control the dimensions of the basic stick cross section. I want to specify a single value that changes the radius if cylinder, or side length if hexagon or triangle, or width and depth if beam.\n*   **Stick Scaling:** A parameter `scale_second_dir` that allows scaling of sticks in the second dimension, perpendicular to its length. This allows for things like flattened sticks (scale < 1) or thicker sticks (scale > 1).\n*   **Dual Extrusion Control:** I want to be able to use the design for dual extrusion, with two distinct parts that can be different materials or colors.\n    *   A parameter `dual_pat` to switch between having the two parts be alternating \"rings\" or alternating even/odd \"sticks\" within a ring. The options would be `ring` and `even_odd`.\n    *   A `part` parameter with options for `both`, `bothorig`, `first`, and `second`. `first` and `second` control which of the two extrusion parts is displayed or rendered. `both` will display them together, with the first part scaled by `scalefirst` and `second` not scaled. The `bothorig` should display both parts without the scaling.\n    *   A parameter `scalefirst` to fine-tune the scale of the first dual extrusion part.\n    *   A `showcolor` parameter (with `yes` or `no`) that controls whether the different parts of dual extrusion are shown in different colors. This is just for preview, I would set to `no` before generating an STL file.\n\n*   **Starting Radius:** A parameter `r0` to control the starting radius at the bottom.\n*   **Number of Sticks:** A parameter `nrsticks` which determines how many sticks are used per ring, and thus the spacing between them.  The `grad_per_stick` value can be derived from `360/nrsticks`, but could be useful as an intermediate for other purposes.\n\n**Bowl/Base:**\n\n*   **Bottom:** A parameter `add_bottom` that can be \"yes\" or \"no\", controlling whether a base is added to the bowl.\n*   **Bottom Height:** If `add_bottom` is set to \"yes\", a parameter `bottom_height` will set the height of the base cylinder.\n\n**Rings:**\n\n*   I want to be able to define up to 12 rings, each with their own parameters. For each ring (numbered 01 through 12):\n    *   A parameter to set the radius `[ring number]_radius` which if `0` means this ring is not generated.\n    *   A parameter to set the height `[ring number]_height`.\n    *   A parameter to set the stick length extension at each end of each stick on that ring `[ring number]_extend`. This should make the sticks extend beyond the radius of the ring itself, and should influence how it connects to the next ring.\n    *   A parameter to skew or rotate each ring `[ring number]_skew`. This rotates the whole ring around the z-axis.\n\n**General Constraints:**\n\n*   **Maximum Height:** A parameter `max_height` to define the maximum height of the generated object. The object should be clipped at this height.\n*   **Maximum Width:** A parameter `max_width` to define the maximum width of the generated object. The object should be clipped at this width.\n\n**Libraries:**\n\n*   I'll need the `MCAD/regular_shapes.scad` library for the `hexagon` and `triangle` shapes, as well as the `utils/build_plate.scad` to display build plate for preview.\n\nI think that covers it. Let me know if you have any questions!\n"
  },
  {
    "object": "Hey cadmonkey, make me a STAMPY - Wax Seal Stamp Customizer",
    "scad": "quality = 25;\nhandle_size = \"large\";\ninput =\"default_TNH\";\nseal_size = 10;\nMove_X = 0;\nMove_Y = 0;\nmodule GoAwayCustomizer(){\n}\nuse <write/Write.scad>\nuse <MCAD/triangles.scad>\nstencil_thickness = 1.5;\noffX = 0;\noffY = 0;\nmargin = 10;\ndispo_width = seal_size;\npoints_array = (input==\"default_TNH\"? [[133,286],[[234.27,6.02],[231.55,7.45],[227.5,10.88],[222.85,15.67],[218.69,20.35],[214.95,25.17],[211.32,30.24],[208.44,34.98],[206.52,39],[205.31,48.23],[204.14,65.5],[202.43,96.43],[199.95,138.5],[197.65,174.91],[196.37,192.25],[195.44,195.38],[192.95,196],[190.58,196.5],[189.09,197.84],[188.55,199.75],[188.65,201.77],[188.28,204.15],[185.74,207.18],[181.17,210.7],[175.06,214.5],[168.61,218.79],[163.29,223.5],[159.05,228.64],[155.24,233.98],[152.19,239.17],[149.77,243.98],[148.11,250.02],[146.97,258.66],[145.84,267.33],[144.06,272.66],[141.97,276.16],[139.87,279.16],[138.4,281.78],[138.36,284.3],[139.83,286.58],[143.12,288.43],[150.09,289.9],[162.38,291.02],[181.28,291.67],[205.5,291.95],[229.79,291.67],[248.86,291],[261.56,289.87],[267.86,288.28],[270.76,286.27],[271.82,283.7],[271.26,280.36],[268.97,275.96],[266.18,270.14],[264.49,261.76],[263.22,253.76],[262.03,247.53],[260.34,242.46],[257.87,237.27],[254.58,232.07],[250.91,227.01],[246.01,222],[239.74,216.91],[233.89,213.03],[230,210.88],[227.72,209.34],[225.75,206.9],[224.51,204.05],[224,201.5],[223.82,199.39],[223.39,197.58],[222.07,196.41],[219.45,196],[216.94,195.74],[215.57,195.11],[215.61,179.54],[216.5,143.36],[217.84,100.02],[218.98,67.24],[219.99,41.97],[223.5,34.86],[227.01,28.44],[230.51,22.99],[232.97,19.44],[234,17.58],[234.64,16.25],[236.17,13.98],[237.73,11.12],[237.19,8.52],[235.86,6.75],[234.27,6.02]],[[212.84,76.5],[212.5,59.5],[211.74,69.5],[210.48,90.08],[208.53,125.5],[206.63,159.58],[205.5,176.93],[204.81,181.12],[203.95,183.56],[203.18,185.98],[202.73,190.13],[202.5,195.5],[206.22,195.81],[209.36,195.65],[210.42,193.81],[211.09,177.78],[212.04,142.5],[212.75,102.9],[212.84,76.5]],[[206,209],[195.82,209.28],[191.5,210],[194.92,210.74],[206,211],[217.08,210.74],[220.5,210],[216.18,209.28],[206,209]],[[205.86,215.72],[183.79,215.5],[178.37,218.41],[172.58,222.55],[166.23,228.5],[160.29,235.76],[156.27,243.19],[153.68,250.66],[151.96,258.09],[150.89,264.79],[149.83,270.5],[148.37,275.16],[146.32,279.34],[144.69,282.17],[144.25,283.58],[147.3,284.15],[154.07,284.97],[173.01,285.68],[205.29,285.98],[237.8,285.68],[256.79,284.92],[263.77,284.03],[266.92,283.42],[266.23,281.75],[264,278.35],[260.66,273.7],[259.87,264.1],[259.05,256.44],[258.15,251.5],[256.85,248.06],[255.05,244],[252.96,239.81],[250.98,236.07],[248.08,232.07],[243.79,227.28],[238.5,222.61],[233.21,218.93],[227.93,215.94],[205.86,215.72]],[[156.85,278.42],[154.78,278.35],[153.53,278.95],[153.45,279.83],[154.19,280.46],[157.32,281.08],[163,281.96],[173.19,282.99],[187.17,283.97],[203.88,284.41],[220.67,283.98],[234.91,283.01],[245.5,281.96],[251.42,280.91],[254.43,279.94],[254.97,279.17],[254.93,278.6],[251.4,278.77],[243.5,279.76],[228.64,280.99],[205,281.42],[182.42,281.13],[168.5,280.22],[161.36,279.17],[156.85,278.42]]]: input);\ninput_width = points_array[0][0];\ninput_height= points_array[0][1];\nsTrace = dispo_width/input_width;\nstencil_height = input_height*sTrace + 2*margin;\nmodule stamp(){\n\tdifference(){\n\t\tunion(){\n\t\t\tcylinder(h=10,r=15, $fn=quality);\n\t\t\ttranslate([0,0,10]) cylinder(h=5.8,r=12, $fn=quality);\n\t\t\ttranslate([0,0,15.8]) cylinder(h=12.8,r1=12, r2=15, $fn=quality);\n\t\t\ttranslate([0,0,28.6]) cylinder(h=14.9,r1=15, r2=17, $fn=quality);\n\t\t\ttranslate([0,0,43.5]) cylinder(h=8,r1=17, r2=17, $fn=quality);\n\t\t\ttranslate([0,0,51.5]) cylinder(h=8,r1=17, r2=14, $fn=quality);\n\t\t}\n\ttranslate([0,0,58.5]) cylinder(h=10,r1=8, r=40, $fn=quality);\n\ttranslate([0,0,40]) write(\"TNH\",h=8,t=1, font=\"write/orbitron.dxf\", center=true );\n\ttranslate([0,2,57]) rotate([0,0,225]) triangle(5, 5, 5);\n\t}\n}\nmodule stamp_small(){\n\tdifference(){\n\t\tunion(){\n\t\t\tcylinder(h=10,r=15, $fn=quality);\n\t\t\ttranslate([0,0,15]) cube([10,25,15], center=true);\n\t\t}\n\ttranslate([0,0,58.5]) cylinder(h=10,r1=8, r=40, $fn=quality);\n\trotate([0,0,90]) #translate([0,0,15]) write(\"TNH\",h=6,t=1, font=\"write/orbitron.dxf\", center=true );\n\ttranslate([0,10,21]) rotate([0,0,225]) triangle(5, 5, 5);\n\t}\n}\nmodule stamp_mask(){\n\tdifference(){\n\t\ttranslate([-100,-100,-.2]) cube([200,200,7]);\n\t\ttranslate([0,0,-.01])cylinder(h=4,r=22);\n\t}\n}\nmodule pattern(){\nunion(){\n\ttranslate([0, 0, stencil_thickness/2])\n\ttranslate([offX, offY, -stencil_thickness/2])\n\tscale([sTrace, -sTrace, 1])\n\ttranslate([-200, -150, 0]) {\n\t\tunion() {\n\t\t\tfor (i = [1:len(points_array) -1] ) {\n\t\t\t\tlinear_extrude(height=stencil_thickness*2) {polygon(points_array[i]);}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nif (handle_size == \"large\"){\n\tdifference(){\n\tstamp();\n\ttranslate([Move_X,Move_Y,-2])pattern();\n\t}\n}\nelse if (handle_size == \"small\"){\n\tdifference(){\n\tstamp_small();\n\ttranslate([Move_X,Move_Y,-2])pattern();\n\t}\n}",
    "description": "Okay, I'm looking to create a customizable wax seal stamp generator in OpenSCAD, and I'd like it to be parametric so I can easily adjust various aspects. I've been playing around with a similar design but I'm looking for a cleaner implementation and some improvements.\n\nHere's what I need:\n\n**Core Functionality:**\n\n1.  **Stencil Input:** The design should accept an array of 2D points (like the `points_array` in my example), which define the outline of the seal design. This array will be the output from a stencil generator, similar to Benjamin's Stencil-o-Matic tool. I need to be able to easily paste this array into a variable. I'm expecting that the first element in the array is the width and height, then the remaining elements are paths to extrude.\n    *   A \"default\" test case should be included in the code if no stencil data is provided, similar to the `input = \"default_TNH\"` conditional.\n2.  **Seal Resizing:**  I need a parameter to control the overall size of the seal design. Ideally, this would scale the stencil proportionally without affecting its shape, with a variable, `seal_size` controlling this scaling, similar to my example.\n3.  **Seal Movement:** Parameters to move the seal design left/right (`Move_X`) and up/down (`Move_Y`).\n4.  **Handle Choice:** I want two handle options: \"large\" and \"small\". The \"large\" handle should have a tiered, decorative look, similar to the current example, with a cylindrical base, and then some concentric cylinders to form the handle. The \"small\" handle should be more basic, using a simple cylinder with a cube for a handle grip.\n\n5.  **Orientation Indicator:** An orientation marker, like a small triangle, on the stamp face, so the user knows the orientation of the stamp design when pressing it into wax. This needs to be part of the handle, not the seal itself.\n6.  **Quality Control:** A variable to control the `$fn` of all the circles, using the same `quality` variable as my example.\n7. **Extrusion Thickness:** A variable, `stencil_thickness`, to control how thick the extruded stencil design is.\n\n**Libraries:**\n\nI'll need the `Write.scad` library for the text on the handle, and the `triangles.scad` library from `MCAD` for the triangle orientation indicator.\n\n**Output:**\n\nThe output should be an STL file when I render the project with the \"print quality\" setting selected. The user shouldn't need to explicitly specify output parameters.\n\n**Structure:**\n\nI'd prefer the code to be structured with clear module definitions for each part:\n\n*   A `stamp()` module for the \"large\" handle.\n*   A `stamp_small()` module for the \"small\" handle.\n*   A `pattern()` module that extrudes the pasted in paths.\n*   A top-level conditional that selects the correct module based on `handle_size`.\n\n**Initial Settings (for testing):**\n\n*   `quality` = 25 (for draft quality, then change to 200 for print quality)\n*   `handle_size` = \"large\" (as the default)\n*   `input = \"default_TNH\"` (as the default).\n*   `seal_size` = 10 (as the default)\n*   `Move_X` = 0 (as the default)\n*   `Move_Y` = 0 (as the default)\n*   `stencil_thickness` = 1.5 (as the default)\n*   `margin` = 10 (as the default)\n\n**Additional Notes:**\n\n*   Please make sure the text on the handle is centered. I'd also like it rotated 90 degrees when the small handle is selected.\n*   The orientation triangle on the handle should point towards the top of the design when printed.\n*  I need to make sure that the top-level conditional applies the `pattern()` module, to the handle selected based on the `handle_size` parameter, so it is cut out of the end of the handle.\n\nI think that's everything. Let me know if you have any questions, and I'm excited to see what you come up with.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Glasses w/ Fillable Lenses",
    "scad": "use <./MCAD/shapes.scad>\nuse <./pins/pins.scad>\nshape=\"square\";\nWidth_of_Nose_Bridge=25;\nlengthBridge=Width_of_Nose_Bridge;\nHeight_of_Nose_Bridge=7;\nwidthBridge=Height_of_Nose_Bridge;\nOverall_Glasses_Width=100;\nlengthFrame=Overall_Glasses_Width-Width_of_Nose_Bridge-20/2;\nHeight_of_Frame=35;\nwidthFrame=Height_of_Frame;\nDepth_of_Glasses=3;\nheightFrame=Depth_of_Glasses;\nThickness_of_Frame=5;\nthicknessFrame=Thickness_of_Frame;\nPattern_Infill_Type=0;\npatternSides=Pattern_Infill_Type;\nPattern_Radius=5;\npatternRadius=Pattern_Radius;\nPattern_Radius_Modifier=0;\npatternRadiusModifier=Pattern_Radius_Modifier;\nPattern_Line_Thickness=11;\npatternThickness=Pattern_Line_Thickness*.1;\nTemple_Length=125;\nstraightLength=Temple_Length;\nHeight_of_Hook_Curve=30;\nhookWidth=Height_of_Hook_Curve;\nLength_of_Hook_Curve=18;\nhookLength=Length_of_Hook_Curve;\nlengthHinge=15+0;\nwidthHinge=27+0;\n$fn=100+0;\nlengthHinge=8+2+heightFrame+0;\nrotate([0, 0, 180])\n{\n\ttranslate([(straightLength/2)+(4)+5, (15/2)+15-10, 0])\n\t{\n\t\tpintack(h=22+2, r=2, lh=3, lt=1, bh=3, br=4);\n\t}\n\ttranslate([(straightLength/2)+(4)+15,  (15/2)+15-10, 0])\n\t{\n\t\tpintack(h=22+2, r=2, lh=3, lt=1, bh=3, br=4);\n\t}\n\ttranslate([0, (15/2)+15+10, 0])\n\t{\n\t\tunion()\n\t\t{\n\t\t\ttranslate([0, 0, heightFrame/2])\n\t\t\t{\n\t\t\t\tcube([straightLength, 15, heightFrame], center=true);\n\t\t\t}\n\t\t\ttranslate([-(straightLength/2)+(8/2)+2, 0, (10/2)+heightFrame])\n\t\t\t{\n\t\t\t\tdifference()\n\t\t\t\t{\n\t\t\t\t\tcube([8, 10, 10], center=true);\n\t\t\t\t\ttranslate([0, 0, 1])\n\t\t\t\t\t{\n\t\t\t\t\t\trotate([90, 0, 0])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcylinder(r=2.5, h=10+1, center=true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([(straightLength/2), hookWidth-(15/2), heightFrame/2])\n\t\t\t{\n\t\t\t\trotate([0, 0, 90])\n\t\t\t\t{\n\t\t\t\t\thook(hookWidth, hookLength, 15, heightFrame, center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ttranslate([0, (15/2)+15-10, 0])\n\t{\n\t\tunion()\n\t\t{\n\t\t\ttranslate([0, 0, heightFrame/2])\n\t\t\t{\n\t\t\t\tcube([straightLength, 15, heightFrame], center=true);\n\t\t\t}\n\t\t\ttranslate([(straightLength/2)-(8/2)-2, 0, (10/2)+heightFrame])\n\t\t\t{\n\t\t\t\tdifference()\n\t\t\t\t{\n\t\t\t\t\tcube([8, 10, 10], center=true);\n\t\t\t\t\ttranslate([0, 0, 1])\n\t\t\t\t\t{\n\t\t\t\t\t\trotate([90, 0, 0])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcylinder(r=2.5, h=10+1, center=true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([-(straightLength/2), hookWidth-(15/2), heightFrame/2])\n\t\t\t{\n\t\t\t\trotate([ 180, 0, 90])\n\t\t\t\t{\n\t\t\t\t\thook(hookWidth, hookLength, 15, heightFrame, center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nunion()\n{\n\ttranslate([(lengthBridge/2)+(lengthFrame)+(8/2), (widthFrame/2)+(5/2)-(widthHinge/2), heightFrame+(10/2)])\n\t{\n\t\thinge(8, 5, 10, 2.5);\n\t}\n\ttranslate([-(lengthBridge/2)-(lengthFrame)-(8/2), (widthFrame/2)+(5/2)-(widthHinge/2), heightFrame+(10/2)])\n\t{\n\t\thinge(8, 5, 10, 2.5);\n\t}\n\tdifference()\n\t{\n\t\tunion()\n\t\t{\n\t\t\ttranslate([0, 6, heightFrame/2])\n\t\t\t{\n\t\t\tcube([lengthBridge+(lengthFrame), widthBridge, heightFrame], center=true);\n\t\t\t}\n\t\t\ttranslate([(lengthFrame/2)+(lengthBridge/2), (widthFrame/2), heightFrame/2])\n\t\t\t{\n\t\t\t\tframe(lengthFrame, widthFrame, heightFrame, thicknessFrame, shape);\n\t\t\t}\n\t\t\ttranslate([-(lengthFrame/2)-(lengthBridge/2), (widthFrame/2), heightFrame/2])\n\t\t\t{\n\t\t\t\tframe(lengthFrame, widthFrame, heightFrame, thicknessFrame, shape);\n\t\t\t}\n\t\t\ttranslate([(lengthBridge/2)+(lengthFrame)+(lengthHinge/2)-(lengthFrame/4), (widthFrame/2), heightFrame/2])\n\t\t\t{\n\t\t\t\tunion()\n\t\t\t\t{\n\t\t\t\t\tcube([lengthHinge+(lengthFrame/2), widthHinge, heightFrame], center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([(-lengthBridge/2)-(lengthFrame)-(lengthHinge/2)+(lengthFrame/4), (widthFrame/2), heightFrame/2])\n\t\t\t{\n\t\t\t\tunion()\n\t\t\t\t{\n\t\t\t\t\tcube([lengthHinge+(lengthFrame/2), widthHinge, heightFrame], center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tunion()\n\t\t{\n\t\t\ttranslate([(lengthFrame/2)+(lengthBridge/2), (widthFrame/2), heightFrame/2])\n\t\t\t{\n\t\t\t\tlens(lengthFrame, widthFrame, heightFrame, thicknessFrame, shape, widthBridge);\n\t\t\t}\n\t\t\ttranslate([-(lengthFrame/2)-(lengthBridge/2), (widthFrame/2), heightFrame/2])\n\t\t\t{\n\t\t\t\tlens(lengthFrame, widthFrame, heightFrame, thicknessFrame, shape, widthBridge);\n\t\t\t}\n\t\t}\n\t}\n\tif(patternSides!=0)\n\t{\n\t\ttranslate([(lengthFrame/2)+(lengthBridge/2), (widthFrame/2), heightFrame/2])\n\t\t{\n\t\t\tintersection()\n\t\t\t{\n\t\t\t\tif(shape==\"round\")\n\t\t\t\t{\n\t\t\t\t\toval((lengthFrame/2)-thicknessFrame, (widthFrame/2)-thicknessFrame, thicknessFrame, center=true);\n\t\t\t\t}\n\t\t\t\telse if(shape==\"square\")\n\t\t\t\t{\n\t\t\t\t\troundedBox(lengthFrame-(thicknessFrame*2), widthFrame-(thicknessFrame*2), heightFrame+.5, 2, center=true);\n\t\t\t\t}\n\t\t\t\tmesh(lengthFrame, widthFrame, heightFrame, patternRadius, patternRadiusModifier, (patternThickness), patternSides);\n\t\t\t}\n\t\t}\n\t\ttranslate([-(lengthFrame/2)-(lengthBridge/2), (widthFrame/2), heightFrame/2])\n\t\t{\n\t\t\tintersection()\n\t\t\t{\n\t\t\t\tif(shape==\"round\")\n\t\t\t\t{\n\t\t\t\t\toval((lengthFrame/2)-thicknessFrame, (widthFrame/2)-thicknessFrame, thicknessFrame, center=true);\n\t\t\t\t}\n\t\t\t\telse if(shape==\"square\")\n\t\t\t\t{\n\t\t\t\t\troundedBox(lengthFrame-(thicknessFrame*2), widthFrame-(thicknessFrame*2), heightFrame+.5, 2, center=true);\n\t\t\t\t}\n\t\t\tmesh(lengthFrame, widthFrame, heightFrame, patternRadius, patternRadiusModifier, (patternThickness), patternSides);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule frame(lengthFrame, widthFrame, heightFrame, thicknessFrame, shape)\n{\n\tif(shape==\"square\")\n\t{\n\t\t\troundedBox(lengthFrame, widthFrame, heightFrame, 2, center=true);\n\t}\n\telse if(shape==\"round\")\n\t{\n\t\t\tovalTube(heightFrame, lengthFrame/2, widthFrame/2, thicknessFrame, center=true);\n\t}\n}\nmodule lens(lengthFrame, widthFrame, heightFrame, thicknessFrame, shape, widthBridge)\n{\n\tif(shape==\"square\")\n\t{\n\t\t\troundedBox(lengthFrame-(thicknessFrame*2), widthFrame-(thicknessFrame*2), heightFrame+.5, 2, center=true);\n\t}\n\telse if(shape==\"round\")\n\t{\n\t\t\toval((lengthFrame/2)-thicknessFrame, (widthFrame/2)-thicknessFrame, thicknessFrame, center=true);\n\t}\n}\nmodule hinge(width, length, height, radius)\n{\n\tdifference()\n\t{\n\t\tcube([width, length, height], center=true);\n\t\ttranslate([0, 0, 1])\n\t\t{\n\t\t\trotate([90, 0, 0])\n\t\t\t{\n\t\t\t\tcylinder(r=radius, h=length+1, center=true);\n\t\t\t}\n\t\t}\n\t}\n\ttranslate([0, widthHinge-(length/2)-(length*2), 0])\n\t{\n\t\tdifference()\n\t\t{\n\t\t\ttranslate([0, 10/2, 0])\n\t\t\t{\n\t\t\tcube([width, length*2, height], center=true);\n\t\t\t}\n\t\t\trotate([-90, 0, 0])\n\t\t\t{\n\t\t\tpinhole(h=7, r=2, lh=3, lt=1, t=.5, tight=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule oval(w,h, height, center = false) {\n  scale([1, h/w, 1]) cylinder(h=height, r=w, center=center);\n}\nmodule mesh(width,length,height,r,rmod,th,sides)\n{\n\tcolumns = length/(r*3)+1;\n\trows = width/(r*sqrt(3)/2*2);\n\ttranslate([-width/2,length/2,0])\n\t\trotate([0,0,-90])\n\t\t\tfor(i = [0:rows]){\n\t\t\t\ttranslate([0,r*sqrt(3)/2*i*2,0])\n\t\t\t\t\tfor(i = [0:columns]){\n\t\t\t\t\t\ttranslate([r*i*3,0,0])\n\t\t\t\t\t\t\tfor(i = [0:1]){\n\t\t\t\t\t\t\t\ttranslate([r*1.5*i,r*sqrt(3)/2*i,0])\n\t\t\t\t\t\t\t\t\tdifference(){\n\t\t\t\t\t\t\t\t\t\tif(sides < 5){\n\t\t\t\t\t\t\t\t\t\t\tcylinder(h=height, r = r+th+(r*rmod/50), center = true, $fn = sides);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tcylinder(h=height, r = r+(r*rmod/50), center = true, $fn = sides);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcylinder(h=height+1, r = r-th+(r*rmod/50), center = true, $fn = sides);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n}\nmodule hook(radius1, radius2, rim, height)\n{\n\tdifference()\n\t{\n\toval(radius1, radius2, height, center=true);\n\t\tunion()\n\t\t{\n\t\t\toval(radius1-rim, radius2-rim, height+1, center=true);\n\t\t\ttranslate([radius1/2, 0, 0])\n\t\t\t{\n\t\t\t\tcube([radius1, radius2*2, height+1], center=true);\n\t\t\t}\n\t\t\ttranslate([0, radius2/2, 0])\n\t\t\t{\n\t\t\t\tcube([radius1*2, radius2, height+1], center=true);\n\t\t\t}\n\t\t}\n\t}\n}",
    "description": "Okay, I've got a cool idea for a pair of customizable glasses, and I need some help creating an OpenSCAD design. I'd like the design to be parametric, so I can easily adjust the sizes and shapes to fit different faces and preferences.\n\nHeres what Im looking for:\n\n**Overall Structure:**\n\n*   The glasses should have a main frame consisting of two lens frames connected by a nose bridge.\n*   There should be hinges connecting the main frame to the temple arms (the ear pieces).\n*   I'd like the hinges to be functional, allowing the arms to fold in. I'm thinking of using pins for the hinges, so please utilize the `pins.scad` library for the hinge design.\n*   I'm also thinking it would be useful to use the `shapes.scad` library, from MCAD, for a rounded box as the base for the frame.\n\n**Specific Components and Parameters:**\n\n*   **Nose Bridge:**\n    *   `Width_of_Nose_Bridge`: The width of the bridge connecting the two lens frames (e.g. 25mm).\n    *   `Height_of_Nose_Bridge`: The height of the bridge (e.g. 7mm).\n*   **Lens Frames:**\n    *   `Overall_Glasses_Width`: The total width of the glasses at eye level (e.g. 100mm).\n    *   `Height_of_Frame`: The height of each lens frame (e.g. 35mm).\n    *   `Depth_of_Glasses`: The depth or thickness of the frame (e.g. 3mm).\n    *   `Thickness_of_Frame`:  The thickness of the frame material around each lens (e.g. 5mm).\n    *   `shape`: Allows for either \"round\" or \"square\" lens shapes.\n*   **Infill Pattern:**\n    *   `Pattern_Infill_Type`:  A parameter to determine the infill pattern within the lens area, with options for:\n        *   0: None\n        *   3: Triangles\n        *   4: Squares\n        *   5: Pentagons\n        *   6: Hexagons\n        *   7: Heptagons\n        *   8: Octagons\n        *   9: Nonagons\n        *  10: Decagons\n        *  40: Circles\n    *   `Pattern_Radius`:  The radius of each individual infill element (e.g. 5mm).\n    *   `Pattern_Radius_Modifier`: An optional parameter for modifying the radius of the pattern elements without changing the spacing (e.g. 0 to 30).\n    *   `Pattern_Line_Thickness`: The thickness of the lines forming the infill pattern (e.g. 11, which translates to 1.1mm).\n*   **Temple Arms:**\n    *   `Temple_Length`: The overall length of the temple arm (e.g. 125mm).\n    *   `Height_of_Hook_Curve`: The height of the curved section of the temple arm that goes around the ear (e.g. 30mm).\n    *   `Length_of_Hook_Curve`: The length of the curved hook section (e.g. 18mm).\n\n**Hinge Details:**\n\n*   The hinges should be designed to use the pintack from the `pins.scad` library to connect the temple arms to the frame.\n*   The hinge should consist of a basic hole for the pin.\n\n**Additional Notes:**\n\n*   I'd like to have an oval shape available as a lens option as well.\n*   The design should be easily customizable, so users can adjust parameters for fit and style.\n*   Im thinking that if the pattern sides parameter is 0, the pattern module should not be invoked.\n*   The frame and lens modules should support either a square or round shape, dictated by the shape parameter, which is a string.\n*   When making the lens module, I want it to subtract, so that the frame has a hole in it.\n*   The hinge module should also include the necessary pinhole for use with the pintack function.\n* The glasses are symmetric.\n\nI think that covers everything. Let me know if you need any more information. I'm really excited to see what you come up with!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Cable Tie",
    "scad": "include <utils/build_plate.scad>\nlength\t\t\t\t\t\t= 190;\nscrewHole\t\t\t\t\t= 0;\nreleaseTab\t\t\t\t\t= 0;\ntapeWidth\t\t\t\t\t= 6.6;\ntapeThickness\t\t\t\t= 1.6;\ntapeScale\t\t\t\t\t= 0.8;\npartCount\t\t\t\t\t= 1;\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nmodule dummy() {}\n$fn = 10;\nmanifoldCorrection = 0.01;\nnozzleDiameter\t\t\t\t= tapeScale;\nlayerHeight\t\t\t\t\t= tapeThickness / 8;\ntapeGearPitch\t\t\t\t= 4 * nozzleDiameter;\ntapeGearBorderThickness\t\t= 2 * nozzleDiameter;\ntapeGearWidth\t\t\t\t= tapeWidth - tapeGearBorderThickness * 2;\nleaderThickness\t\t\t\t= 0.5 * tapeThickness;\nleaderHeightDifference\t\t= tapeThickness - leaderThickness;\nleaderTaperedLength\t\t\t= 4 * tapeGearPitch;\nleaderRoundedFrontDiameter\t= 4 * nozzleDiameter;\nleaderRetainerThickness\t\t= 3 * layerHeight;\nleaderRetainerWidth\t\t\t= 1 * nozzleDiameter * 1.1;\nleaderRetainerCount\t\t\t= 8;\npawlWidth\t\t\t\t\t= tapeGearWidth - nozzleDiameter * 2;\npawlThickness\t\t\t\t= 20 * layerHeight;\npawlToothCount\t\t\t\t= 3;\npawlAngle\t\t\t\t\t= 13;\npawlAttachmentThickness\t\t= 12 * layerHeight;\nheadWidth\t\t\t\t\t= tapeWidth * 1.5;\nheadLength\t\t\t\t\t= tapeThickness * 3 + tapeWidth;\nheadHeight\t\t\t\t\t= pawlToothCount * tapeGearPitch + pawlAttachmentThickness / 2;\nheadTapeGuideWidth\t\t\t= tapeWidth + nozzleDiameter;\nheadTapeGuideThickness\t\t= tapeThickness + nozzleDiameter * 2;\nheadTapeGuidePosition\t\t= [-headLength + tapeWidth / 2, -headWidth / 2 + (headWidth - headTapeGuideWidth) / 2, -manifoldCorrection];\nheadCornerRadius\t\t\t\t= nozzleDiameter;\nheadPawlCutoutLength\t\t\t= tapeThickness * 2;\nheadPawlCutoutPosition\t\t= headTapeGuidePosition + [headTapeGuideThickness - manifoldCorrection, (headTapeGuideWidth - tapeGearWidth) / 2, 0];\npawlAttachmentDimensions\t\t= [headPawlCutoutLength, tapeGearWidth, pawlAttachmentThickness / 2];\npawlPosition\t\t\t\t\t= [headPawlCutoutPosition[0] + pawlThickness - pawlThickness * 0.15, 0, pawlAttachmentThickness / 2];\npawlAttachmentPosition\t\t= [headPawlCutoutPosition[0] + tapeGearPitch/2, -pawlAttachmentDimensions[1] / 2, 0];\nreleaseTabDimenisons\t\t\t= [pawlThickness * 0.75, pawlWidth, pawlAttachmentThickness * 2.5];\nreleaseTabPosition\t\t\t= [- pawlThickness * 1.4 + headCornerRadius, -pawlWidth / 2, tapeGearPitch * pawlToothCount - tapeGearPitch / 2];\nscrewHoleOuterDiameter\t\t= headWidth;\nscrewHoleBorder\t\t\t\t= screwHoleOuterDiameter * 0.2;\nscrewHoleInnerDiameter\t\t= screwHoleOuterDiameter - screwHoleBorder * 2;\nscrewAttachmentThickness\t\t= 24 * layerHeight;\nscrewAttachmentLength\t\t= 1.75 * headLength - headCornerRadius;\nleaderLength\t\t\t\t\t= 15 * tapeGearPitch;\ntapeLength\t\t\t\t\t= floor((length - leaderLength) / tapeGearPitch) * tapeGearPitch;\ncompleteLength\t\t\t\t= headLength + tapeLength + leaderLength;\nleaderFilletLength\t\t\t= 0.1 * leaderLength;\nleaderRetainerCountSpacing\t= (leaderLength - (leaderTaperedLength + leaderFilletLength)) / (leaderRetainerCount + 1);\ncableTieCenterPosition\t\t= [- (headLength + tapeLength + leaderLength) / 2, 0, 0];\nfor ( i = [0:partCount-1] )\n{\n\ttranslate( [0, i * headWidth * 1.25, 0] )\n\t\ttranslate( [0, -((partCount - 1) / 2) * headWidth * 1.25, 0] )\n\t\t\ttranslate( cableTieCenterPosition )\n\t\t\t\tif ( screwHole )\n\t\t\t\t{\n\t\t\t\t\ttranslate( [((screwAttachmentLength - headLength - headCornerRadius) + screwHoleOuterDiameter / 2) / 2, 0, 0] )\n\t\t\t\t\t\tcableTie();\n\t\t\t\t}\n\t\t\t\telse\t\tcableTie();\n}\nmodule cableTie()\n{\n\ttranslate( [headLength, 0, 0] )\n\t{\n\t\ttranslate( [manifoldCorrection, 0, 0] )\n\t\t\thead();\n\t\tif ( screwHole )\n\t\t\t\tscrewHoleAttachment();\n\t\ttape();\n\t\ttranslate( [-manifoldCorrection, 0, 0] )\n\t\t\tleader();\n\t}\n}\nmodule screwHoleAttachment()\n{\n\ttranslate( [-(screwAttachmentLength - headCornerRadius), 0, 0] )\n\t\tdifference()\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tcylinder( r = screwHoleOuterDiameter / 2, h = headHeight, $fn = 40 );\n\t\t\t\ttranslate( [headCornerRadius, -headWidth / 2, 0] )\n\t\t\t\t\tcube( [screwAttachmentLength - headLength, headWidth, screwAttachmentThickness] );\n\t\t\t}\n\t\t\ttranslate( [0, 0, -manifoldCorrection] )\n\t\t\t\tcylinder( r = screwHoleInnerDiameter / 2, h = headHeight + manifoldCorrection * 2, $fn = 40 );\n\t\t}\n}\nmodule head()\n{\n\tdifference()\n\t{\n\t\ttranslate( [-headLength / 2, 0, 0] )\n\t\t\troundedBox(width=headLength, length=headWidth, height=headHeight, cornerRadius = headCornerRadius);\n\t\ttranslate( headTapeGuidePosition )\n\t\t\tcube( [headTapeGuideThickness, headTapeGuideWidth, headHeight + manifoldCorrection * 2] );\n\t\ttranslate( headPawlCutoutPosition )\n\t\t\tcube( [headPawlCutoutLength, tapeGearWidth, headHeight + manifoldCorrection * 2] );\n\t}\n\ttranslate( pawlAttachmentPosition )\n\t\tcube( pawlAttachmentDimensions );\n\ttranslate( pawlPosition )\n\t{\n\t\trotate( [0, -pawlAngle, 0] )\n\t\t\tpawl();\n\t\tif ( releaseTab )\n\t\t{\n\t\t\ttranslate( releaseTabPosition )\n\t\t\t\tcube( releaseTabDimenisons );\n\t\t}\n\t}\n}\nmodule roundedBox(width, length, height, cornerRadius)\n{\n\t\tcylinderOffsetY = headWidth / 2 - cornerRadius;\n\t\tcylinderOffsetX = headLength / 2 - cornerRadius;\n\t\thull()\n\t\t{\n\t\t\tfor( offsetMult = [[-1, -1], [1, -1], [1, 1], [-1, 1]] )\n\t\t\t\ttranslate( [ offsetMult[0] * cylinderOffsetX, offsetMult[1] * cylinderOffsetY, 0] )\n\t\t\t\t\tcylinder( r = cornerRadius, h = height, $fn = 10 );\n\t\t}\n}\nmodule tape()\n{\n\ttranslate( [0, 0, tapeThickness] )\n\t\trotate( [180, 0, 0] )\n\t\t\tdifference()\n\t\t\t{\n\t\t\t\ttranslate( [0, -tapeWidth / 2, 0] )\n\t\t\t\t\tcube( [tapeLength, tapeWidth, tapeThickness] );\n\t\t\t\tfor ( i = [0: tapeGearPitch: tapeLength] )\n\t\t\t\t\ttranslate( [i, 0, layerHeight] )\n\t\t\t\t\t\toneTapeGearRecess();\n\t\t\t}\n}\nmodule leader()\n{\n\ttranslate( [tapeLength, 0, 0] )\n\t{\n\t\thull()\n\t\t{\n\t\t\ttranslate( [0, -tapeWidth / 2, 0] )\n\t\t\t\tcube( [leaderLength - leaderTaperedLength, tapeWidth, leaderThickness] );\n\t\t\ttranslate( [0 + leaderLength, 0, 0] )\n\t\t\t\tcylinder( r = leaderRoundedFrontDiameter / 2, h = leaderThickness, $fn = 10 );\n\t\t}\n\t\ttranslate( [0, tapeWidth / 2, leaderThickness - manifoldCorrection] )\n\t\t\trotate([90, 0, 0] )\n\t\t\t\tlinear_extrude(height = tapeWidth)\n\t\t\t\t\tpolygon([ [0, leaderHeightDifference],\n\t\t\t\t\t\t\t  [leaderFilletLength, 0],\n\t\t\t\t\t\t\t  [0, 0]]);\n\t\ttranslate( [leaderFilletLength, 0, leaderThickness] )\n\t\t{\n\t\t\tfor ( i = [1: leaderRetainerCount] )\n\t\t\t\ttranslate( [i * leaderRetainerCountSpacing, -tapeGearWidth / 2, 0] )\n\t\t\t\t\tcube( [leaderRetainerWidth, tapeGearWidth, leaderRetainerThickness] );\n\t\t}\n\t}\n}\nmodule pawl()\n{\n\trotate( [0, 0, 180] )\n\t\ttranslate( [0, 0, tapeGearPitch * pawlToothCount] )\n\t\t\trotate( [0, 90, 0] )\n\t\t\t\tdifference()\n\t\t\t\t{\n\t\t\t\t\ttranslate( [0, -pawlWidth / 2, 0] )\n\t\t\t\t\t\tcube( [tapeGearPitch * pawlToothCount, pawlWidth, pawlThickness] );\n\t\t\t\t\tfor ( i = [0: tapeGearPitch: tapeGearPitch * pawlToothCount] )\n\t\t\t\t\t\ttranslate( [i + manifoldCorrection, 0, layerHeight] )\n\t\t\t\t\t\t\tonePawlRecess();\n\t\t\t\t}\n}\nmodule onePawlRecess()\n{\n\ttranslate( [0, pawlWidth / 2 + manifoldCorrection, pawlThickness + manifoldCorrection] )\n\t\trotate([90, 0, 0] )\n\t\t\tlinear_extrude(height = pawlWidth + manifoldCorrection * 2 )\n\t\t\t\tpolygon([[0,0],[tapeGearPitch,-tapeGearPitch/2],[tapeGearPitch,0]]);\n}\nmodule oneTapeGearRecess()\n{\n\ttranslate( [0, tapeGearWidth / 2, tapeThickness + nozzleDiameter * 0.25 + manifoldCorrection] )\n\t\trotate([90, 0, 0] )\n\t\t\tlinear_extrude(height = tapeGearWidth )\n\t\t\t\tpolygon([[0,0],[tapeGearPitch/2,-tapeGearPitch/2],[tapeGearPitch,-tapeGearPitch/2],[tapeGearPitch,0]]);\n}",
    "description": "Okay, so I'm looking to get a customizable cable tie designed in OpenSCAD. I want to be able to adjust a bunch of parameters, like the overall length, the width and thickness of the tie itself, and whether or not it has a screw hole in the head or a release tab for the pawl.\n\nI'd like the design to use a gear-like mechanism for the tie and pawl engagement. The tape part of the tie should have recesses to catch the pawl. The head should have a guide for the tape as well as a cutout for the pawl. I want to be able to set the number of teeth for the pawl. The head should have rounded corners on the outside.\n\nFor the leader, I need to include a tapered end for easy insertion, as well as some small retainers along the edges. A fillet where the tape meets the leader would be nice, too.\n\nI'd also like to be able to print multiple of these at once and have them arranged on the build plate correctly for printing.\n\nFor the measurements, I want to define tape width and thickness as main parameters. Also, I'd like to use a tape scaling parameter based on nozzle diameter (like `tapeScale` in the example) to control some other dimensions, which helps with printer accuracy.\n\nSpecifically, I need to be able to adjust:\n*   **`length`**: The overall length of the cable tie.\n*   **`screwHole`**: A boolean to include a screw hole in the head.\n*   **`releaseTab`**: A boolean to include a release tab on the pawl.\n*   **`tapeWidth`**: The width of the main tie.\n*   **`tapeThickness`**: The thickness of the main tie.\n*   **`tapeScale`**: A scaling factor based on nozzle diameter.\n*   **`partCount`**: The number of cable ties to print at once.\n*   **`build_plate_selector`**: A way to choose standard build plates or manual dimensions for printing multiple parts.\n*   **`build_plate_manual_x`**: The x-dimension of the build plate, if `build_plate_selector` is set to manual.\n*    **`build_plate_manual_y`**: The y-dimension of the build plate, if `build_plate_selector` is set to manual.\n\nI'd like the code to have a `build_plate.scad` library, and it should use the `build_plate` module to set up the build plate for printing.\n\nCan you create a complete parametric OpenSCAD design that includes these features?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Power Adapter via Battery Contacts",
    "scad": "BatteryWidth = 44;\nBatteryLength = 65;\nBatteryThickness = 5.4;\nPinThickness = 2;\nPinHeadThickness = 4;\nPinHeadDepth = .5;\nPin1DistanceFromEdge = 4;\nPin2DistanceFromEdge = 8;\nWireWidth = 2;\ndifference()\n{\n\tcube(size = [BatteryWidth, BatteryLength, BatteryThickness], center=true);\n\tcube(size = [BatteryWidth - BatteryThickness * 2, BatteryLength - BatteryThickness * 2, BatteryThickness + 1], center=true);\n\tWireHarness();\n\tInterfaceConnection();\n}\nmodule InterfaceConnection()\n{\n\t\ttranslate([BatteryWidth * .5 - Pin1DistanceFromEdge, BatteryLength * .5,  0]) Pin();\n\t\ttranslate([BatteryWidth * .5 - Pin2DistanceFromEdge, BatteryLength * .5,  0]) Pin();\n\t\thull()\n\t\t{\n\t\t\ttranslate([BatteryWidth * .5 - Pin1DistanceFromEdge, BatteryLength * .5,  0]) PinElbowRoom();\n\t\t\ttranslate([BatteryWidth * .5 - Pin2DistanceFromEdge, BatteryLength * .5,  0]) PinElbowRoom();\n\t\t}\n}\nmodule Pin()\n{\n\ttranslate([0, - (PinHeadDepth + BatteryThickness) * .5,  0]) union()\n\t{\n\trotate([90,90,0]) cylinder(r = PinThickness * .5, h=BatteryThickness, center=true);\n\ttranslate([0, BatteryThickness * .5,  0]) rotate([90,90,0]) cylinder(r = PinHeadThickness * .5, h=PinHeadDepth, $fn=90, center=true);\n\t}\n}\nmodule PinElbowRoom()\n{\n\ttranslate([0, - (BatteryLength- BatteryThickness) * .5,  0]) union()\n\t{\n\t\ttranslate([0, - BatteryThickness * .5,  0]) rotate([90,90,0]) cylinder(r = BatteryThickness * .5, h=BatteryLength - (2 * BatteryThickness ), center=true);\n\t}\n}\nmodule WireHarness()\n{\n\tunion() {\n\t\trotate([90,0,0]) cylinder(r = WireWidth * .5, h=BatteryWidth + BatteryLength, center=true);\n\t\trotate([0,90,0]) cylinder(r = WireWidth * .5, h=BatteryWidth + BatteryLength, center=true);\n\t}\n}",
    "description": "Okay, so I'm trying to design a parametric battery adapter. I've already got a basic OpenSCAD file that creates the main body with two contact pins for a battery, but it's not really user friendly and doesn't include any housing for the electronics.\n\nHere's what I need:\n\n**Basic Functionality:**\n\n*   **Parametric Battery Size:** The adapter should be able to accommodate batteries of varying sizes (width, length, and thickness). The current file has `BatteryWidth`, `BatteryLength`, and `BatteryThickness` parameters, and I'd like to keep those.\n*   **Contact Pins:** The adapter should have two contact pins for the battery terminals. My current design uses nail heads as the contact points. I have `PinThickness`, `PinHeadThickness`, `PinHeadDepth`, `Pin1DistanceFromEdge`, and `Pin2DistanceFromEdge` parameters, and I'd like to keep those as well.\n*   **Wire Routing:** There should be a hole or channel to route wires out of the adapter. I have a `WireWidth` parameter for the hole size, I want this to stay, and have the wire routing go to an opening for the electronics bay as described below.\n\n**New Features and Modifications:**\n\n*   **Electronics Bay:** I need a space to hold a small buck converter. This should be a rectangular cavity on one side of the battery adapter and should have parameters for its width, length, and depth. I'd like to call these `ConverterBayWidth`, `ConverterBayLength`, and `ConverterBayDepth`. This bay should be on the *opposite* side of the battery from the contact pins.\n*   **Enclosure for the Electronics:**  I'd like an enclosure for the converter bay, effectively a lid. I think it would be nice if the lid had a lip so it can friction fit into the converter bay, making it simple to close.  The lid should be a separate part, so it can be printed separately. It needs a parameter for the lip thickness, `LipThickness`. The enclosure should have a parameter that is the same as the lip thickness, `LidThickness`. The lid should be flush with the overall dimensions of the adapter when inserted.\n*   **Mounting Holes:** It would be useful to have the option of adding mounting holes so I can attach this to something. Ideally, these should be configurable  number of holes, hole diameter, and distance from the center of the battery block. I'd like parameters for `MountHoleCount` (1, 2 or 4 allowed), `MountHoleDiameter`, and `MountHoleDistance`.  I would like the mounting holes to be located on the opposite side of the contact pins, and on the 'front and back' or 'side' of the adapter (depending on orientation of the adapter's longer dimension).\n*   **Rounded Corners:**  I think it would make the design look nicer and more printable if the corners on both the battery adapter and the lid were rounded. This would be a single radius value parameter, `CornerRadius`.\n\n**Constraints:**\n\n*   **Parametric Design:** The design must be fully parametric, meaning all dimensions should be controlled by parameters that can be easily changed.\n*   **Printability:** The design should be printable on a standard FDM 3D printer. No excessively thin features or overhangs.\n*   **OpenSCAD:** The design must be in OpenSCAD.\n*   **MCAD library:** Please use the `involute_gear()` module for the screw holes from the MCAD library. Do not include the library itself, as I already have it.\n*   **No other external libraries:** I'd like to keep things as simple as possible and not add any other dependencies.\n\n**Current File:**\n\nI've attached my current OpenSCAD file to this request. (I'm pretending to do this, I know that you don't get to look at it!).\n\n**In short, I want you to take my simple OpenSCAD file and enhance it to be much more complete and useful.**\n\nCan you create a new, parametric OpenSCAD file that includes these features? Let me know if you need any clarification.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Furniture Foot",
    "scad": "FootHeigth = 15;\nTopWith = 10;\nBottomWith = 8;\nHoleDiameter = 2;\nHeadHigth = 2;\nHeadWith = 4;\nmodule FurnitureFoot()\n{\n\tdifference()\n\t{\n\t\tcylinder(r1=TopWith, r2=BottomWith, h=FootHeigth, $fn=250);\n\t\ttranslate([0,0,-1])cylinder(r=HoleDiameter, h=(FootHeigth+2),$fn=100);\n\t\ttranslate([0,0,FootHeigth-HeadHigth])cylinder(r=HeadWith, h=HeadHigth+1,$fn=100);\n\t}\n}\nFurnitureFoot();",
    "description": "Okay, I'm looking to design a simple furniture foot, like what you might find on a chair or small table. I'd like it to be parametric so I can easily adjust its dimensions.\n\nHere's what I have in mind:\n\n*   **Basic Shape:** The foot should be a truncated cone, wider at the top than the bottom.\n*   **Height:** I need to be able to control the total height of the foot.\n*   **Top Width:** I need to control the diameter of the top circle of the cone.\n*   **Bottom Width:** I need to control the diameter of the bottom circle of the cone.\n*   **Mounting Hole:** It needs a central hole going all the way through for mounting it to the furniture, like for a screw or bolt. I need to control the diameter of this hole.\n*   **Countersunk Head:**  I also need to create a countersunk section at the top of the hole, so the screw or bolt head will sit flush with the top of the foot. This countersunk needs to be defined by its height and diameter.\n\nI want to be able to adjust all of these dimensions easily. Could you create an OpenSCAD file for this, using parameters for:\n\n*   `FootHeigth` (Total height of the foot)\n*   `TopWith` (Diameter of the top of the cone)\n*   `BottomWith` (Diameter of the bottom of the cone)\n*   `HoleDiameter` (Diameter of the mounting hole)\n*   `HeadHigth` (Height of the countersunk area for the screw/bolt head)\n*   `HeadWith` (Diameter of the countersunk area for the screw/bolt head)\n\nPlease include comments in the code so I can understand how it's working.\n\nI am not using any libraries at the moment.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Pencil Hat",
    "scad": "include <write/Write.scad>\nmessage_1 = \"Live\";\nmessage_2 = \"Laugh\";\nmessage_3 = \"Love\";\nFont = \"write/orbitron.dxf\";\npencil_diameter = 8;\nthickness =2;\ncorner_radius =2;\nlength = 4;\nmodule triangle (radius=1) {\npolygon(points=[[radius/sin(30),0],[-radius,(radius/sin(30)+radius)/tan(60)],[-radius,-(radius/sin(30)+radius)/tan(60)]], paths=[[0,1,2]]);\n}\nmodule roundcorner(r,a) {\nl=r/sin(a/2);\ndifference () {\npolygon(points=[[0,0],[r*sin(a/2),r*cos(a/2)],[l,0],[r*sin(a/2),-r*cos(a/2)]], paths=[[0,1,2,3]]);\ncircle(r=r,$fn=100);\n}\n}\nmodule label(label,t) {\ntranslate ([p_radius+thickness,0,total_length/2])\nrotate ([0,90,0])\ntranslate ([0,0,t/2])\nwrite(label,t=t, h=font_size, center = true, font = Font);\n}\nfont_size = pencil_diameter;\ntotal_length = max( (max (len(message_1),len(message_2),len(message_3))+1)*pencil_diameter*0.7, length);\np_radius = pencil_diameter/2;\nrotate ([0,0,60])\nlabel(message_1,t);\nrotate ([0,0,180])\nlabel(message_2,t);\nrotate ([0,0,300])\nlabel(message_3,t);\nlinear_extrude(height = total_length)\ndifference() {\ntriangle(p_radius+thickness);\nfor (i=[0:2]) {\nrotate ([0,0,i*120])\ntranslate ([(p_radius+thickness)/sin(30)-corner_radius/sin(30)+0.01,0,0]) roundcorner(corner_radius,60);\ncircle (p_radius,$fn=20);\n}\n}",
    "description": "Okay, I'd like to design a 3D printable pencil topper or a connector for cylindrical objects that has some text on it. I want it to be like a little triangular hat that slides onto a pencil or rod.\n\nHere's what I'm thinking:\n\n**Shape and Structure:**\n\n*   **Basic Shape:** The main structure will be a triangular prism. So, imagine a triangle extruded along its normal.\n*   **Hole:** Inside the triangle, I need a circular hole so it can slide onto a pencil or dowel. The inner diameter of this hole should be adjustable.\n*   **Rounded Corners:** I'd like the corners of the triangle to be rounded to make it more comfortable and less likely to catch on things. This should be a parameter to control the roundness.\n\n**Text/Labels:**\n*   **Placement:** I want to have three separate text messages printed on the outside of the prism, one along each face of the triangle. The text should be facing outwards, away from the center of the triangle.\n*   **Customization:** Each of these three text messages should be customizable, so I can choose the wording of each label.\n*   **Font:** The font should be selectable, I'd like to use a .dxf font file using the Write library\n*   **Text Height:** The height of the letters should be proportional to the inner diameter. I want the letters to be big enough so they can be easily read.\n\n**Parameters:**\n\nI'd need the following parameters to be adjustable:\n*   `pencil_diameter`: The diameter of the cylinder the topper will be attached to. This will control the diameter of the inner hole.\n*   `thickness`: The thickness of the wall of the triangular prism itself.\n*   `corner_radius`: The radius of the rounded corners on the triangle.\n*   `length`: The length of the extrusion, that is the length of the topper along the axis of the hole.\n*   `message_1`: The text for the first face.\n*   `message_2`: The text for the second face.\n*   `message_3`: The text for the third face.\n*   `Font`: The .dxf file to use for the text, I want to use the `write/Write.scad` library.\n\n**Overall:**\nBasically, I want a parametric design where I can specify the size of the hole, the thickness of the walls, the roundness of the corners, and three different text messages to be printed on the faces of the triangle. I want the text to be adjustable and scaled to the size of the object using a font from `write/Write.scad`. The Write library needs to be available in the directory, I do not need the file to be sent.\n\nCould you create an OpenSCAD file for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable 4 Row Tool Bit Tray",
    "scad": "use <MCAD/regular_shapes.scad>\nnumber_of_tools_in_row_1 = 3;\nrow_1_hole_diameter = 26;\nrow_1_hole_shape = 0;\nnumber_of_tools_in_row_2 = 4;\nrow_2_hole_diameter = 15;\nrow_2_hole_shape = 1;\nnumber_of_tools_in_row_3 = 5;\nrow_3_hole_diameter = 10;\nrow_3_hole_shape = 0;\nnumber_of_tools_in_row_4 = 5;\nrow_4_hole_diameter = 10;\nrow_4_hole_shape = 2;\ntray_height = 25;\nhole_taper = 4;\nturn_upside_down_for_printing = 0;\ntray_thickness = 5+0;\nleg_thickness = 2+0;\ny_margin = 5+0;\n\tr1_temp = (number_of_tools_in_row_1 == 0 ? 0:row_1_hole_diameter);\n\tr2_temp = (number_of_tools_in_row_2 == 0 ? 0:row_2_hole_diameter);\n\tr3_temp = (number_of_tools_in_row_3 == 0 ? 0:row_3_hole_diameter);\n\tr4_temp = (number_of_tools_in_row_4 == 0 ? 0:row_4_hole_diameter);\n\ttray_width = max(\n\t\t\tr1_temp*(1.5*number_of_tools_in_row_1+1),\n\t\t\tmax(r2_temp*(1.5*number_of_tools_in_row_2+1),\n\t\t\t\tmax(\tr3_temp*(1.5*number_of_tools_in_row_3+1),\n\t\t\t\t\tr4_temp*(1.5*number_of_tools_in_row_4+1))));\n\ttray_depth = 1.5*(r1_temp+r2_temp+r3_temp+r4_temp)+2*y_margin;\n\tmax_hole = max(r1_temp,\n\t\t\t\t\tmax(r2_temp,\n\t\t\t\t\t\tmax(r3_temp,r4_temp)));\n\tcorner_width = .1*tray_width;\n\tcorner_depth = .1*tray_depth;\n\tcorner_taper = .1+0;\ngenerate_tool_tray();\nmodule generate_tool_tray(){\n\ttranslate([0,0,tray_thickness/2])\n\trotate([turn_upside_down_for_printing, 0,0])\n\tunion(){\n\t\ttray_legs();\n\t\ttray_top();\n\t}\n}\nmodule tray_top(){\n\tunion(){\n\t\tdifference(){\n\t\t\t\t\tcube(size=[tray_width,tray_depth,tray_thickness], center = true);\n\t\t\t\t\ttool_hole_row_1();\n\t\t\t\t\ttool_hole_row_2();\n\t\t\t\t\ttool_hole_row_3();\n\t\t\t\t\ttool_hole_row_4();\n\t\t\t\t}\n\t\ttool_finger_row_1();\n\t\ttool_finger_row_2();\n\t\ttool_finger_row_3();\n\t\ttool_finger_row_4();\n\t}\n}\nmodule tool_hole_row_1(){\n\ttool_space_1 = tray_width/(2*number_of_tools_in_row_1+1);\n\ttool_y_1 = tray_depth/2-.5*r1_temp-y_margin;\n\tif(number_of_tools_in_row_1 != 0){\n\t\ttool_holes_row(-tray_width/2+1.5*tool_space_1,\n\t\t\t\t\t\ttool_y_1,\n\t\t\t\t\t\ttray_thickness,\n\t\t\t\t\t\trow_1_hole_diameter,\n\t\t\t\t\t\ttool_space_1,\n\t\t\t\t \t\tnumber_of_tools_in_row_1,\n\t\t\t\t\t\trow_1_hole_shape);\n\t}\n}\nmodule tool_finger_row_1(){\n\ttool_space_1 = tray_width/(2*number_of_tools_in_row_1+1);\n\ttool_y_1 = tray_depth/2-.5*r1_temp-y_margin;\n\tif(number_of_tools_in_row_1 != 0){\n\t\ttool_fingers_row(-tray_width/2+1.5*tool_space_1,\n\t\t\t\t\t\ttool_y_1,\n\t\t\t\t\t\ttray_thickness,\n\t\t\t\t\t\trow_1_hole_diameter,\n\t\t\t\t\t\ttool_space_1,\n\t\t\t\t \t\tnumber_of_tools_in_row_1,\n\t\t\t\t\t\trow_1_hole_shape);\n\t}\n}\nmodule tool_hole_row_2(){\n\ttool_space_2 = tray_width/(2*number_of_tools_in_row_2+1);\n\ttool_y_2 = tray_depth/2-1.5*r1_temp-.5*r2_temp-y_margin;\n\tif(number_of_tools_in_row_2 != 0){\n\t\ttool_holes_row(-tray_width/2+1.5*tool_space_2,\n\t\t\t\t\t\ttool_y_2,\n\t\t\t\t\t\ttray_thickness,\n\t\t\t\t\t\trow_2_hole_diameter,\n\t\t\t\t\t\ttool_space_2,\n\t\t\t\t \t\tnumber_of_tools_in_row_2,\n\t\t\t\t\t\trow_2_hole_shape);\n\t}\n}\nmodule tool_finger_row_2(){\n\ttool_space_2 = tray_width/(2*number_of_tools_in_row_2+1);\n\ttool_y_2 = tray_depth/2-1.5*r1_temp-.5*r2_temp-y_margin;\n\tif(number_of_tools_in_row_2 != 0){\n\t\ttool_fingers_row(-tray_width/2+1.5*tool_space_2,\n\t\t\t\t\t\ttool_y_2,\n\t\t\t\t\t\ttray_thickness,\n\t\t\t\t\t\trow_2_hole_diameter,\n\t\t\t\t\t\ttool_space_2,\n\t\t\t\t \t\tnumber_of_tools_in_row_2,\n\t\t\t\t\t\trow_2_hole_shape);\n\t}\n}\nmodule tool_hole_row_3(){\n\ttool_space_3 = tray_width/(2*number_of_tools_in_row_3+1);\n\ttool_y_3 = tray_depth/2-1.5*r1_temp-1.5*r2_temp-.5*r3_temp-y_margin;\n\tif(number_of_tools_in_row_3 != 0){\n\t\ttool_holes_row(-tray_width/2+1.5*tool_space_3,\n\t\t\t\t\ttool_y_3,\n\t\t\t\t\ttray_thickness,\n\t\t\t\t\trow_3_hole_diameter,\n\t\t\t\t\ttool_space_3,\n\t\t\t \t\tnumber_of_tools_in_row_3,\n\t\t\t\t\trow_3_hole_shape);\n\t}\n}\nmodule tool_finger_row_3(){\n\ttool_space_3 = tray_width/(2*number_of_tools_in_row_3+1);\n\ttool_y_3 = tray_depth/2-1.5*r1_temp-1.5*r2_temp-.5*r3_temp-y_margin;\n\tif(number_of_tools_in_row_3 != 0){\n\t\ttool_fingers_row(-tray_width/2+1.5*tool_space_3,\n\t\t\t\t\ttool_y_3,\n\t\t\t\t\ttray_thickness,\n\t\t\t\t\trow_3_hole_diameter,\n\t\t\t\t\ttool_space_3,\n\t\t\t \t\tnumber_of_tools_in_row_3,\n\t\t\t\t\trow_3_hole_shape);\n\t}\n}\nmodule tool_hole_row_4(){\n\ttool_space_4 = tray_width/(2*number_of_tools_in_row_4+1);\n\ttool_y_4 = tray_depth/2-1.5*r1_temp-1.5*r2_temp-1.5*r3_temp-.5*r4_temp-y_margin;\n\tif(number_of_tools_in_row_4 != 0){\n\t\ttool_holes_row(-tray_width/2+1.5*tool_space_4,\n\t\t\t\t\ttool_y_4,\n\t\t\t\t\ttray_thickness,\n\t\t\t\t\trow_4_hole_diameter,\n\t\t\t\t\ttool_space_4,\n\t\t\t \t\tnumber_of_tools_in_row_4,\n\t\t\t\t\trow_4_hole_shape);\n\t}\n}\nmodule tool_finger_row_4(){\n\ttool_space_4 = tray_width/(2*number_of_tools_in_row_4+1);\n\ttool_y_4 = tray_depth/2-1.5*r1_temp-1.5*r2_temp-1.5*r3_temp-.5*r4_temp-y_margin;\n\tif(number_of_tools_in_row_4 != 0){\n\t\ttool_fingers_row(-tray_width/2+1.5*tool_space_4,\n\t\t\t\t\ttool_y_4,\n\t\t\t\t\ttray_thickness,\n\t\t\t\t\trow_4_hole_diameter,\n\t\t\t\t\ttool_space_4,\n\t\t\t \t\tnumber_of_tools_in_row_4,\n\t\t\t\t\trow_4_hole_shape);\n\t}\n}\nmodule tool_holes_row(row_x_start, row_y, tray_thk, hole_dia, hole_space, num_holes, hole_type = 0 ){\n\tfor (tool_index = [0:num_holes-1]){\n\t\tif(hole_type == 0){\n\t\t\ttranslate([row_x_start+tool_index*2*hole_space,row_y,-tray_thk/2-10])\n\t\t\t\tcylinder(h=tray_thk+20, r=hole_dia/2,$fs=.1);\n\t\t}\n\t\tif(hole_type == 1){\n\t\t\ttranslate([row_x_start+tool_index*2*hole_space,row_y,0])\n\t\t\t\tcube(center=true, size = [hole_dia, hole_dia, tray_thk+2]);\n\t\t}\n\t\tif(hole_type == 2){\n\t\t\ttranslate([row_x_start+tool_index*2*hole_space,row_y,-tray_thk/2-1])\n\t\t\thexagon_prism(tray_thk+2, hole_dia/2);\n\t\t}\n\t}\n}\nmodule tool_fingers_row(row_x_start, row_y, tray_thk, hole_dia, hole_space, num_holes, hole_type = 0,finger_thk=2){\n\tfor (tool_index = [0:num_holes-1]){\n\t\ttranslate([row_x_start+tool_index*2*hole_space,row_y,-tray_thk/2]) rotate([180, 0, 0]) tool_finger(hole_type, hole_dia, hole_taper, tray_thk, finger_thk);\n\t}\n}\nmodule tool_finger(hole_type=2, hole_dia = 4, hole_taper = 2, tray_thk=5, finger_thk=2){\n\tif (hole_type == 0){\n\t\t\tdifference(){\n\t\t\t\tcylinder(r1=hole_dia/2+finger_thk, r2=hole_dia/2+finger_thk-hole_taper/2,h=tray_thk,$fs=.1);\n\t\t\t\ttranslate([0,0,-.1]) cylinder(r1=hole_dia/2, r2=hole_dia/2-hole_taper/2,h=tray_thk+.2,$fs=.1);\n\t\t\t\ttranslate([hole_dia/2+finger_thk,0,-.1]) cube([1.5*(2*finger_thk+hole_taper),.4*(2*finger_thk+hole_taper),2*tray_thk+.4], center=true);\n\t\t\t\ttranslate([-hole_dia/2-finger_thk,0,-.1]) cube([1.5*(2*finger_thk+hole_taper),.4*(2*finger_thk+hole_taper),2*tray_thk+.4], center=true);\n\t\t\t\ttranslate([0, hole_dia/2+finger_thk,-.1]) cube([.4*(2*finger_thk+hole_taper),1.5*(2*finger_thk+hole_taper),2*tray_thk+.4], center=true);\n\t\t\t\ttranslate([0, -hole_dia/2-finger_thk,-.1]) cube([.4*(2*finger_thk+hole_taper),1.5*(2*finger_thk+hole_taper),2*tray_thk+.4], center=true);\n\t\t\t}\n \t}\n\tif (hole_type == 1){\n\t\tdifference(){\n\t\t\tsquare_pyramid((hole_dia+2*finger_thk), (hole_dia+2*finger_thk),tray_thk*(hole_dia/2+finger_thk)/(hole_taper/2));\n\t\t\ttranslate([0,0,-.1]) square_pyramid(hole_dia, hole_dia, tray_thk*(hole_dia/2+finger_thk)/(hole_taper/2)+.1);\n\t\t\ttranslate([0,0,tray_thk+.5*tray_thk*(hole_dia/2+finger_thk)]) cube([hole_dia+2*finger_thk,hole_dia+2*finger_thk,tray_thk*(hole_dia/2+finger_thk)], center=true);\n\t\t\ttranslate([hole_dia/2+finger_thk,0,-.1]) cube([2*(2*finger_thk+hole_taper),.3*(hole_dia/2+finger_thk),2*tray_thk+.4], center=true);\n\t\t\ttranslate([-hole_dia/2-finger_thk,0,-.1]) cube([2*(2*finger_thk+hole_taper),.3*(hole_dia/2+finger_thk),2*tray_thk+.4], center=true);\n\t\t\ttranslate([0, hole_dia/2+finger_thk,-.1]) cube([.3*(hole_dia/2+finger_thk),2*(2*finger_thk+hole_taper),2*tray_thk+.4], center=true);\n\t\t\ttranslate([0, -hole_dia/2-finger_thk,-.1]) cube([.3*(hole_dia/2+finger_thk),2*(2*finger_thk+hole_taper),2*tray_thk+.4], center=true);\n\t\t}\n\t}\n\tif (hole_type == 2){\n\t\tdifference(){\n\t\t\tcylinder(r1=hole_dia/2+finger_thk, r2=hole_dia/2+finger_thk-hole_taper/2,h=tray_thk,$fs=.1);\n\t\t\ttranslate([0,0,-.1]) cylinder(r1=hole_dia/2, r2=hole_dia/2-hole_taper/2,h=tray_thk+.2,$fs=.1);\n\t\t\ttranslate([hole_dia/2+finger_thk,0,-.1]) cube([2*(2*finger_thk+hole_taper),.3*(hole_dia/2+finger_thk),2*tray_thk+.4], center=true);\n\t\t\ttranslate([-hole_dia/2-finger_thk,0,-.1]) cube([2*(2*finger_thk+hole_taper),.3*(hole_dia/2+finger_thk),2*tray_thk+.4], center=true);\n\t\t\ttranslate([0, hole_dia/2+finger_thk,-.1]) cube([.3*(hole_dia/2+finger_thk),2*(2*finger_thk+hole_taper),2*tray_thk+.4], center=true);\n\t\t\ttranslate([0, -hole_dia/2-finger_thk,-.1]) cube([.3*(hole_dia/2+finger_thk),2*(2*finger_thk+hole_taper),2*tray_thk+.4], center=true);\n\t\t}\n\t}\n}\nmodule tray_legs(){\n\tdifference(){\n\t\ttranslate([0,0,-tray_height/2-tray_thickness/2])\n\t\t\tcube(size=[tray_width,tray_depth,tray_height], center = true);\n\t\ttranslate([0,0,-tray_height/2-tray_thickness/2])\n\t\t\tcube(size=[tray_width-2*leg_thickness,tray_depth-2*leg_thickness,tray_height+2], center = true);\n\t\ttranslate([0, tray_depth/2+1,-tray_height-tray_thickness/2-1]) rotate([90,0,0])\tlinear_extrude(height = tray_depth+2) trapezoid(tray_width-2*corner_width, tray_height+2, corner_taper);\n\t\ttranslate([-tray_width/2-1,0,-tray_height-tray_thickness/2-1]) rotate([90,0,90])\tlinear_extrude(height = tray_width+2) trapezoid(tray_depth-2*corner_depth, tray_height+2, corner_taper);\n\t}\n}\nmodule trapezoid(twidth, theight, taper){\n\tpolygon(points = [ \t[-twidth/2,0],\n\t\t\t\t\t\t[twidth/2,0],\n\t\t\t\t\t\t[(1-taper)*(twidth/2),theight],\n\t\t\t\t\t\t[(1-taper)*(-twidth/2),theight]],\n\t\t\tpaths =\t[\t[0,1,2,3]]\n\t\t);\n}",
    "description": "Okay, I'm looking to create a custom tool tray, and I need an OpenSCAD file that can handle a few specific things. I'd like to have several rows for holding different sized tools, and be able to adjust the number of tools, the diameter of the holes, and the shape of the holes in each row. I want to be able to choose from round, square, and hexagonal holes.\n\nSpecifically, I'd like these parameters:\n\n*   **Number of tools per row:** Should be adjustable per row.\n*   **Hole diameter:** Adjustable per row.\n*   **Hole shape:** Should allow me to select between round, square, and hexagon, adjustable per row.\n*   **Tray height:** The overall height of the tray.\n*   **Hole taper:** Allow for a taper in the holes, and be adjustable.\n*   **Printing Orientation:** A way to flip the tray for printing orientation. I want to make sure I can print it face down.\n*   **Tray thickness:** The thickness of the main tray, which should be adjustable, but perhaps not presented to the user.\n*   **Leg thickness**: The thickness of the supporting legs, and likewise may not need to be presented to the user.\n*   **Margin:** A consistent margin around the tool holes. Not adjustable directly, but would be good to be consistent.\n\nIt's important that the tray's overall dimensions are calculated based on the tool rows I define, and that each row is properly spaced, taking into consideration the hole diameter and some spacing factor between the holes. I am using the MCAD library, so please include that in the code. Specifically, the `regular_shapes.scad` file within that library will be required for the hexagon holes.\n\nI would also like some finger-like cutouts around the top of each hole to make it easier to grab the tools. I have no explicit desire to specify the \"finger\" thickness, however I would like to know that it's an adjustable parameter. I think it would also make sense to add some rounding to the corners to get rid of sharp corners.\n\nThe overall design is essentially a flat tray with legs. The legs should not interfere with any of the holes.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Cartoon Character Maker - A Customizable Avatar Builder",
    "scad": "resolution=8;\nheight=100;\nhead_tilt=20;\ntop_width= 4;\nbottom_width = 3;\nneck = 4;\nhair_type=\"average guy\";\nhair_length = 5;\neye_type=\"eye roll\";\neye_size= 6;\neye_angle=-8;\neye_spacing=4;\nglasses=\"hipster\";\neyebrow_thickness=7;\neyebrow_length=7;\neyebrow_tilt=15;\nfacial_hair=\"full beard\";\nfacial_hair_length=1;\nnose_type=\"average\";\nnose_size=5;\nnose_width=5;\nnose_height=5;\nmouth_type=\"agape\";\nmouth_size=5;\nmouth_height=7;\near_type=\"average\";\near_size=5;\near_angle=2;\nrec=resolution;\nres=resolution*2;\nh=100*1;\nrs=h/4.1*(top_width+10)/10;\nrc=h/4.1*(bottom_width+10)/10;\nrn=rc*(neck+3)/15;\nhm=h-rs-rc;\ntheta=asin((rs-rc)/hm);\neyer=(eye_size/10)*(rs*3/10);\neyemax=rs*3/10;\neyesp=eyer+(eye_spacing/10)*(rs*3/5-2*eyer);\neyex=pow(pow(rs,2)-pow(eyesp,2),1/2)-rs+rc;\nnosez=(1/2)*rc+(h/2-(1/2)*rc)*(nose_height-1)/9;\nmouthmax=(h/2-eyemax)/2*.8;\nmouthd=mouthmax*(mouth_size+5)/15;\nmouthr=mouthd/2;\nmouthz=nosez*(mouth_height+3)/13;\ncolor(\"lightblue\")rotate([0,0,-90])scale([height/100,height/100,height/100])difference(){\n\ttranslate([0,0,-rc*(1-cos(head_tilt))])union(){\n\t\ttranslate([0,0,rc])\n\t\trotate([0,(-head_tilt+theta),0])\n\t\ttranslate([0,0,-rc])\n\t\tunion(){\n\t\t\tdifference(){\n\t\t\t\thead();\n\t\t\t\tmouth_blank();\n\t\t\t}\n\t\t\teyes();\n\t\t\tmouth();\n\t\t\tears();\n\t\t\tnose();\n\t\t\thair();\n\t\t\tbeard();\n\t\t\tbrows();\n\t\t}\n\t\ttranslate([-rc*2/3+rn,0,0])cylinder(r=rn,h=rc+hm,$fn=rec);\n\t}\n\ttranslate([0,0,-50])cube(100,center=true);\n}\nmodule head(){\n\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\ttranslate([0,0,hm])sphere(rs,$fn=res);\n\t\tsphere(rc,$fn=res);\n\t}\n}\nmodule eye_blank(){\n\tintersection(){\n\t\ttranslate([0,0,h/2])rotate([0,90,0])linear_extrude(h=rs+10)for(i=[1,-1])hull(){\n\t\t\ttranslate([0,eyemax*i])circle(eyemax,$fn=rec);\n\t\t\ttranslate([-eyemax/2,-eyemax*i])circle(eyemax/2,$fn=rec);\n\t\t}\n\t\thead();\n\t}\n}\nmodule mouth_blank(){\n\tintersection(){\n\t\ttranslate([0,0,mouthz])rotate([0,90,0])scale([1,1.25,1])cylinder(r=mouthmax,h=rc+10,$fn=rec);\n\t\thead();\n\t}\n}\nmodule eyes(){\n\t\tif(glasses!=\"coke bottle\")\n\t\tfor(i=[1,-1])translate([eyex-eyer/2,eyesp*i,h/2])rotate([eye_angle*i,0,0]){\n\t\t\tif(eye_type==\"average\")eyeball(eyer,6);\n\t\t\tif(eye_type==\"surprised\")eyeball(eyer,15);\n\t\t\tif(eye_type==\"sleepy\")eyeball(eyer,2);\n\t\t\tif(eye_type==\"eye roll\")rotate([0,-30,-30])eyeball(eyer,5);\n\t\t}\n\t\tif(glasses==\"hipster\")translate([eyex+2,0,h/2])rotate([0,5,0])square_glasses();\n\t\tif(glasses==\"circle\")translate([eyex+2,0,h/2])rotate([0,5,0])circle_glasses();\n\t\tif(glasses==\"coke bottle\")translate([eyex+2,0,h/2])rotate([0,5,0])coke_bottle();\n}\nmodule mouth(){\n\tdifference(){\n\t\tmouth_blank();\n\t\tif(mouth_type==\"agape\"){\n\t\t\t\tif(mouthz<rc)translate([pow(pow(rc,2)-pow(rc-mouthz,2),.5),0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])intersection(){\n\t\t\t\tscale([1,1,.7])sphere(10,$fn=res);\n\t\t\t\ttranslate([0,0,-28])sphere(30,$fn=res);}\n\t\t\tif(mouthz>=rc)translate([rc,0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])intersection(){\n\t\t\t\tscale([1,1,.7])sphere(10,$fn=res);\n\t\t\t\ttranslate([0,0,-28])sphere(30,$fn=res);}\n\t\t}\n\t\tif(mouth_type==\"smiling\"){\n\t\t\tif(mouthz<rc)translate([pow(pow(rc,2)-pow(rc-mouthz,2),.5),0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])difference(){\n\t\t\t\tscale([1,1,.7])sphere(10,$fn=res);\n\t\t\t\ttranslate([0,7,20])sphere(20,$fn=res);}\n\t\t\tif(mouthz>=rc)translate([rc,0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])difference(){\n\t\t\t\tscale([1,1,.7])sphere(10,$fn=res);\n\t\t\t\ttranslate([0,7,20])sphere(20,$fn=res);}\n\t\t}\n\t\tif(mouth_type==\"oh no\"){\n\t\t\tif(mouthz<rc)translate([pow(pow(rc,2)-pow(rc-mouthz,2),.5),0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])difference(){\n\t\t\t\tscale([1,1,.7])sphere(10,$fn=res);\n\t\t\t\ttranslate([0,-7,-20])sphere(20,$fn=res);}\n\t\t\tif(mouthz>=rc)translate([rc,0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])difference(){\n\t\t\t\tscale([1,1,.7])sphere(10,$fn=res);\n\t\t\t\ttranslate([0,-7,-20])sphere(20,$fn=res);}\n\t\t}\n\t\tif(mouth_type==\"not feeling well\"){\n\t\t\ttranslate([rc,0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])rotate([0,90,0])rotate([0,0,90])linear_extrude(height=50,center=true){\n\t\t\t\tintersection(){\n\t\t\t\t\ttranslate([-5,-3.5])difference(){\n\t\t\t\t\t\tcircle(5,$fn=20);\n\t\t\t\t\t\tcircle(2,$fn=20);\n\t\t\t\t\t}\n\t\t\t\t\ttranslate([-15,-3.5])square(10);\n\t\t\t\t}\n\t\t\t\thull(){\n\t\t\t\t\ttranslate([-5,0])circle(1.5,$fn=20);\n\t\t\t\t\ttranslate([6,0])circle(1.5,$fn=20);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mouth_type==\"um...\"){\n\t\t\ttranslate([rc,0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])rotate([0,90,0])rotate([0,0,90])linear_extrude(height=50,center=true){\n\t\t\t\thull(){\n\t\t\t\t\ttranslate([-5,0])circle(1.5,$fn=20);\n\t\t\t\t\ttranslate([6,0])circle(1.5,$fn=20);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mouth_type==\"half smile\"){\n\t\t\ttranslate([rc,0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])rotate([0,90,0])rotate([0,0,90])linear_extrude(height=50,center=true){\n\t\t\t\tintersection(){\n\t\t\t\t\ttranslate([-5,3.5])difference(){\n\t\t\t\t\t\tcircle(5,$fn=20);\n\t\t\t\t\t\tcircle(2,$fn=20);\n\t\t\t\t\t}\n\t\t\t\t\ttranslate([-15,-6.5])square(10);\n\t\t\t\t}\n\t\t\t\thull(){\n\t\t\t\t\ttranslate([-5,0])circle(1.5,$fn=20);\n\t\t\t\t\ttranslate([6,0])circle(1.5,$fn=20);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mouth_type==\"chiclet teeth\"){\n\t\t\tif(mouthz<rc)translate([pow(pow(rc,2)-pow(rc-mouthz,2),.5),0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])difference(){\n\t\t\t\tintersection(){\n\t\t\t\t\tscale([1,1,.7])sphere(10,$fn=res);\n\t\t\t\t\ttranslate([0,0,-28])sphere(30,$fn=res);}\n\t\t\t\tfor(j=[0,1])translate([-1*j-5,0,-4.5*j-3])\n\t\t\t\t\tfor(i=[-10.5,-7.5,-4.5,-1.5,1.5,4.5,7.5,10.5])translate([0,i,0])hull(){\n\t\t\t\t\t\ttranslate([0,.5,1])sphere(1,$fn=10);\n\t\t\t\t\t\ttranslate([0,-.5,1])sphere(1,$fn=10);\n\t\t\t\t\t\ttranslate([0,.5,5])sphere(1,$fn=10);\n\t\t\t\t\t\ttranslate([0,-.5,5])sphere(1,$fn=10);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mouthz>=rc)translate([rc,0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])difference(){\n\t\t\t\tintersection(){\n\t\t\t\t\tscale([1,1,.7])sphere(10,$fn=res);\n\t\t\t\t\ttranslate([0,0,-28])sphere(30,$fn=res);}\n\t\t\t\tfor(j=[0,1])translate([-1*j-5,0,-4.5*j-3])\n\t\t\t\t\tfor(i=[-10.5,-7.5,-4.5,-1.5,1.5,4.5,7.5,10.5])translate([0,i,0])hull(){\n\t\t\t\t\t\ttranslate([0,.5,1])sphere(1,$fn=10);\n\t\t\t\t\t\ttranslate([0,-.5,1])sphere(1,$fn=10);\n\t\t\t\t\t\ttranslate([0,.5,5])sphere(1,$fn=10);\n\t\t\t\t\t\ttranslate([0,-.5,5])sphere(1,$fn=10);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(mouth_type==\"lipstick\"){\n\t\tintersection(){\n\t\t\ttranslate([rc,0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])scale([.6,.6,.6])rotate([0,270,0])linear_extrude(height=50,center=true){\n\t\t\t\tdifference(){\n\t\t\t\t\tintersection(){\n\t\t\t\t\t\ttranslate([30,0])circle(40,$fn=30);\n\t\t\t\t\t\tfor(i=[1,-1])translate([3,0])rotate([0,0,15*i])translate([-30,0])circle(30,$fn=30);\n\t\t\t\t\t}\n\t\t\t\t\tfor(i=[1,-1])translate([-2,0])rotate([0,0,15*i])translate([-50,0])circle(50,$fn=30);\n\t\t\t\t}\n\t\t\t\ttranslate([-1,0])intersection(){\n\t\t\t\t\ttranslate([30,0])circle(40,$fn=30);\n\t\t\t\t\tfor(i=[1,-1])translate([3,0])rotate([0,0,15*i])translate([-30,0])circle(30,$fn=30);\n\t\t\t\t\tfor(i=[1,-1])translate([-2,0])rotate([0,0,15*i])translate([-50,0])circle(50,$fn=30);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([3,0,0])mouth_blank();\n\t\t}\n\t}\n\tif(mouth_type==\"just stache\"){\n\t\ttranslate([rc,0,mouthz+5])\n\t\tscale([mouth_size/5,mouth_size/5,mouth_size/5])scale([.7,.7,.7])\n\t\tdifference(){\n\t\t\ttranslate([0,0,5])cube([10,30,10],center=true);\n\t\t\ttranslate([8,0,0])rotate([0,-15,0])translate([0,0,25])cube([10,30,50],center=true);\n\t\t\tfor(i=[-15:3:15]){\n\t\t\t\ttranslate([3,i*pow(2,.5),0])rotate([0,-15,0])rotate([0,0,45])translate([0,0,6])cube([1,1,12],center=true);\n\t\t\t\ttranslate([0,i*pow(2,.5),10])rotate([45,0,0])cube([10,1,1],center=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule ears(){\n\tfor(i=[1,-1])\n\t\tscale([1,i,1])\n\t\ttranslate([0,0,rc])\n\t\trotate([0,-theta,0])\n\t\ttranslate([0,rs,hm])\n\t\trotate([-theta,0,0])\n\t\ttranslate([0,0,h/2-rc-hm])\n\t\tscale([ear_size/4,ear_size/4,ear_size/4]){\n\t\t\tif(ear_type==\"average\")ear_model(Ear_Length=15,Ear_Shape=60,ear_thickness=3,taper=70);\n\t\t\tif(ear_type==\"monkey\")ear_model(Ear_Length=9,Ear_Shape=10,ear_thickness=3,taper=70);\n\t\t\tif(ear_type==\"long\")ear_model(Ear_Length=25,Ear_Shape=30,ear_thickness=3,taper=70);\n\t\t\tif(ear_type==\"pill shaped\")ear_model(Ear_Length=15,Ear_Shape=100,ear_thickness=3,taper=70);\n\t\t\tif(ear_type==\"viking horn\")rotate([15+theta,0,0])horn(hornrad=45,hornshaft=8,hornsweep=60,horncut=5);\n\t\t}\n}\nmodule nose(){\n\ttranslate([rc,0,nosez])scale([nose_size/5,nose_size/5*nose_width/5,nose_size/5]){\n\t\tif(nose_type==\"pointy\")\n\t\t\tnose_model(\n\t\t\t\tnwidth=12,\n\t\t\t\tbridge_width=1,\n\t\t\t\tbridge_prominance=1,\n\t\t\t\ttip_width=1,\n\t\t\t\ttip_height=0,\n\t\t\t\tnheight=16,\n\t\t\t\tnose_length=8,\n\t\t\t\tsoftness=4,\n\t\t\t\tnostril_length=4,\n\t\t\t\tnostril_weight=3,\n\t\t\t\tnostril_width=7,\n\t\t\t\tnostril_bulge=0);\n\t\tif(nose_type==\"upturned\")\n\t\t\tnose_model(\n\t\t\t\tnwidth=10,\n\t\t\t\tbridge_width=3,\n\t\t\t\tbridge_prominance=-4,\n\t\t\t\ttip_width=3,\n\t\t\t\ttip_height=3,\n\t\t\t\tnheight=16,\n\t\t\t\tnose_length=6,\n\t\t\t\tsoftness=9,\n\t\t\t\tnostril_length=4,\n\t\t\t\tnostril_weight=3,\n\t\t\t\tnostril_width=9,\n\t\t\t\tnostril_bulge=0);\n \t\tif(nose_type==\"wide\")\n\t\t\tnose_model(\n\t\t\t\tnwidth=18,\n\t\t\t\tbridge_width=4,\n\t\t\t\tbridge_prominance=1,\n\t\t\t\ttip_width=5,\n\t\t\t\ttip_height=1,\n\t\t\t\tnheight=16,\n\t\t\t\tnose_length=8,\n\t\t\t\tsoftness=7,\n\t\t\t\tnostril_length=8,\n\t\t\t\tnostril_weight=5,\n\t\t\t\tnostril_width=9,\n\t\t\t\tnostril_bulge=.2);\n \t\tif(nose_type==\"average\")\n\t\t\tnose_model(\n\t\t\t\tnwidth=14,\n\t\t\t\tbridge_width=4,\n\t\t\t\tbridge_prominance=-3,\n\t\t\t\ttip_width=6,\n\t\t\t\ttip_height=0,\n\t\t\t\tnheight=16,\n\t\t\t\tnose_length=7,\n\t\t\t\tsoftness=8,\n\t\t\t\tnostril_length=5,\n\t\t\t\tnostril_weight=7,\n\t\t\t\tnostril_width=9,\n\t\t\t\tnostril_bulge=.2);\n \t\tif(nose_type==\"high bridge\")\n\t\t\tnose_model(\n\t\t\t\tnwidth=12,\n\t\t\t\tbridge_width=2,\n\t\t\t\tbridge_prominance=3,\n\t\t\t\ttip_width=4,\n\t\t\t\ttip_height=0,\n\t\t\t\tnheight=16,\n\t\t\t\tnose_length=10,\n\t\t\t\tsoftness=8,\n\t\t\t\tnostril_length=4,\n\t\t\t\tnostril_weight=4,\n\t\t\t\tnostril_width=7,\n\t\t\t\tnostril_bulge=.2);\n \t\tif(nose_type==\"button\")\n\t\t\tnose_model(\n\t\t\t\tnwidth=12,\n\t\t\t\tbridge_width=2,\n\t\t\t\tbridge_prominance=-8,\n\t\t\t\ttip_width=6,\n\t\t\t\ttip_height=1,\n\t\t\t\tnheight=10,\n\t\t\t\tnose_length=5,\n\t\t\t\tsoftness=8,\n\t\t\t\tnostril_length=4,\n\t\t\t\tnostril_weight=4,\n\t\t\t\tnostril_width=7,\n\t\t\t\tnostril_bulge=0);\n\t\tif(nose_type==\"piggy\")scale([1,5/nose_width,1])translate([0,0,7])rotate([0,90,0])difference(){\n\t\t\t\t\tintersection(){\n\t\t\t\t\t\tcylinder(r=7,h=14,center=true,$fn=rec);\n\t\t\t\t\t\tscale([7/14,7/14,1])sphere(r=14,$fn=res);\n\t\t\t\t\t}\n\t\t\t\t\tfor(i=[1,-1])scale([1,i,1])translate([0,2,7])scale([1,.5,1])sphere(r=2.5,$fn=res);\n\t\t\t\t}\n \t\tif(nose_type==\"clown\")scale([1,1,nose_width/5])translate([3,0,10])sphere(r=10,$fn=res);\n\t}\n}\nmodule hair(){\n\tif(hair_type==\"bowl cut\")bowlcut(hairlen=4);\n\tif(hair_type==\"bob\")bob(hairlen=4);\n\tif(hair_type==\"long\")long(hairlen=4);\n\tif(hair_type==\"buzz\")buzz(hairlen=hair_length);\n\tif(hair_type==\"mullet\")mullet(hairlen=hair_length,toplen=5/7*rs,topwidth=0.9);\n\tif(hair_type==\"fro\")buzz(hairlen=20);\n\tif(hair_type==\"monster fro\")buzz(hairlen=30);\n\tif(hair_type==\"male pattern\")intersection(){\n\t\tbuzz(hairlen=hair_length);\n\t\trotate([0,-theta,0])cylinder(r=100,h=h/2+13,$fn=rec);\n\t}\n\tif(hair_type==\"flattop\")flattop(hairlen=hair_length,toplen=rs,topwidth=.95);\n\tif(hair_type==\"average guy\")flattop(hairlen=hair_length,toplen=4/7*rs,topwidth=0.9);\n\tif(hair_type==\"top bun\")topbun(hairlen=1);\n\tif(hair_type==\"pony\")pony(hairlen=1);\n}\nmodule beard(){\n\tif(facial_hair==\"full beard\")fullbeard(facial_hair_length);\n\tif(facial_hair==\"chin strap\")chinstrap(facial_hair_length);\n\tif(facial_hair==\"chops\")chops(facial_hair_length);\n\tif(facial_hair==\"stache\")stache(facial_hair_length);\n\tif(facial_hair==\"soul patch\")soulpatch(facial_hair_length);\n\tif(facial_hair==\"goatee\")goatee(facial_hair_length);\n}\nmodule eyeball(eye_radius,awake){\n\ttheta1=55*awake/10-10;\n\ttheta2=45*awake/10+10;\n\tunion(){\n\t\tdifference(){\n\t\t\tsphere(eye_radius*9/10,$fn=res);\n\t\t\trotate([0,90,0])cylinder(r1=0,r2=eye_radius/1.5,h=eye_radius,$fn=res);\n\t\t}\n\t\tdifference(){\n\t\t\tsphere(eye_radius*8/10,$fn=res);\n\t\t\trotate([0,90,0])cylinder(r1=0,r2=eye_radius/4,h=eye_radius,$fn=res);\n\t\t}\n\t\trotate([0,theta2,0])difference(){\n\t\t\tsphere(eye_radius,$fn=res);\n\t\t\ttranslate([-eye_radius,-eye_radius,0])cube(2*eye_radius);\n\t\t}\n\t\trotate([0,-180-theta1,0])difference(){\n\t\t\tsphere(eye_radius,$fn=res);\n\t\t\ttranslate([-eye_radius,-eye_radius,0])cube(2*eye_radius);\n\t\t}\n\t}\n}\nmodule square_glasses(){\n\trotate([90,0,-90])union(){\n\t\tlinear_extrude(height=2){\n\t\t\tfor(i=[1,-1])scale([i,1])translate([6,-6])difference(){\n\t\t\t\tminkowski(){\n\t\t\t\t\tsquare([16,12]);\n\t\t\t\t\tcircle(r=2.5,$fn=rec);\n\t\t\t\t}\n\t\t\t\tminkowski(){\n\t\t\t\t\tsquare([16,12]);\n\t\t\t\t\tcircle(r=1,$fn=rec);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdifference(){\n\t\t\t\ttranslate([0,1.5])square([7,9],center=true);\n\t\t\t\ttranslate([0,6])circle(r=3.5,$fn=rec);\n\t\t\t\ttranslate([0,-3])circle(r=3.5,$fn=rec);\n\t\t\t}\n\t\t}\n\t\tlinear_extrude(height=20)intersection(){\n\t\t\tfor(i=[1,-1])scale([i,1])translate([6,-6])difference(){\n\t\t\t\tminkowski(){\n\t\t\t\t\tsquare([16,12]);\n\t\t\t\t\tcircle(r=2.5,$fn=rec);\n\t\t\t\t}\n\t\t\t\tminkowski(){\n\t\t\t\t\tsquare([16,12]);\n\t\t\t\t\tcircle(r=1,$fn=rec);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([0,-57])square([100,100],center=true);\n\t\t}\n\t\tlinear_extrude(height=40){\n\t\t\tfor(i=[1,-1])scale([i,1])translate([25.5,0]){\n\t\t\t\ttranslate([0,1.5])square([2,6],center=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule circle_glasses(){\n\trotate([90,0,-90])union(){\n\t\tlinear_extrude(height=2){\n\t\t\tfor(i=[1,-1])scale([i,1])translate([14,1])difference(){\n\t\t\t\tcircle(r=12,$fn=rec);\n\t\t\t\tcircle(r=9,$fn=rec);\n\t\t\t}\n\t\t\tintersection(){\n\t\t\t\tdifference(){\n\t\t\t\t\ttranslate([0,-2])circle(r=6.5,$fn=rec);\n\t\t\t\t\ttranslate([0,-2])circle(r=3.5,$fn=rec);\n\t\t\t\t}\n\t\t\t\ttranslate([-4,0])square([8,10]);\n\t\t\t}\n\t\t}\n\t\tlinear_extrude(height=20)intersection(){\n\t\t\tfor(i=[1,-1])scale([i,1])translate([14,1])difference(){\n\t\t\t\tcircle(r=12,$fn=rec);\n\t\t\t\tcircle(r=9,$fn=rec);\n\t\t\t}\n\t\t\ttranslate([0,-58])square([100,100],center=true);\n\t\t}\n\t\tlinear_extrude(height=40){\n\t\t\tfor(i=[1,-1])scale([i,1])translate([25.5,0]){\n\t\t\t\ttranslate([0,1.5])square([2,6],center=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule coke_bottle(){\n\tcircle_glasses();\n\tfor(i=[1,-1])translate([-2,14*i,1])rotate([0,90,0])cylinder(r=10,h=1,$fn=rec);\n\tintersection(){\n\t\tfor(i=[1,-1])translate([-9,14*i,1])rotate([eye_angle*i,0,0])eyeball(13,5);\n\t\ttranslate([48,0,0])cube(100,center=true);\n\t}\n}\nmodule nose_model(nwidth,bridge_width,bridge_prominance,tip_width,tip_height,nheight,nose_length,softness,nostril_length,nostril_weight,nostril_width,nostril_bulge){\n\tnrad=pow(pow(nose_length,2)+pow(tip_height,2)+pow(nwidth/2,2),1/2)*nostril_length/20;\n\tnostrad=nostril_width/10*nwidth/4;\n\trtop=bridge_width/2*softness/10;\n\trtip=tip_width/2*softness/10;\n\tresnose=10;\n\tnthtz=atan(-nwidth/2/nose_length);\n\tnthty=atan(-tip_height/nose_length);\n\ttranslate([0,0,nrad*nostril_weight/10])difference(){\n\t\tunion(){\n\t\t\thull(){\n\t\t\t\tfor(i=[1,-1])scale([1,i,1])translate([0,nwidth/2,0])rotate([0,nthty,nthtz])translate([nrad,0,0])scale([1,nostril_weight/10,nostril_weight/10])sphere(nrad,$fn=resnose);\n\t\t\t\tfor(i=[1,-1])scale([1,i,1])translate([-nrad,nwidth/2-nrad,0])sphere(r=rtip,$fn=resnose);\n\t\t\t\tfor(i=[1,-1])scale([1,i,1])translate([nose_length-rtip,tip_width/2-rtip,tip_height])sphere(r=rtip,$fn=resnose);\n\t\t\t\tfor(i=[1,-1])scale([1,i,1])translate([(nose_length-rtip)/3+(nose_length-rtip)*2/3*bridge_prominance/10,bridge_width/2-rtop,tip_height+(nheight-tip_height)*2/3])sphere(r=rtop,$fn=resnose);\n\t\t\t\ttranslate([-rtop,0,nheight-rtop])sphere(r=rtop,$fn=resnose);\n\t\t\t}\n\t\t\tfor(i=[1,-1])scale([1,i,1])translate([0,nwidth/2,0])rotate([0,nthty,nthtz])translate([nrad,0,0])scale([1,nostril_weight/10,nostril_weight/10])sphere(nrad+nostril_bulge,$fn=resnose);\n\t\t}\n\t\tfor(i=[-1,1])scale([1,i,1])translate([nostrad/2+(nose_length-nostrad)/10,nostrad+(nwidth/2-nostrad)/10,-nheight/4])rotate([0,-atan(nose_length/2/nheight),0])cylinder(r1=nostrad,r2=0,h=nheight*2/3,$fn=rec);\n\t}\n}\nmodule ear_model(Ear_Length,Ear_Shape,ear_thickness,taper){\n\tTop_Radius=5;\n\tsoft=ear_thickness/6;\n\tBottom_Radius=1+(Top_Radius-1)*Ear_Shape/100;\n\ttopr=Top_Radius;\n\tbotr=Bottom_Radius;\n\teart=ear_thickness;\n\tcutr=(Ear_Length-topr-botr)/2;\n\trotate([0,0,-45*ear_angle/10])translate([-topr*2/3,0,0])rotate([270,0,0])difference(){\n\t\thull(){\n\t\t\t\tcylinder(r1=topr*taper/100,r2=topr,h=eart,$fn=rec*2,center=true);\n\t\t\t\ttranslate([topr-botr,Ear_Length-topr-botr,0])cylinder(r1=botr*taper/100,r2=botr,h=eart,$fn=rec*2,center=true);\n\t\t\t\ttranslate([(topr-botr)/2,Ear_Length-topr,-eart/2])cylinder(r1=botr*taper/200,r2=0,h=eart*3/2,$fn=rec*2,center=true);\n\t\t\t\ttranslate([0,0,ear_thickness/2])scale([1,1,ear_thickness/3/topr])sphere(topr,$fn=res);\n\t\t\t\ttranslate([topr-botr,Ear_Length-topr-botr,ear_thickness/2])scale([1,1,ear_thickness/5/botr])sphere(botr,$fn=res);\n\t\t}\n\t\thull(){\n\t\t\ttranslate([0,0,ear_thickness/2+ear_thickness/3/topr])scale([1,1,ear_thickness/2/topr])sphere(topr-soft,$fn=res);\n\t\t\ttranslate([topr-botr,Ear_Length-topr-botr,ear_thickness/2+ear_thickness/5/topr])scale([1,1,ear_thickness/4/botr])sphere(botr-soft,$fn=res);\n\t\t}\n\t\ttranslate([topr,(Ear_Length-topr-botr)/2,ear_thickness*(1/2+1/3)])scale([1,1,ear_thickness*(1/2+1/3)/cutr])sphere(cutr,$fn=res);\n\t}\n}\nmodule horn(hornrad,hornshaft,hornsweep,horncut){\n\tradstep=hornshaft/(horncut);\n\trotstep=hornsweep/(horncut);\n\trotate([0,0,-90])\n\trotate([0,-90,0])\n\ttranslate([hornrad+hornshaft,0,0])\n\tfor(i=[1:1:horncut]){\n\t\thull(){\n\t\t\trotate([0,rotstep*(i-1),0])translate([-hornrad,0,0])cylinder(r1=hornshaft-radstep*(i-1),r2=0,h=.1);\n\t\t\trotate([0,rotstep*i,0])translate([-hornrad,0,-.1])cylinder(r1=radstep/5,r2=hornshaft-radstep*i,h=.1);\n\t\t}\n\t}\n}\nmodule bob(hairlen){\n\tdifference(){\n\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\ttranslate([0,0,hm])sphere(rs+hairlen,$fn=res);\n\t\t\tsphere(max(rc,rs)+hairlen,$fn=res);\n\t\t}\n\t\trotate([0,-theta,0])translate([50,0,eyer*1.8-rs])cube([100,100,h],center=true);\n\t\trotate([0,-theta,0])translate([50+rs,0,h/2-50+eyer*1.8])cube([100,100,h],center=true);\n\t\trotate([0,-theta,0])translate([rs,0,h/2+eyer*1.8-rs])rotate([90,0,0])cylinder(r=rs,h=125,center=true,$fn=rec);\n\t\tcube([100,100,rc],center=true);\n\t}\n}\nmodule long(hairlen){\n\tdifference(){\n\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\ttranslate([0,0,hm])sphere(rs+hairlen,$fn=res);\n\t\t\ttranslate([0,0,-rc])sphere(max(rc+hairlen,rs+hairlen)+hairlen,$fn=res);\n\t\t}\n\t\trotate([0,-theta,0])translate([50,0,eyer*1.8-rs])cube([100,100,h],center=true);\n\t\trotate([0,-theta,0])translate([50+rs,0,h/2-50+eyer*1.8])cube([100,100,h],center=true);\n\t\trotate([0,-theta,0])translate([rs,0,h/2+eyer*1.8-rs])rotate([90,0,0])cylinder(r=rs,h=125,center=true,$fn=rec);\n\t\ttranslate([0,0,-rc/2])cube([100,100,rc],center=true);\n\t}\n}\nmodule bowlcut(hairlen){\n\tdifference(){\n\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\ttranslate([0,0,hm])sphere(rs+hairlen,$fn=res);\n\t\t\tsphere(rc+hairlen,$fn=res);\n\t\t}\n\t\trotate([0,-theta,0])translate([0,0,eyer*1.2])cube([100,100,h],center=true);\n\t}\n}\nmodule buzz(hairlen){\n\tintersection(){\n\t\ttranslate([0,0,h+hairlen-rs/2])rotate([0,75,0])cylinder(r=rs*1.5+hairlen,h=150,$fn=res,center=true);\n\t\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,hm])sphere(rs+hairlen,$fn=res);\n\t\t\t\tsphere(rc+hairlen,$fn=res);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([50+rs*2/5,0,-h/2+rs/6+rc+hm])cube([100,125,h],center=true);\n\t\t\t\ttranslate([50+rs*(2/5+1/4),0,-h/2+rs/4+rs/6+rc+hm])cube([100,125,h],center=true);\n\t\t\t\ttranslate([rs*(2/5+1/4),0,rc+hm+rs/6])rotate([90,0,0])cylinder(r=rs/4,h=125,center=true,$fn=rec);\n\t\t\t\ttranslate([50-5*2/3*ear_size/4-2-5*ear_size/4,0,.1])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-5*2/3*ear_size/4,0,h/2])rotate([90,0,0])cylinder(r=2+5*ear_size/4,h=125,center=true,$fn=rec);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule mullet(hairlen,toplen,topwidth){\n\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,hm])sphere(rs+hairlen,$fn=res);\n\t\t\t\ttranslate([0,0,hm])cylinder(r=(rs+hairlen)*topwidth,h=toplen,$fn=res);\n\t\t\t\ttranslate([0,0,-rc])cylinder(r=max(rc,rs)+hairlen,h=1,$fn=rec);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([50+rs*2/5,0,-h/2+rs/6+rc+hm])cube([100,125,h],center=true);\n\t\t\t\ttranslate([50+rs*(2/5+1/4),0,-h/2+rs/4+rs/6+rc+hm])cube([100,125,h],center=true);\n\t\t\t\ttranslate([rs*(2/5+1/4),0,rc+hm+rs/6])rotate([90,0,0])cylinder(r=rs/4,h=125,center=true,$fn=rec);\n\t\t\t\ttranslate([50-5*2/3*ear_size/4-2-5*ear_size/4,0,.1])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-5*2/3*ear_size/4,0,h/2])rotate([90,0,0])cylinder(r=2+5*ear_size/4,h=125,center=true,$fn=rec);\n\t\t\t}\n\t}\n}\nmodule flattop(hairlen,toplen,topwidth){\n\tintersection(){\n\t\ttranslate([0,0,h+hairlen-rs/2])rotate([0,75,0])cylinder(r=rs*1.5+hairlen,h=125,$fn=res,center=true);\n\t\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,hm])sphere(rs+hairlen,$fn=res);\n\t\t\t\ttranslate([0,0,hm])cylinder(r=(rs+hairlen)*topwidth,h=toplen,$fn=res);\n\t\t\t\tsphere(rc+hairlen,$fn=res);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([50+rs*2/5,0,-h/2+rs/6+rc+hm])cube([100,125,h],center=true);\n\t\t\t\ttranslate([50+rs*(2/5+1/4),0,-h/2+rs/4+rs/6+rc+hm])cube([100,125,h],center=true);\n\t\t\t\ttranslate([rs*(2/5+1/4),0,rc+hm+rs/6])rotate([90,0,0])cylinder(r=rs/4,h=125,center=true,$fn=rec);\n\t\t\t\ttranslate([50-5*2/3*ear_size/4-2-5*ear_size/4,0,.1])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-5*2/3*ear_size/4,0,h/2])rotate([90,0,0])cylinder(r=2+5*ear_size/4,h=125,center=true,$fn=rec);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule topbun(hairlen){\n\trotate([0,-theta*1.5,0])translate([0,0,h])scale([1,1,.7])sphere(r=rs/2,$fn=res);\n\tbuzz(hairlen);\n}\nmodule pony(hairlen){\n\trotate([0,0,0])translate([-rs,0,rc+hm])rotate([0,-90-theta,0])union(){\n\t\ttranslate([0,0,rs/7])sphere(r=rs/5,$fn=res);\n\t\thull(){\n\t\t\ttranslate([-rs/3,0,rs/3.5])sphere(r=rs/4.5,$fn=res);\n\t\t\ttranslate([-rs/3-rs/2,0,rs/5])sphere(r=rs/6,$fn=res);\n\t\t}\n\t\thull(){\n\t\t\ttranslate([-rs/3-rs/2,0,rs/5])sphere(r=rs/6,$fn=res);\n\t\t\ttranslate([-rc-hm,0,rs/3])sphere(r=2,$fn=res);\n\t\t}\n\t}\n\tbuzz(hairlen);\n}\nmodule fullbeard(beardlen){\n\trbcut=h/2-nosez+4;\n\trbscale=(rc+beardlen-rs*2/5)/rbcut;\n\tintersection(){\n\t\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,(h/2-rc)])sphere(beardlen+rc+(rs-rc)*((h/2-rc)/hm),$fn=res);\n\t\t\t\ttranslate([rc/3,0,0])scale([2/3,.9,1])sphere(rc+beardlen,$fn=res);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([0,0,h])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-50+3+5*1/3*ear_size/4,0,0])translate([0,0,h/2])rotate([0,theta,0])translate([0,0,-h/2])cube([100,125,1.5*h],center=true);\n\t\t\t\ttranslate([rbcut*rbscale+rs*(2/5),0,h/2])scale([rbscale,1,1])rotate([90,0,0])cylinder(r=rbcut,h=125,center=true,$fn=rec);\n\t\t\t\ttranslate([0,0,mouthz-rc*sin(theta)])scale([1,1.7,1])rotate([0,90,0])intersection(){\n\t\t\t\t\tcylinder(r=rc/4,h=50,$fn=rec);\n\t\t\t\t\ttranslate([rc/2-rc/10,0,0])cylinder(r=rc/2,h=50,$fn=rec*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule chinstrap(beardlen){\n\trbcut=h/2+beardlen;\n\trbscale=(rc+beardlen-rs*2/5)/rbcut;\n\tintersection(){\n\t\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,(h/2-rc)])sphere(beardlen+rc+(rs-rc)*((h/2-rc)/hm),$fn=res);\n\t\t\t\ttranslate([rc/3,0,0])scale([2/3,.9,1])sphere(rc+beardlen,$fn=res);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([0,0,h])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-50+3+5*1/3*ear_size/4,0,0])translate([0,0,h/2])rotate([0,theta,0])translate([0,0,-h/2])cube([100,125,1.5*h],center=true);\n\t\t\t\ttranslate([rbcut*rbscale+rs*(2/5),0,h/2])scale([rbscale,1,1])rotate([90,0,0])cylinder(r=rbcut,h=125,center=true,$fn=rec);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule chops(beardlen){\n\trbcut=h/2-nosez+4;\n\trbscale=(rc+beardlen-rs*2/5)/rbcut;\n\tintersection(){\n\t\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,(h/2-rc)])sphere(beardlen+rc+(rs-rc)*((h/2-rc)/hm),$fn=res);\n\t\t\t\ttranslate([rc/3,0,0])scale([2/3,.9,1])sphere(rc+beardlen,$fn=res);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([0,0,h])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-50+3+5*1/3*ear_size/4,0,0])translate([0,0,h/2])rotate([0,theta,0])translate([0,0,-h/2])cube([100,125,1.5*h],center=true);\n\t\t\t\ttranslate([rbcut*rbscale+rs*(2/5),0,h/2])scale([rbscale,1,1])rotate([90,0,0])cylinder(r=rbcut,h=125,center=true,$fn=rec);\n\t\t\t\ttranslate([0,0,.15*h])rotate([0,-30,0])translate([0,0,-h/4])cube([100,100,h/2],center=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule soulpatch(beardlen){\n\trbcut=h/2-nosez+4;\n\trbscale=(rc+beardlen-rs*2/5)/rbcut;\n\tintersection(){\n\t\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,(h/2-rc)])sphere(beardlen+rc+(rs-rc)*((h/2-rc)/hm),$fn=res);\n\t\t\t\ttranslate([rc/3,0,0])scale([2/3,.9,1])sphere(rc+beardlen,$fn=res);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([0,0,h])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-50+3+5*1/3*ear_size/4,0,0])translate([0,0,h/2])rotate([0,theta,0])translate([0,0,-h/2])cube([100,125,1.5*h],center=true);\n\t\t\t\ttranslate([rbcut*rbscale+rs*(2/5),0,h/2])scale([rbscale,1,1])rotate([90,0,0])cylinder(r=rbcut,h=125,center=true,$fn=rec);\n\t\t\t\ttranslate([0,0,mouthz-rc*sin(theta)])scale([1,1.7,1])rotate([0,90,0])intersection(){\n\t\t\t\t\tcylinder(r=rc/4,h=50,$fn=rec);\n\t\t\t\t\ttranslate([rc/2-rc/10,0,0])cylinder(r=rc/2,h=50,$fn=rec*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate([0,0,nosez-4-rc/4])scale([1,.5,1])rotate([0,90,0])intersection(){\n\t\t\tcylinder(r=rc/4,h=50,$fn=rec);\n\t\t\ttranslate([rc/2-rc/10,0,0])cylinder(r=rc/2,h=50,$fn=rec*2);\n\t\t}\n\t}\n}\nmodule stache(beardlen){\n\trbcut=h/2-nosez+4;\n\trbscale=(rc+beardlen-rs*2/5)/rbcut;\n\tintersection(){\n\t\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,(h/2-rc)])sphere(beardlen+rc+(rs-rc)*((h/2-rc)/hm),$fn=res);\n\t\t\t\ttranslate([rc/3,0,0])scale([2/3,.9,1])sphere(rc+beardlen,$fn=res);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([0,0,h])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-50+3+5*1/3*ear_size/4,0,0])translate([0,0,h/2])rotate([0,theta,0])translate([0,0,-h/2])cube([100,125,1.5*h],center=true);\n\t\t\t\ttranslate([rbcut*rbscale+rs*(2/5),0,h/2])scale([rbscale,1,1])rotate([90,0,0])cylinder(r=rbcut,h=125,center=true,$fn=rec);\n\t\t\t\ttranslate([0,0,mouthz-rc*sin(theta)])scale([1,1.7,1])rotate([0,90,0])intersection(){\n\t\t\t\t\tcylinder(r=rc/4,h=50,$fn=rec);\n\t\t\t\t\ttranslate([rc/2-rc/10,0,0])cylinder(r=rc/2,h=50,$fn=rec*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate([0,0,nosez-4])scale([1,1.7,1])rotate([0,90,0])intersection(){\n\t\t\tcylinder(r=rc/4,h=50,$fn=rec);\n\t\t\ttranslate([rc/2-rc/10,0,0])cylinder(r=rc/2,h=50,$fn=rec*2);\n\t\t}\n\t}\n}\nmodule goatee(beardlen){\n\trbcut=h/2-nosez+4;\n\trbscale=(rc+beardlen-rs*2/5)/rbcut;\n\tintersection(){\n\t\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,(h/2-rc)])scale([1,.7,1])sphere(beardlen+rc+(rs-rc)*((h/2-rc)/hm),$fn=res);\n\t\t\t\ttranslate([rc/3,0,0])scale([2/3,.7,1])sphere(rc+beardlen,$fn=res);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([0,0,h])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-50+3+5*1/3*ear_size/4,0,0])translate([0,0,h/2])rotate([0,theta,0])translate([0,0,-h/2])cube([100,125,1.5*h],center=true);\n\t\t\t\ttranslate([rbcut*rbscale+rs*(2/5),0,h/2])scale([rbscale,1,1])rotate([90,0,0])cylinder(r=rbcut,h=125,center=true,$fn=rec);\n\t\t\t\ttranslate([0,0,mouthz-rc*sin(theta)])scale([1,1.7,1])rotate([0,90,0])intersection(){\n\t\t\t\t\tcylinder(r=rc/4,h=50,$fn=rec);\n\t\t\t\t\ttranslate([rc/2-rc/10,0,0])cylinder(r=rc/2,h=50,$fn=rec*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trotate([0,90,0])cylinder(r=nosez,h=50,$fn=rec*2);\n\t}\n}\nmodule brows(){\n\ttranslate([0,0,h/2+eyer-hm])rotate([0,-theta,0])translate([0,0,hm])\n\tfor(i=[1,-1])scale([1,i,1])\n\trotate([0,0,atan(-1.2*eyesp/rs)])\n\trotate([eyebrow_tilt,0,0])\n\tintersection(){\n\t\trotate_extrude(convexity=10,$fn=res)translate([rs-eyebrow_thickness/30*3,0,0])circle(r=eyebrow_thickness/10*3,$fn=rec);\n\t\trotate([0,90,0])cylinder(r1=0,r2=rs*eyebrow_length/14,h=2*rs,$fn=rec*2);\n\t}\n}",
    "description": "Okay, I've been messing around with OpenSCAD and I want to make a really flexible character creator, kind of like the Mii characters from the Nintendo Wii, but in 3D printable form. I've got some basic ideas, but I really need help making it parametric and robust. \n\nHeres what Im envisioning:\n\n**Overall Goal:** A single, parametric OpenSCAD file that generates a stylized, customizable 3D avatar. I'm looking for a program that lets me modify all kinds of facial features so that I can make unique designs.\n\n**Key Features & Parameters:**\n\n1.  **Resolution:** I need a way to control the rendering resolution for previews vs. final prints. So a simple integer variable, like `resolution`, that I can set from say, 5 to 25. Lower for previews, higher for detailed outputs.\n\n2.  **Head Shape:**\n    *   **Height:** A total height parameter, `height`, to set the overall size of the head and neck. I'm thinking the parameter should exclude any hair.\n    *   **Head Tilt:**  A parameter `head_tilt` to control how far the head leans back. Something like 0 to 60 degrees for easy printing.\n    *   **Face Width:** Separate controls for the top and bottom widths of the face, `top_width` and `bottom_width`, both probably in the 1 to 10 range.\n    *   **Neck Thickness:** A `neck` parameter to control how thick the neck is, from 1 to 10, perhaps.\n\n3.  **Hair:**\n    *   **Hair Type:** A `hair_type` parameter using a dropdown menu or similar approach to select different styles like: \"average guy\", \"bald\", \"bowl cut\", \"bob\", \"long\", \"top bun\", \"pony\", \"buzz\", \"fro\", \"monster fro\", \"male pattern\", and \"flattop\".\n    *   **Hair Length:** A `hair_length` parameter to control the length of shorter hair styles (buzz cut, male pattern, flattop, mullet, and \"average guy\" cuts, so 1 to 15 range probably).\n\n4.  **Eyes:**\n    *   **Eye Type:** A `eye_type` parameter with options like \"average\", \"surprised\", \"sleepy\", and \"eye roll\".\n    *   **Eye Size:** `eye_size` to control the overall eye size (1 to 10).\n    *   **Eye Angle:**  `eye_angle` for angling the eyes, something like -30 to 30 degrees should be enough.\n    *   **Eye Spacing:** `eye_spacing` to set the distance between the eyes (1 to 10).\n    *  **Glasses:** A parameter `glasses` with options \"none\", \"hipster\", \"circle\", and \"coke bottle\" for different styles.\n\n5.  **Eyebrows:**\n    *   `eyebrow_thickness` to control the thickness of the eyebrows (1-10).\n    *   `eyebrow_length` to set the length of the eyebrows (1-10).\n    *   `eyebrow_tilt` for the angle of the eyebrows (e.g., -15 to 15).\n\n6.  **Facial Hair:**\n    *   `facial_hair` parameter with options like: \"none\", \"full beard\", \"chin strap\", \"goatee\", \"stache\", \"chops\", and \"soul patch\"\n    *   `facial_hair_length` to control the length of the facial hair (1-10).\n\n7.  **Nose:**\n    *   **Nose Type:** `nose_type` parameter with options like \"pointy\", \"upturned\", \"high bridge\", \"wide\", \"average\", \"button\", \"piggy\", and \"clown\".\n    *   **Nose Size:** `nose_size` to set the overall nose size (1 to 10).\n    *   **Nose Width:** `nose_width` to set the width of the nose (1 to 10).\n    *   **Nose Height:** `nose_height` to position the nose higher or lower on the face (1 to 10).\n\n8.  **Mouth:**\n    *   **Mouth Type:** A `mouth_type` parameter, with options like \"agape\", \"smiling\", \"chiclet teeth\", \"lipstick\", \"half smile\", \"um...\", \"not feeling well\", \"just stache\", and \"oh no\".\n    *   **Mouth Size:** `mouth_size` to control how big the mouth is (1 to 10).\n    *   **Mouth Height:**  `mouth_height` to set the vertical position of the mouth (1 to 10).\n\n9.  **Ears:**\n    *   **Ear Type:** `ear_type` parameter like \"average\", \"monkey\", \"long\", \"pill shaped\", and \"viking horn\".\n    *   **Ear Size:** `ear_size` for the ear size (1 to 10).\n    *   **Ear Angle:** `ear_angle` to set how far the ears stick out from the head (1 to 10).\n\n**Code Structure (My current thoughts, but feel free to optimize):**\n\n*   I think I need a main `difference()` block to create the head shape. I will have to `hull()` together multiple spheres to get the shape I'm looking for.\n*   Separate modules for each feature type (e.g., `eyes()`, `mouth()`, `nose()`, `hair()`, etc.) for better organization.\n*   A lot of `if` statements inside each feature module to handle the different styles.\n*   I'll likely need to do a bunch of math to position things correctly. I have already started on that, but would appreciate help.\n\n**Libraries:**\n\nI don't think I need to use any external libraries for this. I just need to be careful with the math.\n\nI've attached the .scad file that I've been working on. It is already functional, but I would like a robust code that is clean and well commented.\n\nThanks for your help! I'm really excited to get this working.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Wire Coiler",
    "scad": "cylinderRadius = 15;\nmodule outer() {\n\ttranslate([0, 0, -1]) cylinder(r = cylinderRadius + 3, h = 1);\n\ttranslate([0, 0, 5]) cylinder(r = cylinderRadius + 3, h = 1);\n}\nmodule inner() {\n\tcylinder(r = cylinderRadius, h = 5);\n}\ndifference() {\n\tunion() {\n\t\touter();\n\t\tinner();\n\t}\n\ttranslate([0, 0, -3]) cylinder(r = cylinderRadius - 4, h = 10);\n}",
    "description": "Okay, I'm trying to design a simple wire coiler in OpenSCAD, but I want it to be parametric so I can easily adjust the dimensions. I have a basic design already, and I want to expand upon it.\n\nThe core idea is that the coiler is essentially a cylinder. I want to define the radius of the cylinder as the main parameter. Let's call it `cylinderRadius`.\n\nThe current design has a few parts:\n1.  An \"inner\" cylinder, which is the main body where the wire will go. Its radius is `cylinderRadius` and it's 5 units tall.\n2.  Two \"outer\" rings (or disks) that sit at the top and bottom of the cylinder, slightly wider (radius is `cylinderRadius + 3`) and 1 unit tall. These form the flanges.\n3.  A hole that runs through the center with a radius of `cylinderRadius - 4` and is 10 units tall. This forms the hole that would go on a shaft to hold the coiler steady. It's positioned to make the hole centered and also to make it pass through the flanges.\n\nI'd like to make the following changes:\n*   I want to be able to parameterize the height of the main cylinder body. Let's call it `cylinderHeight`. Currently, this is hardcoded to 5.\n*   I want to be able to parameterize the thickness of the outer rings. Currently, this is hardcoded to 1. Let's call it `ringThickness`.\n*   I want to be able to parameterize the added radius for the outer rings, which is currently hardcoded to 3. Let's call it `ringRadiusOffset`.\n*   I want to parameterize the radius of the hole that runs through the center and the height of the hole. The radius is currently `cylinderRadius - 4`. Let's call this `holeRadius` and the height `holeHeight`.\n*   I want to add a parameter that controls the overall vertical offset of the outer rings relative to the main cylinder. Let's call it `ringVerticalOffset`, where the rings are currently 1 unit above and below the body, with the body having z-position from 0 to `cylinderHeight`.\n\nI would also like to ensure that the code is well commented and easy to understand. Please provide the OpenSCAD code as a result of this request.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Pond Pump Laminar Flow Splitter Adapter",
    "scad": "TubingOD = 6;\nTubingID  = 4;\nPumpHousingHole = 19;\nheight = 40;\nWallThickness = 2;\nhoneycomb_radius = 2;\nfloor_thickness = 0;\nHexMath = PumpHousingHole * .5 / (3 * honeycomb_radius);\nsmooth = 180;\nBase();\ntranslate([0,0,height]) ReducerCone (3);\nlinear_extrude(height=height + PumpHousingHole + 3){hexagon(HexMath*1.2);}\nmodule ReducerCone (count)\n{\n\tdifference()\n\t{\n\t\tfor ( i = [1 : count] )\n\t\t{\n\t\t\trotate(a= i * 360 / count) hull()\n\t\t\t{\n\t\t\t\tcylinder(r=PumpHousingHole * .5, h=.01);\n\t\t \t\ttranslate([0, (PumpHousingHole - TubingOD) * .5 , PumpHousingHole + TubingOD])  cylinder(r=(TubingOD + WallThickness) * .5, h=.01);\n\t\t\t}\n\t\t\trotate(a= i * 360 / count) translate([0, (PumpHousingHole - TubingOD) * .5 , PumpHousingHole + TubingOD])  cylinder(r=(TubingOD + WallThickness) * .5, h=TubingOD);\n\t\t}\n\t\tfor ( i = [1 : count] )\n\t\t{\n\t\t\trotate(a= i * 360 / count) hull()\n\t\t\t{\n\t\t\t\tcylinder(r=(PumpHousingHole - WallThickness) * .5, h=.01);\n\t\t\t \ttranslate([0, (PumpHousingHole - TubingOD) * .5 , PumpHousingHole + TubingOD])  cylinder(r=TubingID * .5, h=.01, $fn=smooth);\n\t\t\t}\n\t\t\trotate(a= i * 360 / count) translate([0, (PumpHousingHole - TubingOD) * .5 , PumpHousingHole + TubingOD])  cylinder(r=(TubingOD) * .5, h=TubingOD, $fn=smooth);\n\t\t}\n\t}\n}\nmodule Base()\n{\n\tdifference()\n\t{\n\t\tcylinder(r=PumpHousingHole * .5, h=height);\n\t\ttranslate([0,0,height - (height * .25)]) cylinder(r1=(PumpHousingHole - WallThickness) * .40, r2=(PumpHousingHole - WallThickness) * .5, h=height * .25);\n\t\tpencil_holder(honeycomb_radius, HexMath, height*2, height*2);\n\t}\n\tpencil_holder(honeycomb_radius, HexMath, height, floor_thickness);\n}\nmodule hexagon(radius){\n\tcircle(r=radius,$fn=6);\n}\nmodule cell(radius, height, floor_thickness){\n\tdifference(){\n\t\tlinear_extrude(height=height){hexagon(radius*1.2);}\n\t\ttranslate([0,0,floor_thickness]) linear_extrude(height=height){hexagon(radius*1.1);}\n\t}\n}\nmodule translate_to_hex(x_coord, y_coord, hex_width){\n\tx = x_coord*hex_width*1.75;\n\ty = (2*y_coord*hex_width)+(x_coord*hex_width);\n\ttranslate([x, y, 0]){\n\t\tchild(0);\n\t}\n}\nmodule rounded_cap(radius, hex_width, height){\n\tdifference(){\n\t\ttranslate([0,0,height]) cylinder(r=3*hex_width*radius,h=height *.75,center=true);\n\t\ttranslate([0,0,height/1.5]) scale([1,1,1/radius]) sphere(r=3*hex_width*radius,center=true);\n\t}\n}\nmodule pencil_holder(radius, hex_width, height, floor_thickness){\n\tdifference(){\n\t\tunion(){\n\t\t\tfor(x = [-radius:radius]){\n\t\t\t\tfor(y = [-radius:radius]){\n\t\t\t\t\tassign(z=0-x-y){\n\t\t\t\t\t\tif(max(abs(x),abs(y),abs(z))<=radius){\n\t\t\t\t\t\t\ttranslate_to_hex(x, y, hex_width) cell(hex_width, height, floor_thickness);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trounded_cap(radius, hex_width, height);\n\t}\n}",
    "description": "Okay, I have this OpenSCAD design for a pond pump splitter, and I'd like to make it more flexible and easier to customize. It's currently set up to split the flow into a fixed number of tubes, but I want to be able to easily change that. Also, I think the base could be made a bit more robust with different mounting options.\n\nHeres what I have now. It uses a honeycomb structure to create laminar flow before splitting the water into smaller hoses, which I want to keep. The current code is attached (`PondPumpSplitterAdapter.scad`).\n\nHere's what I'd like the new parametric design to be able to do:\n\n1.  **Variable Output Count:**  Instead of being hardcoded to 3 output hoses, I want to be able to specify the number of output hoses/tubes through a variable (e.g., `output_count = 4;`). These should be evenly spaced around the circumference.\n\n2.  **Hose/Tubing Parameters:** I need to be able to specify the inner and outer diameter of the tubing we are using (`tubing_outer_diameter = 6;` and `tubing_inner_diameter = 4;`).\n\n3.  **Pump Outlet Diameter:** I need a parameter to define the diameter of the pump outlet/base input (`pump_housing_diameter = 19;`). I want this to be the diameter of the cylindrical portion, not the hole.\n\n4.  **Base Height and Shape:** Instead of a simple cylinder, I'd like to have a parameter for the total base height (`base_height = 40;`) and another that controls the shape of the base from cylindrical to truncated cone.  I'd like to specify the diameter at the top of the base (`base_top_diameter`) to control the truncation.\n\n5.  **Wall Thickness:** I need a parameter for the thickness of the walls throughout the model (`wall_thickness = 2;`). This includes the base, output ports, and the transitions.\n\n6. **Laminar Flow Grid:** The current model uses a honeycomb structure for laminar flow using a radius parameter. I want to keep this feature, but I want to be able to set the radius and cell size independently and change the shape of the base grid. I want to add a type parameter to pick a grid type (e.g. `grid_type=\"hexagon\"` or `\"circle\"`) and a radius parameter (`grid_radius = 2`).  The `grid_cell_size` would specify the size of individual cells.\n\n7.  **Transition Smoothness:** I'd like to control the smoothness of the transition from the large input to the smaller output tubes with a `transition_smoothness` variable. This would control the number of facets of rounding cylinders (like the `smooth` variable in the original file).\n\n8.  **Mounting Options:**  I want to be able to add optional mounting flanges or holes to the base. A `mounting_type` parameter could control this, with values like `\"none\"`, `\"flange\"`, or `\"holes\"`. If \"flange\", we'd add a circular flange around the base with `flange_thickness` and `flange_diameter` parameters. If \"holes\", we'd add a number of mounting holes evenly spaced on the flange.\n\n9. **Support Beam:** I'd like to keep the supporting hexagon beam.  It should use the same grid cell size as the laminar flow generator. I should be able to adjust its height.\n\n10.  **Unit Compatibility**: This design needs to work for metric units (mm). Please ensure all calculations are in metric and any units are declared within the comments.\n\nIdeally, the design should be parametric, meaning all of these options are controlled by variables at the top of the file, which are commented appropriately.\n\nFor libraries, please use the `BOSL2` library, if it makes sense. I'm already familiar with its features.\n\nCould you please generate the OpenSCAD file with these features? Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Magnetic Clip",
    "scad": "use <utils/build_plate.scad>\n_length = 12;\n_width = 12;\n_rounding = 3.0;\n_wallThickness = 1.0;\n_magnetDiameter = 3.18;\n_magnetHeight = 3.0;\n_crushRibDiameter = 0.6;\n_partGap = 0.15;\nmodule roundRect(width, depth, height, round) {\n\tmanifold_hack = 0.0000001;\n\tround = min(round, width/2) + manifold_hack;\n\thull() {\n\t\tfor (w=[-1,1])\n\t\tfor (d=[-1,1])\n\t\ttranslate([w * (width/2 - round),d * (depth/2 - round),0]) {\n\t\t\tcylinder(r=round, h=height, center=true);\n\t\t}\n\t}\n}\nmodule makeClip(length, width, wall, rounding, mdiameter, mheight, partGap, ribDiameter) {\n\tthickness = mdiameter + wall*2;\n\teps = 0.1;\n\twidth = max(width, thickness+eps);\n\trounding = min(rounding, (width - thickness)/2);\n\tolength\t= length + 2*thickness;\n\towidth = width + 2*thickness;\n\toheight = mheight*3 + partGap*2;\n\torounding = rounding + thickness;\n\ttranslate([0,0,oheight/2])\n\tdifference() {\n\t\tunion() {\n\t\t\tdifference() {\n\t\t\t\tunion() {\n\t\t\t\t\tdifference() {\n\t\t\t\t\t\troundRect(olength, owidth, oheight, orounding);\n\t\t\t\t\t\troundRect(length, width, oheight+eps, rounding);\n\t\t\t\t\t\ttranslate([0,-(owidth+eps)/2,0]) {\n\t\t\t\t\t\t\tcube(size=[olength+eps, owidth+eps, oheight+eps], center=true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(s=[-1,1])\n\t\t\t\t\ttranslate([s*(length/2+thickness/2), 0, 0]) {\n\t\t\t\t\t\tcylinder(r=thickness/2, h=oheight, center=true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(s=[-1,1])\n\t\t\t\ttranslate([s*(length/2+thickness/2), 0, 0]) {\n\t\t\t\t\tcylinder(r=mdiameter/2, h=oheight+eps, center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(s=[-1,1])\n\t\t\ttranslate([s*(length/2+thickness/2), mdiameter/2, 0]) {\n\t\t\t\tcylinder(r=ribDiameter/2, h=oheight, center=true);\n\t\t\t}\n\t\t}\n\t\ttranslate([length/2+thickness/2, 0, 0]) {\n\t\t\tcube(size=[thickness+eps, thickness+eps, mheight + partGap*2], center=true);\n\t\t}\n\t\tfor(s=[-1,1])\n\t\ttranslate([-(length/2+thickness/2), 0, s*(mheight+partGap)]) {\n\t\t\tcube(size=[thickness+eps, thickness+eps, mheight + partGap*2], center=true);\n\t\t}\n\t}\n}\nbuild_plate(0);\nmakeClip(_length, _width, _wallThickness, _rounding, _magnetDiameter, _magnetHeight, _partGap, _crushRibDiameter, $fn=90);",
    "description": "Okay, I'm looking to create a parametric magnetic clip for things like closing bags. I'd like to be able to customize the size, magnet placement, and some other details.\n\nHere's what I'm envisioning:\n\n**Core Functionality:**\n\n*   The clip will have two main parts that clamp together using magnets.\n*   There should be a rounded rectangular opening in the center of the clip, this is where the bag opening will fit.\n*   The magnets should be embedded within the arms of the clip.\n*   There should be a small gap between the two arms of the clip where they hinge.\n\n**Parameters I want to control:**\n\n*   `length`: The length of the opening of the clip. This will determine how wide a bag opening it can fit over.\n*   `width`: The width of the opening of the clip. This determines the thickness of the material the clip can close.\n*   `rounding`: The radius of the rounding of the corners of the opening.\n*   `wallThickness`: The thickness of the walls of the clip around the magnets.\n*   `magnetDiameter`: The diameter of the cylindrical magnets to be used.\n*   `magnetHeight`: The height of the cylindrical magnets to be used.\n*   `crushRibDiameter`: The diameter of a small cylindrical rib inside each magnet inset that helps to hold the magnet in place.\n*   `partGap`: The gap between the two halves of the clip where they hinge.\n\n**Specific Design Requirements:**\n\n*   The overall clip will be composed of two mirrored arms that are joined by an integrated hinge structure.\n*   The overall size of the clip should be large enough to accomodate the magnet insets.\n*  The hinge should be formed from semi-circular pieces at the outside of the opening, that are divided by gaps that form a hinge.\n*   The magnet cutouts should be a cylinder that go through the hinge structure.\n*   The ribs should be a cylinder that go through the hinge structure.\n*   The rib should be a little smaller than the diameter of the magnet cutout so that the rib acts as a pressure fit point that holds the magnet.\n* The magnet cutouts and ribs should be concentric.\n* The magnet insets should be symmetrical with respect to the length.\n*   I'd like the ability to render it with a fairly high `$fn`.\n\n**Libraries:**\n\n*   I'll be using the `build_plate` module from a `utils/build_plate.scad` file. I expect you to define that module in the generated code, and not assume it exists elsewhere.\n\nCan you provide me with an OpenSCAD file that incorporates these requirements?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Spiral Generator",
    "scad": "use <utils/build_plate.scad>\n_revolutions = 2.0;\n_diameter = 30;\n_thickness = 2.0;\n_height = 3;\n_gap = 0.3;\n_resolution = 60;\nfunction radiusAt(radius, angle, pitch) = radius - pitch * (angle/360);\nmodule spiral(revolutions, diameter, thickness, height, gap, resolution) {\n\teps = 0.2;\n\tradius = diameter/2;\n\trevolutions = min(revolutions, radius/(thickness+gap)-eps);\n\tpitch = thickness + gap;\n\tangleStep = 360/round(resolution);\n\tunion()\n\tfor (angle = [0:angleStep:360*revolutions-angleStep]) {\n\t\tassign(\tr0 = radiusAt(radius, angle, pitch),\n\t\t\t\t\tr1 = radiusAt(radius, angle+angleStep, pitch),\n\t\t\t\t\tr2 = radiusAt(radius-thickness, angle+angleStep, pitch),\n\t\t\t\t\tr3 = radiusAt(radius-thickness, angle, pitch)\n\t\t\t\t\t) {\n\t\t\tlinear_extrude(height = height, slices=1) {\n\t\t\t\t\tpolygon(\tpoints=[\t[r0*sin(angle),r0*cos(angle)],\n\t\t\t\t\t\t\t\t\t\t\t[r1*sin(angle+angleStep),r1*cos(angle+angleStep)],\n\t\t\t\t\t\t\t\t\t\t\t[r2*sin(angle+angleStep+eps),r2*cos(angle+angleStep+eps)],\n\t\t\t\t\t\t\t\t\t\t\t[r3*sin(angle-eps),r3*cos(angle-eps)] ],\n\t\t\t\t\t\t\t\tpaths=[[0,1,2,3]]);\n\t\t\t}\n\t\t}\n\t}\n}\nbuild_plate(0);\nspiral(_revolutions, _diameter, _thickness, _height, _gap, _resolution);",
    "description": "Okay, I'm looking to create a parametric Archimedean spiral generator in OpenSCAD, and I'd like it to be flexible enough to make things like split rings or just interesting spiral shapes. I've seen some examples online, but I want to be able to control it with parameters.\n\nHere's what I'd like the script to do:\n\n*   **Spiral Shape:** Generate an Archimedean spiral, where the distance between each loop (the pitch) is constant.\n*   **Parameters:**\n    *   `revolutions`: The number of full turns the spiral makes around its center. This should be a floating-point number so I can have partial revolutions.\n    *   `diameter`: The overall diameter of the spiral.\n    *   `thickness`: The thickness of each \"ring\" of the spiral.\n    *   `height`: The height of the spiral (for 3D extrusion).\n    *   `gap`: The space between each adjacent ring of the spiral.\n    *   `resolution`: The number of segments used to create each ring in the spiral, which should affect the smoothness of the curves.\n*   **Functionality:**\n    *   The spiral should be extruded along the height parameter.\n    *   I want to control the number of resolutions around the circle using the `resolution` parameter, and the spiral should be constructed from linear segments, not a curve.\n    *   The script should handle cases where the requested number of revolutions exceeds the physical limits based on the diameter, thickness, and gap, clamping it to a maximum sensible value. I'd prefer to do this clamping in the module, not the parameters themselves, so that the parameters still contain the input value.\n*   **Library Usage:** Please include the `build_plate()` from the `utils` library to provide context for the spiral. (I understand that I'll need to have the `utils` library available to use it.)\n*   **Output:**  The final output should be a single, solid 3D object (a single `union()` of the spiral segments is probably the easiest way to achieve this).\n\nBasically, I'd like a reusable module that I can plug different parameter values into to generate different spiral shapes.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Ellipse Message Band",
    "scad": "include <write/Write.scad>\nmessage = \"Live Laugh Love\";\nFont = \"write/orbitron.dxf\";\nband_a = 60;\nband_b = 45;\nband_width = 20;\nthickness = 4;\nband_radius = band_width/2;\nfont_size = band_width*0.6;\nscale ([1,band_b/band_a,1])\nunion () {\ndifference () {\nrotate_extrude(center = true, $fn=72)\ntranslate ([band_a/2+thickness/2,0,0]) scale ([thickness/band_width,1,1]) circle (r=band_radius);\ntranslate ([0,band_a/2,0]) cube ([band_a/2,band_a/2,band_width+2],center=true);\n}\nwritecylinder(message,[0,0,0],band_a/2+thickness,up=0.5,t=thickness/2,h=font_size,center = true,font = Font);\n}",
    "description": "Okay, I'd like to create a customizable message band, kind of like a bracelet, using OpenSCAD. I've seen some examples, and I'd like it to be elliptical in shape, with a message wrapped around the outside. I have a working example, but I want to make it more parametric and have better control over the text and size.\n\nSpecifically, I want these parameters to be customizable:\n\n*   **`band_a`**: This is the major radius of the ellipse, like the width of the bracelet, measuring the wrist horizontally.\n*   **`band_b`**: This is the minor radius of the ellipse, like the thickness of the bracelet, measuring the wrist vertically.\n*   **`band_width`**:  The overall width (thickness) of the band itself (how much it sticks out from the wrist).\n*   **`thickness`**: The thickness of the band material (how deep the band is).\n*   **`message`**: The text to be displayed around the band.\n*   **`font`**: The font to be used for the message, which should come from the `Write.scad` library included in the code I saw. This library allows specifying fonts from .dxf files (e.g. \"write/orbitron.dxf\").\n*   **`font_size`**:  The height of the letters. This I might specify relative to the band width.\n*   **`$fn`**:  The number of segments for the rotational extrusion, which should affect the smoothness of the band's curve. I'm okay with keeping a default, but I want to be able to change it.\n\nMy example code uses `rotate_extrude` to create the main elliptical band shape, and then uses `writecylinder` from the `Write.scad` library to add the message. I like that approach but I would like the `writecylinder` to have the font size be specified directly without calculating based on the band width (unless the user chooses to do so). The code I was using also had a couple of hardcoded scaling factors I would like replaced with parameters. The way the message sits on the band is fine, but I want to be able to control how far the text sits from the surface of the band (which was not included in my example code).\n\nI'd also like the option to change the alignment of the text if possible, rather than the default center alignment.\n\nI'd really appreciate an OpenSCAD file that encapsulates these parameters and gives me full control over the band's dimensions, the message, the font, and the text placement. The use of the `Write.scad` library is essential for the text functionality so don't remove that. The code should be well documented with clear comments and the variable names should match the description above. I will provide my own copy of `Write.scad` so that is not necessary.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Tray Grid",
    "scad": "height=25;\nwidth=40;\ndepth=30;\nwall=1.5;\nradius=10;\nx=3;\ny=4;\n$fn=200;\ntotal_width = x*width + (x+1)*wall;\ntotal_depth = y*depth + (y+1)*wall;\ncr = min(radius, min(x*width, y*depth) / 2);\necho (\"Total width of object:\", total_width);\necho (\"Total depth of object:\", total_depth);\nmodule rounded_corners() {\n\ttranslate([wall+cr, wall])\n\t\tsquare([total_width-2*wall-2*cr, total_depth-2*wall]);\n\ttranslate([wall, wall+cr])\n\t\tsquare([total_width-2*wall, total_depth-2*wall-2*cr]);\n\tfor(xx = [wall+cr, total_width-wall-cr],\n\t\t\tyy = [wall+cr, total_depth-wall-cr])\n\t\ttranslate([xx, yy])\n\t\t\tcircle(r=cr);\n}\ndifference() {\n\tintersection() {\n\t\tcube([total_width, total_depth, height]);\n\t\ttranslate([0,0,-1]) linear_extrude(height=height+2)\n\t\t\trounded_corners();\n\t}\n\tfor(xx = [0 : x-1], yy = [0 : y-1]) {\n\t\ttranslate([xx*width + (xx+1)*wall, yy*depth + (yy+1)*wall, wall])\n\t\t\tcube([width, depth, height]);\n\t}\n}\nlinear_extrude(height=height) difference() {\n\toffset(wall)\n\t\trounded_corners();\n\trounded_corners();\n}",
    "description": "Okay, I'd like to design a customizable tray grid for organizing small parts. I need an OpenSCAD file that allows me to specify several parameters to control the grid's dimensions and features.\n\nSpecifically, I need to be able to define:\n\n*   **Overall Height:** The total height of the tray grid. This will be a single value for all the trays.\n*   **Tray Width & Depth:** The interior width and depth of each individual tray in the grid. All trays will have the same width and depth.\n*   **Number of Trays (X & Y):** I need to specify how many trays are in the x direction (going across) and how many in the y direction (going down)\n*   **Wall Thickness:** The thickness of the walls surrounding each tray and also the outer walls. All walls are the same thickness.\n*   **Corner Radius:** The radius of the rounded corners on both the inner and outer edges of the entire tray grid. It's important that these are well-defined and consistent.\n*   **Resolution:** The resolution of the curves (or $fn) needs to be settable.\n\nThe final output needs to be a solid object that represents the tray grid with all the features described above. So it should look like a grid of rectangular trays enclosed by an outer wall. The internal pockets should have the dimensions of the \"Tray Width\" and \"Tray Depth\".\n\nI need to be able to adjust all these parameters to generate different size grids. I'd like to have reasonable default values, but all those parameters need to be customizable.\n\nI would like you to use the `offset` command to create the outer wall, that is important for my design. I do not need to use any OpenSCAD libraries for this design, just the built-in functions.\n\nCould you generate that OpenSCAD file for me?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Rocket",
    "scad": "$fn=100*1;\nnumerical_slider_1 =  80;\nnumerical_slider_2 =  6;\nscale_wings=100;\nscale_model=100;\ndifference() {\nunion() {\nscale([scale_model/100,scale_model/100,scale_model/100]) {\ncylinder(h=numerical_slider_1, r=numerical_slider_2);\ntranslate([0,0,numerical_slider_1]) scale([1,1,7]) sphere(numerical_slider_2);\nfor (i = [0:3]){\n\t\trotate([0,0,i*360/4])\n\t\t\ttranslate([0,(0.5*scale_wings)/100,0]) {\n\t\t\t\trotate([90,0,0]) {\n\t\t\t\t\tscale([scale_wings/100,scale_wings/100,scale_wings/100]) {\n\t\t\t\t\t\tlinear_extrude(height=1) {\n\t\t\t\t\t\t\tpolygon(points=[[0,0],[20,0],[0,30]]);\n}\n}\n}\n}\n}\n}\n}\ntranslate([0,0,-100*numerical_slider_2*scale_wings*scale_model]) cylinder(h=100*numerical_slider_2*scale_wings*scale_model, r=100*numerical_slider_2*scale_wings*scale_model);\n}",
    "description": "Okay, I'm trying to make a simple rocket model using OpenSCAD, and I want it to be customizable. I've already got a basic file that kinda works but it's a bit clunky and I think could be done better.\n\nHere's what I'm envisioning and what my current code does:\n\n*   **Basic Shape:** The rocket body is a cylinder with a rounded top (a sphere scaled and translated).\n*   **Fins:** It has four fins equally spaced around the base. The fins are triangular, and their size is adjustable, and they are attached with linear extrusions.\n*   **Dimensions:** I need to control the height and diameter of the main body.\n*   **Scale**: I need to control scaling for the fins and entire model.\n*   **Customization:** I want to adjust all dimensions, scale of the fins, and scale of the model through customizer sliders.\n\nRight now I'm using these variables, as you can see in the provided file:\n\n*   `numerical_slider_1`: This controls the rocket's height. I'd like a range from 60 to 1000.\n*   `numerical_slider_2`: This controls the rocket's diameter (radius). The range should be from 2 to 100.\n*   `scale_wings`: This controls the size of the wings. I want this as a percentage slider ranging from 50 to 3000.\n*   `scale_model`: This is supposed to scale the entire model, but not the fins. I want this as a percentage slider.\n\nThe current code uses `difference()` to remove an extremely large cylinder, just in case something goes wrong, but I think there are more elegant solutions available.\n\nCan you help me write a more parametric OpenSCAD file that has:\n\n*   Clean structure for parameter input.\n*   Adjustable rocket body (height and radius).\n*   Adjustable fins (size, using the existing triangular shape).\n*   Ability to easily scale the fins and entire rocket model.\n*  A cleaner way to ensure the base is trimmed, or remove the base-trimming cylinder.\n\nI am not using any libraries beyond the base OpenSCAD, so no extra libraries are needed.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable cube",
    "scad": "cube_size_width = 20;\ncube_size_length = 20;\ncube_size_height = 10;\nfunction BEZ03(u) = pow((1-u), 3);\ndifference() {\n  union() {\n    translate([0, 0, cube_size/2]) cube([cube_size_width,cube_size_length,cube_size_height], center=true);\n    if (show_wheels == \"yes\") {\n      translate([0, 0, cube_size/2]) rotate([0, 90, 0]) {\n        cylinder(r=cube_size/2, h=cube_size+(wheel_thickness*2), center=true);\n      }\n    }\n  }\n  translate([0, 0, cube_size-hole_depth]) cylinder(r=hole_radius, h=hole_depth);\n}",
    "description": "Okay, I'm looking to create a customizable 3D-printable cube with a few specific features. I've tried doing some simple stuff on my own but I think I need some help getting it all into a single, easy-to-use parametric model.\n\nBasically, I want a cube with adjustable dimensions (width, length, and height), and it needs to have a cylindrical hole going partway through it from the top. I'd like to be able to control the radius and depth of that hole.\n\nAdditionally, I'd like to add optional wheels on either side of the cube. These should be cylinders, and I need to control their thickness as well. I want the ability to turn the wheels on or off with a single parameter.\n\nCould you generate an OpenSCAD file for me that allows me to adjust these parameters? I also want to use the `MCAD/BOSL2` library if that's possible. I've heard it helps with making parametric designs easier to maintain and understand. I would prefer if it was all in a single file, please.\n\nSpecifically, here are the parameters I want to control:\n\n*   `cube_width`: The width of the cube.\n*   `cube_length`: The length of the cube.\n*   `cube_height`: The height of the cube.\n*   `hole_radius`: The radius of the cylindrical hole.\n*   `hole_depth`: The depth of the cylindrical hole.\n*   `wheel_thickness`: The thickness of the wheels (if they're enabled).\n*   `show_wheels`: A boolean (or similar) parameter to turn the wheels on or off. I would like to be able to use \"yes\" and \"no\" to control it.\n"
  },
  {
    "object": "Hey cadmonkey, make me a The Duck Clip",
    "scad": "fc_filament=3;\nfc_spool=2;\nfc_rim=0;\nfc_length=10;\nfc_width=3;\nfc_thickness=2;\ndifference()\n\t{\n\t\tunion()\n\t\t\t{\n\t\t\t\tcube([fc_thickness, fc_length, fc_width]);\n\t\t\t\ttranslate([fc_thickness+fc_rim+fc_spool+1, 0, 0])\n\t\t\t\tcube([fc_thickness, fc_length, fc_width]);\n\t\t\t\ttranslate([fc_thickness+(fc_rim+fc_spool+1)/2, fc_length,0])\n\t\t\t\tcylinder(r=fc_thickness+(fc_rim+fc_spool+1)/2, h=fc_width, $fn=24);\n\t\t\t\tdifference()\n\t\t\t\t\t{\n\t\t\t\t\t\ttranslate([fc_thickness,0.5+fc_rim/2+fc_spool*0.05,0])\n\t\t\t\t\t\tcylinder(r=0.5+fc_rim/2+fc_spool*0.05,h=fc_width, $fn=24);\n\t\t\t\t\t\ttranslate([fc_thickness-(0.5+fc_rim/2+fc_spool*0.05+1),0,-1])\n\t\t\t\t\t\tcube([0.5+fc_rim/2+fc_spool*0.05+1,(0.5+fc_rim/2+fc_spool*0.05)*2,fc_width+2]);\n\t\t\t\t\t}\n\t\t\t\tdifference()\n\t\t\t\t\t{\n\t\t\t\t\t\ttranslate([fc_thickness+fc_rim+fc_spool+1,0.5+fc_rim/2+fc_spool*0.05,0])\n\t\t\t\t\t\tcylinder(r=0.5+fc_rim/2+fc_spool*0.05,h=fc_width, $fn=24);\n\t\t\t\t\t\ttranslate([fc_thickness+fc_rim+fc_spool+1,0,-1])\n\t\t\t\t\t\tcube([0.5+fc_rim/2+fc_spool*0.05+1,(0.5+fc_rim/2+fc_spool*0.05)*2,fc_width+2]);\n\t\t\t\t\t}\n\t\t\t\ttranslate([-fc_filament*1.5,fc_length-(fc_filament+2),0])\n\t\t\t\tcube([fc_filament*1.5,fc_filament+2,fc_width]);\n\t\t\t}\n\t\ttranslate([fc_thickness+(fc_rim+fc_spool+1)/2, fc_length,-1])\n\t\tcylinder(r=(fc_rim+fc_spool+1)/2, h=fc_width+2, $fn=24);\n\t\ttranslate([fc_thickness,fc_length-(fc_thickness+(fc_rim+fc_spool+1)/2),-1])\n\t\tcube([fc_rim+fc_spool+1, fc_thickness+(fc_rim+fc_spool+1)/2, fc_width+2]);\n\t\ttranslate([-fc_filament/2,fc_length-fc_filament/2-1,-1])\n\t\tcylinder(r=fc_filament/2, h=fc_width+2, $fn=24);\n\t\ttranslate([-fc_filament*1.5-1,fc_length-fc_filament*0.75-1,-1])\n\t\tcube([fc_filament+1,fc_filament*0.75,fc_width+2]);\n\t}",
    "description": "Okay, I need a custom filament clip designed in OpenSCAD. I'm tired of the generic ones that never quite fit my spools and filament correctly. \n\nHere's what I'm looking for:\n\nThe clip should have two \"arms\" that extend out and then curve around to clip onto the spool. It also needs a little area that grips the filament to keep it from unraveling. The design should be fully parametric so I can easily adjust it for different filament diameters, spool thicknesses (with or without a rim!), and even the length and width of the clip itself.\n\nSpecifically, the parameters I'd like to control are:\n\n*   **Filament Diameter:** The diameter of the filament being used.\n*   **Spool Thickness:** The thickness of the spool itself, not including any rim.\n*   **Spool Rim Thickness:** The thickness or height of any rim that sticks out from the edge of the spool (if any). If there's no rim, this can be zero.\n*   **Arm Length:** How long the straight \"arms\" of the clip should be.\n*   **Clip Width:** The width of the clip (the dimension along the spool axis).\n*   **Clip Thickness:** How thick the clip is (the dimension perpendicular to both the spool and the arms).\n\nThe clip should look something like this (imagine a simplified drawing here): \n\n*   Two rectangular arms coming off the base of the cylinder.\n*   These arms transition into a curved part that wraps around the spool edge. This part should hug the spool tightly.\n*   On one side (preferably the one opposite the spool edge), there's a little cube-shaped feature extending out with a small cylindrical cutout in it to grip the filament.\n\nAlso, the part that grips the filament should not extend below the bottom of the clip, so it sits flat on a surface. \n\nI don't need it to be super fancy but I do need it to work well.\n\nI think this could be done with simple OpenSCAD primitives and unions, differences, and translations. I don't think I need to use any special libraries, but if you have a standard one that does all of the standard primitives in a cleaner format, like dotSCAD, that would be great.\n"
  },
  {
    "object": "Hey cadmonkey, make me a CustomTasse / Cup v.02",
    "scad": "tasseH = 90;\ntasseR = 25;\ntasseWand = 3;\nhenkelType = 2;\nhenkelR = 15;\nhenkelDicke = 4;\nhenkelPosition = 90;\nmodule henkelA(henkelPos)\n{\n\ttranslate([tasseR+henkelR-10,0,henkelPos])\n\trotate([90,0,0])\n\trotate_extrude(convexity = 10, $fn = 360)\n\ttranslate([henkelR, 0, 0])\n\tcircle(henkelDicke);\n}\nmodule henkelB(henkelPos)\n{\n\ttranslate([tasseR+henkelR,0,henkelPos])\n\trotate([-90,90,0])\n\tlinear_extrude(height = henkelDicke){\n\tdifference() {\n\t\tunion(){\n\t\t\tcircle(henkelR, $fn = 360);\n\t\t\ttranslate([0, henkelR , 0]) square([henkelR*2, henkelR*2], center=true);\n\t\t}\n\t\tcircle(henkelR-henkelDicke, $fn = 360);\n\t}\n\t};\n}\nmodule henkel()\n{\n\tpos = ((tasseH-henkelR*2)*henkelPosition/100)+henkelR;\n\tif (henkelType==1) henkelA(pos);\n\tif (henkelType==2) henkelB(pos);\n}\nmodule tasse()\n{\n\tdifference() {\n\t\tunion() {\n\t\tcylinder(h = tasseH, r = tasseR, $fn = 360);\n\t\thenkel();\n\t\t}\n\t\ttranslate([0,0,tasseWand])\n\t\tcylinder(h = tasseH+tasseWand, r = tasseR-tasseWand, $fn = 360);\n\t}\n}\ntasse();",
    "description": "Okay, I'm looking to design a customizable cup, or \"tasse,\" in OpenSCAD, and I'd like your help writing the code. \n\nHere's what I have in mind:\n\n**Basic Cup:**\n\n*   The cup should be cylindrical.\n*   I need to be able to control the overall `tasseH` height and `tasseR` radius.\n*   I also need to be able to set the `tasseWand` wall thickness.\n\n**Handle Options:**\n\n*   I want two different handle types, `henkelType`. \n    *   `henkelType = 1` should produce a more rounded handle, sort of like an extrusion of a circle.\n\t*\t`henkelType = 2` should produce a flatter handle, somewhat like a rounded rectangle with a hole in the middle.\n*   For both handle types, I need to control:\n    *   The `henkelR` radius of the handle (or the main curved section of it).\n    *   The `henkelDicke` thickness (how much it protrudes from the cup's wall).\n*   I need to be able to position the handle vertically on the cup using a `henkelPosition` percentage value (0 to 100), where 0 puts the base of the handle at the bottom of the cup and 100 puts it at the top. This will determine the overall position of the handle along the height of the cup.\n\nEssentially, I'd like to be able to modify the `tasseH`, `tasseR`, `tasseWand`, `henkelType`, `henkelR`, `henkelDicke`, and `henkelPosition` variables as parameters.\n\nI don't need anything complex in terms of the libraries. Just standard OpenSCAD functionality should be fine.\n"
  },
  {
    "object": "Hey cadmonkey, make me a ScissorLiftLeg",
    "scad": "legLength = 80;\nwidth = 12;\nthickness = 5;\npivotDiameter = 6;\nholes = 4;\nholeDiameter = 4;\nholeOffset = 2;\nspaceBetweenPrints = 3;\nprintCount = 1;\nholeStart   = legLength/2 + pivotDiamater;\nmodule scissorLiftLeg() {\n\tdifference() {\n\t\thull() {\n\t\t\ttranslate([(legLength/2),0,0]) cylinder(r=width/2,h=thickness);\n\t\t\ttranslate([(legLength/-2),0,0]) cylinder(r=width/2,h=thickness);\n\t\t}\n\t\tfor (i=[0:holes-1]) {\n\t\t\ttranslate([legLength/2 - legLength/2/(holes+1)*i - pivotDiameter - holeDiameter/2,0,0])\n\t\t\t\tcylinder(r=holeDiameter/2, h=thickness);\n\t\t\ttranslate([-legLength/2 + legLength/2/(holes+1)*i + pivotDiameter + holeOffset,0,0])\n\t\t\t\tcylinder(r=holeDiameter/2, h=thickness);\n\t\t}\n\t\ttranslate([legLength/2,0,0])\n\t\t\tcylinder(r=pivotDiameter/2, h=thickness);\n\t\ttranslate([-legLength/2,0,0])\n\t\t\tcylinder(r=pivotDiameter/2, h=thickness);\n\t\tcylinder(r=pivotDiameter/2, h=thickness);\n\t}\n}\noffsetPerPrint = width+spaceBetweenPrints;\nfor ( i = [0 : printCount/2] ) {\n\ttranslate([0, i*offsetPerPrint, 0])\n\t\tscissorLiftLeg();\n\tif (i*2 < printCount) {\n\ttranslate([0, -i*offsetPerPrint, 0])\n\t\tscissorLiftLeg();\n\t}\n}\nscissorLiftLeg();",
    "description": "Okay, I have a design I'm trying to make in OpenSCAD, and I need some help making it more flexible. I'm building a leg for a scissor lift mechanism, and I want it to be parametric so I can easily change its dimensions and the number of intermediate pivot points.\n\nRight now, I have a basic leg that's essentially a rectangular bar with holes. There are larger pivot holes at each end and in the middle, and then smaller holes evenly spaced in between. I've hardcoded a bunch of these parameters, and I'm having to fiddle with some of them to get it to print right.\n\nHere's a breakdown of what I need:\n\n*   **Overall Leg Length:** I want to be able to set the total length of the leg.\n*   **Bar Width & Thickness:** I need to define the width and thickness of the rectangular bar itself.\n*   **Pivot Hole Diameter:** The larger diameter of the holes at the ends and center of the leg.\n*   **Number of Intermediate Holes:**  The number of smaller holes between the pivot points.\n*   **Intermediate Hole Diameter:** The diameter of those smaller holes.\n*  **Hole Offset**: I have an issue where the intermediate holes need to be slightly offset from their calculated position for them to function, it would be nice to be able to adjust that.\n*   **Printing Spacing**: I want to make it easy to print multiple of these and have a spacing between them for easy removal from the printbed.\n*   **Print Count**: I want to be able to specify how many legs I want to print at once.\n\nI'd like the code to automatically calculate the positions of all the holes based on the total leg length and the number of intermediate holes. It would be great if the code was clear and easy to modify.\n\nI would like to avoid the `hull()` operation if possible, as it can have some unexpected results.\n\nIm also printing multiple of these, I have the ability to print a number of them side-by-side in rows. I'd like the script to automatically space them out in a row and print a certain number of legs.\n\nIdeally, the output would use the BOSL2 library, if that makes sense, for some of its more advanced functions such as creating the holes, or for moving the objects. I'd really like to have a modular design, if possible.\n\nCan you help me generate a parametric OpenSCAD file for this? Im including my current code as reference.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Magnetic Hinge Box",
    "scad": "use <utils/build_plate.scad>\n_part = \"box\";\n_width = 36;\n_length = 36;\n_height = 12;\n_rounding = 4;\n_minimumWallThickness = 0.8;\n_sidewallThickness = 0.8;\n_horizontalThickness = 0.8;\n_magnetDiameter = 3.2;\n_magnetHeight = 3.2;\n_hingeGap = 0.2;\nmodule roundRect(width, depth, height, round) {\n\tround = min(round, width/2);\n\thull() {\n\t\tfor (w=[-1,1])\n\t\tfor (d=[-1,1])\n\t\ttranslate([w * (width/2 - round),d * (depth/2 - round),0]) {\n\t\t\tcylinder(r=round, h=height, center=true);\n\t\t}\n\t}\n}\nmodule makeBase(width, depth, height, rounding, minimum, side, bottom, mdiameter, mheight, gap) {\n\teps = 0.1;\n\tiwidth = width - side*2;\n\tidepth = depth - mdiameter*2 - minimum*4;\n\thingeCutZ = mdiameter + minimum*2 + gap;\n\thingeCutWidth = width - rounding*2 - mheight*2;\n\tfillet = mdiameter/2 + minimum;\n\tdifference() {\n\t\ttranslate([0,0,height/2]) {\n\t\t\tdifference() {\n\t\t\t\troundRect(width, depth, height, rounding);\n\t\t\t\ttranslate([0,0,bottom]) {\n\t\t\t\t\troundRect(iwidth, idepth, height, rounding-side);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate([0,0,height - hingeCutZ/2 + eps/2]) {\n\t\t\tcube(size=[hingeCutWidth, depth+eps, hingeCutZ + eps], center=true);\n\t\t}\n\t\tfor (y=[-1,1]) {\n\t\t\ttranslate([0,y*(depth/2 - fillet/2),height - fillet/2]) {\n\t\t\t\tdifference() {\n\t\t\t\t\tcube(size=[width+eps, fillet+eps, fillet+eps], center=true);\n\t\t\t\t\ttranslate([0,y*-fillet/2,-fillet/2])\n\t\t\t\t\trotate([0,90,0]) {\n\t\t\t\t\t\tcylinder(r=fillet, h=width + eps*2, center=true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (x=[-1,1])\n\t\tfor (y=[-1,1]) {\n\t\t\ttranslate([x * (hingeCutWidth/2 + mheight/2 - eps/2), y*(depth/2 - minimum - mdiameter/2), height - minimum - mdiameter/2])\n\t\t\trotate([0,90,0])\n\t\t\tcylinder(r=mdiameter/2, h=mheight+eps, center=true, $fn=30);\n\t\t}\n\t}\n}\nmodule makeLid(width, depth, rounding, minimum, side, bottom, mdiameter, mheight, gap) {\n\teps = 0.1;\n\thingeWidth = width - rounding*2 - mheight*2 - gap*2;\n\thingeSize = mdiameter + minimum*2;\n\tdifference() {\n\t\tunion() {\n\t\t\ttranslate([0,0,bottom/2]) {\n\t\t\t\troundRect(width, depth, bottom, rounding);\n\t\t\t}\n\t\t\tfor (s=[-1,1]) {\n\t\t\t\ttranslate([0,s*(depth/2 - hingeSize/2),bottom + hingeSize/2]) {\n\t\t\t\t\thull() {\n\t\t\t\t\t\trotate([0,90,0]) {\n\t\t\t\t\t\t\tcylinder(r=hingeSize/2, h=hingeWidth,center=true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttranslate([0,s*-hingeSize/4,0]) {\n\t\t\t\t\t\t\tcube(size=[hingeWidth, hingeSize/2, hingeSize], center=true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttranslate([0,0,-hingeSize/4-eps]) {\n\t\t\t\t\t\t\tcube(size=[hingeWidth, hingeSize, hingeSize/2], center=true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (x=[-1,1])\n\t\tfor (y=[-1,1]) {\n\t\t\ttranslate([x * (hingeWidth/2 - mheight/2 + eps/2), y*(depth/2 - minimum - mdiameter/2), mdiameter/2 + bottom + minimum])\n\t\t\trotate([0,90,0])\n\t\t\tcylinder(r=mdiameter/2, h=mheight+eps, center=true, $fn=30);\n\t\t}\n\t}\n}\nmodule make($fn=60) {\n\teps = 0.1;\n\trounding = max(_rounding, _sidewallThickness + eps);\n\theight = max(_height, _horizontalThickness + _magnetDiameter + _minimumWallThickness*2 + _hingeGap);\n\tif (_part == \"box\") {\n\t\tmakeBase(_width, _length, height, rounding,\n\t\t\t\t\t_minimumWallThickness, _sidewallThickness, _horizontalThickness,\n\t\t\t\t\t_magnetDiameter, _magnetHeight, _hingeGap);\n\t} else if (_part == \"lid\") {\n\t\tmakeLid(_width, _length, rounding,\n\t\t\t\t\t_minimumWallThickness, _sidewallThickness, _horizontalThickness,\n\t\t\t\t\t_magnetDiameter, _magnetHeight, _hingeGap);\n\t}\n}\nbuild_plate(0);\nmake();",
    "description": "Okay, I'm looking for a design for a customizable box with magnetic hinges and a magnetic closure. I've seen some examples online, and I like the idea of using cylindrical magnets for both the hinge mechanism and to keep the box closed.\n\nI need an OpenSCAD file that will let me adjust the following:\n\n*   **Overall Dimensions:** I need to be able to set the width, length, and height of the box.\n*   **Corner Rounding:** I want to be able to specify a radius for rounding the corners of the box.\n*   **Wall Thicknesses:** I need to control the minimum wall thickness around the magnets, the thickness of the side walls (not the hinge area), and the thickness of the top/bottom.\n*   **Magnet Dimensions:** I should be able to set the diameter and height of the magnets I will be using.\n*   **Hinge Gap:** I need to be able to adjust the small gap between the box and lid where the hinge connects. This is important for fit.\n*   **Part Generation:** I need to be able to choose whether I want to generate just the box or just the lid.\n\nThe magnets will be inserted into matching circular cutouts, so the design needs to include the corresponding recesses for the magnets in both the lid and box parts of the hinge. The magnets in the lid and box will need to align correctly to form the hinge. Also, the magnets that hold the lid closed will need to be aligned as well when the lid is closed. The hinges should use 2 magnets each. I'd prefer to have the option to only generate the box or the lid so I can print them separately.\n\nThe general style should be relatively simple, like a rounded rectangular prism, with the magnetic hinges located on one of the longer sides.\n\nI'm using OpenSCAD, and I do want to use the `build_plate` module from the `utils` library.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Whiteboard marker tray (parametric)",
    "scad": "wall_thickness = 2;\ntray_height = 7;\ntray_width = 15;\nclip_height = 11;\nclip_width = 7;\nholder_length = 100;\nmodule marker_holder() {\n  union() {\n    difference() {\n      cube([tray_width + 2 * wall_thickness, tray_height, holder_length]);\n      translate([wall_thickness, -wall_thickness, -wall_thickness / 2]) {\n        cube([tray_width, tray_height, holder_length + wall_thickness]);\n      }\n    }\n    translate([0, 5, 0]) {\n      difference() {\n        cube([clip_width + 2 * wall_thickness, clip_height, holder_length]);\n        translate([wall_thickness, wall_thickness, -wall_thickness / 2]) {\n          cube([clip_width, clip_height, holder_length + wall_thickness]);\n        }\n      }\n    }\n  }\n}\nmarker_holder();",
    "description": "Okay, I need a marker holder designed for whiteboards, and I want it to be easily customizable.\n\nHeres the idea: Id like a tray that sits on the top edge of a whiteboard, with a lip on the back that hooks over the top. I need to be able to adjust the dimensions of the tray, the height of the lip, and the thickness of the material, basically everything.  \n\nHeres a more detailed breakdown of what I need:\n\n**Basic Structure:**\n\n*   The main body should be a rectangular tray shape, created by subtracting a smaller rectangular solid from a larger one, leaving a hollow tray with walls.\n*   The back of the tray should have a clip that also hooks over the whiteboard, so it's secure and wont fall off. This clip should also be created by a difference between two rectangular solids.\n\n**Parameters (that should be customizable):**\n\n*   **`wall_thickness`**: Thickness of the tray walls and the clip. This is the thickness of the plastic itself.\n*   **`tray_height`**: The height of the tray's main body, including the base.\n*   **`tray_width`**: The width of the inside of the tray, where the markers sit.\n*   **`clip_height`**: The overall height of the back clip.\n*    **`clip_depth`**: The distance that the back lip projects out from the back of the tray.\n*   **`clip_width`**: The width of the clip. This determines how far across the board's edge the lip should project.\n*   **`holder_length`**: The overall length of the tray.\n\n**Key Customizations:**\n\n*   I need all dimensions above to be easily adjusted using variables within the SCAD file. This is important as different whiteboards will have different thicknesses and heights on their top edges. I need to change the overall length, width and depth of the tray, as well as how deep the clip goes over the board.\n* The clip should be able to be a different height and depth from the tray.\n* It should use standard OpenSCAD functions (cube, translate, difference, union).\n\nCould you please generate an OpenSCAD file with these features? I would like it to be as easy to modify as possible for different sizes of whiteboards, so the more variables the better.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Phone Wall Mount",
    "scad": "backplateHeight = 60;\nbackplateWidth = 60;\nfrontPlateHeight = 20;\nphoneThickness = 9;\nmodule plate(){\n\tcube([backplateWidth, backplateHeight, 5]);\n\ttranslate([-3, -3, 5 + phoneThickness]) cube([backplateWidth + 6, frontPlateHeight + 3, 3]);\n\ttranslate([-3, -3, 0]) cube([backplateWidth + 6, 3, phoneThickness + 5]);\n\ttranslate([backplateWidth, 0, 0]) cube([3, backplateHeight, 14]);\n\ttranslate([-3, 0, 0]) cube([3, backplateHeight, 14]);\n}\ndifference() {\n\tplate();\n\ttranslate([(backplateWidth/4), 30, -2]) cylinder(r = 2.5, h = 12);\n\ttranslate([3*(backplateWidth/4), 30, -2]) cylinder(r = 2.5, h = 12);\n\ttranslate([(backplateWidth/4), 30, 4]) cylinder(r = 4, h = 2);\n\ttranslate([3*(backplateWidth/4), 30, 4]) cylinder(r = 4, h = 2);\n}",
    "description": "Okay, I need a parametric OpenSCAD design for a wall mount that will hold a phone. I've got some basic ideas already, but I'd like to make it adjustable for different phone sizes.\n\nHere's what I'm envisioning:\n\n**Core Structure:** The mount will have a backplate that mounts to the wall and a front plate that the phone rests against. The front plate should have some raised edges to keep the phone from sliding off. The phone should sit flush with the backplate.\n\n**Key Dimensions & Parameters:**\n\n*   **`backplateHeight`**: The vertical height of the backplate (the part that goes on the wall). I'm currently using 60mm, but I want this to be adjustable.\n*   **`backplateWidth`**: The horizontal width of the backplate (excluding side supports). Currently 60mm and also needs to be adjustable.\n*   **`frontPlateHeight`**: The height of the raised edges on the front plate. I'm using 20mm, but I'd like to adjust it.\n*   **`phoneThickness`**: The thickness of the phone that the mount should accommodate.  My phone is 9mm thick, and this is a very important dimension to parameterize.\n*   **`mountThickness`**: The thickness of the back plate. Currently 5mm.\n*  **`frontPlateThickness`**: The thickness of the front plate. Currently 3mm.\n*  **`sideThickness`**: The thickness of the two supports that come from the back plate up to the front plate. Currently 14mm.\n*  **`baseThickness`**: The thickness of the base on which the phone sits that is connected to the backplate. Currently `phoneThickness + 5`.\n*  **`baseHeight`**: The height of the base on which the phone sits that is connected to the backplate. Currently 3mm.\n\n**Other Considerations:**\n\n*   **Screw Holes:** I need two screw holes in the backplate for mounting, positioned symmetrically. I'm using the parameters of the 2 holes: `holeRadius` and `holeDistance`. Currently r = 2.5, h=12 and located at `backplateWidth/4` and `3*(backplateWidth/4)`.\n*   **Countersinking**: I also need these holes to be countersunk for flat head screws, with a `countersinkRadius` and `countersinkHeight`. Currently r=4, h=2.\n*   **Side Supports**: The mount has some side supports to add strength, their dimensions are determined based on the `sideThickness`\n\n**Specific Needs:**\n*   I'd like a module that takes all of these parameters as inputs.\n*   The screw hole placement should scale with the backplate width, such that they remain evenly spaced.\n\n**Library:** I'm not using any external libraries in the base design.\n\nCould you generate the OpenSCAD code for this parametric phone wall mount?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Magnetic Jars",
    "scad": "use <utils/build_plate.scad>\nuse <write/Write.scad>\n_part = \"jar\";\n_containerSize = 24;\n_height = 24;\n_tilt = 20;\n_minimumWallThickness = 1.0;\n_horizontalWallThickness = 1.0;\n_rounding = 7;\n_lipHeight = 3.0;\n_bayonetDepth = 0.5;\n_partGap = 0.1;\n_magnetDiameter = 0;\n_magnetHeight = 3.1;\n_magnetPlacement = 0.75;\n_lidHoleDiameter = 2;\n_numberOfLidHoles = 0;\n_labelText = \"\";\n_labelFont = \"write/orbitron.dxf\";\n_labelDepth = -0.3;\n_labelHeight = 5;\nbuild_plate(0);\nmake();\nmodule make($fn=120) {\n\tbayonetAngle = 30;\n\tlidHeight = _lipHeight + _horizontalWallThickness + 0.3;\n\tif (_part == \"jar\") {\n\t\tmakeBase( _tilt, _containerSize, _height,\n\t\t\t\t\t_minimumWallThickness, _horizontalWallThickness,\n\t\t\t\t\t_lipHeight, _bayonetDepth, bayonetAngle, _partGap, _rounding,\n\t\t\t\t\t_magnetDiameter, _magnetHeight, _magnetPlacement,\n\t\t\t\t\t_labelText, _labelFont, _labelHeight, _labelDepth);\n\t} else if (_part == \"lid\") {\n\t\tmakeLid(\t_containerSize, lidHeight,\n\t\t\t\t\t_minimumWallThickness, _horizontalWallThickness,\n\t\t\t\t\t_lipHeight, _bayonetDepth, bayonetAngle,\n\t\t\t\t\t_rounding, _numberOfLidHoles, _lidHoleDiameter,\n\t\t\t\t\t_labelText, _labelFont, _labelHeight, _labelDepth);\n\t}\n}\nmodule smallArc(radius0, radius1, angle, depth) {\n\tthickness = radius1 - radius0;\n\teps = 0.01;\n\tunion() {\n\t\tdifference() {\n\t\t\tcylinder(r=radius1, h=depth, center=true);\n\t\t\tcylinder(r=radius0, h=depth+2*eps, center=true);\n\t\t\tfor(z=[0, 180 - angle]) {\n\t\t\t\trotate([0,0,z])\n\t\t\t\ttranslate([-radius1,0,0])\n\t\t\t\tcube(size = [radius1*2, radius1*2, depth+eps], center=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule polyCylinder(sides, radius, height, rounding) {\n\tangle = 360/sides;\n\thull() {\n\t\tfor (a=[0:angle:360])\n\t\trotate([0,0,a])\n\t\ttranslate([0,(radius - rounding)/cos(angle/2),0]) {\n\t\t\tcylinder(r=rounding, h=height);\n\t\t}\n\t}\n}\nmodule thread(r1, r2, angle, height, yoffset, rotation, chamfer=0, r3=0, r4=0) {\n\t\tfor(a=[0:90:360])\n\t\trotate([0,0,a + rotation])\n\t\ttranslate([0,0,yoffset]) {\n\t\t\thull() {\n\t\t\t\tsmallArc(r1, r2, angle, height);\n\t\t\t\tif (chamfer != 0) {\n\t\t\t\t\ttranslate([0,0,chamfer]) {\n\t\t\t\t\t\tsmallArc(r3, r4, angle, height);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\nmodule makeBase(rotation, diameter, height, wall, base, lipHeight, bayonetDepth, bayonetAngle, partGap, rounding, mdiameter, mheight, mplacement, labelText, labelFont, labelHeight, labelDepth) {\n\theight = max(max(height, base+lipHeight), diameter*tan(rotation));\n\trounding = min(rounding, diameter/2);\n\tradius = diameter/2;\n\tinnerRadius = radius - wall*2 - bayonetDepth - partGap;\n\tfullHeight = height + lipHeight;\n\tchamfer = bayonetDepth;\n\tbayonetHeight = (lipHeight-chamfer)/2;\n\teps = 0.05;\n\tmradius=mdiameter/2;\n\tdifference() {\n\t\tunion() {\n\t\t\tdifference() {\n\t\t\t\trotate([rotation,0,0])\n\t\t\t\ttranslate([0,0,-radius * tan(rotation)]) {\n\t\t\t\t\tdifference() {\n\t\t\t\t\t\tunion() {\n\t\t\t\t\t\t\tdifference() {\n\t\t\t\t\t\t\t\trotate([0,0,45])\n\t\t\t\t\t\t\t\tunion() {\n\t\t\t\t\t\t\t\t\tpolyCylinder(4, radius, height, rounding);\n\t\t\t\t\t\t\t\t\ttranslate([0,0,rounding+eps]) {\n\t\t\t\t\t\t\t\t\t\tcylinder(r=innerRadius+wall, h=fullHeight-rounding-eps);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\trotate([0,0,15])\n\t\t\t\t\t\t\t\t\tthread(innerRadius+wall-eps, innerRadius+wall+bayonetDepth,\n\t\t\t\t\t\t\t\t\t\t\tbayonetAngle, bayonetHeight, fullHeight - bayonetHeight/2, 0,\n\t\t\t\t\t\t\t\t\t\t\t-chamfer, innerRadius, innerRadius+wall);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttranslate([0,0,-eps]) {\n\t\t\t\t\t\t\t\t\tcylinder(r=innerRadius, h=fullHeight*2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (labelDepth > 0)\n\t\t\t\t\t\t\t\tlabel(labelText, labelFont, labelHeight, labelDepth, radius, height);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (labelDepth < 0)\n\t\t\t\t\t\t\tlabel(labelText, labelFont, labelHeight, labelDepth, radius, height);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttranslate([0,0,-diameter/cos(rotation)]) {\n\t\t\t\t\tcube(size=diameter/cos(rotation)*2, center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t\thull() {\n\t\t\t\ttranslate([0,0,eps/2]) {\n\t\t\t\t\troundRect(2*innerRadius+eps, 2*innerRadius/cos(rotation), eps, rounding);\n\t\t\t\t}\n\t\t\t\ttranslate([0,-base*tan(rotation),base-eps/2]) {\n\t\t\t\t\troundRect(2*innerRadius+eps, 2*innerRadius/cos(rotation), eps, rounding);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mradius > 0 && mheight > 0) {\n\t\t\t\tmagnetCylinders(innerRadius, rotation, mradius+wall, mheight+wall, mplacement);\n\t\t\t}\n\t\t}\n\t\tif (mradius > 0 && mheight > 0) {\n\t\t\tmagnetCylinders(innerRadius, rotation, mradius, mheight, mplacement, eps);\n\t\t}\n\t}\n}\nmodule roundRect(width, depth, height, round) {\n\tround = min(round, width/2);\n\thull() {\n\t\tfor (w=[-1,1])\n\t\tfor (d=[-1,1])\n\t\ttranslate([w * (width/2 - round),d * (depth/2 - round),0]) {\n\t\t\tcylinder(r=round, h=height, center=true);\n\t\t}\n\t}\n}\nmodule label(labelText, labelFont, labelHeight, labelDepth, offset, height) {\n\teps = 0.1;\n\tdepthy = offset + labelDepth/2;\n\tif (labelDepth != 0 && labelText != \"\") {\n\t\ttranslate([0,labelDepth > 0 ?  depthy - eps : depthy + eps, height/2])\n\t\trotate([90,90,180]) {\n\t\t\twrite(labelText, t=abs(labelDepth)+eps, h=labelHeight, font=labelFont, space=1.1, center=true);\n\t\t}\n\t}\n}\nmodule magnetCylinders(radius, rotation, mradius, mheight, distance, offset = 0) {\n\tif (mradius > 0 && mheight > 0) {\n\t\tfor (x=[-1,1])\n\t\tfor (y=[-1,1])\n\t\ttranslate([x * radius * distance, y * radius/cos(rotation) * distance, -offset]) {\n\t\t\tcylinder(r=mradius, h=mheight + offset);\n\t\t}\n\t}\n}\nmodule makeLid(diameter, height, wall, base, lipHeight, bayonetDepth, bayonetAngle, rounding, numHoles, holeDiameter, labelText, labelFont, labelHeight, labelDepth) {\n\tstyle = \"round\";\n\theight = max(height, base+lipHeight);\n\tbayonetAngle = bayonetAngle+3;\n\tradius = diameter/2;\n\tinnerRadius = radius - wall - bayonetDepth;\n\tchamfer = bayonetDepth;\n\tbayonetHeight = (lipHeight-chamfer)/2;\n\ttwistAngle = 45;\n\tevenHoles = numHoles - numHoles%2;\n\teps = 0.1;\n\trotate([0,0,45])\n\tunion() {\n\t\tdifference() {\n\t\t\tpolyCylinder(4, radius, height, rounding);\n\t\t\ttranslate([0,0,base]) {\n\t\t\t\tcylinder(r=innerRadius, h=height+eps);\n\t\t\t}\n\t\t\trotate([0,0,-15]) {\n\t\t\t\tthread(innerRadius-eps, innerRadius+bayonetDepth,\n\t\t\t\t\t\tbayonetAngle, lipHeight + eps, height - lipHeight/2 + eps/2, twistAngle + bayonetAngle);\n\t\t\t\tthread(innerRadius-eps, innerRadius+bayonetDepth,\n\t\t\t\t\t\tbayonetAngle+twistAngle, bayonetHeight + eps, height - (lipHeight - bayonetHeight/2) + eps/2,\n\t\t\t\t\t\ttwistAngle + bayonetAngle,\n\t\t\t\t\t\tchamfer, innerRadius-eps, innerRadius);\n\t\t\t}\n\t\t\tif (labelDepth < 0) {\n\t\t\t\ttranslate([0,0,-eps])\n\t\t\t\trotate([0,0,-45])\n\t\t\t\tmirror([1,0,0])\n\t\t\t\twrite(labelText, t=abs(labelDepth)+eps, h=labelHeight, font=labelFont, space=1.1, center=true);\n\t\t\t}\n\t\t\ttranslate([0,0,-eps]) {\n\t\t\t\tif (numHoles % 2 == 1) {\n\t\t\t\t\tcylinder(r=holeDiameter/2,h=base+2*eps);\n\t\t\t\t}\n\t\t\t\tfor (n = [0:evenHoles - 1]) {\n\t\t\t\t\trotate([0,0,n * (360/evenHoles)])\n\t\t\t\t\ttranslate([innerRadius*0.6,0,0]) {\n\t\t\t\t\t\tcylinder(r=holeDiameter/2,h=base+2*eps);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (labelDepth > 0) {\n\t\t\ttranslate([0,0,-labelDepth])\n\t\t\trotate([0,0,-45])\n\t\t\tmirror([1,0,0])\n\t\t\twrite(labelText, t=labelDepth+eps, h=labelHeight, font=labelFont, space=1.1, center=true);\n\t\t}\n\t}\n}",
    "description": "Okay, I'm looking to create a customizable spice jar and lid using OpenSCAD. I want it to be parametric so I can adjust various dimensions and features. Here's what I need:\n\n**General Shape and Dimensions:**\n\n*   **Jar/Lid Selection:** The design should be able to generate either the jar base or the lid based on a parameter.\n*   **Container Size:** I need to control the width (diameter) of the exterior of the container.\n*   **Height:** The height of the container body (not including the lid) should be adjustable.\n*   **Tilt:** I want the container to have a tilt angle relative to the vertical, which can be set between 0 and 60 degrees.\n*   **Wall Thickness:** I need a minimum wall thickness setting to ensure it's printable and sturdy.\n*   **Horizontal Wall Thickness:** Separate control over the top of the lid and the bottom of the base thickness. This would be used to make the lid more transparent when printed with clear plastic, by printing a thin single layer or two.\n*   **Rounding:** I want to round the vertical edges of the jar. The radius of this rounding should be adjustable, so I could even have a cylindrical jar if I set the radius large enough.\n*   **Lip Height:** A specific height for the lip between the lid and the base, to ensure it locks properly.\n*   **Bayonet Depth:** The depth of the locking bayonets that engage when the lid is twisted on, to control how tight the closure is.\n*   **Part Gap:** A small gap between the lid and the jar to allow them to fit together, this needs to be adjustable so I can adjust how tight the seal is.\n\n**Lid Specific Features:**\n\n*   **Lid Height:** The overall height of the lid.\n*   **Lid Holes:** An option to add holes to the lid, so the spice jar can be used as a shaker. I need control over the number of holes and their diameter.\n*   **Solid Lid:** The option to have a solid lid with no holes.\n\n**Base Specific Features:**\n\n*   **Magnet Option:** I want the option to add magnets to the bottom of the base.\n*   **Magnet Diameter and Height:** I need to be able to specify the size of the magnets I intend to use.\n*   **Magnet Placement:** A parameter to control the location of the magnets, setting how far towards the edge or the center they are.\n\n**Labeling:**\n\n*   **Label Text:** I need to be able to add text labels to either the jar or the lid, or both.\n*   **Label Font:** I need a way to use different fonts for the label. I would like to include Orbitron, Basic, KneWave, BlackRose and Braille fonts.\n*   **Label Depth:**  A parameter to control if the label is embossed (pushed in) or extruded (pushed out) from the surface of the part.\n*   **Label Height:**  The size of the label, should be adjustable in mm.\n*   **Label Alignment:** I'd like the text label to be aligned vertically on the jar and across the lid.\n\n**Libraries:**\n\n*   I know the design will need a library for rendering the text with different fonts. Specifically, I know that I need the `write/Write.scad` library and I'd like to use the following fonts from it: `\"write/orbitron.dxf\"`, `\"write/letters.dxf\"`, `\"write/knewave.dxf\"`, `\"write/BlackRose.dxf\"`, `\"write/braille.dxf\"`.\n*  Also a `utils/build_plate.scad` is required for visualizing the print on the build plate.\n\n**Mechanism:**\n\n*   The lid and jar will use a bayonet-style locking mechanism.\n* The bayonet angle will be 30 degrees\n\nI would like the file to be well commented, easy to understand and modify.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Wally with extra depth",
    "scad": "plate_width = 1;\nplate_size = 0;\n1st_plate = \"none\";\n1st_plate_bottom_hole = \"none\";\n2nd_plate = \"none\";\n2nd_plate_bottom_hole = \"none\";\n3rd_plate = \"none\";\n3rd_plate_bottom_hole = \"none\";\n4th_plate = \"none\";\n4th_plate_bottom_hole = \"none\";\n5th_plate = \"none\";\n5th_plate_bottom_hole = \"none\";\nplate_sticks_out = 10;\nsticks_out_thick = 3;\nmodule GoAwayCustomizer() {\n}\nl_offset = [34.925,39.6875,44.45];\nr_offset = [34.925,39.6875,44.45];\nspacer = [0,0,46.0375,92.075,138.1125,184.15];\nsolid_plate_width = l_offset[plate_size] + spacer[plate_width] + r_offset[plate_size];\nheight_sizes = [114.3,123.825,133.35];\nheight = 114.3;\ngang_width=[0,69.86,115.824,161.925,206.375,254];\nedgewidth = solid_plate_width + 10;\nrightbevel = solid_plate_width - 4;\nleft_offset = 34.925;\nswitch_offset = 46.0375;\nthinner_offset=[0,0.92,0.95,0.96,0.97,0.973];\npositions=[height_sizes[plate_size]/2,height_sizes[plate_size]/2 - 14.25,height_sizes[plate_size]/2 + 14.25];\nmodule plate1(){\n\tif (1st_plate == \"toggle\" || 1st_plate_bottom_hole == \"toggle\"){\n\t\ttranslate([0,l_offset[plate_size],0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size],0]) hole(\"toggle\");\n\t\t}\n\telse if (1st_plate == \"long_toggle\" || 1st_plate_bottom_hole == \"long_toggle\"){\n\t\ttranslate([0,l_offset[plate_size],0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size],0]) hole(\"long_toggle\");\n\t\t}\n\telse if (1st_plate == \"rocker\" || 1st_plate_bottom_hole == \"rocker\"){\n\t\ttranslate([0,l_offset[plate_size],0]) rocker_screws();\n\t\ttranslate([0,l_offset[plate_size],0]) hole(\"rocker\");\n\t\t}\n\telse if (1st_plate == \"outlet\" || 1st_plate_bottom_hole == \"outlet\") {\n\ttranslate([0,l_offset[plate_size],0]) hole(\"outlet\");\n\t}\n\telse if (1st_plate_bottom_hole == \"none\") {\n\t\ttranslate([0,l_offset[plate_size],0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size],0]) hole(1st_plate);\n\t\t\t}\n\telse if (1st_plate == \"none\") {\n\t\ttranslate([0,l_offset[plate_size],0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size],0]) hole(1st_plate_bottom_hole);\n\t\t\t}\n\telse {\n\ttranslate([0,l_offset[plate_size],0]) box_screws();\n\ttranslate([positions[1],l_offset[plate_size],0]) hole(1st_plate);\n\ttranslate([positions[2],l_offset[plate_size],0]) hole(1st_plate_bottom_hole);\n\t}\n}\nmodule plate2(){\n\tif (2nd_plate == \"toggle\" || 2nd_plate_bottom_hole == \"toggle\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset,0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset,0]) hole(\"toggle\");\n\t\t}\n\telse if (2nd_plate == \"long_toggle\" || 2nd_plate_bottom_hole == \"long_toggle\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset,0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset,0]) hole(\"long_toggle\");\n\t\t}\n\telse if (2nd_plate == \"rocker\" || 2nd_plate_bottom_hole == \"rocker\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset,0]) rocker_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset,0]) hole(\"rocker\");\n\t\t}\n\telse if (2nd_plate == \"outlet\" || 2nd_plate_bottom_hole == \"outlet\") {\n\ttranslate([0,l_offset[plate_size] + switch_offset,0]) hole(\"outlet\");\n\t}\n\telse if (2nd_plate_bottom_hole == \"none\") {\n\t\ttranslate([0,l_offset[plate_size] + switch_offset,0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size] + switch_offset,0]) hole(2nd_plate);\n\t\t\t}\n\telse if (2nd_plate == \"none\") {\n\t\ttranslate([0,l_offset[plate_size] + switch_offset,0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size] + switch_offset,0]) hole(2nd_plate_bottom_hole);\n\t\t\t}\n\telse {\n\ttranslate([0,l_offset[plate_size] + switch_offset,0]) box_screws();\n\ttranslate([positions[1],l_offset[plate_size] + switch_offset,0]) hole(2nd_plate);\n\ttranslate([positions[2],l_offset[plate_size] + switch_offset,0]) hole(2nd_plate_bottom_hole);\n\t}\n}\nmodule plate3(){\n\tif (3rd_plate == \"toggle\" || 3rd_plate_bottom_hole == \"toggle\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) hole(\"toggle\");\n\t\t}\n\telse if (3rd_plate == \"long_toggle\" || 3rd_plate_bottom_hole == \"long_toggle\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) hole(\"long_toggle\");\n\t\t}\n\telse if (3rd_plate == \"rocker\" || 3rd_plate_bottom_hole == \"rocker\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) rocker_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) hole(\"rocker\");\n\t\t}\n\telse if (3rd_plate == \"outlet\" || 3rd_plate_bottom_hole == \"outlet\") {\n\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) hole(\"outlet\");\n\t}\n\telse if (3rd_plate_bottom_hole == \"none\") {\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size] + switch_offset * 2,0]) hole(3rd_plate);\n\t\t\t}\n\telse if (3rd_plate == \"none\") {\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size] + switch_offset * 2,0]) hole(3rd_plate_bottom_hole);\n\t\t\t}\n\telse {\n\ttranslate([0,l_offset[plate_size] + switch_offset * 2,0]) box_screws();\n\ttranslate([positions[1],l_offset[plate_size] + switch_offset * 2,0]) hole(3rd_plate);\n\ttranslate([positions[2],l_offset[plate_size] + switch_offset * 2,0]) hole(3rd_plate_bottom_hole);\n\t}\n}\nmodule plate4(){\n\tif (4th_plate == \"toggle\" || 4th_plate_bottom_hole == \"toggle\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) hole(\"toggle\");\n\t\t}\n\telse if (4th_plate == \"long_toggle\" || 4th_plate_bottom_hole == \"long_toggle\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) hole(\"long_toggle\");\n\t\t}\n\telse if (4th_plate == \"rocker\" || 4th_plate_bottom_hole == \"rocker\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) rocker_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) hole(\"rocker\");\n\t\t}\n\telse if (4th_plate == \"outlet\" || 4th_plate_bottom_hole == \"outlet\") {\n\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) hole(\"outlet\");\n\t}\n\telse if (4th_plate_bottom_hole == \"none\") {\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size] + switch_offset * 3,0]) hole(4th_plate);\n\t\t\t}\n\telse if (4th_plate == \"none\") {\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size] + switch_offset * 3,0]) hole(4th_plate_bottom_hole);\n\t\t\t}\n\telse {\n\ttranslate([0,l_offset[plate_size] + switch_offset * 3,0]) box_screws();\n\ttranslate([positions[1],l_offset[plate_size] + switch_offset * 3,0]) hole(4th_plate);\n\ttranslate([positions[2],l_offset[plate_size] + switch_offset * 3,0]) hole(4th_plate_bottom_hole);\n\t}\n}\nmodule plate5(){\n\tif (5th_plate == \"toggle\" || 5th_plate_bottom_hole == \"toggle\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) hole(\"toggle\");\n\t\t}\n\telse if (5th_plate == \"long_toggle\" || 5th_plate_bottom_hole == \"long_toggle\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) toggle_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) hole(\"long_toggle\");\n\t\t}\n\telse if (5th_plate == \"rocker\" || 5th_plate_bottom_hole == \"rocker\"){\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) rocker_screws();\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) hole(\"rocker\");\n\t\t}\n\telse if (5th_plate == \"outlet\" || 5th_plate_bottom_hole == \"outlet\") {\n\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) hole(\"outlet\");\n\t}\n\telse if (5th_plate_bottom_hole == \"none\") {\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size] + switch_offset * 4,0]) hole(5th_plate);\n\t\t\t}\n\telse if (5th_plate == \"none\") {\n\t\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) box_screws();\n\t\ttranslate([positions[0],l_offset[plate_size] + switch_offset * 4,0]) hole(5th_plate_bottom_hole);\n\t\t\t}\n\telse {\n\ttranslate([0,l_offset[plate_size] + switch_offset * 4,0]) box_screws();\n\ttranslate([positions[1],l_offset[plate_size] + switch_offset * 4,0]) hole(5th_plate);\n\ttranslate([positions[2],l_offset[plate_size] + switch_offset * 4,0]) hole(5th_plate_bottom_hole);\n\t}\n}\nmodule extend_box() { union () {\n\ttranslate([0,0,-plate_sticks_out]) cube([height_sizes[plate_size],sticks_out_thick,plate_sticks_out]);\n\ttranslate([0,solid_plate_width-sticks_out_thick,-plate_sticks_out]) cube([height_sizes[plate_size],sticks_out_thick,plate_sticks_out]);\n\ttranslate([0,0,-plate_sticks_out]) cube([sticks_out_thick,solid_plate_width,plate_sticks_out]);\n\ttranslate([height_sizes[plate_size]-sticks_out_thick,0,-plate_sticks_out]) cube([sticks_out_thick,solid_plate_width,plate_sticks_out]);\n    }\n}\n\t    module plate1_solid(){\nif (1st_plate == \"keystone1\" && 1st_plate_bottom_hole == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (1st_plate == \"keystone1\" && 1st_plate_bottom_hole != \"outlet\" && 1st_plate_bottom_hole != \"toggle\" && 1st_plate_bottom_hole != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2,l_offset[plate_size] - 11.5,-3.9]) hole(\"keystone_solid\");\n\t}\nif (1st_plate_bottom_hole == \"keystone1\" && 1st_plate == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (1st_plate_bottom_hole == \"keystone1\" && 1st_plate != \"outlet\" && 1st_plate != \"toggle\" && 1st_plate != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2 + 28.5,l_offset[plate_size] - 11.5,-3.9]) hole(\"keystone_solid\");\n\t}\n}\nmodule plate2_solid(){\nif (2nd_plate == \"keystone1\" && 2nd_plate_bottom_hole == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5 + switch_offset,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (2nd_plate == \"keystone1\" && 2nd_plate_bottom_hole != \"outlet\" && 2nd_plate_bottom_hole != \"toggle\" && 2nd_plate_bottom_hole != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2,l_offset[plate_size] - 11.5 + switch_offset,-3.9]) hole(\"keystone_solid\");\n\t}\nif (2nd_plate_bottom_hole == \"keystone1\" && 2nd_plate == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5 + switch_offset,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (2nd_plate_bottom_hole == \"keystone1\" && 2nd_plate != \"outlet\" && 2nd_plate != \"toggle\" && 2nd_plate != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2 + 28.5,l_offset[plate_size] - 11.5 + switch_offset,-3.9]) hole(\"keystone_solid\");\n\t}\n}\nmodule plate3_solid(){\nif (3rd_plate == \"keystone1\" && 3rd_plate_bottom_hole == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5 + switch_offset * 2,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (3rd_plate == \"keystone1\" && 3rd_plate_bottom_hole != \"outlet\" && 3rd_plate_bottom_hole != \"toggle\" && 3rd_plate_bottom_hole != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2,l_offset[plate_size] - 11.5 + switch_offset * 2,-3.9]) hole(\"keystone_solid\");\n\t}\nif (3rd_plate_bottom_hole == \"keystone1\" && 3rd_plate == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5 + switch_offset * 2,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (3rd_plate_bottom_hole == \"keystone1\" && 3rd_plate != \"outlet\" && 3rd_plate != \"toggle\" && 3rd_plate != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2 + 28.5,l_offset[plate_size] - 11.5 + switch_offset * 2,-3.9]) hole(\"keystone_solid\");\n\t}\n}\nmodule plate4_solid(){\nif (4th_plate == \"keystone1\" && 4th_plate_bottom_hole == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5 + switch_offset * 3,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (4th_plate == \"keystone1\" && 4th_plate_bottom_hole != \"outlet\" && 4th_plate_bottom_hole != \"toggle\" && 4th_plate_bottom_hole != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2,l_offset[plate_size] - 11.5 + switch_offset * 3,-3.9]) hole(\"keystone_solid\");\n\t}\nif (4th_plate_bottom_hole == \"keystone1\" && 4th_plate == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5 + switch_offset * 3,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (4th_plate_bottom_hole == \"keystone1\" && 4th_plate != \"outlet\" && 4th_plate != \"toggle\" && 4th_plate != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2 + 28.5,l_offset[plate_size] - 11.5 + switch_offset * 3,-3.9]) hole(\"keystone_solid\");\n\t}\n}\nmodule plate5_solid(){\nif (5th_plate == \"keystone1\" && 5th_plate_bottom_hole == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5 + switch_offset * 4,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (5th_plate == \"keystone1\" && 5th_plate_bottom_hole != \"outlet\" && 5th_plate_bottom_hole != \"toggle\" && 5th_plate_bottom_hole != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2,l_offset[plate_size] - 11.5 + switch_offset * 4,-3.9]) hole(\"keystone_solid\");\n\t}\nif (5th_plate_bottom_hole == \"keystone1\" && 5th_plate == \"none\") {\n\ttranslate([height_sizes[plate_size]/2 + 14.3,l_offset[plate_size] - 11.5 + switch_offset * 4,-3.9]) hole(\"keystone_solid\");\n\t}\nelse if (5th_plate_bottom_hole == \"keystone1\" && 5th_plate != \"outlet\" && 5th_plate != \"toggle\" && 5th_plate != \"rocker\") {\n\ttranslate([height_sizes[plate_size]/2 + 28.5,l_offset[plate_size] - 11.5 + switch_offset * 4,-3.9]) hole(\"keystone_solid\");\n\t}\n}\nmodule plate() {\n    union () {\n\tdifference() {\n\t\tcube([height_sizes[plate_size],solid_plate_width,6]);\n\t\ttranslate([-4.3,-5,6.2]) rotate([0,45,0]) cube([6,edgewidth,6]);\n\t\ttranslate([height_sizes[plate_size]-4.2,-5,6.25]) rotate([0,45,0]) cube([6,edgewidth,6]);\n\t\ttranslate([height_sizes[plate_size]+10,-4.4,6.1]) rotate([0,45,90]) cube([6,height_sizes[plate_size]+20,6]);\n\t\ttranslate([height_sizes[plate_size]+10,rightbevel,6]) rotate([0,45,90]) cube([6,height_sizes[plate_size]+10,6]);\n\t    }\n\t}\n    }\nmodule plate_inner() {\n\tscale([0.95,thinner_offset[plate_width],1]){\n\ttranslate([3,3,0]){\n\tdifference() {\n\t\tcube([height_sizes[plate_size],solid_plate_width,6]);\n\t\ttranslate([-4.3,-5,6.2]) rotate([0,45,0]) cube([6,edgewidth,6]);\n\t\ttranslate([height_sizes[plate_size]-4.2,-5,6.25]) rotate([0,45,0]) cube([6,edgewidth,6]);\n\t\ttranslate([height_sizes[plate_size]+10,-4.4,6.1]) rotate([0,45,90]) cube([6,height_sizes[plate_size]+20,6]);\n\t\ttranslate([height_sizes[plate_size]+10,rightbevel,6]) rotate([0,45,90]) cube([6,height_sizes[plate_size]+10,6]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nmodule box_screws(){\n\t translate([height_sizes[plate_size]/2 + 41.67125,0,-1]) cylinder(r=2, h=10, $fn=12);\n\t translate([height_sizes[plate_size]/2 + 41.67125,0,3.5]) cylinder(r1=2, r2=3.3, h=3);\n\t translate([height_sizes[plate_size]/2 - 41.67125,0,-1]) cylinder(r=2, h=10, $fn=12);\n\t translate([height_sizes[plate_size]/2 - 41.67125,0,3.5]) cylinder(r1=2, r2=3.3, h=3);\n}\nmodule rocker_screws(){\n\t translate([height_sizes[plate_size]/2 + 48.41875,0,-1]) cylinder(r=2, h=10, $fn=12);\n\t translate([height_sizes[plate_size]/2 + 48.41875,0,3.5]) cylinder(r1=2, r2=3.3, h=3);\n\t translate([height_sizes[plate_size]/2 - 48.41875,0,-1]) cylinder(r=2, h=10, $fn=12);\n\t translate([height_sizes[plate_size]/2 - 48.41875,0,3.5]) cylinder(r1=2, r2=3.3, h=3);\n}\nmodule toggle_screws(){\n\t translate([height_sizes[plate_size]/2 + 30.1625,0,-1]) cylinder(r=2, h=10, $fn=12);\n\t translate([height_sizes[plate_size]/2 + 30.1625,0,3.5]) cylinder(r1=2, r2=3.3, h=3);\n\t translate([height_sizes[plate_size]/2 - 30.1625,0,-1]) cylinder(r=2, h=10, $fn=12);\n\t translate([height_sizes[plate_size]/2 - 30.1625,0,3.5]) cylinder(r1=2, r2=3.3, h=3);\n}\nmodule hole(hole_type) {\n\tif (hole_type == \"toggle\") {\n\t\ttranslate([height_sizes[plate_size]/2,0,0]) cube([23.8125,10.3188,15], center = true);\n\t\t \t\t\t\t\t\t}\n\tif (hole_type == \"long_toggle\") {\n\t\ttranslate([height_sizes[plate_size]/2,0,0]) cube([43.6563,11.9063,15], center = true);\n\t\t \t\t\t\t\t\t}\n\tif (hole_type == \"rocker\") {\n\t\ttranslate([height_sizes[plate_size]/2,0,0]) cube([67.1,33.3,15], center = true);\n\t\t \t\t\t\t\t\t}\n\tif (hole_type == \"outlet\" || hole_type == \"dualsidetoggle\") {\n\t\ttranslate([height_sizes[plate_size]/2 + 19.3915,0,0]) {\n\t\t\tdifference() {\n\t\t\t\tcylinder(r=17.4625, h=15, center = true);\n\t\t\t\ttranslate([-24.2875,-15,-2]) cube([10,37,15], center = false);\n\t\t\t\ttranslate([14.2875,-15,-2]) cube([10,37,15], center = false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\ttranslate([height_sizes[plate_size]/2 - 19.3915,0,0]){\n\t\t\tdifference(){\n\t\t\t\tcylinder(r=17.4625, h=15, center = true);\n\t\t\t\ttranslate([-24.2875,-15,-2]) cube([10,37,15], center = false);\n\t\t\t\ttranslate([14.2875,-15,-2]) cube([10,37,15], center = false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\ttranslate([height_sizes[plate_size]/2,0,-1]) cylinder(r=2, h=10);\n\t\ttranslate([height_sizes[plate_size]/2,0,3.5]) cylinder(r1=2, r2=3.3, h=3);\n\t\t\t\t\t\t\t}\n\tif (hole_type == \"blank\") { }\n\tif (hole_type == \"vga\" || hole_type == \"db09\") {\n\t\t\ttranslate([0,-12.5,3]) cylinder(r=1.75, h=10, center = true);\n\t\t\ttranslate([0,12.5,3]) cylinder(r=1.75, h=10, center = true);\n\t\t\t\tdifference(){\n\t\t\t\t\tcube([10,19,13], center=true);\n\t\t\t\t\ttranslate([-5,-9.2,1]) rotate([0,0,-35.6]) cube([4.4,2.4,15], center=true);\n\t\t\t\t\ttranslate([.9,-11.2,0]) rotate([0,0,9.6]) cube([10,4.8,15], center=true);\n\t\t\t\t\ttranslate([4.6,-8.5,0]) rotate([0,0,37.2]) cube([4.4,2.4,15], center=true);\n\t\t\t\t\ttranslate([-5,9.2,1]) rotate([0,0,35.6]) cube([4.4,2.4,15], center=true);\n\t\t\t\t\ttranslate([0.9,11.2,0]) rotate([0,0,-9.6]) cube([10,4.8,15], center=true);\n\t\t\t\t\ttranslate([4.6,8.5,0]) rotate([0,0,-37.2]) cube([4.4,2.4,15], center=true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\tif (hole_type == \"hdmi\") {\n\t\ttranslate([0,-13,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,13,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,0,3]) cube([6,16,10], center=true);\n\t\t\t\t\t\t\t}\n\tif (hole_type == \"dvi\") {\n\t\ttranslate([0,-16,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,16,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,0,3]) cube([10,26,10], center=true);\n\t\t\t\t\t\t\t}\n\tif (hole_type == \"displayport\") {\n\t\ttranslate([0,-13.5,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,13.5,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,0,0]){\n\t\t\tdifference(){\n\t\t\t\ttranslate([0,0,3]) cube([7,19,10], center=true);\n\t\t\t\ttranslate([2.47,-9.37,3]) rotate([0,0,-54.6]) cube([3,5,14], center=true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\tif (hole_type == \"usb-a\") {\n\t\ttranslate([0,-15,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,15,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,0,3]) cube([8,16,10], center=true);\n\t\t\t\t\t\t\t}\n\tif (hole_type == \"usb-b\") {\n\t\ttranslate([0,-13,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,13,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,0,3]) cube([11,12,10], center=true);\n\t\t\t\t\t\t\t}\n\tif (hole_type == \"firewire\") {\n\t\ttranslate([0,-13.5,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,13.5,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,0,3]) cube([7,12,10], center=true);\n\t\t\t\t\t\t\t}\n\tif (hole_type == \"f-type\") {\n\t\ttranslate([0,0,3]) cylinder(r=4.7625, h=10, center=true);\n\t\t\t\t\t\t\t}\n\tif (hole_type == \"cat5e\" || hole_type == \"cat6\") {\n\t\ttranslate([0,-12.5,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,12.5,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,0,3]) cube([15,15,10], center=true);\n\t\t}\n\tif (hole_type == \"svideo\" || hole_type == \"ps2\") {\n\t\ttranslate([0,-10,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,10,3]) cylinder(r=1.75, h=10, center = true);\n\t\ttranslate([0,0,3]) cylinder(r=5, h=10, center=true);\n\t\t}\n\tif (hole_type == \"stereo\") {\n\t\ttranslate([0,0,3]) cylinder(r=2.985, h=10, center=true);\n\t\t}\n\tif (hole_type == \"keystone1\") {\n\t\ttranslate([0,0,5]) cube([16.5,15,10], center = true);\n\t}\n\tif (hole_type == \"keystone_solid\") {\n\t\trotate([0,0,90]) {\n\t\t\tdifference(){\n\t\t\t\ttranslate([0,0,.1]) cube([23,30.5,9.8]);\n\t\t\t\t\ttranslate([4,4,0]){\n\t\t\t\t\t\tdifference(){\n\t\t\t\t\t\t\tcube([15,22.5,10]);\n\t\t\t\t\t\t\ttranslate([-1,-0.001,3.501]) cube([17,2,6.5]);\n\t\t\t\t\t\t\ttranslate([-1,2.5,-3.40970]) rotate([45,0,0]) cube([17,2,6.5]);\n\t\t\t\t\t\t\ttranslate([-1,18.501,6.001]) cube([17,4,4]);\n\t\t\t\t\t\t\ttranslate([-1,20.5,0]) rotate([-45,0,0]) cube([17,2,6.5]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\nrotate([0,180,90]){\ntranslate([-height_sizes[plate_size]/2,-solid_plate_width/2,-6]){\n    union() {\nif (plate_width == 1) {\n\tdifference() {\n\t\tplate();\n\t\ttranslate([0,0,-3]) plate_inner();\n\t\tplate1();\n\t\t\t}\n\t\tunion() {\n\t\tplate1_solid();\n\t\t}\n\t    }\nelse if (plate_width == 2) {\ndifference()\n{\nplate();\ntranslate([0,0,-3]) plate_inner();\nplate1();\nplate2();\n}\nunion() {\n\t\tplate1_solid();\n\t\tplate2_solid();\n\t\t}\n}\nelse if (plate_width == 3) {\ndifference()\n{\nplate();\ntranslate([0,0,-3]) plate_inner();\nplate1();\nplate2();\nplate3();\n}\nunion() {\n\t\tplate1_solid();\n\t\tplate2_solid();\n\t\tplate3_solid();\n\t\t}\n}\nelse if (plate_width == 4) {\ndifference()\n{\nplate();\ntranslate([0,0,-3]) plate_inner();\nplate1();\nplate2();\nplate3();\nplate4();\n}\nunion() {\n\t\tplate1_solid();\n\t\tplate2_solid();\n\t\tplate3_solid();\n\t\tplate4_solid();\n\t\t}\n}\nelse if (plate_width == 5) {\ndifference()\n{\nplate();\ntranslate([0,0,-3]) plate_inner();\nplate1();\nplate2();\nplate3();\nplate4();\nplate5();\n}\nunion() {\n\t\tplate1_solid();\n\t\tplate2_solid();\n\t\tplate3_solid();\n\t\tplate4_solid();\n\t\tplate5_solid();\n\t\t}\n}\nextend_box();\n}\n}\n}",
    "description": "Okay, I'm looking for some help designing a customizable wall plate in OpenSCAD. I've seen a few designs online, but I need something a bit more flexible and robust, and I need it to be parametric so that I can make future changes easily.\n\nHere's what I need it to do:\n\n**Core Functionality:**\n\n*   **Multiple Gangs:** The wall plate should support 1 to 5 gangs (or ports), selectable through a variable.\n*   **Variable Plate Sizes:** I need three pre-defined plate sizes to choose from: \"Standard\", \"Junior-Jumbo\", and \"Jumbo\" that change the plate's overall dimensions. The specifics will be included as dimensions below.\n*   **Multiple Port Types:**  Each port should be configurable to one of the following types, which each have their own specific cutouts:\n    *   None\n    *   Blank Port (no cutout, but the other hole should not move to the center)\n    *   Full Plate Toggle Switch\n    *   Full Plate Long Toggle Switch\n    *   Full Plate Duplex Outlet\n    *   Full Plate Rocker/Designer Plate\n    *   Keystone Jack\n    *   VGA Port\n    *   HDMI Port\n    *   DVI-I Port\n    *   DisplayPort\n    *   Cat5e/Cat6 Port\n    *   USB-A Port\n    *   USB-B Port\n    *   Firewire IEEE 1394 Port\n    *    DB-09 Port\n    *    PS2 Port\n    *   F-Type/Coaxial Port\n    *   S-Video Port\n    *   Stereo Headphone Jack\n*   **Dual Hole Support:** Each \"gang\" should have two available locations, a \"top\" and \"bottom\". The top can be one of the aforementioned port types. The bottom location is optional and can be set to either 'none', a 'blank' port, or any of the \"Keystone\" through \"Stereo Headphone\" options. If the \"top\" position is one of \"Toggle\", \"Long_Toggle\", \"Outlet\" or \"Rocker\", the bottom position is ignored, with the full plate type taking up the entire gang. If the \"bottom\" is none, the top should center. If the \"top\" is \"none\", the bottom should center. Otherwise, they should be spaced vertically.\n*   **Extending Box:** The plate should have a parameter to control how much it extends out from the wall, with a second parameter to control how thick the extended portion is (this is useful when the wall box is a little too far recessed).\n\n**Specific Dimensions and Layout (in millimeters):**\n\nThese are based on the original code but I want these to be set as global parameters rather than buried in modules:\n\n*   **Plate Widths:**\n    *   Standard: `[0, 69.86, 115.824, 161.925, 206.375, 254]` (the first element is always 0, the second element is a single gang, third is two gang, etc.)\n*   **Plate Heights:**\n    *   Standard: 114.3\n    *   Junior-Jumbo: 123.825\n    *   Jumbo: 133.35\n*   **Offsets:** These also need to be specified per plate size, but are not just a single number each. \n    * Left Offset: `[34.925, 39.6875, 44.45]`\n    * Right Offset: `[34.925, 39.6875, 44.45]`\n    * Port Spacing: 46.0375 mm\n*   **Screw Hole Layouts:** These vary based on the port type\n    *   Box: + or - 41.67125 from the horizontal center of the gang.\n    *   Rocker: + or - 48.41875 from the horizontal center of the gang.\n    *   Toggle: + or - 30.1625 from the horizontal center of the gang.\n*   **Bevel:**  The plate should have a bevel on all sides. Bevel width is parameterized, but the calculations should match the original design's to maintain the look.\n*   **Vertical Positions:** top and bottom positions are based off the height/2 of the plate, and should be set as `[height_sizes[plate_size]/2,height_sizes[plate_size]/2 - 14.25,height_sizes[plate_size]/2 + 14.25]`\n\n**OpenSCAD Specifics:**\n\n*   I'd like the code to be well-commented and easy to understand.\n*   I do not need external libraries.\n\n**User Interface:**\n\n*   It should have easy-to-use customizer parameters that map to the above functionality.\n\nI think that covers everything. Let me know if you have any questions.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Zoetrope",
    "scad": "parts = \"both\";\nframes = 12;\nwidth = 32;\nheight = 24;\nslit = 4;\nset_diameter = 0;\ndiameter = 120;\nstand_height = 75;\nradius = (height+4 + slit) / 2 / tan(180/frames);\nexpand = tan(180/frames) * (radius + 2) * 2;\nscale = (diameter/(radius*2)-1) * set_diameter + 1;\nprint_part();\nmodule print_part() {\n\tif (parts == \"first\") {\n\t\tsingleWheel();\n\t} else if (parts == \"second\") {\n\t\tsingleStand();\n\t} else if (parts == \"both\") {\n\t\twheelAndStand();\n\t} else {\n\t\twheelAndStand();\n\t}\n}\nmodule wheelAndStand() {\ntranslate([-radius*scale - 10,0,0]){\ndifference(){\nunion(){\nscale(scale){\nfor(i=[0 : frames]){\nrotate([0,0,i*360/frames]){\ntranslate([(height+4)/-2,radius,0]){\ncube([height+4,2,width+4]);\ntranslate([(expand-height-4)/-2,-2,0]){\n\tcube([expand,4,6]);\n}\ntranslate([0,-2,0]){\n\tcube([2,4,width+4]);\n}\ntranslate([height+2,-2,0]){\n\tcube([2,4,width+4]);\n}\ntranslate([0,-2,0]){\n\tcube([4,1,width+4]);\n}\ntranslate([height,-2,0]){\n\tcube([4,1,width+4]);\n}\n}\nrotate([0,0,360/frames/2]){\ntranslate([-3,0,0]){\n\tcube([6,(height+4 + slit) / 2 / sin(180/frames),3]);\n}}}}}\ncylinder(h=5*scale, r=16);\n}\nfor(i=[0 : 3]){\nrotate([0,0,i*90]){\ntranslate([12,0,-1]){\n\tcylinder(h=7*scale, r=3.5);\n}}}\ntranslate([0,0,-1]){\ncylinder(h=7*scale, r=5.5);\n}}}\ntranslate([stand_height/2 + 10,0,0]){\nunion(){\ntranslate([0,-15,1]){\ntranslate([0,0,stand_height]){\nrotate([-90,0,0]){\ndifference(){\ncylinder(h=10,r=15);\ntranslate([0,0,-1]){\ncylinder(h=12,r=5.25);}}}}\ntranslate([-10,0,-1]){\ncube([20,10,stand_height-7.5]);}\ntranslate([stand_height/-2,0,-1]){\ncube([stand_height,10,5]);}\ntranslate([stand_height/-2,-40,-1]){\ncube([10,60,5]);}\ntranslate([(stand_height/2)-10,-40,-1]){\ncube([10,60,5]);}\ntranslate([(stand_height/-2)+5,-40,-1]){\ncylinder(h=5,r=5);}\ntranslate([(stand_height/2)-5,-40,-1]){\ncylinder(h=5,r=5);}\ntranslate([(stand_height/-2)+5,20,-1]){\ncylinder(h=5,r=5);}\ntranslate([(stand_height/2)-5,20,-1]){\ncylinder(h=5,r=5);}\n}\ntranslate([15,45,0]){\nintersection(){\ntranslate([0,0,8]){\nscale([1,1,1.8]){\nsphere(12);}}\ntranslate([0,0,12.5]){\ncube(25, true);}}\ntranslate([0,0,30]){\ncube([8,2,10], true);}\ntranslate([0,0,30]){\ncube([2,8,10], true);}\n}\ntranslate([-15,45,0]){\ndifference(){\ncylinder(h=10,r=15);\ntranslate([0,0,5]){\ncube([9,3,12], true);}\ntranslate([0,0,5]){\ncube([3,9,12], true);}}\nfor(i=[0 : 3]){\nrotate([0,0,i*90]){\ntranslate([12,0,0]){\ncylinder(h=20,r=3, $fn=16);}}}\n}\ntranslate([0,20,0]){\ndifference(){\nhull(){\ntranslate([20,0,0]){\ncylinder(h=10,r=7);}\ntranslate([-20,0,0]){\ncylinder(h=11,r=7);}}\ntranslate([20,0,5]){\ncube([9,3,12], true);}\ntranslate([20,0,5]){\ncube([3,9,12], true);}}\ntranslate([-20,0,0]){\ncylinder(h=21.5,r=5);}\ntranslate([-20,0,25]){\ncube([8,2,10], true);}\ntranslate([-20,0,25]){\ncube([2,8,10], true);}\n}\n}\n}\n}\nmodule singleWheel() {\ndifference(){\nunion(){\nscale(scale){\nfor(i=[0 : frames]){\nrotate([0,0,i*360/frames]){\ntranslate([(height+4)/-2,radius,0]){\ncube([height+4,2,width+4]);\ntranslate([(expand-height-4)/-2,-2,0]){\n\tcube([expand,4,6]);\n}\ntranslate([0,-2,0]){\n\tcube([2,4,width+4]);\n}\ntranslate([height+2,-2,0]){\n\tcube([2,4,width+4]);\n}\ntranslate([0,-2,0]){\n\tcube([4,1,width+4]);\n}\ntranslate([height,-2,0]){\n\tcube([4,1,width+4]);\n}\n}\nrotate([0,0,360/frames/2]){\ntranslate([-3,0,0]){\n\tcube([6,(height+4 + slit) / 2 / sin(180/frames),3]);\n}}}}}\ncylinder(h=5*scale, r=16);\n}\nfor(i=[0 : 3]){\nrotate([0,0,i*90]){\ntranslate([12,0,-1]){\n\tcylinder(h=7*scale, r=3.5);\n}}}\ntranslate([0,0,-1]){\ncylinder(h=7*scale, r=5.5);\n}}\n}\nmodule singleStand() {\nunion(){\ntranslate([0,-15,1]){\ntranslate([0,0,stand_height]){\nrotate([-90,0,0]){\ndifference(){\ncylinder(h=10,r=15);\ntranslate([0,0,-1]){\ncylinder(h=12,r=5.25);}}}}\ntranslate([-5,0,-1]){\ncube([10,10,stand_height-10]);}\ntranslate([stand_height/-2,0,-1]){\ncube([stand_height,10,5]);}\ntranslate([stand_height/-2,-40,-1]){\ncube([10,60,5]);}\ntranslate([(stand_height/2)-10,-40,-1]){\ncube([10,60,5]);}\ntranslate([(stand_height/-2)+5,-40,-1]){\ncylinder(h=5,r=5);}\ntranslate([(stand_height/2)-5,-40,-1]){\ncylinder(h=5,r=5);}\ntranslate([(stand_height/-2)+5,20,-1]){\ncylinder(h=5,r=5);}\ntranslate([(stand_height/2)-5,20,-1]){\ncylinder(h=5,r=5);}\n}\ntranslate([15,45,0]){\nintersection(){\ntranslate([0,0,8]){\nscale([1,1,1.8]){\nsphere(12);}}\ntranslate([0,0,12.5]){\ncube(25, true);}}\ntranslate([0,0,30]){\ncube([8,2,10], true);}\ntranslate([0,0,30]){\ncube([2,8,10], true);}\n}\ntranslate([-15,45,0]){\ndifference(){\ncylinder(h=10,r=15);\ntranslate([0,0,5]){\ncube([9,3,12], true);}\ntranslate([0,0,5]){\ncube([3,9,12], true);}}\nfor(i=[0 : 3]){\nrotate([0,0,i*90]){\ntranslate([12,0,0]){\ncylinder(h=20,r=3, $fn=16);}}}\n}\ntranslate([0,20,0]){\ndifference(){\nhull(){\ntranslate([20,0,0]){\ncylinder(h=10,r=7);}\ntranslate([-20,0,0]){\ncylinder(h=11,r=7);}}\ntranslate([20,0,5]){\ncube([9,3,12], true);}\ntranslate([20,0,5]){\ncube([3,9,12], true);}}\ntranslate([-20,0,0]){\ncylinder(h=21.5,r=5);}\ntranslate([-20,0,25]){\ncube([8,2,10], true);}\ntranslate([-20,0,25]){\ncube([2,8,10], true);}\n}\n}\n}",
    "description": "Okay, I'm looking to design a customizable zoetrope that I can 3D print. I've got a rough idea of what I want, and I've even got some existing OpenSCAD code that kind of gets me there, but it's not quite as flexible as I'd like, and I'm hoping you can help me create a better, parametric version.\n\nHere's what I'm thinking:\n\n**Core Features & Parameters:**\n\n1.  **Parts Selection:** I need to be able to choose whether I want to generate just the wheel, just the stand, or both. The existing code uses a `parts` variable with options like \"both\", \"first\", and \"second\" - maybe you could use similar strings for this.\n2.  **Animation Frames:** I need a parameter to specify how many frames will be in the animation. The current code uses a variable `frames` for this, which works.\n3.  **Frame Dimensions:** The animation frames will be rectangular. I want parameters for the width and height of each frame. I think the existing code uses `width` and `height`, which are fine.\n4.  **Slit Depth:** There needs to be a parameter for how far the frames are pushed out from the center, this creates the slits. This is currently `slit` in the existing code.\n5.  **Wheel Diameter:** I need a way to set the overall diameter of the wheel, while keeping the slit depth correct. The current code has an approach where you can scale the wheel, and it uses a `set_diameter` parameter (0 for no scale and 1 for scale) and a `diameter` parameter, but it's clunky. It would be better if I could just specify a `wheel_diameter` and have the code calculate the correct overall size including slits.\n6.  **Stand Height:** A parameter is needed for the height of the stand (distance from the ground to the axle) for the overall stand height. The current code uses `stand_height`.\n7. **Axel Diameter:** The diameter of the axle needs to be specifiable, this is not currently exposed in the provided code.\n\n**Structural Details (Considerations):**\n\n*   **Wheel Construction:** The wheel needs to have a solid backing and clips to hold the animation frames in place. I like how the current code uses a combination of cubes to accomplish this. Also there needs to be a central hub with mounting holes.\n*   **Stand Design:** The stand should be stable with a base, upright supports, and a location for the axle. It also needs to include the knob and the arm for spinning the zoetrope.\n*   **Parametric Calculations:** I'd like the wheel's radius to be calculated correctly based on the frame height, slit depth, and number of frames. The current code is able to do this, but I want it tied to a simple `wheel_diameter` parameter.\n*   **Material Thickness:** I'm going to print this on a 3D printer so I should be able to specify a general parameter for material thickness so it can be varied.\n\n**Desired Improvements over Current Code:**\n\n*   **Direct Diameter Control:**  I want to set the wheel diameter directly and have the code calculate the rest, rather than the scale method in the current code.\n*   **Clearer Parameter Usage:** I'd like the parameter names to be very clear and easy to understand.\n*   **Better Comments:** I'd love it if the code could be well-commented to explain what each section does.\n*   **More Precise Hub and Axle:** The hub should fit the axle more precisely. The axle diameter should also be an input, and the hole needs to be slightly bigger for a friction fit.\n\n**OpenSCAD Libraries:**\n\nI don't think I need to use any additional libraries for this, just the built-in OpenSCAD functionality should suffice, but if you feel there's a specific library that would make this design easier, let me know.\n\nEssentially, I'm looking for a parametric OpenSCAD model that will allow me to fully customize the zoetrope to my needs. Let me know if you have any questions.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Picture Frame with Optional Stand",
    "scad": "use <utils/build_plate.scad>;\npicture_width=125;\npicture_height=100;\nframe_width=15;\nframe_thickness=15;\nstand=\"yes\";\nstand_tilt=15;\nframe_lip=7;\nframe_depth=5;\nbuild_plate(3,230,200);\ndifference() {\n\ttranslate([-(picture_width/2+frame_width),-(picture_height/2+frame_width),0]) linear_extrude(height=frame_thickness)\n\tdifference() {\n\t\tsquare([picture_width+2*frame_width,picture_height+2*frame_width]);\n\t\ttranslate ([frame_width+frame_lip,frame_width+frame_lip,0]) square([picture_width-2*frame_lip,picture_height-2*frame_lip]);\n\t}\n\ttranslate([-(picture_width/2),-(picture_height/2),frame_thickness-frame_depth])\n\tlinear_extrude(height=frame_depth) square([picture_width,picture_height]);\n}\nh=(picture_height+2*frame_width)/2+frame_thickness;\nif (stand==\"yes\") {\n\ttranslate([-picture_width/2,-(picture_height/2+frame_width/2+h*sin(stand_tilt)),0])\n\trotate([0,270,0])\n\tlinear_extrude(height=frame_width)\n\t\tpolygon([[0,0],[0,h*cos(90-stand_tilt)],[h*cos(stand_tilt),h*sin(stand_tilt)]]);\n\ttranslate([picture_width/2+frame_width,-(picture_height/2+frame_width/2+h*sin(stand_tilt)),0])\n\trotate([0,270,0])\n\tlinear_extrude(height=frame_width)\n\t\tpolygon([[0,0],[h*cos(stand_tilt),h*sin(stand_tilt)],[0,h*cos(90-stand_tilt)]]);\n}",
    "description": "Okay, I'd like to design a customizable picture frame with an optional stand, and I need some help creating the OpenSCAD code for it.\n\nHere's what I'm envisioning:\n\n**Basic Frame:**\n\n*   The frame should hold a picture of a specified width and height.\n*   I need to be able to set the width of the frame itself.\n*   The frame should have a settable thickness.\n*   There needs to be a lip on the inside of the frame to hold the picture and any mat, the depth and overhang needs to be specifiable.\n\n**Stand:**\n\n*   I want the stand to be optional.\n*   If the stand is enabled, it should tilt the frame back by a specified angle.\n*   The stand should be attached to the bottom edge of the frame.\n\n**Parameters I need to control:**\n\n*   `picture_width`: The width of the picture (and mat, if applicable).\n*   `picture_height`: The height of the picture (and mat, if applicable).\n*   `frame_width`: The width of the frame itself.\n*   `frame_thickness`: The thickness of the frame.\n*   `stand`: A boolean option to include the stand (yes/no, or true/false).\n*   `stand_tilt`: The tilt angle of the stand, in degrees.\n*    `frame_lip`: The overhang of the lip inside the frame to hold the picture\n*    `frame_depth`: The thickness of the lip that holds the picture.\n\n**Libraries:**\n\n* I'll need the ability to add a build plate using the included `utils/build_plate.scad` file.\n\nCould you help me generate the OpenSCAD code for this design?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Clips for fixing twisted bag strap! (OpenSCAD)",
    "scad": "x = 15;\ny = 43.5;\nz = 9;\nunion() {\nintersection() { translate(v = [-(x-3)/2, 0, -(z/6)]) cube(size = [3,(y+20),(z/3)], center = true);\nunion() { translate(v = [-(x-3)/2, -1, 0]) rotate(a=[70,0,0]) cube(size = [10,(y+20),(z/1.5)], center = true);\ntranslate(v = [-(x-3)/2, 1, 0]) rotate(a=[-70,0,0]) cube(size = [10,(y+20),(z/1.5)], center = true); } }\nintersection() { translate(v = [(x-3)/2, 0, -(z/6)]) cube(size = [3,(y+20),(z/3)], center = true);\nunion() { translate(v = [(x-3)/2, -1, 0]) rotate(a=[70,0,0]) cube(size = [10,(y+20),(z/1.5)], center = true);\ntranslate(v = [(x-3)/2, 1, 0]) rotate(a=[-70,0,0]) cube(size = [10,(y+20),(z/1.5)], center = true); } }\ndifference() { union() { cube(size = [x,y,z], center = true);\ntranslate(v = [0, -(y/2), 0]) rotate(a=[90,90,90]) cylinder(h = x, r=(z/2), center = true);\ntranslate(v = [0, (y/2), 0]) rotate(a=[90,90,90]) cylinder(h = x, r=(z/2), center = true); }\nunion() { translate(v = [0, -(y/2), 0]) rotate(a=[90,90,90]) cylinder(h = (x+10), r=(z/3.6), center = true);\ntranslate(v = [0, (y/2), 0]) rotate(a=[90,90,90]) cylinder(h = (x+10), r=(z/3.6), center = true);\ntranslate(v = [0, 0, -(z/4)-1]) cube(size = [(x+40),(y+40),(z/2)+2], center = true); } } }\ndifference() {\nunion() { translate(v = [x+(x/2), 0, 0]) cube(size = [x,y,z], center = true);\ntranslate(v = [x+(x/2), -(y/2), 0]) rotate(a=[90,90,90]) cylinder(h = x, r=(z/2), center = true);\ntranslate(v = [x+(x/2), (y/2), 0]) rotate(a=[90,90,90]) cylinder(h = x, r=(z/2), center = true); }\nunion() { translate(v = [x+(x/2), -(y/2), 0]) rotate(a=[90,90,90]) cylinder(h = (x+5), r=(z/3.6), center = true);\ntranslate(v = [x+(x/2), (y/2), 0]) rotate(a=[90,90,90]) cylinder(h = (x+5), r=(z/3.6), center = true);\ntranslate(v = [x+(x/2), 0, -(z/4)-1]) cube(size = [(x+40),(y+40),(z/2)+2], center = true);\nintersection() { translate(v = [x+(x/2), 0, z/6]) cube(size = [(x+5),(y+11),(z/3)+0.2], center = true);\nunion() { translate(v = [x+(x/2), 1.2, 0]) rotate(a=[70,0,0]) cube(size = [(x+5),(y+11),(z/1.5)], center = true);\ntranslate(v = [x+(x/2), -1.2, 0]) rotate(a=[-70,0,0]) cube(size = [(x+5),(y+11),(z/1.5)], center = true);\ntranslate(v = [x+(x/2), 0, 1]) cube(size = [(x-6),(z+1),(z/3)+0.2], center = true); } }\n}\n}",
    "description": "Okay, so I'm trying to design some clips that I can attach to my bag straps. The straps tend to get all twisted up around the metal rings that connect them to the bag, and I want these clips to prevent that. I've tried my hand at OpenSCAD, and I've got a first draft, but I know it's not great.\n\nHere's what I'm after: I need a clip that can essentially clamp onto the strap, preventing it from rotating. I envision a design that has two \"jaws\" that come together to grip the strap. My current design has these two halves joined by a middle section. I used a lot of cylinders and cubes, and some rotations and translations to try and get the right shape. It's a bit messy though! It is not very parametric, and I would like to be able to easily adjust the size, especially the thickness of the strap the clip can fit on, and the length and thickness of the clip itself.\n\nHere are the things I would like:\n\n1.  **Parametric Design:** I need this to be fully parametric. I want to easily adjust parameters like:\n    *   `strap_thickness`: The thickness of the bag strap.\n    *   `strap_width`: The width of the bag strap.\n    *   `clip_length`: The overall length of the clip.\n    *   `clip_width`: The overall width of the clip.\n    *  `jaw_depth`: The depth of the clamping \"jaws\".\n    *   `jaw_angle`: The angle of the gripping arms (like the rotated cubes in my attempt).\n\n2.  **Robust Clamping:** The clip should hold the strap firmly. I think the angled \"jaws\" in my attempt should help with that, but maybe you have some better ideas. The jaws need a bit of clearance so they can actually close on the strap.\n\n3.  **Easy to Print:** It should be printable on a standard FDM printer without requiring supports.\n\n4.  **Rounded Edges:** I'd like rounded edges where possible to avoid sharp corners.\n\n5.  **Preview:** I'd really love a way to visualize this with a small cube to represent the bag strap in the preview, so I can be sure the dimensions are working before printing.\n\n6.  **Use of Libraries:** I'm open to using any useful libraries for things like rounding or more complex shapes. I've seen BOSL and BOSL2 mentioned, and I like the idea of using those if you find them helpful. I'd rather use existing functions to create smooth curves and joints rather than try and make them with more cubes and cylinders. I'm happy to include any other library you think I need; just let me know which and why!\n\nBasically, I'm looking for a more polished and truly parametric version of my initial attempt. Can you help me design this? I think a parametric clip with these features would be super useful for lots of people.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Accessible keyboard",
    "scad": "total_width = 258;\ntotal_height = 174;\nthickness = 2;\nnumber_columns = 6;\nnumber_rows = 6;\nleft_margin = 25;\nright_margin = 25;\ntop_margin = 36;\nbottom_margin = 36;\nhorizontal_gap = 5;\nvertical_gap = 5;\nmodule makebuttons(number_columns,number_rows,left_margin,top_margin,button_width,button_height,horizontal_gap,vertical_gap) {\nfor ( i = [0 : number_columns-1] )\n{\n\tfor (j = [0 : number_rows-1])\n    translate([left_margin + i * (button_width + horizontal_gap), top_margin + j * (button_height + vertical_gap), 0])\n\tlinear_extrude(height=thickness)\n   square([button_width,button_height]);\n}\n}\nbutton_height = (total_height - top_margin - bottom_margin - (number_rows-1)*vertical_gap ) / number_rows;\nbutton_width = (total_width - left_margin - right_margin - (number_columns-1)*horizontal_gap ) / number_columns;\ndifference() {\nlinear_extrude(height = thickness)\nsquare([total_width,total_height]);\nmakebuttons(number_columns,number_rows,left_margin,top_margin,button_width,button_height,horizontal_gap,vertical_gap);\n}",
    "description": "Okay, I'm trying to design a keyboard guard for a tablet. Basically, it's a flat piece of plastic with holes cut out so you can press the on-screen buttons without accidentally hitting the wrong ones. I've got a basic design working in OpenSCAD, but I need to make it more flexible and user-friendly.\n\nHeres what I need it to do:\n\n*   **Parametric Dimensions:** The design should be fully parametric, allowing me to easily adjust the overall size of the guard, button layout, and spacing. The current code has all of these parameters, which are great. I need to keep them! They are:\n    *   `total_width` (overall width of the guard)\n    *   `total_height` (overall height of the guard)\n    *   `thickness` (thickness of the guard)\n    *   `number_columns` (number of columns of buttons)\n    *   `number_rows` (number of rows of buttons)\n    *   `left_margin` (distance from the left edge of the guard to the buttons)\n    *   `right_margin` (distance from the right edge of the guard to the buttons)\n    *   `top_margin` (distance from the top edge of the guard to the buttons)\n    *   `bottom_margin` (distance from the bottom edge of the guard to the buttons)\n    *   `horizontal_gap` (space between buttons horizontally)\n    *   `vertical_gap` (space between buttons vertically)\n*   **Rounded Corners:** I'd like to add rounded corners to the outer edge of the guard to make it more comfortable to handle.\n*   **Button Rounding:** Id also like to round the corners of the cutouts for the buttons, but I'd like to control the radius of the rounding independently from the rounding of the outer rectangle.\n*   **Mounting Holes (Optional):** It would be great to include an option to add mounting holes. I might want to attach this to a stand or something. Id want to specify:\n    *   The number of mounting holes. \n    *   The hole's diameter.\n    *   Their positions, potentially relative to corners or edges (e.g., a margin distance from the corners, or a specified coordinate relative to the center). Perhaps a boolean would allow me to specify the positions are related to the corners or the center?\n    *   Maybe a choice of mounting hole shapes too? I'd like options for circle or countersunk.\n*   **Easy to Adjust:** It should be easy to adjust all these parameters from the beginning of the OpenSCAD file.\n*   **No Dependencies** I don't want to rely on any external libraries. \n\nCan you generate an OpenSCAD file that does all of this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Inscription Ring",
    "scad": "use <write/Write.scad>\nring_size = 15.09;\nc_r=ring_size/2;\nthick=2;\nring_width=5;\nring_angle=15;\ntext_face=\"Bilbo\";\ntext_size_face = 4;\nspace_size_face=1.0*1;\ntext=\"Baggins\";\ntext_size_interior =  3;\nspace_size =1.0*1;\npart = \"ring\";\ns_r=c_r+2*thick;\nx_offset=-thick;\ny_b=ring_width/2;\nx_b=sqrt(s_r*s_r-y_b*y_b);\nangle=ring_angle;\ntranslate([c_r+thick,0,0])\nrotate([0,angle,0])\ntranslate([-x_b,0,y_b])\n{\n  if(part==\"ring\")\n  difference() {\n    difference() {\n      difference() {\n        translate([0,0,0]) sphere(s_r,$fn=100,center=true);\n        union() {\n          translate([-x_offset,0,0]) cylinder(60,c_r,c_r,$fn=100,center=true);\n          translate([+x_b,0,y_b]) rotate([0,angle,0]) translate([-x_b-s_r,-s_r,0]) cube([2*s_r,s_r*2,s_r]);\n          translate([+x_b,0,-y_b]) rotate([0,-angle,0]) translate([-x_b-s_r,-s_r,-s_r]) cube([2*s_r,s_r*2,s_r]);\n        }\n      }\n      translate([-s_r-c_r,-s_r,-s_r]) cube([s_r,2*s_r,2*s_r]);\n    }\n    translate([-x_offset,0,0]) mirror([ 0, 1, 0 ]) writesphere(text,[0,0,0],c_r,east=90,t=thick,h=text_size_interior,font=\"write/Letters.dxf\", space=space_size,center=true);\n      translate([-c_r,0,0]) rotate([90,0,-90]) write(text_face,h=text_size_face,t=thick,font=\"write/Letters.dxf\",space=space_size_face,center=true);\n  }\n  if(part==\"inscription\") {\n    if(len(text))\n    color(\"red\")\n    intersection() {\n      difference() {\n        translate([-x_offset,0,0]) cylinder(10,c_r+thick,c_r+thick,$fn=100,center=true);\n        translate([-x_offset,0,0]) cylinder(10,c_r,c_r,$fn=100,center=true);\n      }\n      translate([-x_offset,0,0]) mirror([ 0, 1, 0 ]) writesphere(text,[0,0,0],c_r,east=90,t=thick,h=text_size_interior,font=\"write/Letters.dxf\", space=space_size,center=true);\n    }\n    if(len(text_face))\n    color(\"red\")\n    intersection() {\n      translate([-c_r,-s_r,-s_r]) cube([thick,2*s_r,2*s_r]);\n      translate([-c_r,0,0]) rotate([90,0,-90]) write(text_face,h=text_size_face,t=thick,font=\"write/Letters.dxf\",space=space_size_face,center=true);\n    }\n  }\n}",
    "description": "Okay, I'd like to design a ring with some text on it, and I need an OpenSCAD file to do it. I've seen a few examples, and I like some of the features, but I need some customizations. \n\nHere are the features I'd like:\n\n1. **Ring Sizing:** I want to be able to easily specify the ring size, preferably using US ring sizes (like the chart from [http://www.thingiverse.com/thing:40704](http://www.thingiverse.com/thing:40704)). I need the design to correctly convert that ring size to the inner diameter of the ring.\n\n2. **Ring Thickness:** I need a parameter to control the thickness of the ring (how far the ring extends from the center of the cylinder).\n\n3. **Ring Width at Back:** I need a parameter to control the width of the ring at the back of the finger. This would be the vertical width of the ring along the back of the finger if you were looking at your finger.\n\n4. **Ring Angle (Taper):**  I want to be able to set an angle that controls how much the ring tapers from the back to the front. Zero degrees would mean the width of the ring is constant, and non-zero would give it a tapered look.\n\n5. **Text on the Face:** I want to be able to put text on the front, outside surface of the ring. I need parameters to specify:\n    * The text itself.\n    * The text size.\n    * The spacing between the letters.\n\n6.  **Text Inside the Ring:**  I need to be able to put an inscription on the inside of the ring. I need parameters to specify:\n    * The text itself.\n    * The text size.\n    * The spacing between the letters.\n\n7. **Part Selection:** I want a parameter to select whether the code generates a full ring, or only the text inscription parts. This is useful if I only want to test what the inscription will look like.\n\n8.  **Dual Extrusion Support:** If I select \"inscription\" I want the resulting text (both internal and external) to be a solid, printable object. Ideally it would have the same width as the ring's thickness, so that if I 3D print them with two extruders, the text could be in a different color. This should be the same thickness as the *ring's* \"thick\" parameter.\n\n9. **`write/Write.scad` Library:** The example files I've seen use the `write/Write.scad` library for the text generation. I'd like to use this same library. Please don't include this library with the code you write, I have it already.\n\nI'd like to be able to preview the ring from the west and have a top tilt view by default in the OpenSCAD preview window.\n\nThe examples I've seen (RingThingV5.scad and RingThingV6.scad) are good starting points but have some minor issues with the inscription part I'd like to avoid. For example, in v5 if `text` or `text_face` are empty strings, they still generate \"something\", and v6 seems to fix this. I'd also like the code to generate the inscription parts as solid objects for dual-extrusion printing. Can you help me write this parametric OpenSCAD code?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Basic Didjeridu Mouthpiece",
    "scad": "rim_diameter = 29;\nrim_curvature = 3;\ninside_bite = 0.1;\nrim_thickness = 6;\noutside_bite = 0.35;\noutside_shoulder_slope = 0.3;\nrimInnerDiameter = rim_diameter;\ntransitionLength = 25;\ndidjOuterDiameter = 48.3;\ndidjInnerDiameter = 40;\nshankWallThickness = 3.36;\nshankLen = 15;\nprinter_spooge_factor = 0.35;\nprintSupport = 0;\nlayerHeight = 0.3;\n$fn = 90;\ndidjOR = didjOuterDiameter/2 + printer_spooge_factor;\ndidjIR = didjInnerDiameter/2 + printer_spooge_factor;\nrimIR = rimInnerDiameter/2 + printer_spooge_factor;\nrimOR = rimIR + rim_thickness;\nrimIR = rim_diameter/2 + printer_spooge_factor;\nrimOR = rimIR + rim_thickness;\ninsideX = rim_thickness*inside_bite;\noutsideX = rim_thickness*outside_bite;\nbite=1;\nrimWid = rim_thickness * (1 - inside_bite - outside_bite) * 0.25;\npRim = [\n  [rimOR, transitionLength - outsideX],\n  [rimOR - (outsideX*outside_shoulder_slope), transitionLength+rim_curvature/2],\n  [rimIR + insideX, transitionLength+rim_curvature/2],\n  [rimIR, transitionLength],\n  [rimIR, transitionLength],\n  [rimIR, transitionLength-insideX]\n];\nbottomY = printSupport ? 0 : didjOR-didjIR;\nrotate_extrude()\n  polygon([\n    [didjOR,0],\n  \t[didjIR, bottomY],\n  \t[rimIR, pRim[0][1]-0.25],\n    PointAlongBez6(pRim, (25-0)/25),\n    PointAlongBez6(pRim, (25-1)/25),\n    PointAlongBez6(pRim, (25-2)/25),\n    PointAlongBez6(pRim, (25-3)/25),\n    PointAlongBez6(pRim, (25-4)/25),\n    PointAlongBez6(pRim, (25-5)/25),\n    PointAlongBez6(pRim, (25-6)/25),\n    PointAlongBez6(pRim, (25-7)/25),\n    PointAlongBez6(pRim, (25-8)/25),\n    PointAlongBez6(pRim, (25-9)/25),\n    PointAlongBez6(pRim, (25-10)/25),\n    PointAlongBez6(pRim, (25-11)/25),\n    PointAlongBez6(pRim, (25-12)/25),\n    PointAlongBez6(pRim, (25-13)/25),\n    PointAlongBez6(pRim, (25-14)/25),\n    PointAlongBez6(pRim, (25-15)/25),\n    PointAlongBez6(pRim, (25-16)/25),\n    PointAlongBez6(pRim, (25-17)/25),\n    PointAlongBez6(pRim, (25-18)/25),\n    PointAlongBez6(pRim, (25-19)/25),\n    PointAlongBez6(pRim, (25-20)/25),\n    PointAlongBez6(pRim, (25-21)/25),\n    PointAlongBez6(pRim, (25-22)/25),\n    PointAlongBez6(pRim, (25-23)/25),\n    PointAlongBez6(pRim, (25-24)/25),\n    PointAlongBez6(pRim, (25-25)/25),\n    [rimIR+(didjIR-rimIR)/2+shankWallThickness, transitionLength/2],\n    [didjOR + shankWallThickness, 0]\n  ]);\nrotate_extrude()\n  polygon([\n    [didjOR,-shankLen],\n    [didjOR,0],\n    [didjOR + shankWallThickness, 0],\n    [didjOR + shankWallThickness, -shankLen]\n]);\nif (printSupport)\n{\n  for ( i = [0 : 30 : 360] )\n  {\n    rotate([0,0,i])\n    translate([0,0,-shankLen])\n    cube([0.25, didjOR - 0.4, shankLen - layerHeight]);\n  }\n}\nfunction BEZ03(u) = pow((1-u), 3);\nfunction BEZ13(u) = 3*u*(pow((1-u),2));\nfunction BEZ23(u) = 3*(pow(u,2))*(1-u);\nfunction BEZ33(u) = pow(u,3);\nfunction PointAlongBez4(p,u) = [\n  BEZ03(u)*p[0][0]+BEZ13(u)*p[1][0]+BEZ23(u)*p[2][0]+BEZ33(u)*p[3][0],\n  BEZ03(u)*p[0][1]+BEZ13(u)*p[1][1]+BEZ23(u)*p[2][1]+BEZ33(u)*p[3][1]\n  ];\nfunction Bez06(t) =            pow(1-t, 5);\nfunction Bez16(t) = 5*pow(t,1)*pow(1-t, 4);\nfunction Bez26(t) = 10*pow(t,2)*pow(1-t, 3);\nfunction Bez36(t) = 10*pow(t,3)*pow(1-t, 2);\nfunction Bez46(t) = 5*pow(t,4)*pow(1-t, 1);\nfunction Bez56(t) =   pow(t,5);\nfunction PointAlongBez6(p,u) = [\n  Bez06(u)*p[0][0]+Bez16(u)*p[1][0]+Bez26(u)*p[2][0]+Bez36(u)*p[3][0]+Bez46(u)*p[4][0]+Bez56(u)*p[5][0],\n  Bez06(u)*p[0][1]+Bez16(u)*p[1][1]+Bez26(u)*p[2][1]+Bez36(u)*p[3][1]+Bez46(u)*p[4][1]+Bez56(u)*p[5][1]\n  ];",
    "description": "Okay, I'd like to design a parametric didgeridoo mouthpiece for 3D printing. I'm using OpenSCAD and I'd like to be able to customize the mouthpiece to fit different size pipes and to adjust the feel of the rim. I currently have a .scad file with most of what I want, but I'd like something more robust and well-organized. I want the following to be easily adjustable:\n\n**Rim:**\n*   **Rim Diameter:** The inner diameter of the rim where it meets the mouth. This will be in millimeters. I need to control how this impacts the model.\n*   **Rim Curvature:** How rounded the inner part of the rim is, from sharp to very rounded. I'm currently doing this with Bezier curves but I'm open to alternatives if it achieves the same feel.\n*  **Inside Bite:** How far inward the inner edge of the rim extends.\n*   **Rim Thickness:** The overall thickness of the rim where you make contact. \n*   **Outside Bite:** How sharp or soft the outer edge of the rim is.\n*   **Outside Shoulder Slope:** How angled the outside of the rim is.\n\n**Shank (the part that fits into the pipe):**\n*   **Transition Length:** The length of the curved part that connects the rim to the shank that fits in the pipe.\n*   **Didj Outer Diameter:** The outer diameter of the pipe.\n*   **Didj Inner Diameter:** The inner diameter of the pipe.\n*   **Shank Wall Thickness:** The thickness of the wall of the shank. This should be a multiple of a layer height to make printing easier.\n*   **Shank Length:** How far the shank extends outside the pipe.\n\n**Printer:**\n*   **Printer Spooge Factor:** A value added to the inner diameters to account for material oozing when printing, so that the fit is correct.\n*  **Print Support:** A boolean to generate automatic supports within the model. Should default to not generating them.\n*  **Layer Height:** A value used when generating supports.\n\n**General**\n*  I want to use good naming practices that make it clear what each variable does.\n*  I want the code to be well-commented so it's easy to understand.\n*  I would prefer to use libraries for anything that has a common use-case, but am happy to accept well-written custom functions instead.\n\nI would like this to be a single parametric .scad file that defines all of these. I will be using this file to generate 3D printable STLs.\n\nCan you help me create a well-organized OpenSCAD file to do this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Handlebar / tube mount for Garmin Montana 600 family ",
    "scad": "print_it=0;\nwhat=\"both\";\nhandlebar_d=23.2;\ntol=0+0.1;\nth= 0+4;\nhnut_th= 0+5;\nhook_x=0+19;\nhook_y=0+19-0.8;\nhook_z=0+34 + 1.2;\nhook_szx= 0+8;\nhook_szy= 0+2.8;\nhook_szz= 0+3;\narm_th= 0+6;\ngps_szx= 0+145;\ngps_szy= 0+37;\ngps_szz= 0+75;\nhandle_y= 19+th + handlebar_d/2;\nmodule body(w,h, margin)\n{\n\tcolor([1,1,0])\n\t{\n\t\tscale([1,1.02,1])\n\t\ttranslate([-2,-2.1-0.6,-w/2]) linear_extrude(height=w) scale(0.192) import(file = \"montana_large.dxf\");\n\t\trotate([0,90,0])\n\t\ttranslate([0.32,-0.45,-h/2])\n\t\trotate([0,0,0.7]) linear_extrude(height=h) scale([0.08,0.082,0.08]) import(file = \"montana_short.dxf\");\n\t}\n}\nmodule ccyl(r,h, rot=[0,0,0])\n{\n\trotate(rot) translate([0,0,-h/2]) cylinder(r=r,h=h, $fs=0.5);\n}\nmodule hook()\n{\n\tcolor([1,0.5,0.5])\n\t\ttranslate([0,-gps_szy/2, 0])\n\t\t{\n\t\t\ttranslate([hook_x,hook_y,hook_z])\n\t\t\t{\n\t\t\t\thull()\n\t\t\t\t{\n\t\t\t\t\tccyl(r=hook_szy/2, h=hook_szx, rot=[0,90,0]);\n\t\t\t\t\ttranslate([0,0,hook_szz]) ccyl(r=hook_szy/2, h=hook_szx, rot=[0,90,0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\nmodule back_plate()\n{\n\thull()\n\t{\n\t\ttranslate([0,20,20]) rotate([0,90,0]) ccyl(r=2.4,h=arm_totszx,$fs=1);\n\t\ttranslate([0,20,0]) rotate([0,90,0]) ccyl(r=2.4,h=arm_totszx,$fs=1);\n\t}\n}\narm_totszx= hook_x*2 + hook_szx;\nmodule roundedarmtop()\n{\n\tdifference()\n\t{\n\t\tintersection()\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\thull()\n\t\t\t\t{\n\t\t\t\tscale([1,1.2,1])\n\t\t\t\t\ttranslate([0,-2.5,gps_szy- gps_szy/2-0.5])\n\t\t\t\t\t\trotate([0,90,0]) ccyl(r=gps_szy/2+th, h=arm_totszx);\n\t\t\t\t\ttranslate([0,-8,34- 15/2])\n\t\t\t\t\t\trotate([0,90,0]) ccyl(r=15, h=arm_totszx);\n\t\t\t\t}\n\t\t\t\tback_plate();\n\t\t\t\thull()\n\t\t\t\t{\n\t\t\t\t\ttranslate([0,-13.5+2,gps_szz-37+8])\n\t\t\t\t\t\trotate([0,90,0]) ccyl(r=2.4,h=arm_totszx,$fs=1);\n\t\t\t\t\ttranslate([0,-13.5+5,gps_szz-37+2])\n\t\t\t\t\t\trotate([0,90,0]) ccyl(r=2.4,h=arm_totszx,$fs=1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tunion()\n\t\t\t{\n\t\t\t\ttranslate([0,-13.5,gps_szz-37]) rotate([0,90,0]) ccyl(r=2.4,h=100,$fs=1);\n\t\t\t\ttranslate([-50,-14,-tol]) cube([100,50,100]);\n\t\t\t}\n\t\t}\n\t\tbody(1,gps_szx-80, 3);\n\t}\n}\nmodule arm_half()\n{\n\tdifference()\n\t{\n\t\troundedarmtop();\n\t\tcube([hook_x*2 - arm_th*2,gps_szy+th*4+tol,gps_szz+th*2+tol+20],center=true);\n\t}\n}\nmodule arms()\n{\n\tfor(mz=[-1:+1])\n\t{\n\t\tscale([1,1,mz])\n\t\t{\n\t\t\tarm_half();\n\t\t\thook(); scale([-1,1,1]) hook();\n\t\t}\n\t}\n}\nmodule handlebar()\n{\n\ttranslate([0,handle_y,0])\n\t\trotate([0,90,0])\n\t\t\tccyl(r=handlebar_d/2,h=100);\n}\nmodule back()\n{\n\tdifference()\n\t{\n\t\thull()\n\t\t{\n\t\t\tintersection()\n\t\t\t{\n\t\t\t\tunion() { back_plate(); scale([1,1,-1]) back_plate(); }\n\t\t\t\tbody(1,gps_szx-80, 3);\n\t\t\t}\n\t\t\ttranslate([0,20+th,0]) cube([arm_totszx,th,41],center=true);\n\t\t}\n\t}\n}\nmodule fullgrip()\n{\n\tdifference()\n\t{\n\t\tunion()\n\t\t{\n\t\t\tarms();\n\t\t\tback();\n\t\t}\n\t\tscrewset(\"onlyscrews\");\n\t\thandlebar();\n\t}\n}\nmodule screw()\n{\n\tcylinder(r=6/2+0.5, h=3, $fs=1);\n\tcylinder(r=3/2+0.2, h=30, $fs=1);\n}\nmodule screwset(what=\"onlyscrews\")\n{\n\tfor(sz=[-1:2:1])\n\t\tfor(sx=[-1:2:1])\n\t\t\ttranslate([11*sx,17,(handlebar_d/2+hnut_th/2)*sz])\n\t\t\t\tfor(mz=[-1:1])\n\t\t\t\t\tscale([1,1,mz])\n\t\t\t\t\t\trotate([-90,0,0])\n\t\t{\n\t\t\tscrew();\n\t\t\tif(what!=\"onlyscrews\")\n\t\t\t\ttranslate([0,0,handle_y-handlebar_d/2-10 + handlebar_d*0.4])\n\t\t\t\t\tcylinder(r1=6.01/2,r2=6.01/2+5,h=40,$fn=6);\n\t\t}\n}\nmodule handle_nut()\n{\n\tdifference()\n\t{\n\t\thull()\n\t\t{\n\t\t\ttranslate([0,handle_y,0])\n\t\t\t{\n\t\t\t\trotate([0,90,0])\n\t\t\t\t\tccyl(r=handlebar_d/2+hnut_th, h=arm_totszx);\n\t\t\t\ttranslate([0,-handlebar_d/2,0])\n\t\t\t\t\tcube([arm_totszx,tol,handlebar_d+hnut_th*2],center=true);\n\t\t\t}\n\t\t}\n\t\tscrewset(\"nuts\");\n\t\thull()\n\t\t{\n\t\t\thandlebar();\n\t\t\ttranslate([0,-20,0]) handlebar();\n\t\t}\n\t\ttranslate([0,handle_y-handlebar_d/2-10,0])\n\t\t\tcube([arm_totszx+tol,34,gps_szz],center=true);\n\t\ttranslate([0,handle_y+handlebar_d-hnut_th,0])\n\t\t\tsphere(r=handlebar_d/2);\n\t}\n}\nif(what==\"nut\" || what==\"both\")\n{\n\trotate([0,print_it?90:0,0])\n\t\thandle_nut();\n}\nif(what==\"arm\" || what==\"both\")\n{\n\trotate([0,print_it?90:0,0])\n\tintersection()\n\t{\n\t\tfullgrip();\n\t\tif(print_it)\n\t\t\ttranslate([0,-50,-50]) cube([100,100,100]);\n\t}\n}",
    "description": "Okay, so I need a mount for my Garmin Montana GPS that I can attach to my bike handlebars. I've seen some designs online, and I have a pretty good idea of what I'm after, but I need an OpenSCAD design that I can tweak to fit different bikes and GPS units in the future.\n\nEssentially, the mount needs two main parts: a handlebar clamp and a GPS cradle with arms.\n\n**Handlebar Clamp:**\n\n*   This part will consist of two halves that bolt together around the handlebar.\n*   It needs to fit handlebars of different diameters, so that should be a parameter. I'd like to set the default diameter to 23.2mm, which is the size of my Rockrider 500, but I want to easily adjust that to fit 15mm up to maybe 32mm.\n*   The clamp halves should have a circular inner profile to grip the handlebar and should have integrated hex nut pockets for M3 bolts. I don't think we need to make the bolt hole diameters a parameter, they can just be standard size.\n*   I would like the clamp to be at least 4mm thick after the hex nut pockets, so that should be a parameter, as well. I'm thinking 5mm, though for the hex nut thickness.\n\n**GPS Cradle:**\n\n*   This part will have two \"arms\" that hold the sides of the GPS unit.\n*   The arms should extend from a back plate that connects to the handlebar clamp using M3 screws.\n*   The arms need to have hooks at the end that grip the Montana unit, specifically. I can provide specific dimensions for these hooks, but let's make those parameters, as well. I'm thinking hook location should be (19mm, 19-0.8mm, 34 + 1.2mm), and the size of the hooks are (8mm, 2.8mm, 3mm), x, y, z, in that order.\n*   The main body of the cradle should be made from the same thickness as the nut part so that it looks cohesive.\n*   The GPS cradle also needs to have a sort of back plate that will bolt to the handle bar clamps. I can imagine this sort of looks like a cylinder extruded along the Z-axis and should be the same width as the clamping portion and be of the same thickness.\n\n**General Requirements:**\n\n*   The entire design should be fully parametric. I'd like to be able to change things like the handlebar diameter, thickness of the clamp, and GPS hook dimensions.\n*   I need a parameter to switch between printing both the clamp and the cradle, just the clamp, or just the cradle.\n*   I would like an option to lay the model down for printing.\n*   I would like the design to be fairly robust, so that I don't have to worry about the mount breaking.\n*   I don't think I'm going to need any libraries for this, so we can probably keep it simple.\n\nCan you generate the OpenSCAD files for this design? Let me know if you have any questions.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Box maker",
    "scad": "internal_x = 100;\ninternal_y = 100;\ninternal_z = 100;\nmaterial_z = 4;\nscrew_outside_diameter = 3;\nscrew_length = 12;\nnut_outside_diameter = 5.5;\nnut_height = 2.5;\nanchor_count = 3;\ntooth_width = 3;\nchannel_position =70;\npart = \"assembled\";\nprint_part();\nmodule print_part() {\n\tif (part == \"bottom\") {\n\t\tbottom();\n\t} else if (part == \"top\") {\n\t\ttop();\n\t} else if (part == \"west\") {\n\t\twest_wall();\n\t}else if (part == \"east\") {\n\t\teast_wall();\n\t }else if (part == \"north\") {\n\t\tnorth_wall();\n\t }else if (part == \"south\") {\n\t\tsouth_wall();\n\t }else if (part == \"assembled\") {\n\t\tassembled();\n\t }else {\n\t\tprint_me();\n\t}\n}\nmaterial_thickness = material_z;\nwall_height = internal_z;\nnorth_buffer = 0;\na_c = anchor_count;\nmill_space = 60;\nboard_x = internal_x;\nboard_y = internal_y;\nboard_z = internal_z;\nmain_buffer = 0;\nmain_x = board_x + material_thickness + main_buffer;\nmain_y = board_y + material_thickness + main_buffer/2;\nmain_z = material_thickness;\nfn = 40;\nmodule east_wall()\n{\n\toffset = (harbor_offset * 2) + (material_thickness * 2);\n\teast_x = main_x - offset;\n\teast_y = wall_height;\n\tpylons = [a_c,a_c,a_c,a_c];\n\ttypes = [1,1,1,1];\n\toffsets = [offset, offset,offset, offset];\n\toffcenters = [0,0,0,0];\n\tgenerate_cube([east_x,east_y,main_z], true, pylons, types, offsets, \toffcenters);\n}\nmodule north_wall()\n{\n\tpylons = [a_c,a_c,a_c,a_c];\n\ttypes = [1,0,1,0];\n\toffset = (harbor_offset * 2) + (material_thickness * 2);\n\toffsets = [0, 0, 0, 0];\n\tsouth_x = main_x;\n\tsouth_y = wall_height;\n\tgenerate_cube([main_x, wall_height, material_thickness], true, pylons, types, offsets);\n}\nmodule top()\n{\n\tpylons = [a_c,a_c,a_c,a_c];\n\ttypes = [0,0,0,0];\n\ttop_x = main_x;\n\ttop_y = main_y;\n\tgenerate_cube([top_x,top_y,main_z], true, pylons, types);\n}\nmodule bottom()\n{\n\tpylons = [a_c,a_c,a_c,a_c];\n\ttypes = [0,0,0,0];\n\tbelow_z = 7;\n\tabove_z = 11;\n\tgenerate_cube([main_x,main_y,main_z], true, pylons, types);\n}\nmodule south_wall()\n{\n\tpylons = [a_c,a_c,a_c,a_c];\n\ttypes = [1,0,1,0];\n\tsouth_x = main_x;\n\tsouth_y = wall_height;\n\tgenerate_cube([south_x,south_y,main_z], true, pylons, types);\n}\nmodule west_wall()\n{\n\teast_wall();\n}\nmodule assembled()\n{\n\ttranslate([0,0,-wall_height/2])\n\tbottom();\n\tcolor(\"green\")\n\tmirror([0,0,1])\n\ttranslate([main_x/2 -material_thickness/2 - harbor_offset,0, -material_thickness/2])\n\trotate([90,0,-90])\n\teast_wall();\n\tcolor(\"orange\")\n\tmirror([1,0,0])\n\tmirror([0,0,1])\n\ttranslate([main_x/2 -material_thickness/2 - harbor_offset, 0, -material_thickness/2])\n\trotate([90,0,-90])\n\twest_wall();\n\tcolor(\"grey\")\n\ttranslate([0, main_y/2 - material_thickness/2 - harbor_offset, material_thickness/2])\n\tmirror([0,1,0])\n\trotate([270,0,0])\n\tnorth_wall();\n\tcolor(\"red\")\n\ttranslate([0, -(main_y/2 - material_thickness/2 - harbor_offset), material_thickness/2])\n\trotate([90,0,0])\n\tsouth_wall();\n\tcolor(\"white\")\n\ttranslate([0,0,wall_height/2 + material_thickness])\n\ttop();\n}\nmodule mill_me()\n{\n\tprojection(cut = true){\n\tbottom();\n\ttranslate([mill_space,0,0])\n\trotate([0,0,90])\n\teast_wall();\n\tmirror([1,0,0])\n\ttranslate([mill_space,0,0])\n\trotate([0,0,90])\n\teast_wall();\n\ttranslate([0,-mill_space, 0])\n\tsouth_wall();\n\ttranslate([0,mill_space, 0])\n\tnorth_wall();\n\ttranslate([0, main_y/2 + wall_height + mill_space,0])\n\ttop();\n\t}\n}\nmodule print_me()\n{\n\tbottom();\n\ttranslate([mill_space,0,0])\n\trotate([0,0,90])\n\tcolor(\"blue\")\n\teast_wall();\n\tmirror([1,0,0])\n\ttranslate([mill_space,0,0])\n\trotate([0,0,90])\n\tcolor(\"orange\")\n\teast_wall();\n\ttranslate([0,-mill_space, 0])\n\tsouth_wall();\n\ttranslate([0,mill_space, 0])\n\tnorth_wall();\n\ttranslate([0, main_y/2 + wall_height + mill_space,0])\n\ttop();\n}\nretain_screw_od = screw_outside_diameter;\nretain_screw_height = screw_length;\nretain_nut_od = nut_outside_diameter;\nretain_nut_height = nut_height;\nanchor_width = tooth_width;\nchannel_top = channel_position/100;\nchannel_bottom = 1 - channel_top;\nbuffer = 0.1;\nanchor_target_width = material_z;\nharbor_offset = material_z;\nharbor_width = anchor_width*2 + retain_screw_od + buffer;\nmodule test()\n{\n\tpylons = [3,2,1,2];\n\ttypes = [1,0,1,0];\n\toffsets = [0,0,0,0];\n\toffcenters = [0,0,0,0];\n\tgenerate_cube([100,110,1], true, pylons, types, offsets, offcenters);\n}\nmodule generate_negative_grid(dim, p, t, offsets = [0,0,0,0],  offcenters = [0,0,0,0])\n{\n\tcube_x = dim[0];\n\tcube_y = dim[1];\n\tside_off = cube_y - cube_x;\n\tfor ( i = [ 0 : 3 ] )\n\t{\n\t\tif ( t[i] == 1)\n\t\t{\n\t\techo(\"POSITIVE:\" ,p[i]);\n\t\tif ( i == 0)\n\t\t{\n\t\t\techo(\"OFFCENTERS: \", offcenters[i]);\n\t\t\ttranslate([offcenters[i],0,0])\n\t\t\tgenerate_shafts(cube_x + offsets[0], cube_y, p[i]);\n\t\t}\n\t\tif ( i == 1)\n\t\t{\n\t\t\techo(\"OFFCENTERS: \", offcenters[i]);\n\t\t\ttranslate([-side_off/2,0,0])\n\t\t\trotate([0,0,270])\n\t\t\ttranslate([offcenters[i],0,0])\n\t\t\tgenerate_shafts(cube_x + offsets[i], cube_y, p[i]);\n\t\t}\n\t\tif ( i == 2)\n\t\t{\n\t\t\techo(\"OFFCENTERS: \", offcenters[i]);\n\t\t\tmirror([0,1,0])\n\t\t\ttranslate([offcenters[i],0,0])\n\t\t\tgenerate_shafts(cube_x + offsets[i], cube_y, p[i]);\n\t\t}\n\t\tif ( i == 3)\n\t\t{\n\t\t\techo(\"OFFCENTERS: \", offcenters[i]);\n\t\t\ttranslate([side_off/2,0,0])\n\t\t\tmirror([1,0,0])\n\t\t\trotate([0,0,-90])\n\t\t\ttranslate([offcenters[i],0,0])\n\t\t\tgenerate_shafts(cube_x + offsets[i], cube_y, p[i]);\n\t\t}\n\t\t}else{\n\t\techo(\"NEGATIVE\", p[i]);\n\t\tif ( i == 0)\n\t\t{\n\t\t\techo(\"OFFCENTERS: \", offcenters[i]);\n\t\t\ttranslate([offcenters[i],0,0])\n\t\t\tgenerate_harbors(cube_x + offsets[i], cube_y, p[i]);\n\t\t}\n\t\tif ( i == 1)\n\t\t{\n\t\t\techo(\"OFFCENTERS: \", offcenters[i]);\n\t\t\ttranslate([-side_off/2,0,0])\n\t\t\trotate([0,0,270])\n\t\t\ttranslate([offcenters[i],0,0])\n\t\t\tgenerate_harbors(cube_x + offsets[i], cube_y, p[i]);\n\t\t}\n\t\tif ( i == 2)\n\t\t{\n\t\t\techo(\"OFFCENTERS: \", offcenters[i]);\n\t\t\tmirror([0,1,0])\n\t\t\ttranslate([offcenters[i],0,0])\n\t\t\tgenerate_harbors(cube_x + offsets[i], cube_y, p[i]);\n\t\t}\n\t\tif ( i == 3)\n\t\t{\n\t\t\techo(\"OFFCENTERS: \", offcenters[i]);\n\t\t\ttranslate([side_off/2,0,0])\n\t\t\tmirror([1,0,0])\n\t\t\trotate([0,0,-90])\n\t\t\ttranslate([offcenters[i],0,0])\n\t\t\tgenerate_harbors(cube_x + offsets[i], cube_y, p[i]);\n\t\t}\n\t\t}\n\t}\n}\nmodule generate_positive_grid(dim, p, t, offsets = [0,0,0,0], offcenters = [0,0,0,0])\n{\n\tcube_x = dim[0];\n\tcube_y = dim[1];\n\tside_off = cube_y - cube_x;\n\techo(\"OFFCENTERS_POSITIVE: \", offcenters);\n\techo(\"OFFSETS\", offsets);\n\tfor ( i = [ 0 : 3 ] )\n\t{\n\t\tif ( t[i] == 1)\n\t\t{\n\t\tif ( i == 0)\n\t\t{\n\t\t\ttranslate([offcenters[i],0,0])\n\t\t\tgenerate_anchors(cube_x + offsets[0], cube_y, p[i]);\n\t\t}\n\t\tif ( i == 1)\n\t\t{\n\t\t\ttranslate([-side_off/2,0,0])\n\t\t\trotate([0,0,270])\n\t\t\ttranslate([offcenters[i],0,0])\n\t\t\tgenerate_anchors(cube_x + offsets[i], cube_y, p[i]);\n\t\t}\n\t\tif ( i == 2)\n\t\t{\n\t\t\tmirror([0,1,0])\n\t\t\ttranslate([offcenters[i],0,0])\n\t\t\tgenerate_anchors(cube_x + offsets[i], cube_y, p[i]);\n\t\t}\n\t\tif ( i == 3)\n\t\t{\n\t\t\ttranslate([side_off/2,0,0])\n\t\t\tmirror([1,0,0])\n\t\t\trotate([0,0,-90])\n\t\t\ttranslate([offcenters[i],0,0])\n\t\t\tgenerate_anchors(cube_x + offsets[i], cube_y, p[i]);\n\t\t}\n\t\t}\n\t}\n}\nmodule generate_cube(dim, centered, points, types, offsets = [0,0,0,0], offcenters = [0,0,0,0])\n{\n\tx = dim;\n\ty = dim;\n\tz = dim;\n\tif ( len(dim) > 1 )\n\t{\n\t\tassign( x = dim[0], y = dim[1], z = dim[2])\n\t\t{\n\t\t\tgen_cube(x , y, z, centered, points, types, offsets, offcenters);\n\t\t}\n\t}else{\n\t\tassign(x = dim, y = dim, z = dim)\n\t\t{\n\t\t\tgen_cube(x, y, z, centered,  points, types, offsets, offcenters);\n\t\t}\n\t}\n}\nmodule gen_cube(x, y , z, centered, points, types, offsets = [0,0,0,0], offcenters = [0,0,0,0] )\n{\n\tunion(){\n\tdifference(){\n\tcube([x,y,z], center = centered);\n\t\tgenerate_negative_grid([x,y,z], points, types, offsets, offcenters);\n\t}\n\t\tgenerate_positive_grid([x,y,z], points, types, offsets, offcenters);\n\t}\n}\nmodule generate_anchors(c_x, c_y, num)\n{\n\twidth = c_x / (num + 1);\n\treset_y = (c_y/2);\n\treset_x =  (width * (num-1))/2;\n\tif ( num > 0)\n\t{\n\ttranslate([-reset_x,reset_y,0])\n\tgen_anchor_span(c_x, c_y, num);\n\t}\n}\nmodule gen_anchor_span(c_x, c_y, num)\n{\n\twidth = c_x / (num + 1);\n\tnumber = num -1;\n\tfor ( x = [0 : number ])\n\t{\n\t\ttranslate([ width * x,0,0])\n\t\tanchors();\n\t}\n}\nmodule generate_harbors(c_x, c_y, num){\n\twidth = c_x / (num + 1);\n\treset_y = (c_y/2) - anchor_target_width/2 - harbor_offset;\n\treset_x =  (width * (num-1))/2;\n\tif(num > 0)\n\t{\n\ttranslate([-reset_x,reset_y,0])\n\tgen_harbor_span(c_x, c_y, num);\n\t}\n}\nmodule gen_harbor_span(c_x, c_y, num){\n\twidth = c_x / (num + 1);\n\tnumber = num -1;\n\tfor ( x = [0 : number ])\n\t{\n\t\ttranslate([ width * x,0,0])\n\t\tharbor();\n\t}\n}\nmodule generate_shafts(c_x, c_y, num){\nwidth = c_x / (num + 1);\n\treset_y = (c_y/2);\n\treset_x =  (width * (num-1))/2;\n\ttranslate([-reset_x,reset_y,0])\n\tif( num > 0)\n\t{\n\tgen_shaft_span(c_x, c_y, num);\n\t}\n}\nmodule gen_shaft_span(c_x, c_y, num){\n\twidth = c_x / (num + 1);\n\tnumber = num -1;\n\tfor ( x = [0 : number ])\n\t{\n\t\ttranslate([ width * x,0,0])\n\t\tshaft();\n\t}\n}\nmodule base(){\n\tcube([cube_x, cube_y, 4], center = true);\n}\nmodule generate_retaining_nut(c_x, c_y, p, t){\n\tfor ( i = [ 0 : 3 ] )\n\t{\n\t\tif ( t[i] == 1)\n\t\t{\n\t\techo(\"POSITIVE:\" ,p[i]);\n\t\tgenerate_pylons(c_x, c_y, p[i]);\n\t\t}else{\n\t\techo(\"NEGATIVE\", p[i]);\n\t\t}\n\t}\n}\nmodule fake_pylon()\n{\n\tcube(pylon_width, center = true);\n}\nmodule anchors()\n{\n\ty_off =  retain_screw_height/2 + anchor_target_width/2;\n\ttranslate([0,- retain_screw_height/2,0])\n\tunion(){\n\ttranslate([retain_screw_od/2 + anchor_width/2, y_off, 0])\n\tcolor(\"Red\")\n\tcube([anchor_width, anchor_target_width, material_z], center = true);\n\ttranslate([-(retain_screw_od/2 + anchor_width/2), y_off, 0])\n\tcolor(\"Orange\")\n\tcube([anchor_width, anchor_target_width, material_z], center = true);\n\t}\n}\nmodule shaft(){\n\ttranslate([0, - (retain_screw_height - anchor_target_width)/2,0])\n\tunion()\n\t{\n\ttranslate([0, -((retain_screw_height - anchor_target_width )/2 - ((retain_screw_height - anchor_target_width ) * channel_bottom)), 0])\n\tcube([retain_nut_od, retain_nut_height, material_z], center = true);\n\tcolor(\"Blue\")\n\tcube([retain_screw_od, retain_screw_height - anchor_target_width, material_z], center = true);\n\t}\n}\nmodule pylon()\n{\n\tunion()\n\t{\n\ttranslate([0, - (retain_screw_height - anchor_target_width)/2,0])\n\tshaft();\n\ttranslate([0,- retain_screw_height/2,0])\n\tanchors();\n\t}\n}\nmodule harbor()\n{\n\tcolor(\"White\")\n\tcube([harbor_width, anchor_target_width, material_z], center = true);\n}\nmodule main()\n{\n\ttranslate([0, cube_y + 5, 0])\n\tcolor(\"Brown\")\n\tdifference()\n\t{\n\tcube([cube_x, cube_y/1.25, anchor_target_width], center = true);\n\ttranslate([0, (cube_y/2) , 0])\n\tharbor();\n\t}\n\tunion()\n\t{\n\tdifference()\n\t{\n\tcube([cube_x,cube_y,material_z], center = true);\n\ttranslate([0,(cube_y/2),0])\n\tshaft();\n\t}\n\ttranslate([0,(cube_y/2),0])\n\tanchors();\n\t}\n}",
    "description": "Okay, I'd like to design a parametric case generator in OpenSCAD. I've seen a design that does almost exactly what I want, but I'd like to take it a little further and also have more control over the overall design.\n\nThe basic idea is to create a box that is built up from flat pieces that are joined using T-slots and screws. I'll give you some parameters and I'd like the design to be parametric based on those.\n\nHere's what I want to be able to configure:\n\n*   **Internal Dimensions:** The internal X, Y, and Z dimensions of the case, so it can fit whatever I want to put inside.\n*   **Material Thickness:** The thickness of the material used to make the case. This will be the thickness of the walls.\n*   **Screw and Nut Dimensions:**\n    *   Outside diameter of the screws.\n    *   Length of the screws.\n    *   Outside diameter of the nuts.\n    *   Height of the nuts.\n*   **Anchor Configuration:** The \"anchors\" are the T-shaped parts that will be pushed into the opposing face of the case.\n    *   Number of anchors on each face.\n    *   Width of the \"teeth\" of the T-shape.\n    *   Position of the nut within the channel for the screw, expressed as a percentage of the channel height.\n*   **Part Selection:** I need to be able to select which parts to generate. I'd want to generate each wall individually, or all of them together in an assembled form, as well as a \"milled\" version. The milled version lays the parts out flat for cutting on a CNC or laser cutter. I'll also want the ability to preview each of the individual walls.\n*   **Overall size**: The case should be slightly bigger than the interior to accommodate the material thickness\n*   **Wall Height**: The walls should all be the same height as the interior Z dimension\n\nThe case will be made up of a bottom, top, and four walls (north, south, east, and west). The bottom and top should be a simple rectangle that encloses the sides and are joined to the sides. Each of the four walls will have the same number of T-shaped \"anchors\" along each edge.\n\nThe basic design is as follows: the walls have a series of T-shaped extrusions (the \"anchors\") along the edges. The top and bottom parts have a corresponding set of matching T-shaped channels (the \"harbors\") to receive these extrusions. The screws go through a hole on the wall piece, and into the channels of the top or bottom piece, which are sized such that the screw holds the two pieces together. I'd like the nut to be trapped within the channel in the top or bottom piece, in a way that allows it to be easily placed without falling out, but also be locked in place by the screw.\n\nI'd also like to make sure that the anchor points along each wall can be offset, or moved closer to or further from the edges, so that we can adjust where the screw joins the mating wall.\n\nI'd like to have it so that these values are all configurable, such that I can easily adjust it in the customizer menu for OpenSCAD.\n\nFinally, I'd like the design to use the MCAD library, specifically for the `projection` command which helps create the flattened \"mill\" layout. I'm not using any other libraries, though feel free to offer an alternative if you think it would be useful.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Split Circle / Torus",
    "scad": "radius = 90;\nthickness = 6;\naddSupport = 1;\ncloseY = 0;\ncloseX = 0;\nsupportThickness = 0.2;\nshowPlatform = 0;\nplatformX = 284;\nplatformY = 154;\ntranslate([radius/3 - closeX,radius/3 + closeY,0])\n\twheelquarter(radius,thickness,addSupport);\nrotate([0,0,180]) translate([radius/3 - closeX,radius/3 + closeY,0])\n\twheelquarter(radius,thickness,addSupport);\nmodule wheelquarter(wheelRadius=120, wheelThickness=6, support=1) {\n\tadded=wheelRadius+wheelThickness/2;\n\tbarSpacing = 10;\n\tdifference() {\n\t\tunion() {\n\t\t\ttranslate([0,0,wheelThickness/2])\n\t\t\t\trotate_extrude() {\n\t\t\t\t  translate([wheelRadius,0,0]) circle(r=wheelThickness/2);\n\t\t\t\t}\n\t\t}\n\t\tcolor(\"red\") cube([added,added,wheelThickness]);\n\t\ttranslate([-added,0,0])color(\"red\") cube([added,added,wheelThickness]);\n\t\ttranslate([-wheelRadius,0.5,wheelThickness/2])\n\t\t\trotate([90,0,0]) scale([0.25,0.25,1])\n\t\t\t\tcylinder(r=wheelThickness,h=wheelThickness/2+0.5);\n\t}\n\ttranslate([wheelRadius,wheelThickness/2,wheelThickness/2])\n\t\trotate([90,0,0]) scale([0.25,0.25,1])\n\t\t\tcylinder(r=wheelThickness,h=wheelThickness/2);\n\tif (support != 0) {\n\t\ttranslate([wheelRadius-supportThickness/2,wheelThickness/2*0.2,0])\n\t\t\tcolor(\"white\") cube([supportThickness,wheelThickness/2*0.8,wheelThickness/4]);\n\t}\n}\nif (showPlatform != 0) {\n\ttranslate([-platformX/2,-platformY/2,-1])\n\t\tcolor(\"gray\") cube([platformX,platformY,0.9]);\n}",
    "description": "Okay, so I have this OpenSCAD file (splitcircle.scad) that makes a split ring, or rather, two quarter-circles with nibs, but I'm looking for something more flexible and customizable.  The current file has a few parameters, but I want to be able to control more aspects of the design, and maybe even create full rings or segments beyond just quarters.\n\nHere's what the existing design does:\n*   It creates two quarter-circle segments of a ring.\n*   Each quarter circle has a 'nib' or connector on the end, kind of like a puzzle piece.\n*   There's an optional support underneath the nib.\n*   It lets you adjust the overall radius of the ring, the thickness of the ring, and the position of the quarter circles.\n*   It also has a somewhat clunky \"platform\" visualizer that's not really needed, and I want a better way to show scale and size.\n\nWhat I'm hoping to achieve is a new parametric OpenSCAD design that includes the following:\n\n1.  **Adjustable Ring Segments:**\n    *   I want to specify a ring segment *angle* instead of being locked into quarter-circles. So, I could make half-circles (180 degrees), quarter-circles (90 degrees) or even much smaller slices.\n    *   I want to specify the number of ring *segments* I use to create the circle (e.g. for a full circle, I should be able to specify 4 quarter circle segments, or 2 half-circle segments, or 8 45-degree segments, etc.).\n    *   This means I don't want the segment placement to be hardcoded like `translate()` and `rotate()`. The code should automatically place the segments according to the number of segments and angle.\n    *   There should be a gap between segments if desired.\n\n2.  **Nib/Connector Customization:**\n    *   I want to specify the shape of the nib, not just be a cylinder, I think I'd like a more rectangular or dovetail shape.\n    *   I want to control the dimensions of the nib (length, width, and height independently, as well as its position and orientation relative to the ring.\n    *   I want the support under the nib to match the shape and style of the nib, if used.\n\n3.  **Platform Options:**\n     *  I would like to be able to include a rectangular platform visualization similar to what I have now, but be able to specify if I want it at all, its dimensions, and also be able to specify the \"offset\" (e.g. if I want it at the same height, underneath the part, above, etc. relative to the rings)\n\n4.  **General Parameters:**\n    *   Ring radius (as in the existing code).\n    *   Ring thickness (as in the existing code).\n    *   Segment gap (as described earlier).\n    *   Individual nib length, width, and height.\n    *   Nib support option (as in the existing code), but I want to be able to control how much larger or smaller it is than the nib dimensions.\n    *   Options to \"bevel\" the edges of the ring (e.g. a chamfer, or a rounded edge).\n    *   All parameters should be easily adjustable and well-commented within the OpenSCAD file.\n    *   The code should be organized well, with modules for each of the basic parts (ring segment, nib, platform), and commented well.\n\n5.  **Library Usage:**\n    *   I'd like you to use the `BOSL2` library if possible as it has lots of nice features. In particular I know it includes chamfering, and better primitives for combining shapes\n\nCould you help me create this parametric OpenSCAD file? I'm looking for the whole code, and not just snippets of code.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Sheriff Star",
    "scad": "use<write/Write.scad>\nradius=32;\nthickness=4;\ntextSize=8;\ntextHeight=1;\nlabelText=\"Sheriff\";\nmodule drawTriangle(rad,thick) {\n  rad=rad/1.15;\n  union() {\n    cylinder(r=rad,thick,center=true, $fn=3);\n    translate([rad,0,0])cylinder(r=rad*.15, thick, center=true, $fn=24);\n    translate([-rad*sin(30),rad*cos(30),0])cylinder(r=rad*.15,thick,center=true, $fn=24);\n    translate([-rad*sin(30),-rad*cos(30),0])cylinder(r=rad*.15,thick,center=true, $fn=24);\n  }\n}\nmodule drawStar(rad,thick){\n  tlen=((2*(rad*(cos(30))))/3)/2;\n  difference(){\n    union() {\n        drawTriangle(rad,thick);\n        rotate([0,0,180]) drawTriangle(rad,thick);\n    }\n    translate([0,tlen,-2*thick+2.5])cube([tlen*2,2.5,thick*3],center=true);\n  }\n}\nunion(){\n  color(\"blue\")rotate([0,0,0])translate([0,0,thickness/2])drawStar(radius,thickness);\n  color(\"red\")translate([0,0,.5*textHeight+thickness])write(labelText,t=textHeight+1,h=textSize,center=true);\n}",
    "description": "Okay, I'd like to create a customizable sheriff's star badge using OpenSCAD. I've seen some examples, and I'd like to be able to tweak a few things.\n\nSpecifically, I need a 5-pointed star with a flat back, not just a star extruded in 2D. I need to be able to adjust:\n\n*   **The overall radius of the star:** I need a parameter for the distance from the center to the tip of the star.\n*   **The thickness of the backing:**  I want to control how thick the flat base of the badge is.\n*   **Text size:** I need to emboss some text onto the front, and I need a parameter to control how large that text is.\n*   **Text embossing height:** I want to control how high the embossed text sticks up from the surface of the badge.\n*   **The text itself:** I need to be able to specify what text is embossed onto the badge.  I'm thinking this would be a single line, maybe with a 64 character limit to avoid getting too crazy.\n*   **A pin slot:**  I need a horizontal slot cut out of the back of the badge, sized for a standard pin or clasp.\n\nThe star should have five distinct points, kind of like a classic sheriff's star. The flat base should be solid, and the text should be centered on top of the star. The slot should be on the back, horizontally oriented, and roughly centered.\n\nI have noticed a library called `Write.scad` that seems to be used for text embossing, and I like that feature!\n\nCould you generate an OpenSCAD file with these parameters exposed so I can easily adjust them in the customizer? Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Modular Hook System",
    "scad": "use <utils/build_plate.scad>\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\ncomponent_type = \"Middle\";\nheight = 50;\nunits = 3;\nunit_1 = \"Blank\";\nunit_2 = \"Blank\";\nunit_3 = \"Blank\";\nunit_4 = \"Blank\";\nunit_5 = \"Blank\";\nunit_6 = \"Blank\";\nscale_factor = height/50;\nthk = 10*scale_factor;\nlength = 80*scale_factor;\nx_shift = length*units/2;\ny_shift = height/2;\nsmooth = 50/scale_factor;\nunion () {\n\tmakeblank ();\n\tif (units > 5) {\n\t\tif (unit_6 == \"Blank\") {\n\t\t} else if (unit_6 == \"Gravity Clamp\") {\n\t\t\tgravity_clamp (5.5*length-x_shift);\n\t\t} else if (unit_6 == \"Hook\") {\n\t\t\tsingle_hook (5.5*length-x_shift);\n\t\t} else if (unit_6 == \"Twin Hook\") {\n\t\t\ttwin_hook (5.5*length-x_shift);\n\t\t} else {\n\t\t\tmake_loop (5.5*length-x_shift);\n\t\t}\n\t}\n\tif (units > 4) {\n\t\tif (unit_5 == \"Blank\") {\n\t\t} else if (unit_5 == \"Gravity Clamp\") {\n\t\t\tgravity_clamp (4.5*length-x_shift);\n\t\t} else if (unit_5 == \"Hook\") {\n\t\t\tsingle_hook (4.5*length-x_shift);\n\t\t} else if (unit_5 == \"Twin Hook\") {\n\t\t\ttwin_hook (4.5*length-x_shift);\n\t\t} else {\n\t\t\tmake_loop (4.5*length-x_shift);\n\t\t}\n\t}\n\tif (units > 3) {\n\t\tif (unit_4 == \"Blank\") {\n\t\t} else if (unit_4 == \"Gravity Clamp\") {\n\t\t\tgravity_clamp (3.5*length-x_shift);\n\t\t} else if (unit_4 == \"Hook\") {\n\t\t\tsingle_hook (3.5*length-x_shift);\n\t\t} else if (unit_4 == \"Twin Hook\") {\n\t\t\ttwin_hook (3.5*length-x_shift);\n\t\t} else {\n\t\t\tmake_loop (3.5*length-x_shift);\n\t\t}\n\t}\n\tif (units > 2) {\n\t\tif (unit_3 == \"Blank\") {\n\t\t} else if (unit_3 == \"Gravity Clamp\") {\n\t\t\tgravity_clamp (2.5*length-x_shift);\n\t\t} else if (unit_3 == \"Hook\") {\n\t\t\tsingle_hook (2.5*length-x_shift);\n\t\t} else if (unit_3 == \"Twin Hook\") {\n\t\t\ttwin_hook (2.5*length-x_shift);\n\t\t} else {\n\t\t\tmake_loop (2.5*length-x_shift);\n\t\t}\n\t}\n\tif (units > 1) {\n\t\tif (unit_2 == \"Blank\") {\n\t\t} else if (unit_2 == \"Gravity Clamp\") {\n\t\t\tgravity_clamp (1.5*length-x_shift);\n\t\t} else if (unit_2 == \"Hook\") {\n\t\t\tsingle_hook (1.5*length-x_shift);\n\t\t} else if (unit_2 == \"Twin Hook\") {\n\t\t\ttwin_hook (1.5*length-x_shift);\n\t\t} else {\n\t\t\tmake_loop (1.5*length-x_shift);\n\t\t}\n\t}\n\tif (unit_1 == \"Blank\") {\n\t} else if (unit_1 == \"Gravity Clamp\") {\n\t\tgravity_clamp (.5*length-x_shift);\n\t} else if (unit_1 == \"Hook\") {\n\t\tsingle_hook (.5*length-x_shift);\n\t} else if (unit_1 == \"Twin Hook\") {\n\t\ttwin_hook (.5*length-x_shift);\n\t} else {\n\t\tmake_loop (.5*length-x_shift);\n\t}\n}\nmodule makeblank() {\n\tdifference() {\n\t\ttranslate ([-x_shift, -y_shift, 0]) cube ([length*units, height, thk]);\n\t\tscrew_hole (thk-x_shift, 3*height/4-y_shift);\n\t\tif ((component_type == \"Solo\") || (component_type == \"End\")) {\n\t\t\tscrew_hole (length*units-thk-x_shift, height/4-y_shift);\n\t\t\tscrew_hole (length*units-thk-x_shift, 3*height/4-y_shift);\n\t\t}\n\t\tif ((component_type == \"Solo\") || (component_type == \"Start\")) {\n\t\t\tscrew_hole (thk-x_shift, height/4-y_shift);\n\t\t}\n\t\tif (component_type == \"Middle\") {\n\t\t\tscrew_hole (length*units-2*thk-x_shift, 3*height/4-y_shift);\n\t\t}\n\t\tif (units > 1) {\n\t\t\tfor (i = [1 : units-1] ) {\n\t\t\t\tscrew_hole (i*length-x_shift, height/2-y_shift);\n\t\t\t}\n\t\t}\n\t\tif ((component_type == \"Middle\") || (component_type == \"End\")) {\n\t\t\tdifference() {\n\t\t\t\ttranslate ([-x_shift, -y_shift, 0]) cube ([thk, height/2, thk]);\n\t\t\t\ttranslate ([thk/2-x_shift, height-y_shift, .28*thk/2]) rotate ([90, 0, 0]) cylinder (h=3*height/4-2*scale_factor, r=.28*thk, center=false, $fn=smooth);\n\t\t\t\ttranslate ([thk/2-x_shift, height/4+3*scale_factor-y_shift, .28*thk/2]) rotate ([90, 0, 0]) cylinder (h=3*scale_factor, r1=.28*thk+scale_factor/2, r2=.28*thk-scale_factor, center=false, $fn=smooth);\n\t\t\t\ttranslate ([thk/2-x_shift, height/4+3*scale_factor-y_shift, .28*thk/2]) rotate ([90, 0, 0]) rotate_extrude (convexity=10, $fn=smooth) translate ([2.5*scale_factor, 0, 0]) circle (r=.87*scale_factor, $fn=smooth);\n\t\t\t}\n\t\t\ttranslate ([thk/2-scale_factor/2-x_shift, -y_shift, 0]) cube ([scale_factor, height/2-2*scale_factor, thk]);\n\t\t}\n\t\tif ((component_type == \"Middle\") || (component_type == \"Start\")) {\n\t\t\ttranslate ([length*units-thk-x_shift, height/2-y_shift, 0]) cube ([thk, height/2, thk]);\n\t\t\ttranslate ([length*units-thk/2-x_shift, height/4-scale_factor-y_shift, .28*thk/2]) rotate ([-90, 0, 0]) cylinder (h=2*height/4+2*scale_factor, r=.30*thk, center=false, $fn=smooth);\n\t\t\ttranslate ([length*units-thk/2-x_shift, height/4+3*scale_factor-y_shift, .28*thk/2]) rotate ([-90, 0, 0]) rotate_extrude (convexity=10, $fn=smooth) translate ([2.5*scale_factor, , 0]) circle (r=scale_factor, $fn=smooth);\n\t\t\ttranslate ([length*units-thk/2-x_shift, height/2-3*scale_factor-y_shift, .28*thk/2]) rotate ([-90, 0, 0]) cylinder (h=3*scale_factor, r1=.28*thk/2, r2=.28*thk+2*scale_factor, center=false, $fn=smooth);\n\t\t}\n\t\tif (component_type == \"Middle\") {\n\t\t\tdifference() {\n\t\t\t\ttranslate ([-thk/2-x_shift, -thk/2-y_shift, thk/2]) cube ([length*units+thk, thk, thk]);\n\t\t\t\ttranslate ([-thk/2-x_shift, thk/2-y_shift, thk/2]) rotate ([0, 90, 0]) cylinder (h=length*units+thk, r=thk/2, center=false, $fn=smooth);\n\t\t\t}\n\t\t\tdifference() {\n\t\t\t\ttranslate ([-thk/2-x_shift, height-thk/2-y_shift, thk/2]) cube ([length*units+thk, thk, thk]);\n\t\t\t\ttranslate ([-thk/2-x_shift, height-thk/2-y_shift, thk/2]) rotate ([0, 90, 0]) cylinder (h=length*units+thk, r=thk/2, center=false, $fn=smooth);\n\t\t\t}\n\t\t} else if (component_type == \"Start\") {\n\t\t\tdifference() {\n\t\t\t\tunion() {\n\t\t\t\t\ttranslate ([-thk/2-x_shift, -thk/2-y_shift, thk/2]) cube ([length*units+thk, thk, thk]);\n\t\t\t\t\ttranslate ([-thk/2-x_shift, -thk/2-y_shift, 0]) cube ([thk, thk, thk]);\n\t\t\t\t\ttranslate ([-thk/2-x_shift, -thk/2-y_shift, thk/2]) cube ([thk, height+thk/2, thk]);\n\t\t\t\t\ttranslate ([-thk/2-x_shift, height-thk/2-y_shift, 0]) cube ([thk, thk, thk]);\n\t\t\t\t\ttranslate ([-thk/2-x_shift, height-thk/2-y_shift, thk/2]) cube ([length*units+thk, thk, thk]);\n\t\t\t\t}\n\t\t\t\ttranslate ([thk/2-x_shift, thk/2-y_shift, thk/2]) sphere (r=thk/2, $fn=smooth);\n\t\t\t\ttranslate ([thk/2-x_shift, height-thk/2-y_shift, thk/2]) sphere (r=thk/2, $fn=smooth);\n\t\t\t\ttranslate ([thk/2-x_shift, thk/2-y_shift, thk/2]) rotate ([0, 90, 0]) cylinder (h=length*units+thk/2, r=thk/2, center=false, $fn=smooth);\n\t\t\t\ttranslate ([thk/2-x_shift, thk/2-y_shift, thk/2]) rotate ([-90, 0, 0]) cylinder (h=height-thk, r=thk/2, center=false, $fn=smooth);\n\t\t\t\ttranslate ([thk/2-x_shift, height-thk/2-y_shift, thk/2]) rotate ([0, 90, 0]) cylinder (h=length*units+thk/2, r=thk/2, center=false, $fn=smooth);\n\t\t\t\ttranslate ([thk/2-x_shift, thk/2-y_shift, 0]) cylinder (h=thk/2, r=thk/2, center=false, $fn=smooth);\n\t\t\t\ttranslate ([thk/2-x_shift, height-thk/2-y_shift, 0]) cylinder (h=thk/2, r=thk/2, center=false, $fn=smooth);\n\t\t\t}\n\t\t} else if (component_type == \"End\") {\n\t\t\tdifference() {\n\t\t\t\tunion() {\n\t\t\t\t\ttranslate ([-thk/2-x_shift, -thk/2-y_shift, thk/2]) cube ([length*units+thk, thk, thk]);\n\t\t\t\t\ttranslate ([length*units-thk/2-x_shift, -thk/2-y_shift, 0]) cube ([thk, thk, thk]);\n\t\t\t\t\ttranslate ([length*units-thk/2-x_shift, -thk/2-y_shift, thk/2]) cube ([thk, height+thk/2, thk]);\n\t\t\t\t\ttranslate ([length*units-thk/2-x_shift, height-thk/2-y_shift, 0]) cube ([thk, thk, thk]);\n\t\t\t\t\ttranslate ([-thk/2-x_shift, height-thk/2-y_shift, thk/2]) cube ([length*units+thk, thk, thk]);\n\t\t\t\t}\n\t\t\t\ttranslate ([length*units-thk/2-x_shift, thk/2-y_shift, thk/2]) sphere (r=thk/2, $fn=smooth);\n\t\t\t\ttranslate ([length*units-thk/2-x_shift, height-thk/2-y_shift, thk/2]) sphere (r=thk/2, $fn=smooth);\n\t\t\t\ttranslate ([-thk/2-x_shift, thk/2-y_shift, thk/2]) rotate ([0, 90, 0]) cylinder (h=length*units, r=thk/2, center=false, $fn=smooth);\n\t\t\t\ttranslate ([length*units-thk/2-x_shift, thk/2-y_shift, thk/2]) rotate ([-90, 0, 0]) cylinder (h=height-thk, r=thk/2, center=false, $fn=smooth);\n\t\t\t\ttranslate ([-thk/2-x_shift, height-thk/2-y_shift, thk/2]) rotate ([0, 90, 0]) cylinder (h=length*units, r=thk/2, center=false, $fn=smooth);\n\t\t\t\ttranslate ([length*units-thk/2-x_shift, thk/2-y_shift, 0]) cylinder (h=thk/2, r=thk/2, center=false, $fn=smooth);\n\t\t\t\ttranslate ([length*units-thk/2-x_shift, height-thk/2-y_shift, 0]) cylinder (h=thk/2, r=thk/2, center=false, $fn=smooth);\n\t\t\t}\n\t\t} else {\n\t\t\tdifference() {\n\t\t\t\tunion() {\n\t\t\t\t\ttranslate ([-thk/2-x_shift, -thk/2-y_shift, thk/2]) cube ([length*units+thk, thk, thk]);\n\t\t\t\t\ttranslate ([-thk/2-x_shift, height-thk/2-y_shift, thk/2]) cube ([length*units+thk, thk, thk]);\n\t\t\t\t\ttranslate ([-thk/2-x_shift, -thk/2-y_shift, thk/2]) cube ([thk, height+thk/2, thk]);\n\t\t\t\t\ttranslate ([length*units-thk/2-x_shift, -thk/2-y_shift, thk/2]) cube ([thk, height+thk/2, thk]);\n\t\t\t\t\ttranslate ([-thk/2-x_shift, -thk/2-y_shift, 0]) cube ([thk, thk, thk]);\n\t\t\t\t\ttranslate ([-thk/2-x_shift, height-thk/2-y_shift, 0]) cube ([thk, thk, thk]);\n\t\t\t\t\ttranslate ([length*units-thk/2-x_shift, -thk/2-y_shift, 0]) cube ([thk, thk, thk]);\n\t\t\t\t\ttranslate ([length*units-thk/2-x_shift, height-thk/2-y_shift, 0]) cube ([thk, thk, thk]);\n\t\t\t\t}\n\t\t\t\ttranslate ([thk/2-x_shift, thk/2-y_shift, thk/2]) sphere (r=thk/2, $fn=smooth);\n\t\t\t\ttranslate ([thk/2-x_shift, height-thk/2-y_shift, thk/2]) sphere (r=thk/2, $fn=smooth);\n\t\t\t\ttranslate ([length*units-thk/2-x_shift, thk/2-y_shift, thk/2]) sphere (r=thk/2, $fn=smooth);\n\t\t\t\ttranslate ([length*units-thk/2-x_shift, height-thk/2-y_shift, thk/2]) sphere (r=thk/2, $fn=smooth);\n\t\t\t\ttranslate ([thk/2-x_shift, thk/2-y_shift, thk/2]) rotate ([0, 90, 0]) cylinder (h=length*units-thk, r=thk/2, center=false, $fn=smooth);\n\t\t\t\ttranslate ([thk/2-x_shift, height-thk/2-y_shift, thk/2]) rotate ([0, 90, 0]) cylinder (h=length*units-thk, r=thk/2, center=false, $fn=smooth);\n\t\t\t\ttranslate ([thk/2-x_shift, thk/2-y_shift, thk/2]) rotate ([-90, 0, 0]) cylinder (h=height-thk, r=thk/2, center=false, $fn=smooth);\n\t\t\t\ttranslate ([length*units-thk/2-x_shift, thk/2-y_shift, thk/2]) rotate ([-90, 0, 0]) cylinder (h=height-thk, r=thk/2, center=false, $fn=smooth);\n\t\t\t\ttranslate ([thk/2-x_shift, thk/2-y_shift, 0]) cylinder (h=thk/2, r=thk/2, center=false, $fn=smooth);\n\t\t\t\ttranslate ([thk/2-x_shift, height-thk/2-y_shift, 0]) cylinder (h=thk/2, r=thk/2, center=false, $fn=smooth);\n\t\t\t\ttranslate ([length*units-thk/2-x_shift, thk/2-y_shift, 0]) cylinder (h=thk/2, r=thk/2, center=false, $fn=smooth);\n\t\t\t\ttranslate ([length*units-thk/2-x_shift, height-thk/2-y_shift, 0]) cylinder (h=thk/2, r=thk/2, center=false, $fn=smooth);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule screw_hole (x_loc, y_loc) {\n\tif (height < 25) {\n\t\ttranslate ([x_loc, y_loc, 0]) cylinder (h=thk, r=2/2, center=false);\n\t\ttranslate ([x_loc, y_loc, thk-1.2]) cylinder (h=1.2+.1, r1=2/2, r2=3.8/2+.05, center=false);\n\t} else if (height < 30) {\n\t\ttranslate ([x_loc, y_loc, 0]) cylinder (h=thk, r=2.5/2, center=false);\n\t\ttranslate ([x_loc, y_loc, thk-1.5]) cylinder (h=1.5+.1, r1=2.5/2, r2=4.7/2+.05, center=false);\n\t} else if (height < 35) {\n\t\ttranslate ([x_loc, y_loc, 0]) cylinder (h=thk, r=3/2, center=false);\n\t\ttranslate ([x_loc, y_loc, thk-1.65]) cylinder (h=1.65+.1, r1=3/2, r2=5.6/2+.05, center=false);\n\t} else if (height < 40) {\n\t\ttranslate ([x_loc, y_loc, 0]) cylinder (h=thk, r=3.5/2, center=false);\n\t\ttranslate ([x_loc, y_loc, thk-2.3]) cylinder (h=2.3+.1, r1=3.5/2, r2=6.5/2+.05, center=false);\n\t} else if (height < 50) {\n\t\ttranslate ([x_loc, y_loc, 0]) cylinder (h=thk, r=4/2, center=false);\n\t\ttranslate ([x_loc, y_loc, thk-2.7]) cylinder (h=2.7+.1, r1=4/2, r2=7.5/2+.05, center=false);\n\t} else if (height < 60) {\n\t\ttranslate ([x_loc, y_loc, 0]) cylinder (h=thk, r=5/2, center=false);\n\t\ttranslate ([x_loc, y_loc, thk-2.5]) cylinder (h=2.5+.1, r1=5/2, r2=9.2/2+.05, center=false);\n\t} else {\n\t\ttranslate ([x_loc, y_loc, 0]) cylinder (h=thk, r=6/2, center=false);\n\t\ttranslate ([x_loc, y_loc, thk-3]) cylinder (h=3, r1=6/2+.1, r2=11/2+.05, center=false);\n\t}\n}\nmodule single_hook (x_loc) {\n\tunion () {\n\t\ttranslate ([x_loc, height/2-y_shift, thk]) sphere (r=thk/2, $fn=smooth);\n\t\ttranslate ([x_loc, height/2-y_shift, thk]) rotate ([90, 0, 0]) cylinder (h=height/4, r=thk/2, $fn=smooth);\n\t\tdifference () {\n\t\t\ttranslate ([x_loc, height/4-y_shift, 2.5*thk]) rotate ([0, -90, 0]) rotate_extrude (convexity=10, $fn=smooth) translate ([1.5*thk, 0, 0]) circle (r=thk/2, $fn=smooth);\n\t\t\ttranslate ([x_loc-thk, height/4-y_shift, 0]) cube ([2*thk, 2.5*thk, 5*thk]);\n\t\t}\n\t\ttranslate ([x_loc, height/4-y_shift, 4*thk]) sphere (r=thk/2, $fn=smooth);\n\t}\n}\nmodule twin_hook (x_loc) {\n\ttheta = 90;\n\tunion () {\n\t\ttranslate ([x_loc, height/2-y_shift, thk]) sphere (r=thk/2, $fn=smooth);\n\t\ttranslate ([x_loc, height/2-y_shift, thk]) rotate ([90, 0, 0]) cylinder (h=height/4, r=thk/2, $fn=smooth);\n\t\tdifference () {\n\t\t\ttranslate ([x_loc+(1.5*thk*cos(theta/2)), height/4-y_shift, 2.5*thk-(1.5*thk-1.5*thk*sin(theta/2))]) rotate ([0, -theta/2, 0]) rotate_extrude (convexity=10, $fn=smooth) translate ([1.5*thk,0,  0]) circle (r=thk/2, $fn=smooth);\n\t\t\ttranslate ([x_loc, height/4-y_shift, -thk/2]) rotate ([0, -theta/2, 0]) cube ([5*thk, 2.5*thk, 2*thk]);\n\t\t}\n\t\ttranslate ([x_loc+(3*thk*cos(theta/2)), height/4-y_shift, 4*thk-2*(1.5*thk-1.5*thk*sin(theta/2))]) sphere (r=thk/2, $fn=smooth);\n\t\tdifference () {\n\t\t\ttranslate ([x_loc-(1.5*thk*cos(theta/2)), height/4-y_shift, 2.5*thk-(1.5*thk-1.5*thk*sin(theta/2))]) rotate ([0, theta/2, 0]) rotate_extrude (convexity=10, $fn=smooth) translate ([1.5*thk, 0, 0]) circle (r=thk/2, $fn=smooth);\n\t\t\ttranslate ([x_loc, height/4-y_shift, -thk/2]) rotate ([0, -theta/2, 0]) cube ([2*thk, 2.5*thk, 5*thk]);\n\t\t}\n\t\ttranslate ([x_loc-(3*thk*cos(theta/2)), height/4-y_shift, 4*thk-2*(1.5*thk-1.5*thk*sin(theta/2))]) sphere (r=thk/2, $fn=smooth);\n\t}\n}\nmodule make_loop (x_loc) {\n\ttranslate ([x_loc, height/2-y_shift, 2*thk]) rotate ([90, 0, 0]) rotate_extrude (convexity=10, $fn=smooth) translate ([1.5*thk, 0, 0]) circle (r=thk/2, $fn=smooth);\n}\nmodule gravity_clamp (x_loc) {\n\txone = x_loc+2.5*thk;\n\tyone = height/2-thk/2-y_shift;\n\txtwo = x_loc+2.5*thk-sqrt(pow(1.63*thk, 2)/2)+.3*thk/2*sin(30)+1.63*thk*cos(30);\n\tytwo = height/2-thk/2-y_shift-sqrt(pow(1.63*thk, 2)/2)-.3*thk/2*cos(30)+1.63*thk*sin(30);\n\tcam_rad = sqrt(pow(xtwo-xone, 2) + pow(ytwo-yone, 2));\n\tunion () {\n\t\tdifference () {\n\t\t\ttranslate ([x_loc-2.5*thk, height/4-y_shift, thk/2]) cube ([thk, height/2, 2.5*thk]);\n\t\t\tdifference () {\n\t\t\t\tunion () {\n\t\t\t\t\ttranslate ([x_loc-2.5*thk-thk/4, height/4-y_shift+thk/4, 3*thk-thk/4]) cube ([2*thk/4, height/2-2*thk/4, 2*thk/4]);\n\t\t\t\t\ttranslate ([x_loc-1.5*thk-thk/4, height/4-y_shift+thk/4, 3*thk-thk/4]) cube ([2*thk/4, height/2-2*thk/4, 2*thk/4]);\n\t\t\t\t\ttranslate ([x_loc-2.5*thk-thk/4, height/4-y_shift-thk/4, 3*thk-thk/4]) cube ([thk+2*thk/4, 2*thk/4, 2*thk/4]);\n\t\t\t\t\ttranslate ([x_loc-2.5*thk-thk/4, 3*height/4-y_shift-thk/4, 3*thk-thk/4]) cube ([thk+2*thk/4, 2*thk/4, 2*thk/4]);\n\t\t\t\t\ttranslate ([x_loc-2.5*thk-thk/4, height/4-y_shift-thk/4, thk/2]) cube ([2*thk/4, 2*thk/4, 2.5*thk+thk/4]);\n\t\t\t\t\ttranslate ([x_loc-1.5*thk-thk/4, height/4-y_shift-thk/4, thk/2]) cube ([2*thk/4, 2*thk/4, 2.5*thk+thk/4]);\n\t\t\t\t\ttranslate ([x_loc-2.5*thk-thk/4, 3*height/4-y_shift-thk/4, thk/2]) cube ([2*thk/4, 2*thk/4, 2.5*thk+thk/4]);\n\t\t\t\t\ttranslate ([x_loc-1.5*thk-thk/4, 3*height/4-y_shift-thk/4, thk/2]) cube ([2*thk/4, 2*thk/4, 2.5*thk+thk/4]);\n\t\t\t\t}\n\t\t\t\ttranslate ([x_loc-2.5*thk+thk/4, height/4-y_shift+thk/4, 3*thk-thk/4]) sphere (r=thk/4, $fn=smooth);\n\t\t\t\ttranslate ([x_loc-1.5*thk-thk/4, height/4-y_shift+thk/4, 3*thk-thk/4]) sphere (r=thk/4, $fn=smooth);\n\t\t\t\ttranslate ([x_loc-2.5*thk+thk/4, 3*height/4-y_shift-thk/4, 3*thk-thk/4]) sphere (r=thk/4, $fn=smooth);\n\t\t\t\ttranslate ([x_loc-1.5*thk-thk/4, 3*height/4-y_shift-thk/4, 3*thk-thk/4]) sphere (r=thk/4, $fn=smooth);\n\t\t\t\ttranslate ([x_loc-2.5*thk+thk/4, height/4-y_shift+thk/4, 3*thk-thk/4]) rotate ([-90, 0, 0]) cylinder (h=height/2-thk/2, r=thk/4, center=false, $fn=smooth);\n\t\t\t\ttranslate ([x_loc-1.5*thk-thk/4, height/4-y_shift+thk/4, 3*thk-thk/4]) rotate ([-90, 0, 0]) cylinder (h=height/2-thk/2, r=thk/4, center=false, $fn=smooth);\n\t\t\t\ttranslate ([x_loc-1.5*thk-thk/4, height/4-y_shift+thk/4, 3*thk-thk/4]) rotate ([0, -90, 0]) cylinder (h=thk-thk/2, r=thk/4, center=false, $fn=smooth);\n\t\t\t\ttranslate ([x_loc-1.5*thk-thk/4, 3*height/4-y_shift-thk/4, 3*thk-thk/4]) rotate ([0, -90, 0]) cylinder (h=thk-thk/2, r=thk/4, center=false, $fn=smooth);\n\t\t\t\ttranslate ([x_loc-2.5*thk+thk/4, height/4-y_shift+thk/4, thk/2]) rotate ([0, 0, 90]) cylinder (h=2.5*thk-thk/4, r=thk/4, center=false, $fn=smooth);\n\t\t\t\ttranslate ([x_loc-1.5*thk-thk/4, height/4-y_shift+thk/4, thk/2]) rotate ([0, 0, 90]) cylinder (h=2.5*thk-thk/4, r=thk/4, center=false, $fn=smooth);\n\t\t\t\ttranslate ([x_loc-2.5*thk+thk/4, 3*height/4-y_shift-thk/4, thk/2]) rotate ([0, 0, 90]) cylinder (h=2.5*thk-thk/4, r=thk/4, center=false, $fn=smooth);\n\t\t\t\ttranslate ([x_loc-1.5*thk-thk/4, 3*height/4-y_shift-thk/4, thk/2]) rotate ([0, 0, 90]) cylinder (h=2.5*thk-thk/4, r=thk/4, center=false, $fn=smooth);\n\t\t\t}\n\t\t}\n\t\tdifference () {\n\t\t\tunion () {\n\t\t\t\ttranslate ([x_loc+2.5*thk-sqrt(pow(1.63*thk, 2)/2), height/2-thk/2-y_shift+sqrt(pow(1.63*thk, 2)/2), thk+scale_factor/2]) cylinder (h=2*thk-scale_factor/2, r=.3*thk/2, $fn=smooth);\n\t\t\t\tfor (n = [30:10:60]) {\n\t\t\t\t\ttranslate ([x_loc+2.5*thk-sqrt(pow(1.63*thk, 2)/2)-.3*thk/2*sin(n), height/2-thk/2-y_shift+sqrt(pow(1.63*thk, 2)/2)-.3*thk/2*cos(n), thk+scale_factor/2]) rotate ([0, 0, -n]) cube ([1.63*thk, .3*thk, 2*thk-scale_factor/2]);\n\t\t\t\t}\n\t\t\t\ttranslate ([x_loc+2.5*thk, height/2-thk/2-y_shift, thk+scale_factor/2]) cylinder (h=2*thk-scale_factor/2, r=cam_rad, $fn=smooth);\n\t\t\t}\n\t\t\ttranslate ([x_loc+2.5*thk, height/2-thk/2-y_shift, thk]) cylinder (h=2*thk+scale_factor, r=thk/4+scale_factor/4, $fn=smooth);\n\t\t}\n\t\ttranslate ([x_loc+2.5*thk, height/2-thk/2-y_shift, thk/2]) cylinder (h=2.5*thk+scale_factor, r=thk/4, $fn=smooth);\n\t\tdifference () {\n\t\t\ttranslate ([x_loc+2.5*thk, height/2-thk/2-y_shift, 3*thk+scale_factor/2]) sphere (r=3*thk/8, $fn=smooth);\n\t\t\ttranslate ([x_loc+2.5*thk, height/2-thk/2-y_shift, 0]) rotate ([0, 0, 90]) cylinder (h=3*thk+scale_factor/2, r=3*thk/8, $fn=smooth);\n\t\t}\n\t}\n}",
    "description": "Okay, I'm looking to create a modular hook system that I can customize for different uses, from small keys to larger tools. I want to be able to print multiple units and connect them together, then screw them to a wall. I've already got a basic design in mind, but I'd like you to help me create a parametric OpenSCAD file that is flexible.\n\nHere's what I'm envisioning:\n\n**Basic Structure:**\n\n*   **Modular Units:** The system will be made up of individual units that can be connected end-to-end. Each unit will consist of a base plate with connection points and a configurable hook/storage element.\n*   **Base Plate:** The base plate should have screw holes for mounting to a wall and alignment pins/holes to connect to other units. It should have options for start, middle, end, and solo units for appropriate pin/hole configurations.\n*  **Height:** The base plate height should be variable with a default of 50mm, but I'd like to be able to adjust this value between 20 and 80 mm.\n*   **Length:** The base plate length will scale with the number of units (and height).\n*   **Thickness:** The base plate should have a thickness that also scales with the height.\n*   **Units per Module:** I'd like to be able to select the number of units per module, ranging from 1 to 6 (so a module could have 1 to 6 individual hooks/storage elements).\n*  **Build Plate:** For visual preview purposes, a build plate outline from the `utils/build_plate.scad` library should be used with options for Replicator 2, Replicator, Thingomatic, or a custom manual size. When selecting \"manual,\" I'd like to define the X and Y dimensions.\n\n**Hook/Storage Elements (Each Unit Can Have One):**\n\n*   **Blank:**  An empty space where no hook or storage element exists.\n*   **Single Hook:** A basic hook for hanging items.\n*   **Twin Hook:** A double hook for greater holding capacity.\n*   **Ring:** A loop for attaching things.\n*   **Gravity Clamp:** A unique hook that uses a gravity-activated cam for holding items.\n\n**Parametric Control:**\n\n*   I need to be able to control the overall height of the base plate. This will influence the scaling of the entire model.\n*   I need to choose the number of units in the modular part (1-6), and each unit should be individually configurable. So for a 3 unit part I should be able to set unit 1 as a hook, unit 2 as a twin hook, and unit 3 as a blank, for example.\n*   The screw hole sizes should automatically adjust based on the height parameter, providing appropriate sizes for M2 to M6 screws. I need a module that can cut the appropriate holes based on the height parameter.\n*   The pin sizes should also be scaled based on the height parameter.\n*   I want to round the edges of the base plate and pin features to reduce sharpness and improve aesthetics.\n*   The pin size should be appropriate for a tight fit between units.\n\n**Libraries:**\n*   I will need the build plate library: `utils/build_plate.scad`.\n\n**Other Requirements:**\n\n*   The model should be easy to print on a typical FDM 3D printer.\n*   It would be great to have a preview with a north view and a top diagonal tilt for a good overview of the model.\n*   I'd like the design to be flexible enough to allow for future additions or modifications.\n\nI think that's a pretty comprehensive overview. I'm really looking forward to seeing what you come up with!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Tower of 3D Skill Badges",
    "scad": "use <MCAD/boxes.scad>\nuse <utils/build_plate.scad>\nuse <write/Write.scad>\ndebug_flag = false;\nstack_this_high = 4;\necho ( \"stack_this_high\" , stack_this_high );\ninitial_cube_size = 80;\necho ( \"initial_cube_size\" , initial_cube_size );\nleft_side_text = \"6050\";\necho ( \"left_side_text\" , left_side_text );\nright_side_text = \"T o M\";\necho ( \"right_side_text\" , right_side_text );\nback_side_text = str(\"B\",\"\");\necho ( \"back_side_text\" , back_side_text );\nshow_badge_count=false;\necho ( \"show_badge_count\" , show_badge_count );\nrotate_this_way=1;\necho ( \"rotate_this_way\" , rotate_this_way );\nwindow_cutout_size = 75;\necho ( \"initial_cube_size\" , initial_cube_size );\npylon_size = 100;\necho ( \"pylon_size\" , pylon_size );\nzstretch = 25;\necho( \"zstretch\" , zstretch );\npolygon_count = 16;\necho( \"Print Quality / Polygon Count\" , polygon_count );\nprint_layer_thickness = 3+0;\necho ( \"print_layer_thickness\" , print_layer_thickness );\nbuild_plate_selector = 2;\nbuild_plate_manual_x = 100 + 0;\nbuild_plate_manual_y = 100 + 0;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\npi_value = 3.14159 *1;\necho ( \"Pi\" , pi_value );\nbelfry_b_logo = str( \"B\", \"\" );\necho ( \"belfry_b_logo\" , belfry_b_logo );\nfudge_factor = 0 + 0.001;\necho ( \"fudge_factor\" , fudge_factor );\nlayerthickness = [0.30,0.29,0.28,0.27,0.26,0.25];\necho ( \"layerthickness\" , layerthickness );\nlayer_thickness = layerthickness[ print_layer_thickness ];\necho ( \"layer_thickness\" , layer_thickness );\ncubex=initial_cube_size;\ncubey=initial_cube_size;\ncubez=initial_cube_size*(zstretch/100);\necho ( \"cubex\" , cubex , \"cubey\" , cubey , \"cubez\" , cubez );\ncut_size=1.25*1;\necho ( \"cut_size\" , cut_size );\nhowthick=(window_cutout_size/100);\necho ( \"howthick\" , howthick );\nedgehowthick=(1-((1-howthick)/2));\necho ( \"edgehowthick\" , edgehowthick );\ncubeholex=cubex*cut_size;\ncubeholey=cubey*howthick;\ncubeholez=cubez*howthick;\necho ( \"cubeholex\" , cubeholex , \"cubeholey\" , cubeholey , \"cubeholez\" , cubeholez );\ncubeholex1=cubex*howthick;\ncubeholey1=cubey*cut_size;\ncubeholez1=cubez*howthick;\necho ( \"cubeholex1\" , cubeholex1 , \"cubeholey1\" , cubeholey1 , \"cubeholez1\" , cubeholez1 );\ncubeholex2=cubex*edgehowthick;\ncubeholey2=cubey*edgehowthick;\ncubeholez2=cubez*cut_size;\necho ( \"cubeholex2\" , cubeholex2 , \"cubeholey2\" , cubeholey2 , \"cubeholez2\" , cubeholez2 );\ncorner_radius=(1-((1-edgehowthick)/2));\necho ( \"corner_radius\" , corner_radius );\nscale_factor=0.75*1;\necho ( \"scale_factor\" , scale_factor );\nbadge_zoffset = [0,0,\ncalc_pylon_height(for_badge_level=1),\ncalc_pylon_height(for_badge_level=1)+\n\tcalc_pylon_height(for_badge_level=2),\ncalc_pylon_height(for_badge_level=1)+\n\tcalc_pylon_height(for_badge_level=2)+\n\tcalc_pylon_height(for_badge_level=3),\ncalc_pylon_height(for_badge_level=1)+\n\tcalc_pylon_height(for_badge_level=2)+\n\tcalc_pylon_height(for_badge_level=3)+\n\tcalc_pylon_height(for_badge_level=4),\ncalc_pylon_height(for_badge_level=1)+\n\tcalc_pylon_height(for_badge_level=2)+\n\tcalc_pylon_height(for_badge_level=3)+\n\tcalc_pylon_height(for_badge_level=4)+\n\tcalc_pylon_height(for_badge_level=5),\ncalc_pylon_height(for_badge_level=1)+\n\tcalc_pylon_height(for_badge_level=2)+\n\tcalc_pylon_height(for_badge_level=3)+\n\tcalc_pylon_height(for_badge_level=4)+\n\tcalc_pylon_height(for_badge_level=5)+\n\tcalc_pylon_height(for_badge_level=6),\ncalc_pylon_height(for_badge_level=1)+\n\tcalc_pylon_height(for_badge_level=2)+\n\tcalc_pylon_height(for_badge_level=3)+\n\tcalc_pylon_height(for_badge_level=4)+\n\tcalc_pylon_height(for_badge_level=5)+\n\tcalc_pylon_height(for_badge_level=6)+\n\tcalc_pylon_height(for_badge_level=7),\ncalc_pylon_height(for_badge_level=1)+\n\tcalc_pylon_height(for_badge_level=2)+\n\tcalc_pylon_height(for_badge_level=3)+\n\tcalc_pylon_height(for_badge_level=4)+\n\tcalc_pylon_height(for_badge_level=5)+\n\tcalc_pylon_height(for_badge_level=6)+\n\tcalc_pylon_height(for_badge_level=7)+\n\tcalc_pylon_height(for_badge_level=8),\ncalc_pylon_height(for_badge_level=1)+\n\tcalc_pylon_height(for_badge_level=2)+\n\tcalc_pylon_height(for_badge_level=3)+\n\tcalc_pylon_height(for_badge_level=4)+\n\tcalc_pylon_height(for_badge_level=5)+\n\tcalc_pylon_height(for_badge_level=6)+\n\tcalc_pylon_height(for_badge_level=7)+\n\tcalc_pylon_height(for_badge_level=8)+\n\tcalc_pylon_height(for_badge_level=9),\ncalc_pylon_height(for_badge_level=1)+\n\tcalc_pylon_height(for_badge_level=2)+\n\tcalc_pylon_height(for_badge_level=3)+\n\tcalc_pylon_height(for_badge_level=4)+\n\tcalc_pylon_height(for_badge_level=5)+\n\tcalc_pylon_height(for_badge_level=6)+\n\tcalc_pylon_height(for_badge_level=7)+\n\tcalc_pylon_height(for_badge_level=8)+\n\tcalc_pylon_height(for_badge_level=9)+\n\tcalc_pylon_height(for_badge_level=10)\n];\necho ( \"badge_zoffset\" , badge_zoffset );\necho ( \"<<<<<<<<<<<<<<<<<<<  start of the program >>>>>>>>>>>>>>>>>>>>>>\" );\n{\nfor ( tower_count=[1:stack_this_high] )\n{\n\techo(\"tower_count\",tower_count);\n\tmake_this_badge( badge_number = tower_count );\n}\n\t\t\tif ( debug_flag == false )\n\t\t\t{\n\t\t\t}\n\t\t\tif ( debug_flag == false )\n\t\t\t{\n\t\t\t}\n}\necho (\"end of program\" );\nmodule start_with_a_cube(include_towers=true,badgecount=1)\n{\necho ( \"start_with_a_cube() module\" );\ndifference()\n{\nunion()\n{\nbadge_top_cube();\ntranslate([0,0,(fudge_factor-(cubez*scale_factor))])\n\tbadge_bottom_cube();\n}\ntranslate([0,-((cubey/2)+(0.25*(cubey*(1-edgehowthick)))),-(cubez*0.75)+(0.50*(cubez*(1-edgehowthick)))]) write(\"3D\",center=true,rotate=[90,0,0],h=(cubez*0.50),t=cubex*(1-edgehowthick));\nif ( show_badge_count == true )\n{\ntranslate([0,((cubey/2)+(0.25*(cubey*(1-edgehowthick)))),-(cubez*0.75)+(0.50*(cubez*(1-edgehowthick)))]) write(str(back_side_text,badgecount),center=true,rotate=[90,0,180],h=(cubez*0.50),t=cubex*(1-edgehowthick));\n}\nelse\n{\ntranslate([0,((cubey/2)+(0.25*(cubey*(1-edgehowthick)))),-(cubez*0.75)+(0.50*(cubez*(1-edgehowthick)))]) write(back_side_text,center=true,rotate=[90,0,180],h=(cubez*0.50),t=cubex*(1-edgehowthick));\n}\ntranslate([-((cubey/2)+(0.25*(cubey*(1-edgehowthick)))),0,-(cubez*0.75)+(0.50*(cubez*(1-edgehowthick)))]) write(str(left_side_text),center=true,rotate=[90,0,270],h=(cubez*0.50),t=cubex*(1-edgehowthick));\ntranslate([((cubey/2)+(0.25*(cubey*(1-edgehowthick)))),0,-(cubez*0.75)+(0.50*(cubez*(1-edgehowthick)))]) write(str(right_side_text),center=true,rotate=[90,0,90],h=(cubez*0.50),t=cubex*(1-edgehowthick));\n}\nif (include_towers == true )\n{\ncylinder_towers();\n}\n}\nmodule badge_bottom_cube()\n{\ndifference()\n{\nroundedBox( [cubex,cubey,(cubez*0.50)] , cubex*(1-(corner_radius)) , true , $fn=polygon_count );\ntranslate( [0,0,fudge_factor-((cubez*(1-edgehowthick))*0.50)] )\n\tcube([cubeholex2,cubeholey2,(cubez*0.50)],center=true);\n}\ntranslate([0,0,(cubez*0.25)+((cubez*(1-edgehowthick))/2)-fudge_factor])\n\troundedBox( [((cubex*edgehowthick)*0.50),((cubey*edgehowthick)*0.50),(cubez*(1-edgehowthick))] , ((cubex*edgehowthick)*0.50)*(1-(corner_radius)) , true , $fn=polygon_count );\ntranslate([0,0,(cubez*0.25)+((cubez*(1-edgehowthick))*1.5)-(fudge_factor*2)]) write(\"3D\",center=true,t=(cubez*(1-edgehowthick)),h=(((cubey*edgehowthick)*0.50)*0.70));\n}\nmodule badge_top_cube()\n{\necho (\"module badge_top_cube()\");\ndifference()\n{\nroundedBox([cubex,cubey,cubez], cubex*(1-(corner_radius)), true , $fn=polygon_count);\ntranslate([0,0,0]) cube( [cubeholex,cubeholey,cubeholez] , center=true );\ntranslate([0,0,0]) cube( [cubeholex1,cubeholey1,cubeholez1] , center=true );\ncube([cubeholex2,cubeholey2,cubeholez2],center=true );\n}\n}\nmodule cylinder_tower()\n{\necho (\"module cylinder_tower()\");\necho( \"radius\" , cubex*(1-(corner_radius))*scale_factor );\n\tcylinder(h=(cubez*(pylon_size/100))+(2*fudge_factor),r=((cubex*(1-(corner_radius)))*scale_factor),center=false,$fn=polygon_count);\n}\nmodule cylinder_towers()\n{\necho (\"module cylinder_towers()\");\necho( \"radius\" , cubex*(1-(corner_radius)) );\ntower_radius = ((cubex*(1-(corner_radius)))*scale_factor);\necho ( \"tower_radius\" , tower_radius );\ntower_offset = (cubex*(scale_factor/2))-tower_radius;\necho ( \"tower_offset\" , tower_offset );\ntower_z_offset = (cubez/2)-cubez-fudge_factor;\necho (\"tower_z_offset\" , tower_z_offset );\n{\nunion()\n{\ntranslate([tower_offset,tower_offset,tower_z_offset])\n\tcylinder_tower();\ntranslate([tower_offset,-tower_offset,tower_z_offset])\n\tcylinder_tower();\ntranslate([-tower_offset,tower_offset,tower_z_offset])\n\tcylinder_tower();\ntranslate([-tower_offset,-tower_offset,tower_z_offset])\n\tcylinder_tower();\n}\n}\n}\nmodule make_this_badge( badge_number = 1 )\n{\necho ( \"start make_this_badge module\" , badge_number );\ntranslate([0,0,move_2_zero(what_badge=badge_number)])\ntranslate([0,0,badge_zoffset[badge_number]])\nrotate([0,0,(90*rotate_this_way)*(badge_number-1)])\n\tscale(pow(scale_factor,badge_number-1))\n\tstart_with_a_cube(include_towers=(stack_this_high>=badge_number+1),badgecount=badge_number);\n}\nfunction move_2_zero(what_badge) = (cubez*pow(scale_factor,what_badge-1))-fudge_factor;\necho(\"Move_2_zero \", move_2_zero(what_badge=1));\nfunction calc_pylon_height(for_badge_level=1) = ((pow(scale_factor , for_badge_level-1)*(cubez/2))+(pow(scale_factor,for_badge_level-1)*(cubez*(pylon_size/100))))-\nfudge_factor;\necho( \"calc_pylon_height \" , calc_pylon_height(for_badge_level=1) , \"for_badge_level\" , 1);",
    "description": "Okay, I'm looking to create a customizable tower of 3D badges, kind of like a physical stackable achievement system. I've seen some similar designs, but I want something that's really flexible and easy to adjust for different sizes and texts.\n\nHere's what I'm envisioning:\n\n*   **Stackable Badges:** The core idea is to create a series of stackable, cube-like badges.  The number of badges in the tower should be a customizable parameter.\n*   **Initial Cube Size:** Each badge should start with a base cube dimension that I can specify. This should scale on the Z-axis by a configurable stretch percentage and with each level of the tower.\n*   **Custom Text:** Each badge should be able to display custom text on the left, right, and back sides of the cube.\n*   **Badge Count:** It would be cool to optionally display the badge number on the back of each cube (instead of or in addition to custom text). I should be able to turn that on and off.\n*   **Rotation:**  I'd like to rotate each level of the tower clockwise or counter-clockwise.\n*   **Window Cutouts:** Each badge should have cutouts on each face. The depth of the cutouts should be adjustable with a percentage.\n*   **Stacking Pylons:** The badges need to be stackable, so I need cylindrical pylons on the top surface to fit into the bottom of the next badge. The size of these pylons should be adjustable.\n*    **Z-Height Stretch:**  There should be a percentage setting to allow for stretching (or squashing) the cube in Z-height\n*   **Print Quality:**  I'd like to control the roundness of the edges, probably with a polygon count setting.\n*   **Layer Thickness:** I need to be able to specify which layer thickness value is used by the printer.\n*   **Build Plate Preview:** It would be nice to have a build plate preview for different printers. I need to be able to choose from different preset printers like Replicator 2, Replicator, Thingomatic or choose a manual option with manual dimensions for the X and Y axes.\n\nI want to use OpenSCAD for this, and I'd like you to provide me with a parametric .scad file. I'm aware that I'll need to use existing libraries, but I'm not familiar with which. Based on what I've described, It looks like `MCAD/boxes.scad` and `utils/build_plate.scad` and `write/Write.scad` are necessary. Please assume I have these libraries included and do not include them with your response, but do make sure you utilize them when generating the .scad.\n\nEssentially, I need something that allows me to create a customizable tower of stackable 3D badges with text, a configurable number of badges, adjustable sizes, rotations, and cutouts. Let me know if you have any questions, and thanks in advance for your help!\n"
  },
  {
    "object": "Hey cadmonkey, make me a SD Key Chain",
    "scad": "number_of_cards = 2;\ncard_width = 25;\ncard_height = 34;\ncard_depth = 2.25;\nedge_thickness = 1;\nhinge_thickness = 0.5;\nhinge_bend_gap = 0.4;\nloop_hole_radius = 2.5;\nloop_outer_radius = 4.5;\nloop_hole_location = 4.5;\nfudge = 0.2;\nhalffudge = fudge / 2;\n    container_depth = card_depth * number_of_cards;\n    halfcontainer_depth = container_depth / 2;\n    model_height = card_width + edge_thickness * 2;\n    model_depth = halfcontainer_depth + edge_thickness;\n    hole_depth = model_depth;\n    modelwidth = (card_height + edge_thickness + model_depth) * 2;\n    translate([-model_height/2, -modelwidth/2, 0])\n    difference() {\n        union() {\n            difference() {\n                union() {\n                    cube([model_height, modelwidth, model_depth], center = false);\n                }\n                union() {\n                    translate([edge_thickness, edge_thickness, edge_thickness])\n                    cube([card_width, card_height + fudge, halfcontainer_depth + fudge]);\n                    translate([edge_thickness, card_height + edge_thickness + model_depth * 2, edge_thickness])\n                    cube([card_width, card_height, halfcontainer_depth + fudge]);\n                }\n            }\n            union() {\n                translate([loop_hole_location, 0, 0])\n                cylinder(h = hole_depth, r = loop_outer_radius);\n                translate([loop_hole_location, modelwidth, 0])\n                cylinder(h = hole_depth, r = loop_outer_radius);\n            }\n        }\n        union() {\n            translate([loop_hole_location, 0, -halffudge])\n            cylinder(h = hole_depth + fudge, r = loop_hole_radius);\n            translate([loop_hole_location, modelwidth, -halffudge])\n            cylinder(h = hole_depth + fudge, r = loop_hole_radius);\n            translate([-halffudge, card_height + edge_thickness, .5])\n            cube([model_height + fudge, model_depth * 2 + fudge, model_depth - hinge_thickness + fudge]);\n            translate([0, card_height + edge_thickness - hinge_bend_gap, 0])\n            cube([model_height, hinge_bend_gap, hinge_bend_gap], center = false);\n            translate([0, card_height + edge_thickness + model_depth * 2, 0])\n            cube([model_height, hinge_bend_gap, hinge_bend_gap], center = false);\n        }\n    }",
    "description": "Okay, I'm trying to design an SD card holder that can be attached to a keychain, and I'm pretty new to OpenSCAD, so I need some help.\n\nHere's what I want:\n\n**General Concept:** I need a rectangular case that holds SD cards, with a hinge to allow it to open and close, and a loop to attach it to a keychain. It should print flat, and then be folded up.\n\n**Card Dimensions:** I'll need to be able to specify the width, height, and depth of the SD cards that the case is designed to hold. Also, I need to be able to specify the number of cards the case should hold, so that the overall depth of the case can be adjusted.\n\n**Case Dimensions:** The edges of the case should have a specified thickness. The hinge should also have its own thickness, as well as a gap to help the bending process. I also need to specify the radius of the keychain loop hole, and the outer radius of the keychain loop itself, and the placement of the hole.\n\n**Parameters:** I'd like these to be configurable:\n\n*   `number_of_cards`: The number of SD cards the case should hold (e.g., 1, 2, 3).\n*   `card_width`: The width of the SD card (mm).\n*   `card_height`: The height of the SD card (mm).\n*   `card_depth`: The depth of the SD card (mm).\n*   `edge_thickness`: The thickness of the edges of the case (mm).\n*   `hinge_thickness`: The thickness of the hinge (mm).\n*   `hinge_bend_gap`: The size of the gap to facilitate bending for the hinge (mm).\n*   `loop_hole_radius`: The inner radius of the keychain loop hole (mm).\n*   `loop_outer_radius`: The outer radius of the keychain loop (mm).\n*   `loop_hole_location`: The distance from the edge where the loop is positioned (mm).\n\n**Specifics:**\n*   The case should consist of two halves connected by a living hinge. When folded, the two halves form the case to contain SD cards.\n*   The hinge should run along the short edge of the rectangular case halves.\n* The two halves should be the same size and shape with the case formed by the long edge of each half aligning.\n\n**OpenSCAD Libraries:** I would like to keep it simple for now, so I do not want to use any additional libraries.\n\nCould you please write an OpenSCAD file that does this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Minecraft Creeper - Now With Dualstrusion!",
    "scad": "part = \"first\";\npixel_size = 1;\nscale(pixel_size)\n{\ntranslate([0,0,8]) rotate([0,90,0])\n{\nif(part == \"first\")\n{\nunion()\n{\ncube([8,4,6 + 1]);\ntranslate([0,8,0]) cube([8,4,6 + 1]);\ntranslate([0,4,6]) cube([8,4,12]);\ndifference()\n{\ntranslate([0,2,16]) cube(8);\nunion()\n{\ntranslate([2,2,16 - 0.1]) cube([1,0.5,3 + 0.1]);\ntranslate([2,2,17]) cube(1);\ntranslate([5,2,16 - 0.1]) cube([1,0.5,3 + 0.1]);\ntranslate([5,2,17]) cube(1);\ntranslate([3,2,17]) cube([2,0.5,3]);\ntranslate([3,2,17]) cube([2,1,2]);\ntranslate([1 - 0.1,2,20]) cube([2,1,2]);\ntranslate([1 - 0.1,2,20]) cube([1,2,2]);\ntranslate([2 - 0.1,2,21]) cube([1,2,1]);\ntranslate([5 + 0.1,2,20]) cube([2,1,2]);\ntranslate([6 + 0.1,2,20]) cube([1,2,2]);\ntranslate([5 + 0.1,2,21]) cube([1,2,1]);\n}\n}\n}\n}\nelse if (part == \"second\")\n{\nunion()\n{\ncube([8,4,6 + 1]);\ntranslate([0,8,0]) cube([8,4,6 + 1]);\ntranslate([0,4,6]) cube([8,4,12]);\ndifference()\n{\ntranslate([0,2,16]) cube(8);\nunion()\n{\ntranslate([2,2,16 - 0.1]) cube([1,1,3 + 0.1]);\ntranslate([5,2,16 - 0.1]) cube([1,1,3 + 0.1]);\ntranslate([3,2,17]) cube([2,1,3]);\ntranslate([1 - 0.1,1,20]) cube([1,2,2]);\ntranslate([2 - 0.1,1,21]) cube([1,2,1]);\ntranslate([6 + 0.1,1,20]) cube([1,2,2]);\ntranslate([5 + 0.1,1,21]) cube([1,2,1]);\n}\n}\n}\n}\nelse if (part == \"third\")\n{\nunion()\n{\ntranslate([2,2,16 - 0.1]) cube([1,1,3 + 0.1]);\ntranslate([5,2,16 - 0.1]) cube([1,1,3 + 0.1]);\ntranslate([3,2,17]) cube([2,1,3]);\ntranslate([1 - 0.1,2,20]) cube([1,1,2]);\ntranslate([2 - 0.1,2,21]) cube([1,1,1]);\ntranslate([6 + 0.1,2,20]) cube([1,1,2]);\ntranslate([5 + 0.1,2,21]) cube([1,1,1]);\n}\n}\n}\n}",
    "description": "Okay, I'm trying to design a more robust version of a Minecraft Creeper using OpenSCAD, and I'd like to make it fully parametric. I already have a basic model, but its a bit hardcoded. I'd like to make some improvements and also add some features.\n\nHeres what I want:\n\n1.  **Parametric Pixel Size:** The core design is based on a pixel grid. I need a parameter, `pixel_size`, that controls the size of each pixel in millimeters. The default should be 1 mm. So if I set it to 2, every unit in the model gets scaled up by a factor of 2.\n\n2.  **Three-Part Build:** I want to be able to generate three distinct parts of the creeper, selectable by a parameter called `part`. These will be used for different things, like a single color print or a multi-extrusion print. The available options for `part` should be:\n    *   `\"first\"`: This will create the main body with legs, and a simple head. This is meant for a regular, single-color print.\n    *   `\"second\"`: This creates the same body, but changes the eyes and mouth to be single-extrusion-friendly. This will have a different look that is more suitable for 2 color prints.\n    *   `\"third\"`: This just creates the face components (mouth and eyes) as separate extrudable objects. It is important that the face geometry for `\"second\"` and `\"third\"` are completely equivalent, so you can print the face separately with `\"third\"` and fit it on the `\"second\"` body.\n\n3.  **Orientation:** The model should be initially designed lying on its side (rotated), and then placed upright when `pixel_size` is applied. So initially the design should be laid out flat, then rotated 90 degrees around the Y axis and translated up 8 units.\n\n4. **Body:**\n   * The body consists of legs, body and a head.\n   * The legs are two 8x4x7 blocks located at 0,0,0 and 0,8,0 relative to the body.\n   * The main body is an 8x4x12 block at 0,4,6 relative to the body.\n   * The head is an 8x8x8 cube placed on top of the body.\n\n5.  **Face (Mouth & Eyes):**\n    *   The basic shape of the head is an 8x8x8 cube, but the face is not part of this.\n    *   **Mouth:** For `\"first\"`, the mouth consists of:\n        * Two 1x0.5x3.1 rectangles, offset by 2 and 5 units along the x axis, and on the bottom of the head, and then moved 0.1 units below the head.\n        * Two 1x1x1 rectangles, offset by 2 and 5 units along the x axis, and on the bottom of the head.\n        * One 2x0.5x3 rectangle connecting the above at 3 along the x axis.\n        * One 2x1x2 rectangle connecting the above at 3 along the x axis.\n\n        *For `\"second\"` the mouth consists of:*\n        * Two 1x1x3.1 rectangles, offset by 2 and 5 units along the x axis, and on the bottom of the head, and then moved 0.1 units below the head.\n       * One 2x1x3 rectangle connecting the above at 3 along the x axis.\n    *   **Eyes:**\n        *For `\"first\"`*\n         *   **Left Eye:**\n            *   Two 2x1x2 blocks at (1,2,20)\n            *   A 1x2x2 block at (1,2,20)\n            *   A 1x2x1 block at (2,2,21)\n        *   **Right Eye:**\n            *   Two 2x1x2 blocks at (5,2,20)\n            *   A 1x2x2 block at (6,2,20)\n            *   A 1x2x1 block at (5,2,21)\n\n         *For `\"second\"`*\n        *   **Left Eye:**\n            *  A 1x2x2 block at (1,1,20)\n            *  A 1x2x1 block at (2,1,21)\n        *   **Right Eye:**\n             *  A 1x2x2 block at (6,1,20)\n             *  A 1x2x1 block at (5,1,21)\n\n         *For `\"third\"`*\n        *   **Left Eye:**\n           *  A 1x1x2 block at (1,2,20)\n            *  A 1x1x1 block at (2,2,21)\n        *   **Right Eye:**\n            *  A 1x1x2 block at (6,2,20)\n            *  A 1x1x1 block at (5,2,21)\n    * All coordinates are relative to the origin of the head at (0,2,16)\n\nI think this should cover all of the major features of the design. I do not require any external libraries for this task. Can you please generate the parametric OpenSCAD file?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Card Holder with Lid",
    "scad": "card_x = 54;\ncard_y = 80;\nshow_logo = \"yes\";\nconnectors = \"yes\";\nlid = 1;\ncard_space = 3;\nwall_thickness = 3;\nplate_height = 3;\nwall_height = 12;\nuse_sticky_corners = \"no\";\nshortwall_cut = card_x/(card_y/card_x);\nshortwall = (card_x-shortwall_cut)/2+wall_thickness+card_space/2;\nlongwall=(card_y-card_x)/2+wall_thickness+card_space/2;\nhinge_r = 2;\nhinge = min(0.6*longwall/2, wall_height/2);\nlid_slop = 0.5*lid;\nlid_height = hinge*2;\nlid_reveal = hinge*2+0.5;\nconnector_extra = lid * (wall_thickness*2 + lid_slop*2);\ncirc_ratio =2.5;\nfemale_con_x = 10+1-1;\nfemale_con_y1 = 21+1-2;\nfemale_con_y2 = 12.5+1-1;\nmale_con_x = 11.4+1-1;\nmale_con_y1 = 19.8+1-1;\nmale_con_y2 = 10.46+1-1;\nangle = atan( ((female_con_y1-female_con_y2)/2) / female_con_x );\nmodule logo() {\n    union() {\n\ttranslate([0, -4.5, 0])\n\tcube(size = [19,9,10], center = true);\n\tdifference() {\n\t    translate([-4.5, 0.5 ,0])\n\t    cube(size = [10,19,10], center = true);\n\t    translate([0.5, 12 ,0])\n\t    rotate([0, 0, 45])\n\t    cube(size = [10,12,11], center = true);\n\t    translate([-9.5, 12 ,0])\n\t    rotate([0, 0, 45])\n\t    cube(size = [12,10,11], center = true);\n\t}\n    }};\nmodule bump(rad,dir) {\n    difference() {\n\tsphere(r=rad, center=true, $fn = 40);\n\ttranslate(dir*rad)\n\tcube([rad*2,rad*2,rad*2],center=true);\n    }\n};\nmodule round_cut1() {\n    translate([0,card_y/1.27,-card_x/4])\n    cylinder(card_x/2, card_x/2, card_x/2, $fa=2);\n    };\nunion() {\n    if (use_sticky_corners == \"yes\") {\n\tunion() {\n\t    translate([(card_x+card_space+wall_thickness*2)/2, (card_y+card_space+wall_thickness*2)/2,-plate_height/2])\n\t    cylinder(r=15,h=0.35,center=\"yes\");\n\t    translate([-(card_x+card_space+wall_thickness*2)/2, (card_y+card_space+wall_thickness*2)/2,-plate_height/2])\n\t    cylinder(r=15,h=0.35,center=\"yes\");\n\t    translate([(card_x+card_space+wall_thickness*2)/2, -(card_y+card_space+wall_thickness*2)/2,-plate_height/2])\n\t    cylinder(r=15,h=0.35,center=\"yes\");\n\t    translate([-(card_x+card_space+wall_thickness*2)/2, -(card_y+card_space+wall_thickness*2)/2,-plate_height/2])\n\t    cylinder(r=15,h=0.35,center=\"yes\");\n\t    if(lid == 1) {\n\t    \ttranslate([card_x+card_space+wall_thickness*2+4+lid_slop+connector_extra,-lid_reveal/2,-plate_height/2]) {\n\t\t    translate([(card_x+card_space+wall_thickness*4+lid_slop)/2, (card_y+card_space+wall_thickness*2+lid_reveal)/2,0])\n\t\t    cylinder(r=15,h=0.35,center=\"yes\");\n\t\t    translate([-(card_x+card_space+wall_thickness*4+lid_slop)/2, (card_y+card_space+wall_thickness*2+lid_reveal)/2,0])\n\t\t    cylinder(r=15,h=0.35,center=\"yes\");\n\t\t    translate([(card_x+card_space+wall_thickness*4+lid_slop)/2, -(card_y+card_space+wall_thickness*2-lid_reveal)/2,0])\n\t\t    cylinder(r=15,h=0.35,center=\"yes\");\n\t\t    translate([-(card_x+card_space+wall_thickness*4+lid_slop)/2, -(card_y+card_space+wall_thickness*2-lid_reveal)/2,0])\n\t\t    cylinder(r=15,h=0.35,center=\"yes\");\n\t\t}\n\t    }\n\t}\n    }\n    difference() {\n\t\tunion() {\n\t\t    cube(size = [card_x+card_space+wall_thickness*2, card_y+card_space+wall_thickness*2,plate_height], center = true);\n\t\t    if (connectors == \"yes\" && lid == 1) {\n\t\t\ttranslate( [ (card_x/2) + card_space/2 + wall_thickness, -female_con_y1, -plate_height/2])\n\t\t\tcube(size = [connector_extra/2, female_con_y1*2, plate_height], center = false);\n\t\t    }\n\t\t}\n\t\tround_cut1();\n\t\ttranslate([0,-card_y/1.27,-card_x/4])\n\t\tcylinder(card_x/2, card_x/2, card_x/2, $fa=2);\n\t\tcylinder(card_x/circ_ratio, card_x/circ_ratio, card_x/circ_ratio, $fa=2);\n\t\tif (show_logo == \"yes\") {\n\t\t    logo();\n\t\t}\n\t\tif (connectors == \"yes\") {\n\t\t\ttranslate( [ (card_x/2) - female_con_x + card_space/2 + wall_thickness +connector_extra/2+0.01 , -female_con_y1/2, -plate_height ] )\n\t\t\tdifference() {\n\t\t\t\tcube(size = [female_con_x, female_con_y1, plate_height*2], center = false);\n\t\t\t\ttranslate( [ 0,female_con_y1,-1 ] )\n\t\t\t\trotate([0, 0, -angle])\n\t\t\t\tcube(female_con_x*2);\n\t\t\t\ttranslate( [ 0,0,-1 ] )\n\t\t\t\trotate([0, 0, angle-90])\n\t\t\t\tcube(female_con_x*2);\n\t\t\t}\n\t\t}\n\t}\n\tif (connectors == \"yes\") {\n\t\ttranslate( [ -(card_x/2) - card_space/2 - wall_thickness - male_con_x-connector_extra/2, -male_con_y1/2, -plate_height/2 ] )\n\t\tunion() {\n\t\t    difference() {\n\t\t\tcube(size = [male_con_x, male_con_y1, plate_height], center = false);\n\t\t\ttranslate( [ 0,male_con_y1,-1 ] )\n\t\t\trotate([0, 0, -angle])\n\t\t\tcube(male_con_x*2);\n\t\t\ttranslate( [ 0,0,-1 ] )\n\t\t\trotate([0, 0, angle-90])\n\t\t\tcube(male_con_x*2);\n\t\t    }\n\t\t    translate( [male_con_x, -male_con_y1/2, 0] )\n\t\t    cube(size = [connector_extra/2, male_con_y1*2, plate_height], center = false);\n\t\t}\n\t}\n\tdifference() {\n\t    union() {\n\t\ttranslate([  (card_x+card_space+wall_thickness*2)/2 , (card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\t\trotate([0,0,180])\n\t\tcube(size = [wall_thickness,longwall,wall_height] ,center = false);\n\t\ttranslate([  -(card_x+card_space+wall_thickness*2)/2 +wall_thickness , (card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\t\trotate([0,0,180])\n\t\tcube(size = [wall_thickness,longwall,wall_height] ,center = false);\n\t\ttranslate([  (card_x+card_space+wall_thickness*2)/2 -wall_thickness, -(card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\t\trotate([0,0,0])\n\t\tcube(size = [wall_thickness,longwall,wall_height] ,center = false);\n\t\ttranslate([  -(card_x+card_space+wall_thickness*2)/2 , -(card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\t\trotate([0,0,0])\n\t\tcube(size = [wall_thickness,longwall,wall_height] ,center = false);\n\ttranslate([  -(card_x+card_space+wall_thickness*2)/2  , (card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\trotate([0,0,270])\n\tcube(size = [wall_thickness, shortwall , wall_height] ,center = false);\n\ttranslate([  (card_x+card_space+wall_thickness*2)/2 , -(card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\trotate([0,0,90])\n\tcube(size = [wall_thickness, shortwall , wall_height] ,center = false);\n\ttranslate([  -(card_x+card_space+wall_thickness*2)/2 , -(card_y+card_space+wall_thickness*2)/2 +wall_thickness ,plate_height/2])\n\trotate([0,0,270])\n\tcube(size = [wall_thickness, shortwall , wall_height] ,center = false);\n\ttranslate([  (card_x+card_space+wall_thickness*2)/2 , (card_y+card_space+wall_thickness*2)/2 -wall_thickness ,plate_height/2])\n\trotate([0,0,90])\n\tcube(size = [wall_thickness, shortwall , wall_height] ,center = false);\n\t    }\n\t    if (lid == 1) {\n\t\trotate([0,90,0]) {\n\t\t    union () {\n\t\t\ttranslate([-(plate_height/2+wall_height)+hinge,card_y/2+card_space/2+wall_thickness-hinge,0])\n\t\t\tcylinder(h=card_x+card_space+wall_thickness*2+2,r=hinge_r, center=true, $fn = 40);\n\t\t\ttranslate([-(plate_height/2+wall_height)+hinge,-card_y/2-card_space/2-wall_thickness+hinge,0])\n\t\t\tcylinder(h=card_x+card_space+wall_thickness*2+2,r=hinge_r, center=true, $fn = 40);\n\t\t\t    union () {\n\t\t\t\ttranslate([-(plate_height/2+wall_height)+hinge,card_y/2+card_space/2+wall_thickness-hinge,0])\n\t\t\t\tdifference() {\n\t\t\t\t    translate([-hinge,hinge,0])\n\t\t\t\t    cube([hinge*2,hinge*2,card_x+card_space+wall_thickness*2+1],center=true);\n\t\t\t\t    cylinder(h=card_x+card_space+wall_thickness*2+2,r=hinge, center=true, $fn = 40);\n\t\t\t\t}\n\t\t\t    }\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (lid == 1) {\n\t    translate([card_x+card_space+wall_thickness*2+4+lid_slop+connector_extra,0,0]) {\n\t\tunion() {\n\t\t    difference() {\n\t\t\ttranslate([0,-lid_reveal/2,0])\n\t    \t\tcube(size = [card_x+card_space+wall_thickness*4+lid_slop, card_y+card_space+wall_thickness*2-lid_reveal,plate_height], center = true);\n\t\tcylinder(card_x/circ_ratio, card_x/circ_ratio, card_x/circ_ratio, $fa=2);\n\t\ttranslate([0,-lid_reveal,0])\n\t\t\tround_cut1();\n\t\t\tif (show_logo == \"yes\") {\n\t\t\t    rotate([180,0,180])\n\t\t\t    logo();\n\t\t\t}\n\t\t    }\n\t\t    translate([0,-(card_y+card_space+wall_thickness)/2,hinge/2+plate_height/2])\n\t\t    cube(size=[card_x - (2*shortwall+1),wall_thickness,hinge],center=true);\n\t\t    translate([  (card_x+card_space+wall_thickness*4+lid_slop)/2 , (card_y+card_space+wall_thickness*2)/2 ,-plate_height/2])\n\t\t    rotate([0,0,180])\n\t\t    cube(size = [wall_thickness,longwall,lid_height+plate_height] ,center = false);\n\t\t    translate([  -(card_x+card_space+wall_thickness*4+lid_slop)/2 +wall_thickness , (card_y+card_space+wall_thickness*2)/2 ,-plate_height/2])\n\t\t    rotate([0,0,180])\n\t\t    cube(size = [wall_thickness,longwall,lid_height+plate_height] ,center = false);\n\t\t    translate([  (card_x+card_space+wall_thickness*4+lid_slop)/2 -wall_thickness, -(card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\t\t    rotate([0,0,0])\n\t\t    cube(size = [wall_thickness,longwall,lid_height] ,center = false);\n\t\t    translate([  -(card_x+card_space+wall_thickness*4+lid_slop)/2 , -(card_y+card_space+wall_thickness*2)/2 ,plate_height/2])\n\t\t    rotate([0,0,0])\n\t\t    cube(size = [wall_thickness,longwall,lid_height] ,center = false);\n\t\t    translate([((card_x+card_space)/2+lid_slop+hinge_r),(card_y+card_space)/2+wall_thickness-hinge,lid_height+plate_height/2-hinge]) {\n\t\t\tbump(hinge_r,[1,0,0]);\n\t\t    }\n\t\t    translate([-((card_x+card_space)/2+lid_slop+hinge_r),(card_y+card_space)/2+wall_thickness-hinge,lid_height+plate_height/2-hinge]) {\n\t\t\tbump(hinge_r,[-1,0,0]);\n\t\t    }\n\t\t    translate([((card_x+card_space)/2+lid_slop+1.5*hinge_r),-((card_y+card_space)/2-+wall_thickness-hinge),lid_height+plate_height/2-hinge]) {\n\t\t\tbump(hinge_r,[1,0,0]);\n\t\t    }\n\t\t    translate([-((card_x+card_space)/2+lid_slop+1.5*hinge_r),-((card_y+card_space)/2+wall_thickness-hinge),lid_height+plate_height/2-hinge]) {\n\t\t\tbump(hinge_r,[-1,0,0]);\n\t\t    }\n\t\t}\n\t    }\n\t}\n}",
    "description": "Okay, I'm looking to design a card holder, like for trading cards or game cards, with a hinged lid. I want to be able to adjust the dimensions easily, and have some options for customization.\n\nHere's what I'm envisioning:\n\n**Core Functionality:**\n\n*   **Card Dimensions:** The holder needs to fit standard rectangular cards. I need to be able to specify the short side (`card_x`) and long side (`card_y`) dimensions in millimeters as parameters.\n*   **Card Space:** There should be a small gap (`card_space`) between the cards and the inside walls of the holder, which I can also control via a parameter.\n*   **Wall Thickness:** The thickness of the holder's walls (`wall_thickness`) should be adjustable.\n*   **Wall Height:** The height of the walls (`wall_height`) of the base should be adjustable.\n*  **Base Plate Height:**  The thickness of the bottom plate of the base (`plate_height`) should be adjustable.\n*   **Lid:** I'd like an option to include a lid (`lid`). It should be a simple flip lid hinged on one of the long sides. I want a parameter to toggle it on or off.\n*   **Hinge:** The hinge should be a simple cylindrical shape, and the hinge radius (`hinge_r`) should be adjustable as a parameter. I need to control the depth of the hinge (`hinge`), which should have a formula relating it to the wall height.  I also need to control the slop in the lid (`lid_slop`).\n*   **Lid Reveal:** The amount of lid that extends past the base when closed (`lid_reveal`) should be controllable based on the hinge size and include a small additional fixed amount.\n*   **Connectors:** I need the option to have interlocking connectors on the sides of the card holders so they can be connected to each other (`connectors`). These connectors should be designed with a \"male\" and \"female\" side. There should be a parameter to toggle them on or off. The connectors need to be parametrically generated based on the dimensions provided in the original code (`female_con_x`, `female_con_y1`, `female_con_y2`, `male_con_x`, `male_con_y1`, `male_con_y2`). \n*  **Connector Extra:** The extra length added to the main card holder for interlocking connectors (`connector_extra`). This should be controllable by a formula based on other parameters.\n\n**Optional Features:**\n\n*   **Logo:** I want the option to include a small logo on the base and lid. This should be a toggle-able parameter (`show_logo`). The logo should be the same design as the one in the provided code.\n*   **Sticky Corners:** I need an option to add small, circular \"sticky corners\" that help with printing on FDM printers (`use_sticky_corners`). This should be a toggle-able parameter.\n\n**Specific Requirements for the SCAD:**\n\n*   The code should be well-commented and easy to understand.\n*   It should be fully parametric, allowing me to easily change all dimensions and options.\n*   The design should account for a small cut in the bottom of the card holder to make it easier to remove cards, similar to the \"round_cut1\" module in the given code.\n*   I'd also like to keep the small cut out of the base plate, defined by a `card_x/circ_ratio` cylinder in the original code, where `circ_ratio` is 2.5, and is not a user defined variable.\n*   I would like to use the `sphere()` function with `$fn = 40` for the `bump()` module.\n*   I don't need any external libraries to be included for this.\n\nCould you generate the OpenSCAD code for this design, please? I've attached my current code as a starting point. The variable `angle` should be calculated as `atan( ((female_con_y1-female_con_y2)/2) / female_con_x )`.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Spring Seat",
    "scad": "resolution=50;\nbolt_hole_radius=2.5;\nseat_radius=5;\nsupport_height=3;\nseat_type=\"inside\";\nthickness=1;\n$fn=resolution;\nmodule base(){\n\tcylinder(r=seat_radius,h=thickness);\n\tcylinder(r=seat_radius-thickness-0.25,h=support_height);\n}\nif (seat_type==\"inside\"){\n\tdifference(){\n\t\tbase();\n\t\tcylinder(r=bolt_hole_radius,h=support_height);\n\t}\n}\nelse {\n\tdifference(){\n\t\tcylinder(r=seat_radius+thickness,h=support_height);\n\t\ttranslate([0,0,thickness])cylinder(r=seat_radius,h=support_height);\n\t\tcylinder(r=bolt_hole_radius,h=support_height);\n\t}\n}",
    "description": "Okay, I'm looking to design a spring seat for my 3D printer projects, and I'd like the design to be a bit more robust and flexible than what I've seen online. I want to be able to easily adjust the size of the seat and the hole for the bolt.\n\nHere's what I'm thinking:\n\nI need a spring seat that can be either an \"inside\" or \"outside\" type, like the one described in the example I have (I can show you that if needed, but it's pretty basic). The \"inside\" type has the support for the spring *inside* the base cylinder, making it more compact, while the \"outside\" type has the support on the outside, creating a larger overall footprint but hiding the base of the spring.\n\nHere's the core functionality I need, parametrically defined:\n\n*   **`seat_type`**: A string variable to define whether the seat is \"inside\" or \"outside\". Default to \"inside\".\n*   **`bolt_hole_radius`**: The radius of the center hole for a bolt.\n*   **`seat_radius`**: The radius of the base circle that the spring will sit on.\n*   **`support_height`**: The height of the supporting wall for the spring, not including the base thickness.\n*   **`thickness`**: The thickness of the base of the seat.\n*   **`resolution`**:  The resolution (number of segments) for the cylinders.\n*   **`base_diameter`**:  The diameter of the flat base, for when the support is of type outside.\n*   **`spring_guide_thickness`**: The thickness of the wall that guides the spring itself (this would always be on the inside). I think it would be an additional parameter, so not a calculated value, with a different default than `thickness`.\n*   **`spring_guide_diameter`**: The inside diameter of the spring support cylinder (to fit a spring), different from the radius of the base. This will vary depending on the outside diameter of the springs I'm using.\n*   **`chamfer_angle`**: The angle of the chamfer on the top edge, will be used if chamfer is enabled. \n*  **`chamfer_enabled`**: A Boolean that enables a chamfer on the top outer edge. Defaults to false.\n*   **`corner_radius`**: The radius applied to the top inside corner of the spring guide (where the base meets the guide).\n*   **`corner_fillet_enabled`**: A Boolean to turn on or off rounding of the inner corner between the guide and the base. Defaults to true.\n\nI'd also like to add these features:\n\n*   **Chamfer**: A chamfered top edge on the outer rim of the spring seat to improve print quality and visual appeal. This should be optional, with a parameter to control the angle.\n*   **Fillet**: A small fillet radius at the inside corner where the support wall meets the base, to reduce stress concentrations and also to improve print quality (less overhanging corners). This should be optional.\n\nI'd like to use these parameters to create a parametric OpenSCAD file. Could you generate the code? I think I'll only need the basic OpenSCAD language, no need for any libraries.\n"
  },
  {
    "object": "Hey cadmonkey, make me a covers to aluminum profile 30x30",
    "scad": "lun=82;\ncube([16,lun,1.5]);\ntranslate([4,0,1.5]) cube([8,lun,2.4]);\ntranslate([3.8,0,3.6]) cube([8.4,lun,1.5]);",
    "description": "Okay, so I'm working with some 30x30 aluminum profiles and I need a cover that not only hides the profile's structure but also conceals cables running through the grooves. I've already made a quick and dirty version (coperchio_profilato_30x30.scad), but it's not parametric at all. I'd like to have a more flexible design I can adjust for different lengths and potentially different profile sizes later on.\n\nHere's what I'm looking for:\n\n**Core Functionality:**\n\n*   The cover should sit flush on top of a 30x30 aluminum profile.\n*   It should have a main base that wraps around the top and partially down the sides of the profile, mimicking the general shape of my example SCAD file.\n*   There should be an inner \"lip\" or step that helps hold the cover in place and also creates the space for the cables.\n*   The design needs to be parametric. I'd like to be able to control at least the following:\n    *   **`length`**: The overall length of the cover.\n    *   **`profile_width`**: The width of the aluminum profile (in this case, it will initially be 30mm, but I'd like to be able to change it).\n    *   **`profile_height`**:  The height of the aluminum profile (initially 30mm).\n    *   **`cover_thickness`**: The thickness of the main base material.\n    *   **`lip_height`**: The height of the inner lip.\n    *   **`lip_thickness`**: The thickness of the inner lip.\n    *   **`lip_offset`**: The distance of the inner lip from the edge of the main base.\n\n**Additional Considerations:**\n\n*   I don't need it to completely encase the profile; it should just cover the top and part of the sides as in my example.\n*   It would be helpful if the design was easy to understand and modify if I need to tweak things in the future.\n*   I'm not doing anything fancy with curves or complex shapes, so simple primitives (cubes mostly) should be sufficient.\n\n**Requested File:**\n\nCould you please generate a parametric OpenSCAD file based on this description, using the parameters specified?  I don't need any special libraries, just vanilla OpenSCAD primitives.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Oval Keychain",
    "scad": "include <write/Write.scad>\ninclude <utils/build_plate.scad>\nwidth=25;\nlength=50;\nheight=1.6;\nlip=0.4;\ntext=\"Hello World\";\ntext_size = 6;\ntext_font = \"write/Letters.dxf\";\nring_radius=1.6;\nring_thickness=0.8;\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nkf_fn=25;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nmodule ovalKeyChain(plateWidth=width, plateLength=length, wall=lip,plateHeight=height, tabRadius=ring_radius, tabThickness=ring_thickness,fn=kf_fn)\n{\n\tinnerRadius = (plateWidth/2)-(wall/2);\n\tactualBase = plateHeight-wall;\n\tscale = (plateLength-wall)/(plateWidth-wall);\n\tdifference()\n\t{\n\t\tunion()\n\t\t{\n\t\t\tminkowski()\n\t\t\t{\n\t\t\t\tscale([scale,1,1])\n\t\t\t\t{\n\t\t\t\t\tcylinder(r=innerRadius, h=actualBase, $fn=fn);\n\t\t\t\t}\n\t\t\t\ttranslate([-wall/scale,-wall/scale,0])\n\t\t\t\t{\n\t\t\t\t\tcube(wall);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([-plateLength/2,0,0])\n\t\t\t\trotate_extrude(convexity = 10, $fn=fn)\n\t\t\t\t\ttranslate([tabRadius, 0, 0])\n\t\t\t\t\t\tsquare([tabThickness,tabThickness]);\n\t\t}\n\t\tunion()\n\t\t{\n\t\t\ttranslate([0,0,actualBase])\n\t\t\t{\n\t\t\t\tscale([scale,1,1.5])\n\t\t\t\t{\n\t\t\t\t\tcylinder(r=innerRadius, h=actualBase,$fn=fn);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule renderText(txt=text, txtSize=text_size, txtFont=text_font, txtDepth=height)\n{\n\ttranslate([0,0,txtDepth/2])\n\t\twrite(txt,h=txtSize,t=txtDepth,font=txtFont,center=true);\n}\novalKeyChain();\nrenderText();",
    "description": "Okay, I'm looking to design a customizable oval keychain, and I've got a basic design in mind but need to make it parametric. I'm using OpenSCAD.\n\nHere's what I want:\n\n*   **Shape:** The base shape should be an oval with a lip or raised border around the edge.\n*   **Dimensions:**\n    *   I need to control the overall `width` and `length` of the oval in millimeters.\n    *   I need to control the overall `height` (thickness) of the keychain.\n    *   I also need to be able to adjust the `lip` height, which is the height of the raised border and is added onto the base. This should be in millimeters as well.\n*   **Text:**\n    *   I want to be able to add text to the top surface of the keychain.\n    *   The text content should be a variable string.\n    *   The size of the text should be adjustable.\n    *   I want to be able to select from different font files. I've currently been using the `write` library, which uses `.dxf` files for fonts, so a basic font is what I'm after.\n*   **Ring Attachment:**\n    *   The keychain needs a circular loop or tab for attaching the keyring.\n    *   I need to be able to control the `radius` of this loop.\n    *   I also want to control the `thickness` of the loop (i.e., how wide it is, basically how long it protrudes from the main body of the keychain)\n*   **Build Plate:**\n    * I also am including support for displaying a build plate for visualization. This does not need to factor into the code as far as rendering the object itself\n*   **General:**\n    *   I want to have a variable to control the number of facets used for cylinders and curves. I'm currently using a `$fn` parameter for that.\n    * The `write` library is being used, specifically for it's font capabilities. Please be sure to include this functionality in the response.\n    *  I also am using the `build_plate` library for display only, it doesn't need to factor into code relating to the object itself.\n\nI'm thinking this would need some kind of `minkowski` operation to create the lip, and likely a difference to carve out the inner volume. I'm also open to other suggestions if there are better approaches. Can you create an OpenSCAD file that can do all of this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Ring Band Creation Script - USA sizes Customizer",
    "scad": "ring_size_us_can=6.5;\nmain_wall=2;\nmain_depth=4.34;\nmain_feature=0.2;\n\tmain_internal_diameter=(ring_size_us_can+14.312)/1.2308;\ncs_shape=\"cs_half_pill\";\ntext_enabled=\"false\";\ntext_engraved=\"true\";\ntext_inside=\"true\";\ntext_itself=\"Your Text Here\";\ntext_height=2;\ntext_depth=1;\ntext_spacing=1.1;\ntext_font=\"write/orbitron.dxf\";\nsmoothness=20;\ncolour_RGBA_metal=[0.65,0.65,0.65,1];\na_bit=0.01*1;\n$fn=smoothness*1;\necho(\"main_internal_diameter \", main_internal_diameter);\nif (text_enabled==\"true\"){\n\tif (text_engraved==\"true\"){\n\t\tdifference(){\n\t\t\tcolor(colour_RGBA_metal) ring_shape(main_internal_diameter, main_depth, main_wall, main_feature);\n\t\t\tring_engraving(main_internal_diameter, main_wall, main_depth, text_inside, text_itself, text_height, text_depth, text_spacing);\n\t\t}\n\t}else{\n\t\tunion(){\n\t\t\tcolor(colour_RGBA_metal) ring_shape(main_internal_diameter, main_depth, main_wall, main_feature);\n\t\t\tring_engraving(main_internal_diameter, main_wall, main_depth, text_inside, text_itself, text_height, text_depth, text_spacing);\n\t\t}\n\t}\n}else{\n\tcolor(colour_RGBA_metal) ring_shape(main_internal_diameter, main_depth, main_wall, main_feature);\n}\nmodule ring_engraving(internal_diameter=20, wall=5, depth=5, text_inside=false, text_itself=\"Some Text\", text_height, text_depth=1, text_spacing=1.2, text_font=\"write/orbitron.dxf\"){\n\tinternal_radius=internal_diameter/2;\n\texternal_radius=(internal_diameter/2)+wall;\n\tif (text_inside==\"true\"){\n\t\tmirror(1,0,0)rotate(a=[0,0,180])writecylinder(text_itself,[0,0,-depth/2],internal_radius,depth,rotate=0,t=text_depth,h=text_height,space=text_spacing,font=text_font);\n\t}else{\n\t\twritecylinder(text_itself,[0,0,-depth/2],external_radius,depth,rotate=0,t=text_depth,h=text_height,space=text_spacing,font=text_font);\n\t}\n}\nmodule ring_shape(ring_internal_diameter, ring_depth, ring_wall, ring_feature){\n\trotate_extrude (convexity = 20) translate([(ring_internal_diameter)/2, 0, 0]){\n\t\tif(cs_shape==\"cs_pill\"){\n\t\t\techo(\"Pill Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\tpill_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_ellipse\"){\n\t\t\techo(\"Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\tellipse_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_hemi_ellipse\"){\n\t\t\techo(\"Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\themi_ellipse_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_hemi_ellipse\"){\n\t\t\techo(\"Rounded Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_hemi_ellipse_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rectangle\"){\n\t\t\techo(\"Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\trectangle_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_scallopped_rectangle\"){\n\t\t\techo(\"Scallopped Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\tscallopped_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_scallopped_rectangle\"){\n\t\t\techo(\"Rounded Scallopped Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_scallopped_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_rectangle\"){\n\t\t\techo(\"Rounded Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_chamfered_rectangle\"){\n\t\t\techo(\"Chamfered Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\tchamfered_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_half_pill\"){\n\t\t\techo(\"Half Pill Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\thalf_pill_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_reverse_hemi_ellipse\"){\n\t\t\techo(\"Reverse Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\ttranslate (v=[ring_wall,0,0]) rotate(a=[0,0,180]) hemi_ellipse_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_reverse_rounded_hemi_ellipse\"){\n\t\techo(\"Reverse Rounded Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\", ring_wall, \"feature\", ring_feature);\n\t\t\ttranslate (v=[ring_wall,0,0]) rotate(a=[0,0,180]) rounded_hemi_ellipse_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_half_chamfered_rectangle\"){\n\t\t\techo(\"Chamfered Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\thalf_chamfered_rectangle_shape (ring_depth, ring_wall+(sin(45)*ring_feature), ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_ellipse_intersection\"){\n\t\t\techo(\"Ellipse Intercestion Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\tellipse_intersection_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_ellipse_intersection\"){\n\t\t\techo(\"Rounded Ellipse Intercestion Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_ellipse_intersection_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t}\n}\nmodule pill_shape (pill_l, pill_b){\n\ttranslate(v=[pill_b/2,0,0]){\n\t\ttranslate (v=[0,-(pill_l-pill_b)/2,0]) circle (r=pill_b/2, center=true);\n\t\tsquare (size=[pill_b, pill_l-pill_b], center=true);\n\t\ttranslate (v=[0,(pill_l-pill_b)/2,0]) circle(r=pill_b/2, center=true);\n\t}\n}\nmodule ellipse_shape (ellipse_x, ellipse_y){\n\ttranslate(v=[ellipse_y/2,0,0]) scale(v=[ellipse_y,ellipse_x]) circle(r=0.5,$fn=40, center=true);\n}\nmodule hemi_ellipse_shape(hemi_ellipse_x,hemi_ellipse_y){\n\tscale(v=[2*hemi_ellipse_y,hemi_ellipse_x]) difference () {\n\t\tcircle(r=0.5,$fn=40, center=true);\n\t\ttranslate (v=[-1.5,0,0]) square (size=3, center=true);\n\t}\n}\nmodule rectangle_shape (rectangle_x, rectangle_y){\n\ttranslate(v=[rectangle_y/2,0,0]) square(size=[rectangle_y, rectangle_x], center=true);\n}\nmodule scallopped_rectangle_shape (scallopped_rectangle_y, scallopped_rectangle_x, scallopped_rectangle_z){\n\tdifference (){\n\t\trectangle_shape (scallopped_rectangle_y, scallopped_rectangle_x);\n\t\ttranslate(v=[scallopped_rectangle_x,0,0]) rotate(a=[0,0,180]) hemi_ellipse_shape(scallopped_rectangle_y,scallopped_rectangle_z);\n\t}\n}\nmodule rounded_scallopped_rectangle_shape (rounded_scallopped_rectangle_y, rounded_scallopped_rectangle_x, rounded_scallopped_rectangle_z){\n\tminkowski(){\n\t\ttranslate(v=[rounded_scallopped_rectangle_z,0,0]) difference (){\n\t\t\trectangle_shape (rounded_scallopped_rectangle_y-2*rounded_scallopped_rectangle_z, rounded_scallopped_rectangle_x-2*rounded_scallopped_rectangle_z);\n\t\t\ttranslate(v=[rounded_scallopped_rectangle_x-2*rounded_scallopped_rectangle_z,0,0]) rotate(a=[0,0,180]) hemi_ellipse_shape(rounded_scallopped_rectangle_y-2*rounded_scallopped_rectangle_z,rounded_scallopped_rectangle_z);\n\t\t}\n\tcircle(r=rounded_scallopped_rectangle_z, $fn=40);\n\t}\n}\nmodule rounded_hemi_ellipse_shape(rounded_ellipse_x, rounded_ellipse_y, rounded_ellipse_z){\n\ttranslate(v=[rounded_ellipse_z,0,0]){\n\t\tminkowski(){\n\t\t\themi_ellipse_shape(rounded_ellipse_x-2*rounded_ellipse_z,rounded_ellipse_y-2*rounded_ellipse_z);\n\t\t\tcircle(r=rounded_ellipse_z, $fn=40);\n\t\t}\n\t}\n}\nmodule rounded_rectangle_shape(rounded_rectangle_y, rounded_rectangle_x, rounded_rectangle_z){\n\ttranslate(v=[rounded_rectangle_x/2,0,0]){\n\t\tminkowski(){\n\t\t\tsquare(size=[rounded_rectangle_x-2*rounded_rectangle_z,rounded_rectangle_y-2*rounded_rectangle_z], center=true);\n\t\t\tcircle(r=rounded_rectangle_z, $fn=40);\n\t\t}\n\t}\n}\nmodule chamfered_rectangle_shape(chamfered_rectangle_y, chamfered_rectangle_x, chamfered_rectangle_z){\n\ttranslate(v=[chamfered_rectangle_x/2,-sin(45)*chamfered_rectangle_z,0]){\n\t\tminkowski(){\n\t\t\tsquare(size=[chamfered_rectangle_x-2*sin(45)*chamfered_rectangle_z,chamfered_rectangle_y-2*sin(45)*chamfered_rectangle_z],center=true);\n\t\t\trotate (a=[0,0,45]) square (size=chamfered_rectangle_z);\n\t\t}\n\t}\n}\nmodule half_chamfered_rectangle_shape(half_chamfered_rectangle_y, half_chamfered_rectangle_x, half_chamfered_rectangle_z){\n\ttranslate(v=[-sin(45)*half_chamfered_rectangle_z,0,0]){\n\t\tdifference(){\n\t\t\tchamfered_rectangle_shape (half_chamfered_rectangle_y, half_chamfered_rectangle_x+(sin(45)*half_chamfered_rectangle_z), half_chamfered_rectangle_z);\n\t\t\ttranslate(v=[(-0.1+sin(45)*half_chamfered_rectangle_z)/2,0,0]) square (size=[(sin(45)*half_chamfered_rectangle_z + 0.1),half_chamfered_rectangle_y+0.1], center=true);\n\t\t}\n\t}\n}\nmodule half_pill_shape (pill_l, pill_b){\n\ttranslate(v=[-pill_b,0,0]) difference (){\n\t\tpill_shape(pill_l,2*pill_b);\n\t\tsquare (size=[2*pill_b,pill_l], center=true);\n\t}\n}\nmodule ellipse_intersection_shape (ellipse_inter_x, ellipse_inter_y, ellipse_inter_z,rounding_rad_m=0){\n\tband_width_m = ellipse_inter_x;\n\tband_depth_m = ellipse_inter_y;\n\tinner_depth_ratio_m = ellipse_inter_z;\n\tinner_height_m=(band_depth_m)*inner_depth_ratio_m;\n\touter_height_m=(band_depth_m)-inner_height_m;\n\tinner_rad_m=(inner_height_m/2) + (band_width_m)*(band_width_m)/(8*inner_height_m);\n\touter_rad_m=(outer_height_m/2) + (band_width_m)*(band_width_m)/(8*outer_height_m);\n\trotate(a=-90)translate(v=[0, (band_depth_m)*inner_depth_ratio_m ]) intersection(){\n\t\ttranslate(v=[0,inner_rad_m-inner_height_m]) circle(r=inner_rad_m);\n\t\ttranslate(v=[0,-(outer_rad_m-outer_height_m)]) circle(r=outer_rad_m);\n\t}\n}\nmodule rounded_ellipse_intersection_shape (rounded_ellipse_inter_x, rounded_ellipse_inter_y, rounded_ellipse_inter_z,rounded_rounding_rad_l=0.5){\n\tband_width_l = rounded_ellipse_inter_x;\n\tband_depth_l = rounded_ellipse_inter_y;\n\tinner_depth_ratio_l = rounded_ellipse_inter_z;\n\tminkowski(){\n\t\tcircle(r=rounded_rounding_rad_l);\n\t\ttranslate(v=[rounded_rounding_rad_l,0])ellipse_intersection_shape (rounded_ellipse_inter_x-2*rounded_rounding_rad_l, rounded_ellipse_inter_y-2*rounded_rounding_rad_l, rounded_ellipse_inter_z,rounded_rounding_rad_l);\n\t}\n}",
    "description": "Okay, I'm looking to create a custom ring band using OpenSCAD, similar to the functionality of that \"Ring_band_creation_script_v1.4-USA.scad\" script I saw on Thingiverse. I need a script that is parametric so I can easily customize the size, shape, and text.\n\nHere's what I need the script to be able to do:\n\n**Ring Sizing:**\n\n*   I need to be able to specify the ring size using US/Canadian numerical ring sizes (e.g., 6.5, 10.25, 13). I need fractional size support (e.g., 6.25 or 6.75).\n*   I need to control the wall thickness (the difference between the inner and outer radius), which I'll refer to as `main_wall`. I want to be able to specify this in millimeters.\n*   I need to control the width of the band, which I'll call `main_depth`, also in millimeters.\n*   Finally, some of the cross-sections need a third variable, which I'll call `main_feature`.\n\n**Cross-Section Shapes:**\n\nI want to be able to select from a variety of cross-section shapes for the ring band. Specifically, I need all of the following:\n\n*   `cs_ellipse`\n*   `cs_rectangle`\n*  `cs_pill`\n*   `cs_hemi_ellipse`\n*   `cs_scallopped_rectangle`\n*   `cs_rounded_scallopped_rectangle`\n*   `cs_rounded_hemi_ellipse`\n*   `cs_rounded_rectangle`\n*  `cs_chamfered_rectangle`\n*  `cs_half_pill`\n* `cs_reverse_hemi_ellipse`\n* `cs_reverse_rounded_hemi_ellipse`\n* `cs_half_chamfered_rectangle`\n*  `cs_ellipse_intersection`\n*  `cs_rounded_ellipse_intersection`\n I should be able to choose one of these by setting a variable (perhaps a string, as in the reference code) called `cs_shape`.\n\n**Text:**\n\n*   I need the ability to add text to the ring band. This should be toggled on or off with a `text_enabled` boolean variable.\n*   The text should be able to be either engraved (cut into the ring) or raised (protruding from the ring). I should control this with a `text_engraved` boolean variable.\n*   I need to specify if the text is on the inside or outside of the band, using a `text_inside` boolean variable.\n*   I need to be able to specify the text itself using a variable called `text_itself`.\n*   I need to control the height of the letters using a variable called `text_height`.\n*   I need to control the depth of the engraved or raised letters using a variable `text_depth`.\n*   I need to control the spacing between the letters with a `text_spacing` variable.\n*   I need to be able to select the font, which will need to use the `write.scad` library. I will need to specify the path to a `.dxf` file. This should use a variable called `text_font`. The `write.scad` library from Thingiverse should be used to manage the text.\n\n**Other Requirements:**\n\n*   I need a `smoothness` variable to control the number of facets used in the curves of the ring; larger numbers will be smoother but take longer to render. I'd like to use this same variable to set `$fn`.\n*   I need to be able to set the color of the metal using an RGBA vector, `colour_RGBA_metal` with values between 0-1.\n*   There should be some small offset that helps with manifoldness etc., which is a variable called `a_bit`. Set to 0.01 in the original script is probably fine.\n\nThe script should output the ring based on the parameters specified. Can you please create the OpenSCAD code for me?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Ring Band Creation Script - UK sizes Customizer",
    "scad": "ring_size_uk_ie_aus_nz=12.5;\nmain_wall=2;\nmain_depth=4.34;\nmain_feature=0.2;\n\tmain_internal_diameter=(ring_size_uk_ie_aus_nz+29.549)/2.5352;\ncs_shape=\"cs_half_pill\";\ntext_enabled=\"false\";\ntext_engraved=\"true\";\ntext_inside=\"true\";\ntext_itself=\"Your Text Here\";\ntext_height=2;\ntext_depth=1;\ntext_spacing=1.1;\ntext_font=\"write/orbitron.dxf\";\nsmoothness=20;\ncolour_RGBA_metal=[0.65,0.65,0.65,1];\na_bit=0.01*1;\n$fn=smoothness*1;\necho(\"main_internal_diameter \", main_internal_diameter);\nif (text_enabled==\"true\"){\n\tif (text_engraved==\"true\"){\n\t\tdifference(){\n\t\t\tcolor(colour_RGBA_metal) ring_shape(main_internal_diameter, main_depth, main_wall, main_feature);\n\t\t\tring_engraving(main_internal_diameter, main_wall, main_depth, text_inside, text_itself, text_height, text_depth, text_spacing);\n\t\t}\n\t}else{\n\t\tunion(){\n\t\t\tcolor(colour_RGBA_metal) ring_shape(main_internal_diameter, main_depth, main_wall, main_feature);\n\t\t\tring_engraving(main_internal_diameter, main_wall, main_depth, text_inside, text_itself, text_height, text_depth, text_spacing);\n\t\t}\n\t}\n}else{\n\tcolor(colour_RGBA_metal) ring_shape(main_internal_diameter, main_depth, main_wall, main_feature);\n}\nmodule ring_engraving(internal_diameter=20, wall=5, depth=5, text_inside=false, text_itself=\"Some Text\", text_height, text_depth=1, text_spacing=1.2, text_font=\"write/orbitron.dxf\"){\n\tinternal_radius=internal_diameter/2;\n\texternal_radius=(internal_diameter/2)+wall;\n\tif (text_inside==\"true\"){\n\t\tmirror(1,0,0)rotate(a=[0,0,180])writecylinder(text_itself,[0,0,-depth/2],internal_radius,depth,rotate=0,t=text_depth,h=text_height,space=text_spacing,font=text_font);\n\t}else{\n\t\twritecylinder(text_itself,[0,0,-depth/2],external_radius,depth,rotate=0,t=text_depth,h=text_height,space=text_spacing,font=text_font);\n\t}\n}\nmodule ring_shape(ring_internal_diameter, ring_depth, ring_wall, ring_feature){\n\trotate_extrude (convexity = 20) translate([(ring_internal_diameter)/2, 0, 0]){\n\t\tif(cs_shape==\"cs_pill\"){\n\t\t\techo(\"Pill Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\tpill_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_ellipse\"){\n\t\t\techo(\"Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\tellipse_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_hemi_ellipse\"){\n\t\t\techo(\"Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\themi_ellipse_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_hemi_ellipse\"){\n\t\t\techo(\"Rounded Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_hemi_ellipse_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rectangle\"){\n\t\t\techo(\"Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\trectangle_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_scallopped_rectangle\"){\n\t\t\techo(\"Scallopped Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\tscallopped_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_scallopped_rectangle\"){\n\t\t\techo(\"Rounded Scallopped Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_scallopped_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_rectangle\"){\n\t\t\techo(\"Rounded Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_chamfered_rectangle\"){\n\t\t\techo(\"Chamfered Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\tchamfered_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_half_pill\"){\n\t\t\techo(\"Half Pill Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\thalf_pill_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_reverse_hemi_ellipse\"){\n\t\t\techo(\"Reverse Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\ttranslate (v=[ring_wall,0,0]) rotate(a=[0,0,180]) hemi_ellipse_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_reverse_rounded_hemi_ellipse\"){\n\t\techo(\"Reverse Rounded Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\", ring_wall, \"feature\", ring_feature);\n\t\t\ttranslate (v=[ring_wall,0,0]) rotate(a=[0,0,180]) rounded_hemi_ellipse_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_half_chamfered_rectangle\"){\n\t\t\techo(\"Chamfered Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\thalf_chamfered_rectangle_shape (ring_depth, ring_wall+(sin(45)*ring_feature), ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_ellipse_intersection\"){\n\t\t\techo(\"Ellipse Intercestion Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\tellipse_intersection_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_ellipse_intersection\"){\n\t\t\techo(\"Rounded Ellipse Intercestion Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_ellipse_intersection_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t}\n}\nmodule pill_shape (pill_l, pill_b){\n\ttranslate(v=[pill_b/2,0,0]){\n\t\ttranslate (v=[0,-(pill_l-pill_b)/2,0]) circle (r=pill_b/2, center=true);\n\t\tsquare (size=[pill_b, pill_l-pill_b], center=true);\n\t\ttranslate (v=[0,(pill_l-pill_b)/2,0]) circle(r=pill_b/2, center=true);\n\t}\n}\nmodule ellipse_shape (ellipse_x, ellipse_y){\n\ttranslate(v=[ellipse_y/2,0,0]) scale(v=[ellipse_y,ellipse_x]) circle(r=0.5,$fn=40, center=true);\n}\nmodule hemi_ellipse_shape(hemi_ellipse_x,hemi_ellipse_y){\n\tscale(v=[2*hemi_ellipse_y,hemi_ellipse_x]) difference () {\n\t\tcircle(r=0.5,$fn=40, center=true);\n\t\ttranslate (v=[-1.5,0,0]) square (size=3, center=true);\n\t}\n}\nmodule rectangle_shape (rectangle_x, rectangle_y){\n\ttranslate(v=[rectangle_y/2,0,0]) square(size=[rectangle_y, rectangle_x], center=true);\n}\nmodule scallopped_rectangle_shape (scallopped_rectangle_y, scallopped_rectangle_x, scallopped_rectangle_z){\n\tdifference (){\n\t\trectangle_shape (scallopped_rectangle_y, scallopped_rectangle_x);\n\t\ttranslate(v=[scallopped_rectangle_x,0,0]) rotate(a=[0,0,180]) hemi_ellipse_shape(scallopped_rectangle_y,scallopped_rectangle_z);\n\t}\n}\nmodule rounded_scallopped_rectangle_shape (rounded_scallopped_rectangle_y, rounded_scallopped_rectangle_x, rounded_scallopped_rectangle_z){\n\tminkowski(){\n\t\ttranslate(v=[rounded_scallopped_rectangle_z,0,0]) difference (){\n\t\t\trectangle_shape (rounded_scallopped_rectangle_y-2*rounded_scallopped_rectangle_z, rounded_scallopped_rectangle_x-2*rounded_scallopped_rectangle_z);\n\t\t\ttranslate(v=[rounded_scallopped_rectangle_x-2*rounded_scallopped_rectangle_z,0,0]) rotate(a=[0,0,180]) hemi_ellipse_shape(rounded_scallopped_rectangle_y-2*rounded_scallopped_rectangle_z,rounded_scallopped_rectangle_z);\n\t\t}\n\tcircle(r=rounded_scallopped_rectangle_z, $fn=40);\n\t}\n}\nmodule rounded_hemi_ellipse_shape(rounded_ellipse_x, rounded_ellipse_y, rounded_ellipse_z){\n\ttranslate(v=[rounded_ellipse_z,0,0]){\n\t\tminkowski(){\n\t\t\themi_ellipse_shape(rounded_ellipse_x-2*rounded_ellipse_z,rounded_ellipse_y-2*rounded_ellipse_z);\n\t\t\tcircle(r=rounded_ellipse_z, $fn=40);\n\t\t}\n\t}\n}\nmodule rounded_rectangle_shape(rounded_rectangle_y, rounded_rectangle_x, rounded_rectangle_z){\n\ttranslate(v=[rounded_rectangle_x/2,0,0]){\n\t\tminkowski(){\n\t\t\tsquare(size=[rounded_rectangle_x-2*rounded_rectangle_z,rounded_rectangle_y-2*rounded_rectangle_z], center=true);\n\t\t\tcircle(r=rounded_rectangle_z, $fn=40);\n\t\t}\n\t}\n}\nmodule chamfered_rectangle_shape(chamfered_rectangle_y, chamfered_rectangle_x, chamfered_rectangle_z){\n\ttranslate(v=[chamfered_rectangle_x/2,-sin(45)*chamfered_rectangle_z,0]){\n\t\tminkowski(){\n\t\t\tsquare(size=[chamfered_rectangle_x-2*sin(45)*chamfered_rectangle_z,chamfered_rectangle_y-2*sin(45)*chamfered_rectangle_z],center=true);\n\t\t\trotate (a=[0,0,45]) square (size=chamfered_rectangle_z);\n\t\t}\n\t}\n}\nmodule half_chamfered_rectangle_shape(half_chamfered_rectangle_y, half_chamfered_rectangle_x, half_chamfered_rectangle_z){\n\ttranslate(v=[-sin(45)*half_chamfered_rectangle_z,0,0]){\n\t\tdifference(){\n\t\t\tchamfered_rectangle_shape (half_chamfered_rectangle_y, half_chamfered_rectangle_x+(sin(45)*half_chamfered_rectangle_z), half_chamfered_rectangle_z);\n\t\t\ttranslate(v=[(-0.1+sin(45)*half_chamfered_rectangle_z)/2,0,0]) square (size=[(sin(45)*half_chamfered_rectangle_z + 0.1),half_chamfered_rectangle_y+0.1], center=true);\n\t\t}\n\t}\n}\nmodule half_pill_shape (pill_l, pill_b){\n\ttranslate(v=[-pill_b,0,0]) difference (){\n\t\tpill_shape(pill_l,2*pill_b);\n\t\tsquare (size=[2*pill_b,pill_l], center=true);\n\t}\n}\nmodule ellipse_intersection_shape (ellipse_inter_x, ellipse_inter_y, ellipse_inter_z,rounding_rad_m=0){\n\tband_width_m = ellipse_inter_x;\n\tband_depth_m = ellipse_inter_y;\n\tinner_depth_ratio_m = ellipse_inter_z;\n\tinner_height_m=(band_depth_m)*inner_depth_ratio_m;\n\touter_height_m=(band_depth_m)-inner_height_m;\n\tinner_rad_m=(inner_height_m/2) + (band_width_m)*(band_width_m)/(8*inner_height_m);\n\touter_rad_m=(outer_height_m/2) + (band_width_m)*(band_width_m)/(8*outer_height_m);\n\trotate(a=-90)translate(v=[0, (band_depth_m)*inner_depth_ratio_m ]) intersection(){\n\t\ttranslate(v=[0,inner_rad_m-inner_height_m]) circle(r=inner_rad_m);\n\t\ttranslate(v=[0,-(outer_rad_m-outer_height_m)]) circle(r=outer_rad_m);\n\t}\n}\nmodule rounded_ellipse_intersection_shape (rounded_ellipse_inter_x, rounded_ellipse_inter_y, rounded_ellipse_inter_z,rounded_rounding_rad_l=0.5){\n\tband_width_l = rounded_ellipse_inter_x;\n\tband_depth_l = rounded_ellipse_inter_y;\n\tinner_depth_ratio_l = rounded_ellipse_inter_z;\n\tminkowski(){\n\t\tcircle(r=rounded_rounding_rad_l);\n\t\ttranslate(v=[rounded_rounding_rad_l,0])ellipse_intersection_shape (rounded_ellipse_inter_x-2*rounded_rounding_rad_l, rounded_ellipse_inter_y-2*rounded_rounding_rad_l, rounded_ellipse_inter_z,rounded_rounding_rad_l);\n\t}\n}",
    "description": "Okay, I'm looking to design a custom ring and I'd like to use OpenSCAD to do it. I found this script online, \"Ring_band_creation_script_v1.4-UK.scad,\" and it's almost exactly what I want but it's missing a few key things. I want the design to be entirely parametric and flexible, like the original but with these enhancements.\n\nHere's what I need:\n\n**Core Functionality (From the Existing Script):**\n\n*   **Ring Size:** I need to be able to specify the ring size using UK/Ireland/Australia/New Zealand sizing (the `ring_size_uk_ie_aus_nz` variable in the script). The script already includes the conversion to internal diameter, so that needs to be maintained.\n*   **Ring Band Dimensions:**  I need to set the band's width (`main_depth`), wall thickness (`main_wall`), and a \"feature\" variable (`main_feature`) that changes depending on the selected cross section.\n*   **Cross-Section Shapes:**  The script offers a bunch of pre-defined cross-section shapes (like `cs_pill`, `cs_ellipse`, `cs_rectangle`, etc.), and I want all of those to remain. I need to be able to choose from this list: `cs_ellipse`, `cs_rectangle`, `cs_pill`, `cs_hemi_ellipse`, `cs_scallopped_rectangle`, `cs_rounded_scallopped_rectangle`, `cs_rounded_hemi_ellipse`, `cs_rounded_rectangle`, `cs_chamfered_rectangle`, `cs_half_pill`, `cs_reverse_hemi_ellipse`, `cs_reverse_rounded_hemi_ellipse`, `cs_half_chamfered_rectangle`, `cs_ellipse_intersection`, `cs_rounded_ellipse_intersection`.\n*   **Text:** The script currently supports adding text, I need this functionality, it needs to allow me to enable/disable the text (`text_enabled`), choose between engraved or raised text (`text_engraved`), specify whether the text is on the inside or outside of the ring (`text_inside`), set the text itself (`text_itself`), the letter height (`text_height`), the depth of engraving or raising (`text_depth`), the spacing between letters (`text_spacing`) and the font (`text_font`). The text needs to wrap around the ring, and I should be able to use the included \"write.scad\" library (so it's a dependency).\n\n**Enhancements I Need:**\n\n1.  **Customizable Chamfers:** I need a more flexible chamfering option. Instead of the fixed `cs_chamfered_rectangle`, I'd like to be able to specify a chamfer angle and a chamfer size for *any* rectangular based cross-section. This should be applied to both the inner and outer edges of the cross section. It should also be applicable to only the inner or outer edge of the ring. If it could also be applied to non-rectangular cross sections that would be even better!\n\n2.  **Customizable Fillets:** Similar to the chamfer, I need the option to apply fillets (rounded edges) with a specified radius to both the inner and outer edges of *any* cross section (if possible), or at least the rectangular ones. These can also be inner, outer, or both edges.\n\n3.  **Variable Wall Angle:** It would be great to have a parameter to allow the wall of the ring to be angled. Instead of always being perpendicular to the ring's circular axis, I'd like to specify an angle for the wall, which means the profile wouldn't be extruded straight up, but at an angle.\n\n4.  **Customizable Cross Section:**  The biggest thing I would like is the ability to define my *own* cross section by specifying a list of 2D coordinates (X,Y). This would give me the ultimate flexibility in ring profile creation. The script has all the right functions for doing the extrude, so that should still work.\n\n**General Requirements:**\n\n*   **Parametric:** Everything should be parametric and customizable via variables at the top of the file.\n*   **Comments:** Include clear comments explaining each parameter and section.\n*   **Modularity:** The code should be organized into modules to improve readability and maintainability, like the original script.\n*   **Libraries:** Make sure the script uses the \"write.scad\" library that was used in the original script, as I still need the font and text wrapping support that it provides. I don't want to include any other libraries.\n\nSo, in short, I'm looking for an enhanced version of \"Ring_band_creation_script_v1.4-UK.scad\" that includes the chamfer and fillet enhancements, a wall angle parameter, and the ability to specify a custom cross section using a list of coordinates, whilst maintaining the current script's cross section choices, ring size input, and text capabilities.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric screwdriver bit holder",
    "scad": "hexDia=7.1;\nclr=0.5;\ntiers=4;\nrPcs=9;\nblkD=hexDia*1.6;\nblkW=hexDia*1.4;\nblkH=hexDia*1.9;\nhInc=5;\nmain();\nmodule main(){\n\tdifference(){\n\t\tstack();\n\t\tfor (r=[0:tiers-1])\n\t\t\ttranslate([r*blkD+blkD/2,rPcs*blkW/2,0])cube([2,rPcs*blkW+0.1,1],center=true);\n\t\tfor(c=[0:rPcs-1])\n\t\t\ttranslate([tiers*blkD/2,c*blkD+blkW/2,0])cube([tiers*blkD+0.1,2,1],center=true);\n\t}\n}\nmodule stack(){\n\tfor (r=[0:tiers-1]){\n\t\tdifference(){\n\t\t\ttranslate([blkD*r,0,0])cube([blkD,blkW*rPcs,blkH+hInc*r]);\n\t\t\ttranslate([r*blkD+blkD/2,0,r*hInc]){\n\t\t\t\tif (round(r/2)*2==r) {\n\t\t\t\t\trow(rPcs);\n\t\t\t\t}else{\n\t\t\t\t\ttranslate([0,blkW/2,0])row(rPcs-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule row(pcs){\n\tfor (p=[0:pcs-1]){\n\t\ttranslate([0,p*blkW+blkW/2,3])cylinder(r=hexDia/2+clr, h=blkH);\n\t}\n}",
    "description": "Okay, I'm looking to design a parametric bit holder for screwdriver bits, hex keys, and similar small tools. I've started something, but I'd like to improve it and make it more flexible.\n\nCurrently, my design uses a stack of rectangular \"tiers,\" each with a grid of cylindrical holes to hold the bits. The holes are arranged in rows, and the number of holes per row alternates between rows. Here's a breakdown of the key features and what I'm looking to achieve:\n\n**Current Design Parameters:**\n\n*   `hexDia`: Diameter of the hex bits (currently 7.1 mm). This determines the hole size.\n*   `clr`: Clearance around the hex bit (currently 0.5 mm). This is added to the hex diameter when making the holes.\n*   `tiers`: The number of tiers or levels in the stack (currently 4).\n*   `rPcs`: The number of bit positions in the longest row (currently 9). The number of bits in alternating rows is `rPcs - 1`\n*   `blkD`: The depth of each \"tier\" block (currently `hexDia * 1.6`).\n*   `blkW`: The width of the rectangle for a bit position (currently `hexDia * 1.4`).\n*   `blkH`: The base height of each tier's block (currently `hexDia * 1.9`).\n*   `hInc`: Height increment for each tier (currently 5). Tiers get progressively taller.\n\n**Desired Functionality and Improvements:**\n\n1.  **Parametric Control:** I want full control over all the parameters. I should be able to easily adjust the number of tiers, number of holes per row, the dimensions of the blocks, and the clearance.\n\n2.  **Customizable Hole Shape:** I want to be able to specify whether the bit holding holes are circular or hexagonal (and of what size). I want to be able to add a bit of clearance based on my \"clr\" parameter.\n\n3.  **Staggered Rows:** The alternating row lengths are good for spacing but it could be helpful if the alternating row lengths could be specified explicitly, rather than always subtracting 1. Alternatively, it'd be nice to set row offsets rather than always beginning on the same side of the row.\n\n4.  **Base:** I need a base for the design, ideally something flat and customizable. I should be able to specify the base dimensions. A fillet would be a nice touch as well. The base should be able to be disabled (a zero base height should remove it entirely).\n\n5.  **Mounting:** It would be very helpful if I could optionally add mounting holes to the base, for example for screws. I'd like to be able to specify the number, size, and placement of these.\n\n6.  **Material Clearance:** I need to be able to specify a general `materialClearance` parameter in addition to the per-hole `clr` parameter, to apply to the overall shape, including the base.\n\n7.  **OpenSCAD Libraries:** I'd like to use the `MCAD` library if it's useful for this, specifically the `threads` module if we end up needing any mounting holes or features. I do not need custom mounting holes but would like to be able to use the threads module to optionally include them.\n\n**In summary,** I'm looking for a flexible and highly customizable parametric bit holder that allows for adjustment of all dimensions, shapes, and mounting options, with the ability to use the `MCAD` library for things like thread creation on the mounting holes. Please don't attach the MCAD library, just utilize it.\n\nCould you help me create a robust and well-organized OpenSCAD file for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Ring Band Creation Script - Swiss sizes Customizer",
    "scad": "ring_size_switz=12.75;\nmain_wall=2;\nmain_depth=4.34;\nmain_feature=0.2;\n\tmain_internal_diameter=(ring_size_switz+39.561)/3.1314;\ncs_shape=\"cs_half_pill\";\ntext_enabled=\"false\";\ntext_engraved=\"true\";\ntext_inside=\"true\";\ntext_itself=\"Your Text Here\";\ntext_height=2;\ntext_depth=1;\ntext_spacing=1.1;\ntext_font=\"write\\orbitron.dxf\";\nsmoothness=20;\ncolour_RGBA_metal=[0.65,0.65,0.65,1];\na_bit=0.01*1;\n$fn=smoothness*1;\necho(\"main_internal_diameter \", main_internal_diameter);\nif (text_enabled==\"true\"){\n\tif (text_engraved==\"true\"){\n\t\tdifference(){\n\t\t\tcolor(colour_RGBA_metal) ring_shape(main_internal_diameter, main_depth, main_wall, main_feature);\n\t\t\tring_engraving(main_internal_diameter, main_wall, main_depth, text_inside, text_itself, text_height, text_depth, text_spacing);\n\t\t}\n\t}else{\n\t\tunion(){\n\t\t\tcolor(colour_RGBA_metal) ring_shape(main_internal_diameter, main_depth, main_wall, main_feature);\n\t\t\tring_engraving(main_internal_diameter, main_wall, main_depth, text_inside, text_itself, text_height, text_depth, text_spacing);\n\t\t}\n\t}\n}else{\n\tcolor(colour_RGBA_metal) ring_shape(main_internal_diameter, main_depth, main_wall, main_feature);\n}\nmodule ring_engraving(internal_diameter=20, wall=5, depth=5, text_inside=false, text_itself=\"Some Text\", text_height, text_depth=1, text_spacing=1.2, text_font=\"write/orbitron.dxf\"){\n\tinternal_radius=internal_diameter/2;\n\texternal_radius=(internal_diameter/2)+wall;\n\tif (text_inside==\"true\"){\n\t\tmirror(1,0,0)rotate(a=[0,0,180])writecylinder(text_itself,[0,0,-depth/2],internal_radius,depth,rotate=0,t=text_depth,h=text_height,space=text_spacing,font=text_font);\n\t}else{\n\t\twritecylinder(text_itself,[0,0,-depth/2],external_radius,depth,rotate=0,t=text_depth,h=text_height,space=text_spacing,font=text_font);\n\t}\n}\nmodule ring_shape(ring_internal_diameter, ring_depth, ring_wall, ring_feature){\n\trotate_extrude (convexity = 20) translate([(ring_internal_diameter)/2, 0, 0]){\n\t\tif(cs_shape==\"cs_pill\"){\n\t\t\techo(\"Pill Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\tpill_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_ellipse\"){\n\t\t\techo(\"Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\tellipse_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_hemi_ellipse\"){\n\t\t\techo(\"Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\themi_ellipse_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_hemi_ellipse\"){\n\t\t\techo(\"Rounded Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_hemi_ellipse_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rectangle\"){\n\t\t\techo(\"Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\trectangle_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_scallopped_rectangle\"){\n\t\t\techo(\"Scallopped Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\tscallopped_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_scallopped_rectangle\"){\n\t\t\techo(\"Rounded Scallopped Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_scallopped_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_rectangle\"){\n\t\t\techo(\"Rounded Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_chamfered_rectangle\"){\n\t\t\techo(\"Chamfered Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\tchamfered_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_half_pill\"){\n\t\t\techo(\"Half Pill Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\thalf_pill_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_reverse_hemi_ellipse\"){\n\t\t\techo(\"Reverse Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\ttranslate (v=[ring_wall,0,0]) rotate(a=[0,0,180]) hemi_ellipse_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_reverse_rounded_hemi_ellipse\"){\n\t\techo(\"Reverse Rounded Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\", ring_wall, \"feature\", ring_feature);\n\t\t\ttranslate (v=[ring_wall,0,0]) rotate(a=[0,0,180]) rounded_hemi_ellipse_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_half_chamfered_rectangle\"){\n\t\t\techo(\"Chamfered Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\thalf_chamfered_rectangle_shape (ring_depth, ring_wall+(sin(45)*ring_feature), ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_ellipse_intersection\"){\n\t\t\techo(\"Ellipse Intercestion Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\tellipse_intersection_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_ellipse_intersection\"){\n\t\t\techo(\"Rounded Ellipse Intercestion Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_ellipse_intersection_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t}\n}\nmodule pill_shape (pill_l, pill_b){\n\ttranslate(v=[pill_b/2,0,0]){\n\t\ttranslate (v=[0,-(pill_l-pill_b)/2,0]) circle (r=pill_b/2, center=true);\n\t\tsquare (size=[pill_b, pill_l-pill_b], center=true);\n\t\ttranslate (v=[0,(pill_l-pill_b)/2,0]) circle(r=pill_b/2, center=true);\n\t}\n}\nmodule ellipse_shape (ellipse_x, ellipse_y){\n\ttranslate(v=[ellipse_y/2,0,0]) scale(v=[ellipse_y,ellipse_x]) circle(r=0.5,$fn=40, center=true);\n}\nmodule hemi_ellipse_shape(hemi_ellipse_x,hemi_ellipse_y){\n\tscale(v=[2*hemi_ellipse_y,hemi_ellipse_x]) difference () {\n\t\tcircle(r=0.5,$fn=40, center=true);\n\t\ttranslate (v=[-1.5,0,0]) square (size=3, center=true);\n\t}\n}\nmodule rectangle_shape (rectangle_x, rectangle_y){\n\ttranslate(v=[rectangle_y/2,0,0]) square(size=[rectangle_y, rectangle_x], center=true);\n}\nmodule scallopped_rectangle_shape (scallopped_rectangle_y, scallopped_rectangle_x, scallopped_rectangle_z){\n\tdifference (){\n\t\trectangle_shape (scallopped_rectangle_y, scallopped_rectangle_x);\n\t\ttranslate(v=[scallopped_rectangle_x,0,0]) rotate(a=[0,0,180]) hemi_ellipse_shape(scallopped_rectangle_y,scallopped_rectangle_z);\n\t}\n}\nmodule rounded_scallopped_rectangle_shape (rounded_scallopped_rectangle_y, rounded_scallopped_rectangle_x, rounded_scallopped_rectangle_z){\n\tminkowski(){\n\t\ttranslate(v=[rounded_scallopped_rectangle_z,0,0]) difference (){\n\t\t\trectangle_shape (rounded_scallopped_rectangle_y-2*rounded_scallopped_rectangle_z, rounded_scallopped_rectangle_x-2*rounded_scallopped_rectangle_z);\n\t\t\ttranslate(v=[rounded_scallopped_rectangle_x-2*rounded_scallopped_rectangle_z,0,0]) rotate(a=[0,0,180]) hemi_ellipse_shape(rounded_scallopped_rectangle_y-2*rounded_scallopped_rectangle_z,rounded_scallopped_rectangle_z);\n\t\t}\n\tcircle(r=rounded_scallopped_rectangle_z, $fn=40);\n\t}\n}\nmodule rounded_hemi_ellipse_shape(rounded_ellipse_x, rounded_ellipse_y, rounded_ellipse_z){\n\ttranslate(v=[rounded_ellipse_z,0,0]){\n\t\tminkowski(){\n\t\t\themi_ellipse_shape(rounded_ellipse_x-2*rounded_ellipse_z,rounded_ellipse_y-2*rounded_ellipse_z);\n\t\t\tcircle(r=rounded_ellipse_z, $fn=40);\n\t\t}\n\t}\n}\nmodule rounded_rectangle_shape(rounded_rectangle_y, rounded_rectangle_x, rounded_rectangle_z){\n\ttranslate(v=[rounded_rectangle_x/2,0,0]){\n\t\tminkowski(){\n\t\t\tsquare(size=[rounded_rectangle_x-2*rounded_rectangle_z,rounded_rectangle_y-2*rounded_rectangle_z], center=true);\n\t\t\tcircle(r=rounded_rectangle_z, $fn=40);\n\t\t}\n\t}\n}\nmodule chamfered_rectangle_shape(chamfered_rectangle_y, chamfered_rectangle_x, chamfered_rectangle_z){\n\ttranslate(v=[chamfered_rectangle_x/2,-sin(45)*chamfered_rectangle_z,0]){\n\t\tminkowski(){\n\t\t\tsquare(size=[chamfered_rectangle_x-2*sin(45)*chamfered_rectangle_z,chamfered_rectangle_y-2*sin(45)*chamfered_rectangle_z],center=true);\n\t\t\trotate (a=[0,0,45]) square (size=chamfered_rectangle_z);\n\t\t}\n\t}\n}\nmodule half_chamfered_rectangle_shape(half_chamfered_rectangle_y, half_chamfered_rectangle_x, half_chamfered_rectangle_z){\n\ttranslate(v=[-sin(45)*half_chamfered_rectangle_z,0,0]){\n\t\tdifference(){\n\t\t\tchamfered_rectangle_shape (half_chamfered_rectangle_y, half_chamfered_rectangle_x+(sin(45)*half_chamfered_rectangle_z), half_chamfered_rectangle_z);\n\t\t\ttranslate(v=[(-0.1+sin(45)*half_chamfered_rectangle_z)/2,0,0]) square (size=[(sin(45)*half_chamfered_rectangle_z + 0.1),half_chamfered_rectangle_y+0.1], center=true);\n\t\t}\n\t}\n}\nmodule half_pill_shape (pill_l, pill_b){\n\ttranslate(v=[-pill_b,0,0]) difference (){\n\t\tpill_shape(pill_l,2*pill_b);\n\t\tsquare (size=[2*pill_b,pill_l], center=true);\n\t}\n}\nmodule ellipse_intersection_shape (ellipse_inter_x, ellipse_inter_y, ellipse_inter_z,rounding_rad_m=0){\n\tband_width_m = ellipse_inter_x;\n\tband_depth_m = ellipse_inter_y;\n\tinner_depth_ratio_m = ellipse_inter_z;\n\tinner_height_m=(band_depth_m)*inner_depth_ratio_m;\n\touter_height_m=(band_depth_m)-inner_height_m;\n\tinner_rad_m=(inner_height_m/2) + (band_width_m)*(band_width_m)/(8*inner_height_m);\n\touter_rad_m=(outer_height_m/2) + (band_width_m)*(band_width_m)/(8*outer_height_m);\n\trotate(a=-90)translate(v=[0, (band_depth_m)*inner_depth_ratio_m ]) intersection(){\n\t\ttranslate(v=[0,inner_rad_m-inner_height_m]) circle(r=inner_rad_m);\n\t\ttranslate(v=[0,-(outer_rad_m-outer_height_m)]) circle(r=outer_rad_m);\n\t}\n}\nmodule rounded_ellipse_intersection_shape (rounded_ellipse_inter_x, rounded_ellipse_inter_y, rounded_ellipse_inter_z,rounded_rounding_rad_l=0.5){\n\tband_width_l = rounded_ellipse_inter_x;\n\tband_depth_l = rounded_ellipse_inter_y;\n\tinner_depth_ratio_l = rounded_ellipse_inter_z;\n\tminkowski(){\n\t\tcircle(r=rounded_rounding_rad_l);\n\t\ttranslate(v=[rounded_rounding_rad_l,0])ellipse_intersection_shape (rounded_ellipse_inter_x-2*rounded_rounding_rad_l, rounded_ellipse_inter_y-2*rounded_rounding_rad_l, rounded_ellipse_inter_z,rounded_rounding_rad_l);\n\t}\n}",
    "description": "Okay, I'm looking for an OpenSCAD script to generate custom ring bands, specifically wedding band style rings. I want a lot of control over the ring's shape and the ability to add text.\n\nHere's what I need:\n\n**Ring Sizing:**\n\n*   I need to be able to specify the ring size using the Swiss numerical ring sizing system. I need a parameter called `ring_size_switz`.\n*   The script needs to calculate the internal diameter (`main_internal_diameter`) based on the provided Swiss size, using the formula `(ring_size_switz+39.561)/3.1314`.\n*   I also need parameters to control the ring's wall thickness (`main_wall`) and band width or depth (`main_depth`).\n*   There's also a `main_feature` parameter that's used differently by the different cross-section shapes - I'll need to be able to set that.\n\n**Ring Profile (Cross-Section Shape):**\n\n*   I need to be able to select from a variety of pre-defined cross-section shapes using a string variable called `cs_shape`.\n*   The options for the `cs_shape` variable should be:\n    *   `cs_ellipse`\n    *   `cs_rectangle`\n    *   `cs_pill`\n    *   `cs_hemi_ellipse`\n    *   `cs_scallopped_rectangle`\n    *   `cs_rounded_scallopped_rectangle`\n    *   `cs_rounded_hemi_ellipse`\n    *   `cs_rounded_rectangle`\n    *   `cs_chamfered_rectangle`\n    *   `cs_half_pill`\n    *   `cs_reverse_hemi_ellipse`\n    *   `cs_reverse_rounded_hemi_ellipse`\n    *   `cs_half_chamfered_rectangle`\n    *   `cs_ellipse_intersection`\n    *   `cs_rounded_ellipse_intersection`\n*   I need all these shapes defined in modules.\n\n**Text Engraving:**\n\n*   I need to be able to enable or disable text using a boolean variable called `text_enabled`.\n*   I need to control whether the text is engraved or raised using a boolean called `text_engraved`.\n*   I need to be able to choose whether the text is on the inside or outside of the ring using a boolean called `text_inside`.\n*   I need a string variable `text_itself` to specify the text.\n*   I need parameters to control `text_height` for the letter height, `text_depth` for the depth of engraving or raising, and `text_spacing` between letters.\n*   I want to be able to choose the font via `text_font` and use files like:  `write\\orbitron.dxf`, `write\\Letters.dxf`, `write\\BlackRose.dxf`, `write\\braille.dxf`.\n\n**Other:**\n\n*   A `smoothness` parameter, where bigger numbers make smoother rings (but take longer to render).  This is used as a multiplier for `$fn`.\n*   I want a parameter to control the ring's colour called `colour_RGBA_metal` as a RGBA vector with values between 0-1.\n*  There is a helper variable called `a_bit` that I would like included and set to `0.01`. This is to help ensure manifoldness.\n*   I need to include the `write.scad` library which you will find here: http://www.thingiverse.com/thing:16193 and use its `writecylinder` function.\n*   I need to echo out to the console the calculated `main_internal_diameter`.\n*  Please use `echo` to print out the parameters of the shape being used inside of the `ring_shape` module.\n\nI think that covers everything. Let me know if you have any questions.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Ring Band Creation Script - Indian sizes Customizer",
    "scad": "ring_size_ind_chn_jpn=11;\nmain_wall=2;\nmain_depth=4.34;\nmain_feature=0.2;\n\tmain_internal_diameter=(ring_size_ind_chn_jpn+34.749)/2.7924;\ncs_shape=\"cs_half_pill\";\ntext_enabled=\"false\";\ntext_engraved=\"true\";\ntext_inside=\"true\";\ntext_itself=\"Your Text Here\";\ntext_height=2;\ntext_depth=1;\ntext_spacing=1.1;\ntext_font=\"orbitron.dxf\";\nsmoothness=20;\ncolour_RGBA_metal=[0.65,0.65,0.65,1];\na_bit=0.01*1;\n$fn=smoothness*1;\necho(\"main_internal_diameter \", main_internal_diameter);\nif (text_enabled==\"true\"){\n\tif (text_engraved==\"true\"){\n\t\tdifference(){\n\t\t\tcolor(colour_RGBA_metal) ring_shape(main_internal_diameter, main_depth, main_wall, main_feature);\n\t\t\tring_engraving(main_internal_diameter, main_wall, main_depth, text_inside, text_itself, text_height, text_depth, text_spacing);\n\t\t}\n\t}else{\n\t\tunion(){\n\t\t\tcolor(colour_RGBA_metal) ring_shape(main_internal_diameter, main_depth, main_wall, main_feature);\n\t\t\tring_engraving(main_internal_diameter, main_wall, main_depth, text_inside, text_itself, text_height, text_depth, text_spacing);\n\t\t}\n\t}\n}else{\n\tcolor(colour_RGBA_metal) ring_shape(main_internal_diameter, main_depth, main_wall, main_feature);\n}\nmodule ring_engraving(internal_diameter=20, wall=5, depth=5, text_inside=false, text_itself=\"Some Text\", text_height, text_depth=1, text_spacing=1.2, text_font=\"write/orbitron.dxf\"){\n\tinternal_radius=internal_diameter/2;\n\texternal_radius=(internal_diameter/2)+wall;\n\tif (text_inside==\"true\"){\n\t\tmirror(1,0,0)rotate(a=[0,0,180])writecylinder(text_itself,[0,0,-depth/2],internal_radius,depth,rotate=0,t=text_depth,h=text_height,space=text_spacing,font=text_font);\n\t}else{\n\t\twritecylinder(text_itself,[0,0,-depth/2],external_radius,depth,rotate=0,t=text_depth,h=text_height,space=text_spacing,font=text_font);\n\t}\n}\nmodule ring_shape(ring_internal_diameter, ring_depth, ring_wall, ring_feature){\n\trotate_extrude (convexity = 20) translate([(ring_internal_diameter)/2, 0, 0]){\n\t\tif(cs_shape==\"cs_pill\"){\n\t\t\techo(\"Pill Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\tpill_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_ellipse\"){\n\t\t\techo(\"Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\tellipse_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_hemi_ellipse\"){\n\t\t\techo(\"Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\themi_ellipse_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_hemi_ellipse\"){\n\t\t\techo(\"Rounded Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_hemi_ellipse_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rectangle\"){\n\t\t\techo(\"Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\trectangle_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_scallopped_rectangle\"){\n\t\t\techo(\"Scallopped Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\tscallopped_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_scallopped_rectangle\"){\n\t\t\techo(\"Rounded Scallopped Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_scallopped_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_rectangle\"){\n\t\t\techo(\"Rounded Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_chamfered_rectangle\"){\n\t\t\techo(\"Chamfered Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\tchamfered_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_half_pill\"){\n\t\t\techo(\"Half Pill Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\thalf_pill_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_reverse_hemi_ellipse\"){\n\t\t\techo(\"Reverse Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\ttranslate (v=[ring_wall,0,0]) rotate(a=[0,0,180]) hemi_ellipse_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_reverse_rounded_hemi_ellipse\"){\n\t\techo(\"Reverse Rounded Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\", ring_wall, \"feature\", ring_feature);\n\t\t\ttranslate (v=[ring_wall,0,0]) rotate(a=[0,0,180]) rounded_hemi_ellipse_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_half_chamfered_rectangle\"){\n\t\t\techo(\"Chamfered Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\thalf_chamfered_rectangle_shape (ring_depth, ring_wall+(sin(45)*ring_feature), ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_ellipse_intersection\"){\n\t\t\techo(\"Ellipse Intercestion Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\tellipse_intersection_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_ellipse_intersection\"){\n\t\t\techo(\"Rounded Ellipse Intercestion Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_ellipse_intersection_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t}\n}\nmodule pill_shape (pill_l, pill_b){\n\ttranslate(v=[pill_b/2,0,0]){\n\t\ttranslate (v=[0,-(pill_l-pill_b)/2,0]) circle (r=pill_b/2, center=true);\n\t\tsquare (size=[pill_b, pill_l-pill_b], center=true);\n\t\ttranslate (v=[0,(pill_l-pill_b)/2,0]) circle(r=pill_b/2, center=true);\n\t}\n}\nmodule ellipse_shape (ellipse_x, ellipse_y){\n\ttranslate(v=[ellipse_y/2,0,0]) scale(v=[ellipse_y,ellipse_x]) circle(r=0.5,$fn=40, center=true);\n}\nmodule hemi_ellipse_shape(hemi_ellipse_x,hemi_ellipse_y){\n\tscale(v=[2*hemi_ellipse_y,hemi_ellipse_x]) difference () {\n\t\tcircle(r=0.5,$fn=40, center=true);\n\t\ttranslate (v=[-1.5,0,0]) square (size=3, center=true);\n\t}\n}\nmodule rectangle_shape (rectangle_x, rectangle_y){\n\ttranslate(v=[rectangle_y/2,0,0]) square(size=[rectangle_y, rectangle_x], center=true);\n}\nmodule scallopped_rectangle_shape (scallopped_rectangle_y, scallopped_rectangle_x, scallopped_rectangle_z){\n\tdifference (){\n\t\trectangle_shape (scallopped_rectangle_y, scallopped_rectangle_x);\n\t\ttranslate(v=[scallopped_rectangle_x,0,0]) rotate(a=[0,0,180]) hemi_ellipse_shape(scallopped_rectangle_y,scallopped_rectangle_z);\n\t}\n}\nmodule rounded_scallopped_rectangle_shape (rounded_scallopped_rectangle_y, rounded_scallopped_rectangle_x, rounded_scallopped_rectangle_z){\n\tminkowski(){\n\t\ttranslate(v=[rounded_scallopped_rectangle_z,0,0]) difference (){\n\t\t\trectangle_shape (rounded_scallopped_rectangle_y-2*rounded_scallopped_rectangle_z, rounded_scallopped_rectangle_x-2*rounded_scallopped_rectangle_z);\n\t\t\ttranslate(v=[rounded_scallopped_rectangle_x-2*rounded_scallopped_rectangle_z,0,0]) rotate(a=[0,0,180]) hemi_ellipse_shape(rounded_scallopped_rectangle_y-2*rounded_scallopped_rectangle_z,rounded_scallopped_rectangle_z);\n\t\t}\n\tcircle(r=rounded_scallopped_rectangle_z, $fn=40);\n\t}\n}\nmodule rounded_hemi_ellipse_shape(rounded_ellipse_x, rounded_ellipse_y, rounded_ellipse_z){\n\ttranslate(v=[rounded_ellipse_z,0,0]){\n\t\tminkowski(){\n\t\t\themi_ellipse_shape(rounded_ellipse_x-2*rounded_ellipse_z,rounded_ellipse_y-2*rounded_ellipse_z);\n\t\t\tcircle(r=rounded_ellipse_z, $fn=40);\n\t\t}\n\t}\n}\nmodule rounded_rectangle_shape(rounded_rectangle_y, rounded_rectangle_x, rounded_rectangle_z){\n\ttranslate(v=[rounded_rectangle_x/2,0,0]){\n\t\tminkowski(){\n\t\t\tsquare(size=[rounded_rectangle_x-2*rounded_rectangle_z,rounded_rectangle_y-2*rounded_rectangle_z], center=true);\n\t\t\tcircle(r=rounded_rectangle_z, $fn=40);\n\t\t}\n\t}\n}\nmodule chamfered_rectangle_shape(chamfered_rectangle_y, chamfered_rectangle_x, chamfered_rectangle_z){\n\ttranslate(v=[chamfered_rectangle_x/2,-sin(45)*chamfered_rectangle_z,0]){\n\t\tminkowski(){\n\t\t\tsquare(size=[chamfered_rectangle_x-2*sin(45)*chamfered_rectangle_z,chamfered_rectangle_y-2*sin(45)*chamfered_rectangle_z],center=true);\n\t\t\trotate (a=[0,0,45]) square (size=chamfered_rectangle_z);\n\t\t}\n\t}\n}\nmodule half_chamfered_rectangle_shape(half_chamfered_rectangle_y, half_chamfered_rectangle_x, half_chamfered_rectangle_z){\n\ttranslate(v=[-sin(45)*half_chamfered_rectangle_z,0,0]){\n\t\tdifference(){\n\t\t\tchamfered_rectangle_shape (half_chamfered_rectangle_y, half_chamfered_rectangle_x+(sin(45)*half_chamfered_rectangle_z), half_chamfered_rectangle_z);\n\t\t\ttranslate(v=[(-0.1+sin(45)*half_chamfered_rectangle_z)/2,0,0]) square (size=[(sin(45)*half_chamfered_rectangle_z + 0.1),half_chamfered_rectangle_y+0.1], center=true);\n\t\t}\n\t}\n}\nmodule half_pill_shape (pill_l, pill_b){\n\ttranslate(v=[-pill_b,0,0]) difference (){\n\t\tpill_shape(pill_l,2*pill_b);\n\t\tsquare (size=[2*pill_b,pill_l], center=true);\n\t}\n}\nmodule ellipse_intersection_shape (ellipse_inter_x, ellipse_inter_y, ellipse_inter_z,rounding_rad_m=0){\n\tband_width_m = ellipse_inter_x;\n\tband_depth_m = ellipse_inter_y;\n\tinner_depth_ratio_m = ellipse_inter_z;\n\tinner_height_m=(band_depth_m)*inner_depth_ratio_m;\n\touter_height_m=(band_depth_m)-inner_height_m;\n\tinner_rad_m=(inner_height_m/2) + (band_width_m)*(band_width_m)/(8*inner_height_m);\n\touter_rad_m=(outer_height_m/2) + (band_width_m)*(band_width_m)/(8*outer_height_m);\n\trotate(a=-90)translate(v=[0, (band_depth_m)*inner_depth_ratio_m ]) intersection(){\n\t\ttranslate(v=[0,inner_rad_m-inner_height_m]) circle(r=inner_rad_m);\n\t\ttranslate(v=[0,-(outer_rad_m-outer_height_m)]) circle(r=outer_rad_m);\n\t}\n}\nmodule rounded_ellipse_intersection_shape (rounded_ellipse_inter_x, rounded_ellipse_inter_y, rounded_ellipse_inter_z,rounded_rounding_rad_l=0.5){\n\tband_width_l = rounded_ellipse_inter_x;\n\tband_depth_l = rounded_ellipse_inter_y;\n\tinner_depth_ratio_l = rounded_ellipse_inter_z;\n\tminkowski(){\n\t\tcircle(r=rounded_rounding_rad_l);\n\t\ttranslate(v=[rounded_rounding_rad_l,0])ellipse_intersection_shape (rounded_ellipse_inter_x-2*rounded_rounding_rad_l, rounded_ellipse_inter_y-2*rounded_rounding_rad_l, rounded_ellipse_inter_z,rounded_rounding_rad_l);\n\t}\n}",
    "description": "Okay, I'd like to design a ring using OpenSCAD, and I've seen a script that looks like it does most of what I want, but I need it to be fully parametric and a bit more flexible.\n\nHere's the basic idea: I want to create a ring with a customizable cross-sectional shape, text engraving/raising, and sizing based on India, China, and Japan numerical ring sizes. The ring band's inner diameter should be calculated from the ring size parameter. The script I've seen uses the following formula: `main_internal_diameter=(ring_size_ind_chn_jpn+34.749)/2.7924` to convert from ring size to inner diameter (in mm).\n\nI need the following parameters to be adjustable:\n\n*   **Ring Size:** An integer value representing the India/China/Japan numerical ring size (e.g., 1-27).\n*   **Band Wall Thickness:** The difference between the inner and outer radius of the ring, essentially the thickness of the metal (in mm).\n*   **Band Depth:** The width of the ring band (in mm).\n*   **Cross-Section Shape:** A selection from a list of pre-defined cross-sectional shapes. I'd like to use the following shapes (and I don't need all the aliases, I just need the core names, which are found by removing the 'cs_' prefixes):\n    *   `ellipse`\n    *   `rectangle`\n    *   `pill`\n    *   `hemi_ellipse`\n    *   `scallopped_rectangle`\n    *   `rounded_scallopped_rectangle`\n    *   `rounded_hemi_ellipse`\n    *   `rounded_rectangle`\n    *   `chamfered_rectangle`\n    *   `half_pill`\n    *   `reverse_hemi_ellipse`\n    *   `reverse_rounded_hemi_ellipse`\n    *   `half_chamfered_rectangle`\n    *    `ellipse_intersection`\n    *    `rounded_ellipse_intersection`\n*   **Cross-Section Feature:** A floating-point value used by some of the cross-section shapes to fine tune, for example the size of chamfers or radii. Some cross sections might not use this parameter.\n*   **Text Enable:** A boolean value (`true`/`false`) indicating whether text should be added to the ring.\n*   **Text Engraved:** A boolean value (`true`/`false`) determining whether the text is engraved (cut into the ring) or raised (extruded from the ring surface).\n*   **Text Inside:** A boolean value (`true`/`false`) specifying whether the text is on the inside or outside of the ring band.\n*   **Text String:** The string of text to be added.\n*   **Text Height:** The height of the text characters in mm.\n*   **Text Depth:** The depth of the engraved/raised text.\n*   **Text Spacing:** The spacing between characters of the text.\n*  **Text Font:** The filename of the font to use.  I'd like to be able to use the Write.scad library for this. I know it defaults to \"orbitron.dxf\", but I would like this to be parameterizable.\n*   **Smoothness:** A number controlling the $fn value for smoother shapes.\n*   **Metal Color:** RGBA value for the ring color.\n\nI need the design to use `rotate_extrude` to generate the ring shape, and also make use of the `minkowski` function where rounded shapes are generated. I will also need to include and use `write.scad` from http://www.thingiverse.com/thing:16193 to write the text on the ring.\n\nThe text should use the `writecylinder` function from `write.scad` to properly curve the text around the ring.\n\nThe user-facing interface should clearly label all parameters and provide reasonable default values to make it easy to get started.\n\nCan you generate the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Ring Band Creation Script - MM sizes Customizer",
    "scad": "ring_size_mm=20;\nmain_wall=2;\nmain_depth=4.34;\nmain_feature=0.2;\n\tmain_internal_diameter=ring_size_mm;\ncs_shape=\"cs_half_pill\";\ntext_enabled=\"false\";\ntext_engraved=\"true\";\ntext_inside=\"true\";\ntext_itself=\"Your Text Here\";\ntext_height=2;\ntext_depth=1;\ntext_spacing=1.1;\ntext_font=\"orbitron.dxf\";\nsmoothness=20;\ncolour_RGBA_metal=[0.65,0.65,0.65,1];\na_bit=0.01*1;\n$fn=smoothness*1;\necho(\"main_internal_diameter \", main_internal_diameter);\nif (text_enabled==\"true\"){\n\tif (text_engraved==\"true\"){\n\t\tdifference(){\n\t\t\tcolor(colour_RGBA_metal) ring_shape(main_internal_diameter, main_depth, main_wall, main_feature);\n\t\t\tring_engraving(main_internal_diameter, main_wall, main_depth, text_inside, text_itself, text_height, text_depth, text_spacing);\n\t\t}\n\t}else{\n\t\tunion(){\n\t\t\tcolor(colour_RGBA_metal) ring_shape(main_internal_diameter, main_depth, main_wall, main_feature);\n\t\t\tring_engraving(main_internal_diameter, main_wall, main_depth, text_inside, text_itself, text_height, text_depth, text_spacing);\n\t\t}\n\t}\n}else{\n\tcolor(colour_RGBA_metal) ring_shape(main_internal_diameter, main_depth, main_wall, main_feature);\n}\nmodule ring_engraving(internal_diameter=20, wall=5, depth=5, text_inside=false, text_itself=\"Some Text\", text_height, text_depth=1, text_spacing=1.2, text_font=\"write/orbitron.dxf\"){\n\tinternal_radius=internal_diameter/2;\n\texternal_radius=(internal_diameter/2)+wall;\n\tif (text_inside==\"true\"){\n\t\tmirror(1,0,0)rotate(a=[0,0,180])writecylinder(text_itself,[0,0,-depth/2],internal_radius,depth,rotate=0,t=text_depth,h=text_height,space=text_spacing,font=text_font);\n\t}else{\n\t\twritecylinder(text_itself,[0,0,-depth/2],external_radius,depth,rotate=0,t=text_depth,h=text_height,space=text_spacing,font=text_font);\n\t}\n}\nmodule ring_shape(ring_internal_diameter, ring_depth, ring_wall, ring_feature){\n\trotate_extrude (convexity = 20) translate([(ring_internal_diameter)/2, 0, 0]){\n\t\tif(cs_shape==\"cs_pill\"){\n\t\t\techo(\"Pill Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\tpill_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_ellipse\"){\n\t\t\techo(\"Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\tellipse_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_hemi_ellipse\"){\n\t\t\techo(\"Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\themi_ellipse_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_hemi_ellipse\"){\n\t\t\techo(\"Rounded Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_hemi_ellipse_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rectangle\"){\n\t\t\techo(\"Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\trectangle_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_scallopped_rectangle\"){\n\t\t\techo(\"Scallopped Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\tscallopped_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_scallopped_rectangle\"){\n\t\t\techo(\"Rounded Scallopped Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_scallopped_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_rectangle\"){\n\t\t\techo(\"Rounded Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_chamfered_rectangle\"){\n\t\t\techo(\"Chamfered Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\tchamfered_rectangle_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_half_pill\"){\n\t\t\techo(\"Half Pill Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\thalf_pill_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_reverse_hemi_ellipse\"){\n\t\t\techo(\"Reverse Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall);\n\t\t\ttranslate (v=[ring_wall,0,0]) rotate(a=[0,0,180]) hemi_ellipse_shape (ring_depth, ring_wall);\n\t\t}\n\t\telse if(cs_shape==\"cs_reverse_rounded_hemi_ellipse\"){\n\t\techo(\"Reverse Rounded Hemi Ellipse Shaped Cross Section, depth\",  ring_depth, \"wall\", ring_wall, \"feature\", ring_feature);\n\t\t\ttranslate (v=[ring_wall,0,0]) rotate(a=[0,0,180]) rounded_hemi_ellipse_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_half_chamfered_rectangle\"){\n\t\t\techo(\"Chamfered Rectangle Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\thalf_chamfered_rectangle_shape (ring_depth, ring_wall+(sin(45)*ring_feature), ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_ellipse_intersection\"){\n\t\t\techo(\"Ellipse Intercestion Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\tellipse_intersection_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t\telse if(cs_shape==\"cs_rounded_ellipse_intersection\"){\n\t\t\techo(\"Rounded Ellipse Intercestion Shaped Cross Section, depth\",  ring_depth, \"wall\",ring_wall,\"feature\", ring_feature);\n\t\t\trounded_ellipse_intersection_shape (ring_depth, ring_wall, ring_feature);\n\t\t}\n\t}\n}\nmodule pill_shape (pill_l, pill_b){\n\ttranslate(v=[pill_b/2,0,0]){\n\t\ttranslate (v=[0,-(pill_l-pill_b)/2,0]) circle (r=pill_b/2, center=true);\n\t\tsquare (size=[pill_b, pill_l-pill_b], center=true);\n\t\ttranslate (v=[0,(pill_l-pill_b)/2,0]) circle(r=pill_b/2, center=true);\n\t}\n}\nmodule ellipse_shape (ellipse_x, ellipse_y){\n\ttranslate(v=[ellipse_y/2,0,0]) scale(v=[ellipse_y,ellipse_x]) circle(r=0.5,$fn=40, center=true);\n}\nmodule hemi_ellipse_shape(hemi_ellipse_x,hemi_ellipse_y){\n\tscale(v=[2*hemi_ellipse_y,hemi_ellipse_x]) difference () {\n\t\tcircle(r=0.5,$fn=40, center=true);\n\t\ttranslate (v=[-1.5,0,0]) square (size=3, center=true);\n\t}\n}\nmodule rectangle_shape (rectangle_x, rectangle_y){\n\ttranslate(v=[rectangle_y/2,0,0]) square(size=[rectangle_y, rectangle_x], center=true);\n}\nmodule scallopped_rectangle_shape (scallopped_rectangle_y, scallopped_rectangle_x, scallopped_rectangle_z){\n\tdifference (){\n\t\trectangle_shape (scallopped_rectangle_y, scallopped_rectangle_x);\n\t\ttranslate(v=[scallopped_rectangle_x,0,0]) rotate(a=[0,0,180]) hemi_ellipse_shape(scallopped_rectangle_y,scallopped_rectangle_z);\n\t}\n}\nmodule rounded_scallopped_rectangle_shape (rounded_scallopped_rectangle_y, rounded_scallopped_rectangle_x, rounded_scallopped_rectangle_z){\n\tminkowski(){\n\t\ttranslate(v=[rounded_scallopped_rectangle_z,0,0]) difference (){\n\t\t\trectangle_shape (rounded_scallopped_rectangle_y-2*rounded_scallopped_rectangle_z, rounded_scallopped_rectangle_x-2*rounded_scallopped_rectangle_z);\n\t\t\ttranslate(v=[rounded_scallopped_rectangle_x-2*rounded_scallopped_rectangle_z,0,0]) rotate(a=[0,0,180]) hemi_ellipse_shape(rounded_scallopped_rectangle_y-2*rounded_scallopped_rectangle_z,rounded_scallopped_rectangle_z);\n\t\t}\n\tcircle(r=rounded_scallopped_rectangle_z, $fn=40);\n\t}\n}\nmodule rounded_hemi_ellipse_shape(rounded_ellipse_x, rounded_ellipse_y, rounded_ellipse_z){\n\ttranslate(v=[rounded_ellipse_z,0,0]){\n\t\tminkowski(){\n\t\t\themi_ellipse_shape(rounded_ellipse_x-2*rounded_ellipse_z,rounded_ellipse_y-2*rounded_ellipse_z);\n\t\t\tcircle(r=rounded_ellipse_z, $fn=40);\n\t\t}\n\t}\n}\nmodule rounded_rectangle_shape(rounded_rectangle_y, rounded_rectangle_x, rounded_rectangle_z){\n\ttranslate(v=[rounded_rectangle_x/2,0,0]){\n\t\tminkowski(){\n\t\t\tsquare(size=[rounded_rectangle_x-2*rounded_rectangle_z,rounded_rectangle_y-2*rounded_rectangle_z], center=true);\n\t\t\tcircle(r=rounded_rectangle_z, $fn=40);\n\t\t}\n\t}\n}\nmodule chamfered_rectangle_shape(chamfered_rectangle_y, chamfered_rectangle_x, chamfered_rectangle_z){\n\ttranslate(v=[chamfered_rectangle_x/2,-sin(45)*chamfered_rectangle_z,0]){\n\t\tminkowski(){\n\t\t\tsquare(size=[chamfered_rectangle_x-2*sin(45)*chamfered_rectangle_z,chamfered_rectangle_y-2*sin(45)*chamfered_rectangle_z],center=true);\n\t\t\trotate (a=[0,0,45]) square (size=chamfered_rectangle_z);\n\t\t}\n\t}\n}\nmodule half_chamfered_rectangle_shape(half_chamfered_rectangle_y, half_chamfered_rectangle_x, half_chamfered_rectangle_z){\n\ttranslate(v=[-sin(45)*half_chamfered_rectangle_z,0,0]){\n\t\tdifference(){\n\t\t\tchamfered_rectangle_shape (half_chamfered_rectangle_y, half_chamfered_rectangle_x+(sin(45)*half_chamfered_rectangle_z), half_chamfered_rectangle_z);\n\t\t\ttranslate(v=[(-0.1+sin(45)*half_chamfered_rectangle_z)/2,0,0]) square (size=[(sin(45)*half_chamfered_rectangle_z + 0.1),half_chamfered_rectangle_y+0.1], center=true);\n\t\t}\n\t}\n}\nmodule half_pill_shape (pill_l, pill_b){\n\ttranslate(v=[-pill_b,0,0]) difference (){\n\t\tpill_shape(pill_l,2*pill_b);\n\t\tsquare (size=[2*pill_b,pill_l], center=true);\n\t}\n}\nmodule ellipse_intersection_shape (ellipse_inter_x, ellipse_inter_y, ellipse_inter_z,rounding_rad_m=0){\n\tband_width_m = ellipse_inter_x;\n\tband_depth_m = ellipse_inter_y;\n\tinner_depth_ratio_m = ellipse_inter_z;\n\tinner_height_m=(band_depth_m)*inner_depth_ratio_m;\n\touter_height_m=(band_depth_m)-inner_height_m;\n\tinner_rad_m=(inner_height_m/2) + (band_width_m)*(band_width_m)/(8*inner_height_m);\n\touter_rad_m=(outer_height_m/2) + (band_width_m)*(band_width_m)/(8*outer_height_m);\n\trotate(a=-90)translate(v=[0, (band_depth_m)*inner_depth_ratio_m ]) intersection(){\n\t\ttranslate(v=[0,inner_rad_m-inner_height_m]) circle(r=inner_rad_m);\n\t\ttranslate(v=[0,-(outer_rad_m-outer_height_m)]) circle(r=outer_rad_m);\n\t}\n}\nmodule rounded_ellipse_intersection_shape (rounded_ellipse_inter_x, rounded_ellipse_inter_y, rounded_ellipse_inter_z,rounded_rounding_rad_l=0.5){\n\tband_width_l = rounded_ellipse_inter_x;\n\tband_depth_l = rounded_ellipse_inter_y;\n\tinner_depth_ratio_l = rounded_ellipse_inter_z;\n\tminkowski(){\n\t\tcircle(r=rounded_rounding_rad_l);\n\t\ttranslate(v=[rounded_rounding_rad_l,0])ellipse_intersection_shape (rounded_ellipse_inter_x-2*rounded_rounding_rad_l, rounded_ellipse_inter_y-2*rounded_rounding_rad_l, rounded_ellipse_inter_z,rounded_rounding_rad_l);\n\t}\n}",
    "description": "Okay, I need a parametric OpenSCAD file for creating custom ring bands, similar to what's described in the \"Ring_band_creation_script_v1.4-MM.scad\" file. I want to be able to adjust various aspects of the ring band, including its size, shape, and add text.\n\nHere are the specific features I need:\n\n**Ring Size:**\n*   I need to specify the ring size by its inner diameter in millimeters.\n*   I need a parameter to control the thickness of the ring band wall.\n*   I need a parameter for the width of the ring band.\n\n**Cross-Section Shape:**\n*   I want to select from various cross-section shapes, including:\n    *   Pill\n    *   Ellipse\n    *   Hemi-Ellipse\n    *   Rounded Hemi-Ellipse\n    *   Rectangle\n    *   Scalloped Rectangle\n    *   Rounded Scalloped Rectangle\n    *   Rounded Rectangle\n    *   Chamfered Rectangle\n    *   Half-Pill\n    *   Reverse Hemi-Ellipse\n    *   Reverse Rounded Hemi-Ellipse\n    *   Half-Chamfered Rectangle\n    *   Ellipse Intersection\n    *   Rounded Ellipse Intersection\n*   There should be a parameter for controlling a \"feature\" value for some shapes like scalloped rectangles, rounded rectangles, etc., to fine-tune the shape.\n\n**Text:**\n*   I need to be able to enable/disable text.\n*   I need the option to engrave or raise the text.\n*   I need to choose whether the text appears on the inside or outside of the ring band.\n*   I need a parameter to specify the text itself.\n*   I need to control the height and depth of the text.\n*   I need to control letter spacing.\n*   I need to be able to select the text font, preferably with the ability to choose from multiple fonts that are included or that can be added.\n*   I will need the `write.scad` library from Thingiverse user \"HarlanDMii\", which is located at http://www.thingiverse.com/thing:16193, to support text writing.\n\n**Other Parameters**\n\n*   I need a parameter to adjust the smoothness of the ring; that is, the `$fn` parameter.\n*  I need to specify the metal color using RGBA values.\n\n**Output:**\n\nThe script should output a single, manifold 3D model of the ring band according to my specifications.\n\nCould you generate the OpenSCAD file for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Flashlight grip for sliding bike handlebar mounts",
    "scad": "outer_r = 14.9;\ninner_r = 12.5;\nlength = 40;\ngap = 6;\nslide_width = 22.8;\nrail_width = 18;\noverhang = 2.6;\nrail_thickness = 2.5;\noverhang_thickness = 2.4;\nrail_wall = (slide_width - rail_width)/2;\nslide_thickness = 7.3;\ntop_thickness = slide_thickness - rail_thickness - overhang_thickness;\nflange_width = 2.4;\nflange_height = 12;\nbolt_diameter = 3.8;\nnut_diameter = 7.8;\nhole_height = 33.5;\nhole_length = 4;\nhole_width = 4;\nhole_depth = 1;\n$fn=100;\nmodule grip()\n{\n  difference()\n  {\n    cylinder(r=outer_r, h=length);\n    translate([0, 0, -1])\n      cylinder(r=inner_r, h=length+2);\n    translate([0, -gap/2, -1])\n      cube([outer_r, gap, length+2]);\n  }\n}\nmodule bolt_hole()\n{\n  rotate([-90, 0, 0])\n    cylinder(r=bolt_diameter/2, h=flange_width + 2);\n}\nmodule flange()\n{\n  difference()\n  {\n    cube([flange_height, flange_width, length]);\n    translate([flange_height/2, -1, length/4]) bolt_hole();\n    translate([flange_height/2, -1, length/2]) bolt_hole();\n    translate([flange_height/2, -1, 3*length/4]) bolt_hole();\n  }\n}\nmodule nut_hole()\n{\n  rotate([-90, 0, 0])\n    cylinder(r=nut_diameter/2, h=flange_width, $fn=6);\n}\nmodule flanges()\n{\n  translate([0, gap/2, 0])\n    flange();\n  translate([0, -gap/2 - flange_width, 0])\n    difference()\n    {\n      flange();\n      translate([flange_height/2, -1, length/4]) nut_hole();\n      translate([flange_height/2, -1, length/2]) nut_hole();\n      translate([flange_height/2, -1, 3*length/4]) nut_hole();\n    }\n}\nmodule hole()\n{\n  translate([-top_thickness - 1, -hole_width/2, hole_height])\n    cube([hole_depth + 1, hole_width, hole_length]);\n}\nmodule slide()\n{\n  difference()\n  {\n    cube([slide_thickness, slide_width, length]);\n    translate([overhang_thickness, rail_wall, -1])\n      cube([rail_thickness, rail_width, length + 2]);\n    translate([-1, overhang + rail_wall, -1])\n      cube([overhang_thickness + 2, slide_width-2*(rail_wall + overhang), length + 2]);\n  }\n}\ndifference()\n{\n  union()\n  {\n    translate([inner_r, 0, 0]) grip();\n    translate([2 * inner_r, 0, 0]) flanges();\n    translate([-slide_thickness, -slide_width/2, 0]) slide();\n  }\n  hole();\n}",
    "description": "Okay, I've got an OpenSCAD file that I've been using to 3D print a flashlight mount for my bike, but it's a bit clunky and I'd really like something more flexible and user-friendly. Im hoping you can help me design a much better version.\n\nHeres the basic idea: I want to mount a cylindrical flashlight onto those sliding handlebar grips that come with a lot of cheap bike lights. My current design is okay, but it has a lot of hardcoded values and isn't very easy to customize.\n\nMy current model has three main parts: a cylindrical grip to hold the flashlight, flanges that extend from the grip for bolting to the slide, and a slide that attaches to the handlebar grip rail. I also need a hole in the slide for a spring clip.\n\nHere are the key parameters that I need to be able to adjust:\n\n**Cylinder (Grip):**\n\n*   `outer_r`: The outer radius of the cylinder.\n*   `inner_r`: The inner radius of the cylinder (this needs to fit the flashlight with a bit of padding).\n*   `length`: The overall length of the cylinder.\n*   `gap`: The width of the gap cut out of the cylinder to make it a clamp.\n\n**Slide (Rail Attachment):**\n\n*   `slide_width`: The overall width of the slide piece.\n*   `rail_width`: The width of the rail on the handlebar grip that the slide needs to fit. I need to be able to add some wiggle room.\n*   `overhang`: The width of the overhang under the rail.\n*   `rail_thickness`: The thickness of the rail itself.\n*   `overhang_thickness`: The thickness of the overhanging part of the slide.\n*   `slide_thickness`: The overall thickness of the slide.\n\n**Flange and Bolts:**\n\n*   `flange_width`: The width of the flange that the bolts go through.\n*   `flange_height`: The height of the flange.\n*   `bolt_diameter`: The diameter of the bolt holes.\n*   `nut_diameter`: The diameter of the nut recess in the flange.\n\n**Hole in Slide:**\n\n*   `hole_height`: The distance from the end of the slide to the hole center.\n*   `hole_length`: The length of the spring clip hole.\n*   `hole_width`: The width of the spring clip hole.\n*  `hole_depth`: How deep the spring clip hole extends.\n\nI'd like the design to be fully parametric, so I can easily change these values and generate different sized mounts. I'm also using the `$fn` to smooth out the cylinder and would appreciate it if you added that to the design.\n\nHere's what I'm hoping for:\n\n1.  A single, well-structured OpenSCAD file. I'd prefer if you kept the code modular and used the `module` keyword.\n2.  The main design should be built from the parametric values I've provided.\n3.  All parameters should be clearly defined at the top of the file as variables that are easy to modify.\n4.  The file should create a single, printable object.\n5.  If you can, I'd like the final object to include a boolean subtraction (difference) using a hole that uses the parameters I mentioned.\n\nI'm not sure if any OpenSCAD libraries would be useful for this particular project, but if you think there is any that would help, please include that in your response. I do not need to use any libraries to create this design.\n\nLet me know if you need any more information. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Nozzle for flex hose",
    "scad": "$fn=48;\nr=7;\nt=1;\nh = 0.7;\nd= 0.3;\nneck = 0.3;\ntube(r,t,h,neck,d);\nmodule tube(r,t,u,l1,l2)\n{\n  trunc_r = r*sqrt(1-u*u);\n  cone_h = (r+t)/l1 - (r+t)*l1;\n  cone_r = (r+t)*sqrt(1-l1*l1);\n  cone_factor = trunc_r/cone_r;\n  zscale = r/(r+t);\n  p = ((r+t)*l1+cone_h*(1-cone_factor))*zscale+r*u;\n  union() {\n    scale([1,1,zscale]) {\n      truncSphere(r+t,l2,l1);\n      translate([0,0,(r+t)*l1])cylinder(r1=cone_r,r2=cone_r*(cone_factor/3),h=cone_h*(1-cone_factor/4));\n    }\n  }\n}\nmodule truncSphere(r,h1,h2) {\n  intersection() {\n    sphere(r);\n    translate(-r*[1,1,h1])cube(r*[2,2,h1+h2]);\n  }\n}",
    "description": "Okay, I've been working on this cool flexible tubing project and I've got a good starting point, but I need some help taking it to the next level. I've already got a SCAD file that makes a single segment of the flex tube, which I've attached. It works great, prints really easily with no infill and just a single wall thickness. I've also got a bit of a nozzle design concept that I'd like to combine with the tubing, and I need the whole thing to be parametric so I can adjust it.\n\nHere's what I need:\n\nI want to generate a flexible nozzle that consists of a series of connected segments, exactly like the tube segment I have created, but with the last segment of the nozzle terminating in a cylindrical extrusion. Basically, each flexible segment is identical to the `tube()` module in the file, and they should all be connected sequentially in a way that they can be bent and flexed. The last of these flexible segments should transition into the extrusion, which will have its own set of parameters for length and radius.\n\nThe parameters from my original tube design are:\n\n*   `r`: The radius of the joint sphere.\n*   `t`: Wall thickness.\n*   `h`: Height of the top sphere, affects the max bending angle and inner diameter of tube.\n*   `d`: Height of the bottom sphere segment. Affects how difficult it is to join parts.\n*   `neck`: Determines the slope of the neck. Should not be lower than `d`.\n\nIn addition to these parameters, I need:\n\n*   `num_segments`: The number of flexible segments that comprise the nozzle.\n*   `extrusion_length`: The length of the cylindrical nozzle extrusion.\n*   `extrusion_radius`: The radius of the cylindrical nozzle extrusion.\n\nThe design should use standard OpenSCAD primitives and logic. It should avoid using external libraries, and I would like to keep the final output in one single .scad file.\n\nCan you generate a parametric OpenSCAD file that implements this nozzle design? It should be a single module that uses these parameters, and should generate a bendable nozzle with an attached extrusion. The tube segments should still print with no infill and a single wall.\n\nI want to be able to tweak all of these parameters to get different nozzle characteristics. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Binary Nametag",
    "scad": "text = \"JS\";\nbit_style = \"bevel\";\nbase_style = \"bevel\";\nbit_size = 100;\nbase_length = 70;\nbail = \"side\";\nbail_size = 100;\nreverse_bit_direction = \"no\";\nextra_bit = \"no\";\nTXT= text;\nHEIGHT=.5*1;\nBITMODE = bit_style;\nBASEMODE = base_style;\nBITSCALE = 1.4*bit_size/100;\nNBITS=\textra_bit == \"yes\" ? 8 : 7;\nNCHARS=len(TXT);\nREVERSEBITS = reverse_bit_direction == \"yes\";\nPENDENT=bail;\nPENDENTSCALE = 1.5*bail_size/100;\nSIZEMMS = base_length;\nmodule simple_innie_outie() {\n\tunion() {\n\t\tdifference() {\n\t\t\tbasis();\n\t\t\tallzeros();\n\t\t}\n\t\tallones();\n\t}\n}\nmodule allones() {\n\tfor (i=[0:NCHARS-1]) {\n\t\ttranslate([0,line_position_y(i)]) ones(char2bits(TXT[i]));\n\t}\n}\nmodule allzeros() {\n\tfor (i=[0:NCHARS-1]) {\n\t\ttranslate([0,line_position_y(i)]) zeros(char2bits(TXT[i]));\n\t}\n}\nmodule zeros(bits) {\n\tfor (i=[0:NBITS-1]) {\n\t\tif (bits[i]==\"0\") {\n\t\t\ttranslate([bit_position_x(i),0,HEIGHT-0.01]) scale([BITSCALE,BITSCALE,HEIGHT]) bit();\n\t\t}\n\t}\n}\nmodule ones(bits) {\n\tfor (i=[0:NBITS-1]) {\n\t\tif (bits[i]==\"1\") {\n\t\t\ttranslate([bit_position_x(i),0,HEIGHT-0.01]) scale([BITSCALE,BITSCALE,HEIGHT]) bit();\n\t\t}\n\t}\n}\nmodule bit() {\n\tif (BITMODE==\"flat\") {\n\t\tcube([1,1,1],center=true);\n\t} else if (BITMODE==\"circle\") {\n\t\thull() {\n\t\tcylinder(r1=.5,r2=.4,h=0.5,center=false,$fn=30);\n\t\ttranslate([0,0,-.5]) cylinder(r1=.4,r2=.5,h=0.5,center=false,$fn=30);\n\t\t}\n\t} else if (BITMODE==\"round\") {\n\t\ttranslate([-0.2,-0.2,-0.5])\n\t\tminkowski() {\n\t\t\tcube([0.4,0.4,.5]);\n\t\t\tcylinder(r=0.3,h=.5,$fn=20);\n\t\t}\n\t} else if (BITMODE==\"bevel\") {\n\t\ttranslate([-0.5,-0.5,-0.5]) makebevel(1,1,1,.4);\n\t} else if (BITMODE==\"hexagon\") {\n\t\thull() {\n\t\tcylinder(r1=.5,r2=.4,h=0.5,center=false,$fn=6);\n\t\ttranslate([0,0,-.5]) cylinder(r1=.4,r2=.5,h=0.5,center=false,$fn=6);\n\t\t}\n\t}\n}\nmodule makebevel(sx,sy,sz,r) {\n\thull() {\n\t\ttranslate([r, \t\tr, \t\tr \t]) sphere(r=r,$fn=20);\n\t\ttranslate([sx-r,\tr, \t\tr \t]) sphere(r=r,$fn=20);\n\t\ttranslate([r, \t\tsy-r,\tr \t]) sphere(r=r,$fn=20);\n\t\ttranslate([sx-r,\tsy-r,\tr \t]) sphere(r=r,$fn=20);\n\t\ttranslate([r, \t\tr, \t\tsz-r]) sphere(r=r,$fn=20);\n\t\ttranslate([sx-r,\tr, \t\tsz-r]) sphere(r=r,$fn=20);\n\t\ttranslate([r, \t\tsy-r,\tsz-r]) sphere(r=r,$fn=20);\n\t\ttranslate([sx-r,\tsy-r,\tsz-r]) sphere(r=r,$fn=20);\n\t}\n}\nmodule basis() {\n\tunion() {\n\t\tif (BASEMODE == \"flat\") {\n\t\t\tcube([NBITS*2+1,NCHARS*2+1,HEIGHT]);\n\t\t} else if (BASEMODE == \"bevel\") {\n\t\t\tmakebevel(NBITS*2+1,NCHARS*2+1,HEIGHT,.25);\n\t\t}\n\t\tif (PENDENT == \"side\") {\n\t\t\ttranslate([NBITS*2+1,(NCHARS*2+1)/2,0.01]) pendent();\n\t\t} else if (PENDENT == \"top\") {\n\t\t\ttranslate([(NBITS*2+1)/2,(NCHARS*2+1)-.3*PENDENTSCALE,0.01]) rotate(90) pendent();\n\t\t}\n\t}\n}\nmodule pendent() {\n\tscale([PENDENTSCALE,PENDENTSCALE,.3])\n\ttranslate([0,0,HEIGHT/2])\n\tdifference() {\n\t\tcube([2,1,HEIGHT],center=true);\n\t\tcube([1.6,.6,HEIGHT*3],center=true);\n\t}\n}\nfunction bit_position_x(i) = REVERSEBITS? 1 + (NBITS-1 -i)*2 + 0.5: 1 + i*2 + 0.5 ;\nfunction line_position_y(i) = 1.5 + (NCHARS-1-i)*2;\nascii_table= [[\" \",\"0100000\"],[\"!\",\"0100001\"],[\"\\\"\",\"0100010\"],[\"#\",\"0100011\"],[\"$\",\"0100100\"],[\"%\",\"0100101\"],[\"&\",\"0100110\"],[\"'\",\"0100111\"],[\"(\",\"0101000\"],[\")\",\"0101001\"],[\"*\",\"0101010\"],[\"+\",\"0101011\"],[\",\",\"0101100\"],[\"-\",\"0101101\"],[\".\",\"0101110\"],[\"/\",\"0101111\"],[\"0\",\"0110000\"],[\"1\",\"0110001\"],[\"2\",\"0110010\"],[\"3\",\"0110011\"],[\"4\",\"0110100\"],[\"5\",\"0110101\"],[\"6\",\"0110110\"],[\"7\",\"0110111\"],[\"8\",\"0111000\"],[\"9\",\"0111001\"],[\":\",\"0111010\"],[\";\",\"0111011\"],[\"<\",\"0111100\"],[\"=\",\"0111101\"],[\">\",\"0111110\"],[\"?\",\"0111111\"],[\"@\",\"1000000\"],[\"A\",\"1000001\"],[\"B\",\"1000010\"],[\"C\",\"1000011\"],[\"D\",\"1000100\"],[\"E\",\"1000101\"],[\"F\",\"1000110\"],[\"G\",\"1000111\"],[\"H\",\"1001000\"],[\"I\",\"1001001\"],[\"J\",\"1001010\"],[\"K\",\"1001011\"],[\"L\",\"1001100\"],[\"M\",\"1001101\"],[\"N\",\"1001110\"],[\"O\",\"1001111\"],[\"P\",\"1010000\"],[\"Q\",\"1010001\"],[\"R\",\"1010010\"],[\"S\",\"1010011\"],[\"T\",\"1010100\"],[\"U\",\"1010101\"],[\"V\",\"1010110\"],[\"W\",\"1010111\"],[\"X\",\"1011000\"],[\"Y\",\"1011001\"],[\"Z\",\"1011010\"],[\"[\",\"1011011\"],[\"\\\\\",\"1011100\"],[\"]\",\"1011101\"],[\"^\",\"1011110\"],[\"_\",\"1011111\"],[\"`\",\"1100000\"],[\"a\",\"1100001\"],[\"b\",\"1100010\"],[\"c\",\"1100011\"],[\"d\",\"1100100\"],[\"e\",\"1100101\"],[\"f\",\"1100110\"],[\"g\",\"1100111\"],[\"h\",\"1101000\"],[\"i\",\"1101001\"],[\"j\",\"1101010\"],[\"k\",\"1101011\"],[\"l\",\"1101100\"],[\"m\",\"1101101\"],[\"n\",\"1101110\"],[\"o\",\"1101111\"],[\"p\",\"1110000\"],[\"q\",\"1110001\"],[\"r\",\"1110010\"],[\"s\",\"1110011\"],[\"t\",\"1110100\"],[\"u\",\"1110101\"],[\"v\",\"1110110\"],[\"w\",\"1110111\"],[\"x\",\"1111000\"],[\"y\",\"1111001\"],[\"z\",\"1111010\"],[\"{\",\"1111011\"],[\"|\",\"1111100\"],[\"}\",\"1111101\"],[\"~\",\"1111110\"]];\nfunction char2bits(c) = str(NBITS==8? \"0\" : \"\",ascii_table[search(c,ascii_table,0,0)[0][0]][1]);\nscale(SIZEMMS/(NBITS*2+1))\ntranslate([-(NBITS*2+1)/2, -(NCHARS*2+1)/2])\nsimple_innie_outie();",
    "description": "Okay, I'd like to create a customizable 3D model that represents text in binary. I've got some specific ideas about how I want it to look and be configurable. \n\nHere's what I'm imagining:\n\n**Basic Structure:**\n\n*   **Text Input:** The design should take text as input, like \"JS\" or \"42\".\n*   **Binary Conversion:** Each character of the input text should be converted into its 7-bit or 8-bit ASCII binary representation. (It would be cool if there was an option to add an extra zero to force 8 bits, just because).\n*   **Bit Arrangement:** The binary for each character should form a row. If the text has multiple characters, the bits will be stacked on top of each other to create a grid pattern. Bits should be written either left-to-right or right-to-left, selectable by a flag.\n*   **Bit Representation:** Each bit (0 or 1) should be represented by a 3D shape. These should be configurable.\n*   **Base:** The rows of bits should sit on a base with a configurable style.\n*   **Bail (Hanger):** The design needs a bail (a loop or hook for attaching it to a necklace or keychain). This should be configurable too, and there should be an option to have no bail.\n\n**Parameters I want to control:**\n\n*   **`text`:** The string of ASCII characters to convert to binary.\n*   **`bit_style`:** The shape to represent each bit. I'd like options like:\n    *   \"bevel\": A beveled cube.\n    *   \"flat\": A simple cube.\n    *   \"circle\": A cylinder with rounded ends\n    *   \"hexagon\": A hexagonal cylinder with rounded ends.\n    *  \"round\": A rounded cube (using minkowski)\n*   **`base_style`:** The style for the base. I'd like at least \"bevel\" and \"flat\" options.\n*   **`bit_size`:**  A percentage representing how large the bit shapes should be. I think it would be useful to have a scaling factor applied to a basic size.\n*   **`base_length`:** The length in mm of the overall base. This will determine the overall size of the piece\n*   **`bail`:** The position of the bail. Options should be \"side\", \"top\", and \"none\".\n*   **`bail_size`:**  A percentage value determining how large the bail should be. \n*  **`reverse_bit_direction`:** A boolean or string to choose whether the bits are written from right to left or left to right\n*  **`extra_bit`:**  A flag or string to specify whether the binary representation for each letter should be 7 bits (standard) or 8 (with an extra zero in front)\n\n**OpenSCAD Requirements:**\n\n*   The design should be parametric using OpenSCAD.\n*   I'd like to see all code, even for very simple shapes, so that I can get a better idea of how it all fits together.\n*   I'd rather not use code external libraries if possible. I'm ok with you using built-in functions. \n\n**Example:**\n\nLet's say I input \"JS\", with `bit_style=\"bevel\"`, `base_style=\"bevel\"`, `bit_size=100`, `base_length=70`, `bail=\"side\"`, `bail_size=100`, `reverse_bit_direction=\"no\"`, and `extra_bit=\"no\"`. The output would have the binary representation of 'J' on the top line and 'S' on the line below, with each bit a beveled cube. The text would be left-aligned and have a beveled base, with a bail on the right side of the shape.\n\nI think that's it. Can you create an OpenSCAD file that meets those specifications?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Another Refrigerator Magnet",
    "scad": "Dmagnet = 10.0;\nHmagnet = 2.5;\nDtop = 22;\nDbot = 16;\nHholder = 6;\nRmagnet = Dmagnet/2;\nRbot    = Dbot/2;\nRtop    = Dtop/2;\ndifference() {\n\tcylinder(h = Hholder, r1 = Rtop, r2 = Rbot);\n\ttranslate([0,0,Hholder-Hmagnet-0.1])\n\t\tcylinder(h=Hmagnet+0.1, r=Rmagnet);\n\ttranslate([0,0,Hholder-(Hmagnet*0.25)])\n\t\tcylinder(h=1, r1=Rmagnet*0.98, r2=Rmagnet*1.07);\n\t}",
    "description": "Okay, I'm looking to design a refrigerator magnet, similar to the one I already have, but I want it to be fully parametric so I can easily adjust the size and fit different magnets. I need the design to be created in OpenSCAD.\n\nHere's what I'm thinking. The basic shape is a truncated cone, with the wide end on the outside, and the narrow end flush against the fridge. The magnet will be recessed into the narrow end, with a small chamfer on the edge of the magnet hole to make insertion easier.  I plan on printing it upside down, so the magnet cutout would be on the top.\n\nHere are the key parameters I want to control:\n\n*   **`Dmagnet`**: The diameter of the magnet. This is crucial, so I will want it to be easily adjustable.\n*   **`Hmagnet`**: The thickness of the magnet.\n*   **`Dtop`**: The diameter of the wide end of the cone, the one facing outwards from the fridge.\n*   **`Dbot`**: The diameter of the narrow end of the cone, the one against the fridge.  This needs to be larger than the magnet diameter.\n*   **`Hholder`**: The overall height/thickness of the magnet holder.\n\nI also need to have the magnet hole be just a little deeper than the magnet itself. I'd like to have a slight clearance for the magnet, maybe 0.1mm extra in height and slightly bigger diameter for a snug fit. The chamfer I'd like to use is similar to the provided .scad file: 0.98x magnet radius on the bottom of the chamfer and 1.07x magnet radius on the top of the chamfer, over a height of 1mm.\n\nI'd like the final design to be a single `difference()` that first generates the basic truncated cone, second generates a cylinder for the magnet hole and finally generates a chamfer on the magnet hole, similar to the example I'm basing this on.\n\nCould you provide me with an OpenSCAD file that I can use to generate this? I don't need any extra libraries for this design, just a straight scad file with these parameters, and with good commenting for readability.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Hinge",
    "scad": "use <utils/build_plate.scad>;\nbuild_plate_selector = 1;\nhingePieces = 4;\nhingeHeight = 42;\nwingWidth = 18;\nwingThickness = 2;\ntolerance = 0.3;\ninsideDiameter = 3;\noutsideDiameter = 6;\nnumHoles = 2;\nholeDiameter = 8;\nvertSupport = 1;\nnumberOfSupports = 7;\nsupportThickness = 0.4;\ncl = 42;\nprintHalf = 0;\nbuild_plate(build_plate_selector);\n\thinge(hingeHeight, wingWidth, wingThickness, tolerance, insideDiameter,\n\t\t\toutsideDiameter, hingePieces);\nmodule hinge(l=50, w=10, th=5, t=1, id=5, od=10, i=5) {\n\tinterval = l/i;\n\tnumHingeA = round(i/2);\n\tnumHingeB = i-numHingeA;\n\tdifference() {\n\t\tunion() {\n\t\t\tcylinder(r=id/2,h=l,$fn=cl);\n\t\t\tfor (j = [0:numHingeA-1]) {\n\t\t\t\tunion() {\n\t\t\t\t\ttranslate([0,0,interval*j*2]) cylinder(r=od/2, h=interval-t,$fn=cl);\n\t\t\t\t\ttranslate([0,od/2-th,interval*j*2]) cube([w,th,interval-t]);\n\t\t\t\t\tif (j < numHingeB) {\n\t\t\t\t\t\ttranslate([od/2+t,od/2-th,interval*j*2+interval-t])\n\t\t\t\t\t\t\tcube([w-od/2-t,th,interval+t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j = [0:numHingeB-1]) {\n\t\t\t\tdifference() {\n\t\t\t\t\tunion() {\n\t\t\t\t\t\ttranslate([0,0,interval*j*2+interval]) color(\"green\") cylinder(r=od/2, h=interval-t,$fn=cl);\n\t\t\t\t\t\ttranslate([-od/2-t-0.05,od/2-th+t,interval*j*2+interval])\n\t\t\t\t\t\t\tcolor(\"green\") cube([od/2+t+0.1,th-t,interval-t]);\n\t\t\t\t\t}\n\t\t\t\t\ttranslate([0,0,interval*j*2+interval]) cylinder(r=(id+t)/2, h=interval-t,$fn=cl);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([-w,od/2-th,0]) color(\"orange\")\n\t\t\t\tcube([w-od/2-t,th,l]);\n\t\t\tif (i%2 == 1) {\n\t\t\t\ttranslate([-w,od/2-th+t,interval*(i-1)-t])\n\t\t\t\t\tcolor(\"green\") cube([w-od/2-t,th-t,interval+t]);\n\t\t\t}\n\t\t}\n\t\ttranslate([-w,-w,-t*3]) cube([w*2.5,w*2.5,t*3]);\n\t\ttranslate([-w,-w,l-t]) cube([w*2.5,w*2.5,t*3]);\n\t\tfor (j = [0:numHoles-1]) {\n\t\t\ttranslate([wingWidth/3*2,wingThickness*3,(j+1)*hingeHeight/(numHoles+1)]) rotate([90,0,0])\n\t\t\t\tcylinder(r=holeDiameter/2, h=4*wingThickness,$fn=cl);\n\t\t\ttranslate([-wingWidth/3*2,wingThickness*3,(j+1)*hingeHeight/(numHoles+1)]) rotate([90,0,0])\n\t\t\t\tcylinder(r=holeDiameter/2, h=6*wingThickness,$fn=cl);\n\t\t}\n\t}\n\tif (vertSupport != 0) {\n\t\tfor (i=[1:i-1]) {\n\t\t\tfor (j=[0:numberOfSupports]) {\n\t\t\t\trotate([0,0,j*360/numberOfSupports])\n\t\t\t\ttranslate([insideDiameter/2+t,0,i*interval-t])\n\t\t\t\t\tcolor(\"red\")\n\t\t\t\t\tcube([outsideDiameter/2-insideDiameter/2-t,supportThickness,t]);\n\t\t\t}\n\t\t}\n\t}\n}",
    "description": "Okay, I'm looking to create a customizable hinge design using OpenSCAD, and I'd like your help generating the code. I have an existing design Im trying to replicate and improve, and I want to be able to adjust various parameters easily.\n\nHere's what I need:\n\n**Basic Hinge Structure:**\n\n*   The hinge should consist of alternating cylindrical segments that interlock. There will be two sets of these: one set of 'outer' cylinders with a wing attached to each of these, and another set of inner cylinders with an axle in the center, that rotates *inside* the outer cylinders. The inner cylinders and axle are 'fixed' together.\n*   The hinge has a height, which I'll call `hingeHeight`, that determines the overall length of the hinge.\n*   There should be parameters to control the width (`wingWidth`) and thickness (`wingThickness`) of the flat, rectangular parts attached to the outer cylinders  the \"wings\"\n*   There needs to be a tolerance setting, `tolerance`, that determines the clearance between the interlocking parts, including inner axles and outer cylinders. This can be a global parameter to simplify.\n*   There should be an `insideDiameter` parameter for the central axle cylinder.\n*   There should be an `outsideDiameter` parameter for the outer hinge cylinder sections.\n\n**Hinge Segmentation:**\n*   I want to be able to control how many alternating sections (outer and inner) are in the hinge using a `hingePieces` parameter. This number will divide the height into segments and determine the number of cylinders. I want to use this number to determine the number of outer cylinders and inner cylinders.\n*   The alternating segments should fit together such that each outer cylinder has a wing and each inner cylinder has an axle, and that each outer cylinder segment contains one inner cylinder segment.\n\n**Additional Features:**\n\n*   I want to be able to add screw holes to the wings. There should be a `numHoles` parameter to control the number of holes, and a `holeDiameter` parameter to control the size of the holes. The holes should be evenly distributed along the length of the wings. \n*   I would like a print support system for vertical printing. I need to be able to toggle this on and off with a `vertSupport` parameter (0 for off, 1 for on). The supports should be small columns, extending from the center axle to the interior surface of the surrounding cylinder. I also need to specify `numberOfSupports` to control how many columns are in a ring, and `supportThickness` to control how thick these columns are.\n*   I want to be able to control the \"roundness\" of the cylinders. This should be controlled by an `cl` parameter which will be passed to the `$fn` argument in OpenSCAD's `cylinder` primitive.\n*   I need a variable called `interval`, which is just the hinge length divided by the number of pieces.\n*   There needs to be a boolean variable called `printHalf` that can be toggled on or off. For the moment, it can just exist and do nothing.\n\n**Libraries:**\n* The existing design uses a library called `utils/build_plate.scad`, which I think is just to show the build plate. I need to use that in the final code. I don't have a copy of that library to send to you, but your response should include the `use <utils/build_plate.scad>;` line.\n\n**Existing parameters that should be kept:**\n*   `build_plate_selector` - should default to 1\n*   The existing parameters should have default values as in the existing design:\n    `hingeHeight = 42;`\n    `wingWidth = 18;`\n    `wingThickness = 2;`\n    `tolerance = 0.3;`\n    `insideDiameter = 3;`\n    `outsideDiameter = 6;`\n    `numHoles = 2;`\n    `holeDiameter = 8;`\n    `vertSupport = 1;`\n    `numberOfSupports = 7;`\n    `supportThickness = 0.4;`\n    `cl = 42;`\n    `printHalf = 0;`\n\nI think that covers it. The goal is to have a fully parametric hinge that I can adjust to different sizes and configurations. Let me know if you need any more information or clarification.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Battery Case",
    "scad": "use <write/Write.scad>\n_part = \"bottom\";\n_batteryDiameter = 10.7;\n_insideHeight = 30;\n_columns = 3;\n_rows = 2;\n_walls = 0.8;\n_base = 0.8;\n_lipHeight = 2;\n_fitGap = 0.1;\n_labelText = \"\";\n_labelFont = \"write/orbitron.dxf\";\n_labelDepth = -0.3;\n_labelHeight = 8;\nmodule cylinderAt(r, h, x, y, z) {\n\ttranslate([x,y,z]) {\n\t\tcylinder(r=r, h=h, center=true);\n\t}\n}\nmodule cubeAt(xy, h, x, y) {\n\ttranslate([x,y,0]) {\n\t\tcube(size=[xy,xy,h], center=true);\n\t}\n}\nmodule roundRect(width, depth, height, rounding) {\n\thull()\n\tfor (x=[-width/2 + rounding, width/2 - rounding])\n\tfor (y=[-depth/2 + rounding, depth/2 - rounding]) {\n\t\ttranslate([x,y])\n\t\tcylinder(r=rounding, h=height);\n\t}\n}\nmodule batteryGrid(diameter, height, rows, columns) {\n\tangle = 35;\n\tr = diameter/2;\n\tcut = 2*r*sin(angle);\n\ttan = tan(angle);\n\tfilletCenter = r - r * tan;\n\tfilletCenter2 = r + r * tan;\n\tfilletOffset = r * tan;\n\tfilletRadius = r/cos(angle) - r;\n\txstart = ((columns-1) * diameter)/2;\n\tystart = ((rows-1) * diameter)/2;\n\teps = 0.1;\n\tunion() {\n\t\tdifference() {\n\t\t\tunion() {\n\t\t\t\tfor (x=[-xstart:diameter:xstart+eps]) {\n\t\t\t\t\tfor (y=[-ystart:diameter:ystart+eps]) {\n\t\t\t\t\t\tcylinderAt(r,height,x,y,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rows > 1) {\n\t\t\t\t\tfor (x=[-xstart:diameter:xstart+eps])\n\t\t\t\t\tfor (y=[-ystart+r:diameter:ystart-r+eps]) {\n\t\t\t\t\t\tcubeAt(cut, height, x, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (columns > 1) {\n\t\t\t\t\tfor (x=[-xstart+r:diameter:xstart-r+eps])\n\t\t\t\t\tfor (y=[-ystart:diameter:ystart+eps]) {\n\t\t\t\t\t\tcubeAt(cut, height, x, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (columns > 1) {\n\t\t\t\tfor (x=[-xstart+r:diameter:xstart-r+eps])\n\t\t\t\tfor (y=[-ystart-r:diameter:ystart+r+eps])\n\t\t\t\tfor(y2=[filletOffset, -filletOffset]) {\n\t\t\t\t\tcylinderAt(filletRadius,height+eps,x,r+y+y2,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rows > 1) {\n\t\t\t\tfor (x=[-xstart:diameter:xstart+eps])\n\t\t\t\tfor (y=[-ystart:diameter:ystart+eps])\n\t\t\t\tfor(x2=[filletOffset, -filletOffset]) {\n\t\t\t\t\tcylinderAt(filletRadius, height+eps,x + x2, r+y, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule makeTray(diameter, height, rows, columns, wall, base, lipHeight, fitGap, label, lfont, ldepth, lheight) {\n\teps = 0.1;\n\twall2 = wall * 2;\n\trounding = diameter/2 + wall;\n\twidth = diameter * columns + wall*2;\n\tdepth = diameter * rows + wall*2;\n\tgridHeight = (lipHeight > 0) ? height + lipHeight - fitGap : height;\n\tunion() {\n\t\tdifference() {\n\t\t\troundRect(width, depth, gridHeight+base, rounding);\n\t\t\ttranslate([0,0,gridHeight/2 + base + eps/2]) {\n\t\t\t\tbatteryGrid(diameter, gridHeight+eps, rows, columns);\n\t\t\t}\n\t\t\tif (lipHeight < 0) {\n\t\t\t\tassign(gap = min(fitGap, -0.01)) {\n\t\t\t\t\ttranslate([0,0,base+height+lipHeight]) {\n\t\t\t\t\t\troundRect(width - 2*wall+gap, depth - 2*wall+gap, -lipHeight+eps, rounding - wall);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (lipHeight > 0) {\n\t\t\t\tassign(gap = max(fitGap, 0.01)) {\n\t\t\t\t\ttranslate([0,0,base+height])\n\t\t\t\t\tdifference() {\n\t\t\t\t\t\ttranslate([0,0,(lipHeight+eps)/2]) {\n\t\t\t\t\t\t\tcube(size=[width+eps, depth+eps, lipHeight+eps], center=true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttranslate([0,0,-eps]) {\n\t\t\t\t\t\t\troundRect(width - 2*(wall+gap), depth - 2*(wall+gap), lipHeight + 2*eps, rounding - wall - gap);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif (lipHeight > wall) {\n\t\t\t\t\tfor (m = [-1,1]) {\n\t\t\t\t\t\thull()\n\t\t\t\t\t\tfor (o = [0,1]) {\n\t\t\t\t\t\t\ttranslate([0,m*(depth/2 + lipHeight/2 - wall*2 + o*wall - gap), base + height + 1.5*lipHeight - o*wall - gap]) {\n\t\t\t\t\t\t\t\tcube(size=[width, lipHeight, lipHeight], center=true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\thull()\n\t\t\t\t\t\tfor (o = [0,1]) {\n\t\t\t\t\t\t\ttranslate([m*(width/2 + lipHeight/2 - wall*2 + o*wall - gap),0, base + height + 1.5*lipHeight - o * wall - gap ]) {\n\t\t\t\t\t\t\t\tcube(size=[lipHeight, depth, lipHeight], center=true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ldepth < 0) {\n\t\t\t\taddLabel(label, (-ldepth+eps)/2 - eps, -ldepth+eps, lheight, lfont);\n\t\t\t}\n\t\t}\n\t\tif (ldepth > 0) {\n\t\t\taddLabel(label, -(ldepth+eps)/2 + eps, ldepth+eps, lheight, lfont);\n\t\t}\n\t}\n}\nmodule addLabel(label, zoffset, depth, height, font) {\n\tif (label != \"\") {\n\t\ttranslate([0,0,zoffset])\n\t\tmirror([0,1,0])\n\t\twrite(label, t=depth, h=height, font=font, space=1.2, center=true);\n\t}\n}\nmodule make($fn=90) {\n\tif (_part == \"top\") {\n\t\tmakeTray(_batteryDiameter, _insideHeight, _rows, _columns, _walls, _base, -_lipHeight, _fitGap,\n\t\t\t\t\t_labelText, _labelFont, _labelDepth, _labelHeight);\n\t} else {\n\t\tmakeTray(_batteryDiameter, _insideHeight, _rows, _columns, _walls, _base, _lipHeight, _fitGap,\n\t\t\t\t\t_labelText, _labelFont, _labelDepth, _labelHeight);\n\t}\n}\nmake();",
    "description": "Okay, I'd like to design a customizable battery case, kind of like a travel holder. I've seen a design online, but it uses magnets and I'd prefer something that just snaps together. I need it to be parametric so I can adjust it for different battery sizes and quantities.\n\nHere's what I have in mind:\n\n**Core Features:**\n\n*   **Two-Part Design:** The case should be made of two parts: a top and a bottom, which snap together using a lip or tab system rather than magnets.\n*   **Cylindrical Battery Holders:** The interior should consist of individual cylindrical recesses or pockets to hold the batteries securely.\n*   **Customizable Grid:** I need to be able to specify how many rows and columns of batteries I want the case to hold.\n*   **Adjustable Battery Size:** I need to be able to set the diameter of the battery holders to accommodate different battery sizes (like AAA, AA, 123A, etc.).\n*   **Adjustable Depth:** I'd like to specify the depth of the battery recesses as well as the overall height of the top and bottom pieces, ideally to be slightly larger than the battery to ensure they are not sticking out.\n*   **Wall Thickness:** I want to set the thickness of the side walls of the case, and also the thickness of the bottom part.\n\n**Snap-Fit Mechanism:**\n\n*   **Overlapping Lip:** The snap fit should be based on an overlapping lip system. The top should have a lip that goes down and overlaps the base, or vice versa.\n*   **Adjustable Lip Height:** I need to be able to adjust the height of this lip to get a snug and secure fit.\n*   **Adjustable Fit Gap:** I need to adjust the gap between the top and bottom parts to dial in the fit.\n\n**Optional Features:**\n\n*   **Label:** I'd like to be able to add a label to the top or bottom, like \"AA\" or \"AAA\". This should be able to be embossed or extruded.\n*   **Font Choice:** I need to specify the font to use for the label.\n*   **Adjustable Label Depth:**  I need to be able to adjust the depth of the label (positive for extrusion, negative for embossing).\n*   **Adjustable Label Height:** I need to specify how tall the label text should be.\n\n**Specific Requests for the Design:**\n\n*   The design should be fully parametric, so every dimension mentioned above is adjustable through variables.\n*   I'd like the design to have rounded corners, but I don't want to have to use a large number of small parts to do so. I see there's a `roundRect()` module in the example I've included, and that seems good.\n*   I need to ensure the design does *not* use any magnets or cutouts for magnets.\n*   The design should use the `write/Write.scad` library for text generation/embossing. I've also included an example where I'm using that.\n\nCan you generate a parametric OpenSCAD file based on these requirements?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Bandsaw zero clearance insert",
    "scad": "diameter=30;\nthickness=2;\n$fn=90;\ncylinder (r=diameter/2,h=thickness);",
    "description": "Okay, I'm looking to create a customizable cylinder that I can use as a filler for the blade gap on my bandsaw. I have a simple example I've been using, but I'd like something that's more parametric so I can easily adjust it for different saws, or even other purposes.\n\nHere's what I need:\n\nThe design is a simple cylinder. I need to be able to control the following:\n\n*   **Diameter:**  This will be the diameter of the circle of the cylinder. I need a variable called `diameter` for this.\n*   **Thickness:** This will be the height of the cylinder. I need a variable called `thickness` for this.\n*   **Resolution:** I'd like to be able to control the number of segments used to generate the cylinder circle; i.e., `$fn`.\n*   I want to be able to set the values of `diameter`, `thickness`, and `$fn` independently.\n\nI'd like to have the code written in OpenSCAD. I'm familiar with the basic syntax.\n\nThe provided code I've been using is like this:\n\n```\n//------------parameters---------------------------\n// diameter of circle\ndiameter=30;  \n// Thickness \nthickness=2;  \n// resolution\n$fn=90;\n\n//-------------------------------------------------\ncylinder (r=diameter/2,h=thickness);\n```\n\nCould you create an OpenSCAD file that allows me to easily adjust those parameters? I am not looking for anything fancy just a well written parametric version of the code I have provided.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Lens Holder",
    "scad": "Lens_Diameter=25.4;\nLens_Holder_Thickness=10;\nLens_Holder_Lip_Size=3;\nBase_Diameter=25;\nBase_Height=25;\nGuide_Rod_Length=20;\nGuide_Rod_Diameter=8;\nSet_Screw_Diameter=3;\nSet_Screw_Nut_Diameter=6;\nSet_Screw_Nut_Thickness=3;\nx=Lens_Diameter;\ny=Lens_Holder_Thickness;\nz=Lens_Holder_Lip_Size;\nX=Base_Diameter;\nY=Base_Height;\ne=Guide_Rod_Length;\nd=Guide_Rod_Diameter;\na=Set_Screw_Diameter;\nb=Set_Screw_Nut_Diameter;\nc=Set_Screw_Nut_Thickness;\nlens_holder();\nmodule lens_holder(){\ndifference(){\ncylinder(y/2,(x+10)/2,(x+10)/2);\ncylinder((y+2)/2,(x-3)/2,(x-3)/2);\ntranslate([0,0,1.5])cylinder((y+2)/2,(x+1)/2,(x+1)/2);\ntranslate([0,(x+10)/2+5,(b+3)/2])rotate([90,0,0])cylinder(10,(a+1)/2,(a+1)/2);\ntranslate([0,(x+8)/2,(b+3)/2])nuttrap();\ntranslate([(x+15)/2,e/2,(d+6)/2])rotate([90,0,0])cylinder(e,(d+6)/2, (d+6)/2);\n}\ndifference(){\ntranslate([0,0,y/2])cylinder((y)/2,(x+5)/2,(x+5)/2);\ncylinder((y)*2,(x+1)/2,(x+1)/2);\ntranslate([0,(x+10)/2+5,(b+3)/2])rotate([90,0,0])cylinder(25,(b+3)/2,(b+3)/2);\ntranslate([0,(x+8)/2,(b+3)/2])nuttrap();\n}\ndifference(){\ntranslate([0,(x+8)/2,0])set_screw((b+3)/2);\ncylinder((y+2),(x+1)/2,(x+1)/2);\n}\ndifference(){\ntranslate([(x+15)/2,0,0])guide_rod();\nrotate([0,0,90]){\n#translate([0,((x+7)/-2)-((d)),(d+6)/2])rotate([90,0,0])cylinder(50,(a+1)/2,(a+1)/2);\ntranslate([((x+7.5)/2)+((d+6)),0,0])rotate([0,0,90])set_screw1((d+6)/2);\n}\n}\ntranslate([((x+7.5)/2)+((d+6)),0,0])rotate([0,0,90])set_screw((d+6)/2);\n}\nmodule guide_rod(){\ndifference(){\ntranslate([0,e/2,(d+6)/2])rotate([90,0,0])cylinder(e,(d+6)/2, (d+6)/2);\ntranslate([0,(e/2)+1,(d+6)/2])rotate([90,0,0])cylinder(e+2,(d+1)/2, (d+1)/2);\n}\ndifference(){\ntranslate([0,0,(d+6)/4])cube([(d+6),e,(d+6)/2], center = true);\ntranslate([0,(e/2)+1,(d+6)/2])rotate([90,0,0])cylinder(e+2,(d+1)/2, (d+1)/2);\n}\n}\nmodule set_screw(h){\ndifference(){\ntranslate([0,5,h])rotate([90,0,0])cylinder(10,(b+3)/2, (b+3)/2);\n#translate([0,10,h])rotate([90,0,0])cylinder(200,(a+1)/2, (a+1)/2);\ntranslate([0,0,h])nuttrap();\n}\ndifference(){\ntranslate([0,0,h/2])cube([(b+3),10,h], center = true);\ntranslate([0,6,h])rotate([90,0,0])cylinder(12,(a+1)/2, (a+1)/2);\ntranslate([0,0,h])nuttrap();\n}\n}\nmodule set_screw1(h){\ntranslate([0,5,h])rotate([90,0,0])cylinder(10,(b+3)/2, (b+3)/2);\ntranslate([0,0,h/2])cube([(b+3),10,h], center = true);\n}\nmodule nuttrap(){\ntranslate([0,(c+1)/2,0])rotate([90,0,0])hexagon(c+1,(b+1)/2);\ntranslate([0,0,(b*3)/2])cube([b+1,c+1,b*3],center = true);\n}\nmodule reg_polygon(sides,radius)\n{\n  function dia(r) = sqrt(pow(r*2,2)/2);\n  if(sides<2) square([radius,0]);\n  if(sides==3) triangle(radius);\n  if(sides==4) square([dia(radius),dia(radius)],center=true);\n  if(sides>4) circle(r=radius,$fn=sides);\n}\nmodule hexagonf(radius)\n{\n  reg_polygon(6,radius);\n}\nmodule hexagon(height,radius)\n{\n  linear_extrude(height=height) hexagonf(radius);\n}",
    "description": "Okay, I'm looking to create a customizable lens holder for optical experiments. I want it to be parametric, so I can easily adjust the dimensions for different lenses and setups. I've found a basic design I like as a starting point, but I want to make it more flexible and robust.\n\nHere's what I need the design to be able to do:\n\n**Core Functionality:**\n\n*   **Lens Holding:** The main function is to securely hold a lens of a specified diameter. There should be a recessed lip that fits the edge of the lens.\n*   **Base Mounting:** The holder needs a base that can be mounted to a support or other equipment.\n*   **Guide Rod:** It should have a guide rod extending from the side to allow for precise alignment and mounting to a rail system if needed.\n*   **Set Screws:** There should be at least one, possibly two, set screw holes to lock the lens in place. These holes need to include space for a nut.\n\n**Parametric Dimensions (I need to be able to control these):**\n\n*   **Lens Diameter:** The diameter of the lens it's designed to hold.\n*   **Lens Holder Thickness:** The overall thickness of the main lens holding cylinder.\n*   **Lens Holder Lip Size:** The size of the lip that retains the lens. This should be smaller than the holder thickness.\n*   **Base Diameter:** The diameter of the base for mounting.\n*   **Base Height:** The height of the base.\n*   **Guide Rod Length:** The length of the guide rod.\n*   **Guide Rod Diameter:** The diameter of the guide rod.\n*   **Set Screw Diameter:** The diameter of the set screw threads.\n*   **Set Screw Nut Diameter:** The outside diameter of the nut for the set screw.\n*   **Set Screw Nut Thickness:** The thickness of the nut for the set screw.\n\n**Desired Features:**\n\n*   **Clearance for Lens:** I want a small amount of clearance for the lens within the holder to accommodate slight variations in lens diameter and allow easy insertion.\n*   **Nut Trap for Set Screw:** The design should incorporate a nut trap to hold the nut in place for the set screw, so that the nut won't rotate when the set screw is tightened, as in the original design.\n*   **Two Set Screws:** I would like to have the option of two set screws, potentially on opposite sides of the lens holder, for more secure mounting if desired.\n*   **Clean Design:** I'd prefer a relatively simple and clean design that will print well.\n\n**Additional Request:**\n\n*   I would like to use the `BOSL` library for general parametric design and avoid including `reg_polygon` and `hexagon` functions in the generated code. Specifically, I would like to use `hex()` for the nut trap.\n\nCould you generate an OpenSCAD file with these requirements in mind? Please ensure all relevant parameters are clearly named and can be easily modified. I'm looking for a versatile lens holder that I can easily customize for my optical experiments. Thank you!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable iPhone Stencil Case",
    "scad": "primary_color=\"red\";\niphone_version = 1;\ncase_thickness = 1.8;\ntype_of_case = 3;\ninclude_hooks=\"no\";\ninput = \"no_input\";\nimage_scale=100;\noffX =0;\noffY =0;\nimage_rotation =30;\npattern_shape =6;\npattern_radius =17;\npattern_overlap = 18;\npattern_rotation = 13;\npattern_thickness = 5;\nmashup_type=1;\nindex_i=1;\nindex_j=0;\ncase_taper=3;\n4_perimeter_tolerance=.5;\n4_height_tolerance=.2;\n4width=58.55;\n4length=115.25;\n4height=9.5;\n4cornerR = 8;\n4swidth=6.17;\n4sthick=.6;\n5_perimeter_tolerance=.5;\n5_height_tolerance=.2;\n5width = 58.6;\n5length = 123.8;\n5height = 7.6;\n5cornerR = 8;\n5swidth=6.1;\n5sthick = 1.0;\nmodule Void(){}\nmode=\"render\";\nhoneycomb_radius = pattern_radius;\nhoneycomb_radius_modifier = pattern_overlap;\nhoneycomb_sides = pattern_shape;\nhoneycomb_rotation = pattern_rotation;\nline_thickness = pattern_thickness;\nhoneycomb_thickness = line_thickness*.4;\nstencil_thickness = 10;\ncthk = case_thickness;\n4ctol = 4_perimeter_tolerance;\n4htol = 4_height_tolerance;\n5ctol = 5_perimeter_tolerance;\n5htol = 5_height_tolerance;\n4margin=4width/2-(4width/2-3)*image_scale/100;\n5margin=5width/2-(5width/2-3)*image_scale/100;\nheightvar=.24;\nhomebuttonR = 5.6;\nhomebuttonD = homebuttonR*2;\ntop_bottom_opening_width = 50;\nleftholelength = 25.43;\nleftholeR = 2.4;\ntopholelength = 38.57;\ntopholeR = 2.5;\nbottomholelength1 = 43.97;\nbottomholelength2 = 26.05;\nbottombigR = 1.53;\nbottomsmallR = 1.15;\ncorner_resolution = 6;\ncircle_resolution = corner_resolution*4;\nfudge = .05;\nif(mode==\"render\")\ncolor(primary_color)rotate([0,0,90]){\n\tif(iphone_version == 1){\n\t\ttranslate([0,0,(4height+cthk/2+2*4htol)/2])iPhone4Case();\n\t}else{\n\t\ttranslate([0,0,(5height+cthk+2*5htol)/2])iPhone5Case();\n\t}\n}\nif(mode==\"testfit\")\nintersection(){\n\trotate([0,0,90]){\n\t\tif(iphone_version == 1){\n\t\t\tunion(){\n\t\t\t\tcolor(\"red\")iPhone4Case();\n\t\t\t\tcolor(\"green\")translate([0,0,cthk/4])oldiPhone4(w=4width,\n\t\t\t\t\t\tl=4length,\n\t\t\t\t\t\th=4height,\n\t\t\t\t\t\tcR=4cornerR,\n\t\t\t\t\t\tsw=4swidth,\n\t\t\t\t\t\tst=4sthick,\n\t\t\t\t\t\ttaper=case_taper);\n\t\t\t}\n\t\t}else{\n\t\t\tunion(){\n\t\t\t\tcolor(\"red\")iPhone5Case();\n\t\t\t\tcolor(\"green\")translate([0,0,0])oldiPhone5(w=5width,\n\t\t\t\t\t\tl=5length,\n\t\t\t\t\t\th=5height,\n\t\t\t\t\t\tcR=5cornerR,\n\t\t\t\t\t\tsw=5swidth,\n\t\t\t\t\t\tst=5sthick,\n\t\t\t\t\t\ttaper=case_taper);\n\t\t\t}\n\t\t}\n\t}\n\tcolor(\"white\")translate([-100,0,0])cube(200,center=true);\n}\nif(mode==\"test\"){\n\t%color(\"red\")translate([-4width/2,0,0])rotate([0,10,0])cube(5);\n\t%color(\"green\")intersection(){\n\t\toldiPhone5(w=5width,\n\t\t\t\t\t\tl=5length,\n\t\t\t\t\t\th=5height,\n\t\t\t\t\t\tcR=5cornerR,\n\t\t\t\t\t\tsw=5swidth,\n\t\t\t\t\t\tst=5sthick);\n\t\ttranslate([-500,-500,0])cube(1000,center=true);\n\t}\n\t%difference(){\n\t\tiPhone5(w=5width,\n\t\t\t\t\t\tl=5length,\n\t\t\t\t\t\th=5height,\n\t\t\t\t\t\tcR=5cornerR,\n\t\t\t\t\t\tsw=5swidth,\n\t\t\t\t\t\tst=5sthick,\n\t\t\t\t\t\ttaper=10);\n\t\ttranslate([-500,-500,0])cube(1000,center=true);\n\t}\niPhone5(w=5width+2*(cthk+5ctol),\n\t\t\t\t\tl=5length+2*(cthk+5ctol),\n\t\t\t\t\th=5height+cthk+2*5htol,\n\t\t\t\t\tcR=5cornerR+cthk+5ctol,\n\t\t\t\t\tsw=5swidth+cthk+2*5ctol,\n\t\t\t\t\tst=5sthick,\n\t\t\t\t\ttaper=case_taper);\n}\nmodule oldiPhoneGlass(\tw,\n\t\t\t\tl,\n\t\t\t\th,\n\t\t\t\tr,\n\t\t\t\tst)   {\n\twi=w-2*st;\n\tli=l-2*st;\n\tri=r-st;\n\tunion(){\n\t\tcube([wi,li-ri*2,h],center = true);\n\t\tcube([wi-ri*2,li,h],center = true);\n\t\tfor(i=[1,-1]){\n\t\t\tfor(j=[1,-1]){\n\t\t\t\ttranslate([i*(wi/2-ri),j*(li/2-ri),0])\n\t\t\t\t\tcylinder(\th = h,\n\t\t\t\t\t\t\tr = ri,\n\t\t\t\t\t\t\tcenter = true,\n\t\t\t\t\t\t\t$fn = circle_resolution);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule iPhoneGlass(\tw,\n\t\t\t\tl,\n\t\t\t\th,\n\t\t\t\tr,\n\t\t\t\tst,\n\t\t\t\ttaper){\n\twi=w-2*st;\n\tli=l-2*st;\n\tri=r-st;\n\ttap=h*tan(taper);\n\thull(){\n\t\tunion(){\n\t\t\ttranslate([0,0,-h/2+.005])cube([wi,li-ri*2,.01],center = true);\n\t\t\ttranslate([0,0,-h/2+.005])cube([wi-ri*2,li,.01],center = true);\n\t\t\ttranslate([0,0,-h/2+.005])for(i=[1,-1]){\n\t\t\t\tfor(j=[1,-1]){\n\t\t\t\t\ttranslate([i*(wi/2-ri),j*(li/2-ri),0])\n\t\t\t\t\t\tcylinder(\th = .01,\n\t\t\t\t\t\t\t\tr = ri,\n\t\t\t\t\t\t\t\tcenter = true,\n\t\t\t\t\t\t\t\t$fn = circle_resolution);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tunion(){\n\t\t\ttranslate([0,0,h/2-.005])cube([wi-tap*2,li-ri*2-tap*2,.01],center = true);\n\t\t\ttranslate([0,0,h/2-.005])cube([wi-ri*2-tap*2,li-tap*2,.01],center = true);\n\t\t\ttranslate([0,0,h/2-.005])for(i=[1,-1]){\n\t\t\t\tfor(j=[1,-1]){\n\t\t\t\t\ttranslate([i*(wi/2-ri-tap),j*(li/2-ri-tap),0])\n\t\t\t\t\t\tcylinder(\th = .01,\n\t\t\t\t\t\t\t\tr = ri,\n\t\t\t\t\t\t\t\tcenter = true,\n\t\t\t\t\t\t\t\t$fn = circle_resolution);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule oldiPhoneStrip(\tw,\n\t\t\t\tl,\n\t\t\t\th,\n\t\t\t\tr,\n\t\t\t\tst\t) {\n\tunion(){\n\t\tcube([w,l-r*2,h],center = true);\n\t\tcube([w-r*2,l,h],center = true);\n\t\tfor(i=[1,-1]){\n\t\t\tfor(j=[1,-1]){\n\t\t\t\ttranslate([i*(w/2-r),j*(l/2-r),0])\n\t\t\t\t\tcylinder(\th = h,\n\t\t\t\t\t\t\t\tr = r,\n\t\t\t\t\t\t\t\tcenter = true,\n\t\t\t\t\t\t\t\t$fn = circle_resolution);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule iPhoneStrip(\tw,\n\t\t\t\tl,\n\t\t\t\th,\n\t\t\t\tr,\n\t\t\t\tst,\n\t\t\t\ttaper){\n\ttap=h*tan(taper);\n\thull(){\n\t\tunion(){\n\t\t\ttranslate([0,0,-h/2+.005])cube([w,l-r*2,.01],center = true);\n\t\t\ttranslate([0,0,-h/2+.005])cube([w-r*2,l,.01],center = true);\n\t\t\ttranslate([0,0,-h/2+.005])for(i=[1,-1]){\n\t\t\t\tfor(j=[1,-1]){\n\t\t\t\t\ttranslate([i*(w/2-r),j*(l/2-r),0])\n\t\t\t\t\t\tcylinder(\th = .01,\n\t\t\t\t\t\t\t\t\tr = r,\n\t\t\t\t\t\t\t\t\tcenter = true,\n\t\t\t\t\t\t\t\t\t$fn = circle_resolution);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tunion(){\n\t\t\ttranslate([0,0,h/2-.005])cube([w-2*tap,l-r*2-2*tap,.01],center = true);\n\t\t\ttranslate([0,0,h/2-.005])cube([w-r*2-2*tap,l-2*tap,.01],center = true);\n\t\t\ttranslate([0,0,h/2-.005])for(i=[1,-1]){\n\t\t\t\tfor(j=[1,-1]){\n\t\t\t\t\ttranslate([i*(w/2-r-tap),j*(l/2-r-tap),0])\n\t\t\t\t\t\tcylinder(\th = .01,\n\t\t\t\t\t\t\t\t\tr = r,\n\t\t\t\t\t\t\t\t\tcenter = true,\n\t\t\t\t\t\t\t\t\t$fn = circle_resolution);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule iPhoneCameraHole(w,h,r){\n\thull(){\n\t\ttranslate([w/2,0,0])\n\t\t\tcylinder(h = h,r = r,center = true, $fn = circle_resolution);\n\t\ttranslate([-w/2,0,0])\n\t\t\tcylinder(h = h,r = r,center = true, $fn = circle_resolution);\n\t}\n}\nmodule oldiPhone5(w,l,h,cR,sw,st){\n\thull(){\n\t\toldiPhoneGlass(w,l,h,cR,st);\n\t\toldiPhoneStrip(w,l,sw,cR,st);\n\t}\n}\nmodule iPhone5(w,l,h,cR,sw,st,taper){\n\thull(){\n\t\tiPhoneGlass(w,l,h,cR,st,taper);\n\t\tiPhoneStrip(w,l,sw,cR,st,taper);\n\t}\n}\nmodule oldiPhone4(w,l,h,cR,sw,st){\n\tunion(){\n\t\thull(){\n\t\t\toldiPhoneGlass(w,l,sw+(h-sw)/4,cR,st);\n\t\t\toldiPhoneStrip(w,l,sw,cR,st);\n\t\t}\n\t\toldiPhoneGlass(w,l,h,cR,st);\n\t}\n}\nmodule iPhone4(w,l,h,cR,sw,st,taper){\n\tunion(){\n\t\thull(){\n\t\t\tiPhoneGlass(w,l,sw+(h-sw)/4,cR,st,taper);\n\t\t\tiPhoneStrip(w,l,sw,cR,st,taper);\n\t\t}\n\t\tiPhoneGlass(w,l,h,cR,st,taper);\n\t}\n}\nmodule iPhone5Case(){\n\t\tdifference(){\n\t\t\tunion(){\n\t\t\t\tiPhone5(w=5width+2*(cthk+5ctol),\n\t\t\t\t\tl=5length+2*(cthk+5ctol),\n\t\t\t\t\th=5height+cthk+2*5htol,\n\t\t\t\t\tcR=5cornerR+cthk+5ctol,\n\t\t\t\t\tsw=5swidth+cthk+2*5ctol,\n\t\t\t\t\tst=5sthick,\n\t\t\t\t\ttaper=case_taper);\n\t\t\t\tif(include_hooks==\"yes\")translate([0,0,-(5height+cthk+2*5htol)/2])\n\t\t\t\t\t3hooks(w=5width+2*(cthk+5ctol),\n\t\t\t\t\t\th=5length/3,\n\t\t\t\t\t\tbandd=3.5,\n\t\t\t\t\t\tthick=2,\n\t\t\t\t\t\tdepth=8,\n\t\t\t\t\t\tclosure=60);\n\t\t\t}\n\t\t\ttranslate([0,0,0])iPhone5(w=5width+2*5ctol,\n\t\t\t\t\tl=5length+2*5ctol,\n\t\t\t\t\th=5height+2*5htol,\n\t\t\t\t\tcR=5cornerR+5ctol,\n\t\t\t\t\tsw=5swidth+2*5ctol,\n\t\t\t\t\tst=5sthick,\n\t\t\t\t\ttaper=case_taper);\n\t\t\tiPhoneGlass(w=5width+2*5ctol+.05,\n\t\t\t\t\tl=5length+2*5ctol+.05,\n\t\t\t\t\th=5height+2*5htol+cthk+.01,\n\t\t\t\t\tr=5cornerR+5ctol,\n\t\t\t\t\tst=5sthick,\n\t\t\t\t\ttaper=case_taper);\n\t\t\ttranslate([0,0,cthk/2])\n\t\t\t\tcube([44,5length+20,5height+cthk/2],center = true);\n\t\t\ttranslate([-5width/2-cthk*.8,30,4.5])\n\t\t\t\trotate([90,0,90])\n\t\t\t\tscale([1,1,2])\n\t\t\t\tiPhoneCameraHole(30,cthk*2,8);\n\t\t}\n\t\ttranslate([0,0,-(5height+cthk+2*5htol)/2+cthk/4])difference(){\n\t\t\tunion(){\n\t\t\t\tintersection(){\n\t\t\t\t\tiPhoneGlass(w=5width+2*5ctol+fudge,\n\t\t\t\t\t\t\tl=5length+2*5ctol+fudge,\n\t\t\t\t\t\t\th=cthk/2,\n\t\t\t\t\t\t\tr=5cornerR+5ctol-fudge,\n\t\t\t\t\t\t\tst=5sthick,\n\t\t\t\t\t\t\ttaper=0);\n\t\t\t\t\tbackpat();\n\t\t\t\t}\n\t\t\t\ttranslate([15,52.4,0])\n\t\t\t\t\tiPhoneCameraHole(7.8,cthk/2,7.8+1.6);\n\t\t\t}\n\t\t\ttranslate([15,52.4,0])\n\t\t\t\tscale([1,1,2])\n\t\t\t\tiPhoneCameraHole(7.8,cthk/2,7.8);\n\t\t}\n}\nmodule iPhone4Case(){\n\t\tdifference(){\n\t\t\tunion(){\n\t\t\t\tiPhone5(w=4width+2*(cthk+4ctol),\n\t\t\t\t\tl=4length+2*(cthk+4ctol),\n\t\t\t\t\th=4height+cthk/2+2*4htol,\n\t\t\t\t\tcR=4cornerR+cthk+4ctol,\n\t\t\t\t\tsw=4swidth+cthk+2*4ctol,\n\t\t\t\t\tst=1.5*4sthick,\n\t\t\t\t\ttaper=case_taper);\n\t\t\t\tif(include_hooks==\"yes\")translate([0,0,-(4height+cthk/2+2*4htol)/2])3hooks(w=4width+2*(cthk+4ctol),\n\t\t\t\t\th=4length/3,\n\t\t\t\t\tbandd=3.5,\n\t\t\t\t\tthick=2,\n\t\t\t\t\tdepth=8,\n\t\t\t\t\tclosure=60);\n\t\t\t}\n\t\t\ttranslate([0,0,\n\t\t\t\t-(4height+cthk/2+2*4htol)/2\n\t\t\t\t+cthk/2\n\t\t\t\t+(4height/2+(4swidth+(4height-4swidth)/4)/2+2*4htol)/2])\n\t\t\t\tiPhone5(w=4width+2*4ctol,\n\t\t\t\t\tl=4length+2*4ctol,\n\t\t\t\t\th=4height/2+(4swidth+(4height-4swidth)/4)/2+2*4htol,\n\t\t\t\t\tcR=4cornerR+4ctol,\n\t\t\t\t\tsw=4swidth/2+4height/2,\n\t\t\t\t\tst=4sthick,\n\t\t\t\t\ttaper=case_taper);\n\t\t\tiPhoneGlass(w=4width+2*4ctol+.05,\n\t\t\t\t\tl=4length+2*4ctol+.05,\n\t\t\t\t\th=4height+2*4htol+cthk/2+.01,\n\t\t\t\t\tr=4cornerR+4ctol,\n\t\t\t\t\tst=4sthick,\n\t\t\t\t\ttaper=case_taper);\n\t\t\ttranslate([0,0,cthk])\n\t\t\t\tcube([44,4length+20,4height+cthk/2],center = true);\n\t\t\ttranslate([-4width/2-cthk*.8,30,(4height+cthk/2+2*4htol)/2])\n\t\t\t\trotate([90,0,90])\n\t\t\t\tscale([1,1,2])\n\t\t\t\tiPhoneCameraHole(24,cthk*2,4height+cthk/2+2*4htol-cthk-4sthick);\n\t\t}\n\t\ttranslate([0,0,-(4height+cthk/2+2*4htol)/2+cthk/4])difference(){\n\t\t\tunion(){\n\t\t\t\tintersection(){\n\t\t\t\t\t\tiPhoneGlass(w=4width+2*4ctol+fudge,\n\t\t\t\t\t\t\tl=4length+2*4ctol+fudge,\n\t\t\t\t\t\t\th=cthk/2,\n\t\t\t\t\t\t\tr=4cornerR+4ctol-fudge,\n\t\t\t\t\t\t\tst=4sthick,\n\t\t\t\t\t\t\ttaper=0);\n\t\t\t\t\t\tbackpat();\n\t\t\t\t}\n\t\t\t\ttranslate([15,48.2,0])\n\t\t\t\t\tiPhoneCameraHole(7.8,cthk/2,7.8+1.6);\n\t\t\t}\n\t\t\ttranslate([15,48.2,0])\n\t\t\t\tscale([1,1,2])\n\t\t\t\tiPhoneCameraHole(7.8,cthk/2,7.8);\n\t\t}\n}\nmodule stencil(stencil_width,stencil_height,stencil_rotation,margin){\n\tdispo_width = stencil_width - 2*margin;\n\tpoints_array = (input==\"no_input\"? [[179,268],[[199.26,15.12],[189.19,15.56],[181.5,16.45],[175.52,17.83],[169.55,19.42],[163.57,21.55],[157.55,24.22],[151.62,27.5],[145.87,31.09],[140.35,35.49],[135,40.71],[130.05,46.71],[125.52,53],[121.87,59.06],[119.06,64.5],[117.12,69.21],[115.55,73.5],[114.31,77.65],[113.16,82],[112.07,87.29],[110.96,93.7],[110.36,99.39],[110.49,102.95],[111.13,105],[136.96,105],[158.46,104.73],[163.39,103.42],[163.83,101.08],[164.04,97.67],[164.46,93.04],[165.44,87.75],[167.04,82.4],[168.96,77.59],[171.9,73.02],[175.98,68.21],[180.98,63.93],[186.13,60.62],[192.15,58.45],[201.05,58],[208.86,58.34],[214.1,59.16],[217.74,60.82],[221.73,63.19],[225.41,66.46],[228.34,70.28],[230.39,74.63],[231.97,79.15],[232.75,85.01],[232.85,92.65],[232.01,100.96],[229.51,107.41],[225.45,113.48],[218.91,119.91],[211.35,126.37],[203.83,132.63],[197.2,138.54],[191.77,144.13],[187.33,150.15],[183.1,157.07],[179.62,164.83],[176.98,172.85],[175.42,181.69],[175.22,192.28],[175.5,203.5],[199,203.5],[222.5,203.5],[222.74,198.5],[223.25,193.21],[224.15,187.5],[225.64,181.94],[227.6,177],[230.92,172.02],[235.69,166.37],[243.47,159.38],[254,151.21],[264.03,143.56],[270.61,137.84],[274.46,133.36],[277.95,128.69],[281.05,123.47],[283.96,117.69],[286.32,111.7],[288.09,106],[289.06,98.48],[289.47,88],[289.05,76.45],[287.17,68],[284.48,60.83],[281.31,54.14],[276.58,47.41],[270.1,40.14],[262.4,33.38],[254.68,28.12],[246.8,24.2],[238.72,20.92],[230.05,18.48],[220.76,16.55],[210.43,15.49],[199.26,15.12]],[[198.05,226.08],[178.93,226.28],[170.25,226.66],[169.27,232.87],[169,254.48],[169.27,277.23],[170.58,282.39],[179.4,282.82],[198.38,283],[218.91,282.73],[225.8,281.8],[226.73,274.94],[227,254.5],[226.73,234.06],[225.8,227.2],[218.87,226.29],[198.05,226.08]]]: input);\n\tinput_width = points_array[0][0];\n\tinput_height= points_array[0][1];\n\tsTrace = dispo_width/input_width;\n\tdifference() {\n\t\ttranslate([0, 0, stencil_thickness/2])\n\t\tcube([stencil_width, stencil_height,3* stencil_thickness], center=true);\n\t\ttranslate([offX, offY, -stencil_thickness/2])\n\t\trotate([0,0,stencil_rotation])\n\t\tscale([sTrace, -sTrace, 1])\n\t\ttranslate([-200, -150, 0]) {\n\t\t\tunion() {\n\t\t\t\tfor (i = [1:len(points_array) -1] ) {\n\t\t\t\t\tlinear_extrude(height=stencil_thickness*2) {polygon(points_array[i]);}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule honeycomb(w,l,h,r,rmod,th,sides){\n\tcolumns = l/(r*3)+2;\n\trows = w/(r*sqrt(3)/2*2)+1;\n\ttranslate([-w/2,l/2,0])\n\t\trotate([0,0,-90])\n\t\t\tfor(i = [-1:rows]){\n\t\t\t\ttranslate([0,r*sqrt(3)/2*i*2,0])\n\t\t\t\t\tfor(i = [-1:columns]){\n\t\t\t\t\t\ttranslate([r*i*3,0,0])\n\t\t\t\t\t\t\tfor(i = [0:1]){\n\t\t\t\t\t\t\t\ttranslate([r*1.5*i,r*sqrt(3)/2*i,0])\n\t\t\t\t\t\t\t\t\trotate([0,0,honeycomb_rotation])\n\t\t\t\t\t\t\t\t\tdifference(){\n\t\t\t\t\t\t\t\t\t\tif(sides < 5){\n\t\t\t\t\t\t\t\t\t\t\tcylinder(h = h, r = r+th+(r*rmod/50), center = true, $fn = sides);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tcylinder(h = h, r = r+(r*rmod/50), center = true, $fn = sides);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcylinder(h = h+1, r = r-th+(r*rmod/50), center = true, $fn = sides);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n}\nmodule backpat(){\n\tscale([-1,1,5]){\n\t\t\tif(iphone_version==1 && type_of_case==1)\n\t\t\t\tstencil(4width+2*4ctol,4length+2*4ctol,image_rotation,4margin);\n\t\t\tif(iphone_version==2 && type_of_case==1)\n\t\t\t\tstencil(5width+2*5ctol,5length+2*5ctol,image_rotation,5margin);\n\t\t\tif(iphone_version==1 && type_of_case==2)\n\t\t\t\thoneycomb(4width+2*4ctol,4length+2*4ctol,4height,\n\t\t\t\t\thoneycomb_radius,honeycomb_radius_modifier,\n\t\t\t\t\thoneycomb_thickness,honeycomb_sides);\n\t\t\tif(iphone_version==2 && type_of_case==2)\n\t\t\t\thoneycomb(5width+2*5ctol,5length+2*5ctol,5height,\n\t\t\t\t\thoneycomb_radius,honeycomb_radius_modifier,\n\t\t\t\t\thoneycomb_thickness,honeycomb_sides);\n\t\t\tif(iphone_version==1 && type_of_case==3 && mashup_type==1)\n\t\t\t\tmashup1(image_rotation,\n\t\t\t\t\t4width+2*4ctol,4length+2*4ctol,4height,\n\t\t\t\t\thoneycomb_radius,honeycomb_radius_modifier,\n\t\t\t\t\thoneycomb_thickness,honeycomb_sides,\n\t\t\t\t\tindex_i,index_j);\n\t\t\tif(iphone_version==2 && type_of_case==3 && mashup_type==1)\n\t\t\t\tmashup1(image_rotation,\n\t\t\t\t\t5width+2*5ctol,5length+2*5ctol,5height,\n\t\t\t\t\thoneycomb_radius,honeycomb_radius_modifier,\n\t\t\t\t\thoneycomb_thickness,honeycomb_sides,\n\t\t\t\t\tindex_i,index_j);\n\t\t\tif(iphone_version==1 && type_of_case==3 && mashup_type==2)\n\t\t\t\tmashup2(4width+2*4ctol,4length+2*4ctol,image_rotation,4margin,\n\t\t\t\t\t4width+2*4ctol,4length+2*4ctol,4height,\n\t\t\t\t\thoneycomb_radius,honeycomb_radius_modifier,\n\t\t\t\t\thoneycomb_thickness,honeycomb_sides);\n\t\t\tif(iphone_version==2 && type_of_case==3 && mashup_type==2)\n\t\t\t\tmashup2(5width+2*5ctol,5length+2*5ctol,image_rotation,5margin,\n\t\t\t\t\t5width+2*5ctol,5length+2*5ctol,5height,\n\t\t\t\t\thoneycomb_radius,honeycomb_radius_modifier,\n\t\t\t\t\thoneycomb_thickness,honeycomb_sides);\n\t}\n}\nmodule mashup1(stencil_rotation,w,l,h,r,rmod,th,sides,index_i,index_j){\n\tstencil_width=1*(r+(r*rmod/50));\n\tstencil_height=2*h;\n\tmargin=0;\n\tcolumns = l/(r*3)+1;\n\trows = w/(r*sqrt(3)/2*2);\n\timod=floor(columns)-(round(columns/2)-floor(columns/2))+index_i;\n\tjmod=floor(rows)-(round(rows/2)-floor(rows/2))+index_j*2+ceil(index_i/2)-floor(index_i/2);\n\techo(columns,rows);\n\techo(index_i,index_j);\n\techo(imod,jmod);\n\tpoints_array = (input==\"no_input\"? [[179,268],[[199.26,15.12],[189.19,15.56],[181.5,16.45],[175.52,17.83],[169.55,19.42],[163.57,21.55],[157.55,24.22],[151.62,27.5],[145.87,31.09],[140.35,35.49],[135,40.71],[130.05,46.71],[125.52,53],[121.87,59.06],[119.06,64.5],[117.12,69.21],[115.55,73.5],[114.31,77.65],[113.16,82],[112.07,87.29],[110.96,93.7],[110.36,99.39],[110.49,102.95],[111.13,105],[136.96,105],[158.46,104.73],[163.39,103.42],[163.83,101.08],[164.04,97.67],[164.46,93.04],[165.44,87.75],[167.04,82.4],[168.96,77.59],[171.9,73.02],[175.98,68.21],[180.98,63.93],[186.13,60.62],[192.15,58.45],[201.05,58],[208.86,58.34],[214.1,59.16],[217.74,60.82],[221.73,63.19],[225.41,66.46],[228.34,70.28],[230.39,74.63],[231.97,79.15],[232.75,85.01],[232.85,92.65],[232.01,100.96],[229.51,107.41],[225.45,113.48],[218.91,119.91],[211.35,126.37],[203.83,132.63],[197.2,138.54],[191.77,144.13],[187.33,150.15],[183.1,157.07],[179.62,164.83],[176.98,172.85],[175.42,181.69],[175.22,192.28],[175.5,203.5],[199,203.5],[222.5,203.5],[222.74,198.5],[223.25,193.21],[224.15,187.5],[225.64,181.94],[227.6,177],[230.92,172.02],[235.69,166.37],[243.47,159.38],[254,151.21],[264.03,143.56],[270.61,137.84],[274.46,133.36],[277.95,128.69],[281.05,123.47],[283.96,117.69],[286.32,111.7],[288.09,106],[289.06,98.48],[289.47,88],[289.05,76.45],[287.17,68],[284.48,60.83],[281.31,54.14],[276.58,47.41],[270.1,40.14],[262.4,33.38],[254.68,28.12],[246.8,24.2],[238.72,20.92],[230.05,18.48],[220.76,16.55],[210.43,15.49],[199.26,15.12]],[[198.05,226.08],[178.93,226.28],[170.25,226.66],[169.27,232.87],[169,254.48],[169.27,277.23],[170.58,282.39],[179.4,282.82],[198.38,283],[218.91,282.73],[225.8,281.8],[226.73,274.94],[227,254.5],[226.73,234.06],[225.8,227.2],[218.87,226.29],[198.05,226.08]]]: input);\n\tdispo_width = stencil_width - 2*margin;\n\tinput_width = points_array[0][0];\n\tinput_height= points_array[0][1];\n\tsTrace = dispo_width/input_width*image_scale/100;\n\tcolor(\"red\")translate([-w/2,l/2,0])\n\t\trotate([0,0,-90]){\n\t\t\tdifference(){\n\t\t\t\tfor(i = [0:rows]){\n\t\t\t\t\ttranslate([0,r*sqrt(3)/2*i*2,0])\n\t\t\t\t\t\tfor(i = [0:columns]){\n\t\t\t\t\t\t\ttranslate([r*i*3,0,0])\n\t\t\t\t\t\t\t\tfor(i = [0:1]){\n\t\t\t\t\t\t\t\t\ttranslate([r*1.5*i,r*sqrt(3)/2*i,0])\n\t\t\t\t\t\t\t\t\t\trotate([0,0,honeycomb_rotation])\n\t\t\t\t\t\t\t\t\t\tdifference(){\n\t\t\t\t\t\t\t\t\t\t\tif(sides < 5){\n\t\t\t\t\t\t\t\t\t\t\t\tcylinder(h = h, r = r+th+(r*rmod/50), center = true, $fn = sides);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tcylinder(h = h, r = r+(r*rmod/50), center = true, $fn = sides);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tcylinder(h = h+1, r = r-th+(r*rmod/50), center = true, $fn = sides);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttranslate([r*imod*1.5,r*sqrt(3)/2*jmod,0])\n\t\t\t\t\t\trotate([0,0,honeycomb_rotation])\n\t\t\t\t\t\t\tcylinder(h = h+1, r = r-th+(r*rmod/50), center = true, $fn = sides);\n\t\t\t}\n\t\t\ttranslate([r*imod*1.5,r*sqrt(3)/2*jmod,0])difference(){\n\t\t\t\t\trotate([0,0,honeycomb_rotation])\n\t\t\t\t\t\tcylinder(h = h, r = r-th+(r*rmod/50), center = true, $fn = sides);\n\t\t\t\t\ttranslate([offX, offY, -stencil_thickness/2])\n\t\t\t\t\t\trotate([0,0,90-stencil_rotation])\n\t\t\t\t\t\tscale([sTrace, -sTrace, 1])\n\t\t\t\t\t\ttranslate([-200, -150, 0]) {\n\t\t\t\t\t\t\tunion() {\n\t\t\t\t\t\t\t\tfor (i = [1:len(points_array) -1] ) {\n\t\t\t\t\t\t\t\t\tlinear_extrude(height=stencil_thickness*2){\n\t\t\t\t\t\t\t\t\t\tpolygon(points_array[i]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t}\n}\nmodule mashup2(stencil_width,stencil_height,stencil_rotation,margin,w,l,h,r,rmod,th,sides){\n\tdispo_width = stencil_width - 2*margin;\n\tcolumns = l/(r*3)+1;\n\trows = w/(r*sqrt(3)/2*2);\n\tpoints_array = (input==\"no_input\"? [[179,268],[[199.26,15.12],[189.19,15.56],[181.5,16.45],[175.52,17.83],[169.55,19.42],[163.57,21.55],[157.55,24.22],[151.62,27.5],[145.87,31.09],[140.35,35.49],[135,40.71],[130.05,46.71],[125.52,53],[121.87,59.06],[119.06,64.5],[117.12,69.21],[115.55,73.5],[114.31,77.65],[113.16,82],[112.07,87.29],[110.96,93.7],[110.36,99.39],[110.49,102.95],[111.13,105],[136.96,105],[158.46,104.73],[163.39,103.42],[163.83,101.08],[164.04,97.67],[164.46,93.04],[165.44,87.75],[167.04,82.4],[168.96,77.59],[171.9,73.02],[175.98,68.21],[180.98,63.93],[186.13,60.62],[192.15,58.45],[201.05,58],[208.86,58.34],[214.1,59.16],[217.74,60.82],[221.73,63.19],[225.41,66.46],[228.34,70.28],[230.39,74.63],[231.97,79.15],[232.75,85.01],[232.85,92.65],[232.01,100.96],[229.51,107.41],[225.45,113.48],[218.91,119.91],[211.35,126.37],[203.83,132.63],[197.2,138.54],[191.77,144.13],[187.33,150.15],[183.1,157.07],[179.62,164.83],[176.98,172.85],[175.42,181.69],[175.22,192.28],[175.5,203.5],[199,203.5],[222.5,203.5],[222.74,198.5],[223.25,193.21],[224.15,187.5],[225.64,181.94],[227.6,177],[230.92,172.02],[235.69,166.37],[243.47,159.38],[254,151.21],[264.03,143.56],[270.61,137.84],[274.46,133.36],[277.95,128.69],[281.05,123.47],[283.96,117.69],[286.32,111.7],[288.09,106],[289.06,98.48],[289.47,88],[289.05,76.45],[287.17,68],[284.48,60.83],[281.31,54.14],[276.58,47.41],[270.1,40.14],[262.4,33.38],[254.68,28.12],[246.8,24.2],[238.72,20.92],[230.05,18.48],[220.76,16.55],[210.43,15.49],[199.26,15.12]],[[198.05,226.08],[178.93,226.28],[170.25,226.66],[169.27,232.87],[169,254.48],[169.27,277.23],[170.58,282.39],[179.4,282.82],[198.38,283],[218.91,282.73],[225.8,281.8],[226.73,274.94],[227,254.5],[226.73,234.06],[225.8,227.2],[218.87,226.29],[198.05,226.08]]]: input);\n\tinput_width = points_array[0][0];\n\tinput_height= points_array[0][1];\n\tsTrace = dispo_width/input_width;\n\tunion(){\n\t\ttranslate([offX, offY, -stencil_thickness/2])\n\t\t\trotate([0,0,stencil_rotation])\n\t\t\tscale([sTrace, -sTrace, 1])\n\t\t\ttranslate([-200, -150, 0]) {\n\t\t\t\tunion() {\n\t\t\t\t\tfor (i = [1:len(points_array) -1] ) {\n\t\t\t\t\t\tlinear_extrude(height=stencil_thickness*2) {polygon(points_array[i]);}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\thoneycomb(w=w,l=l,h=h,r=r,rmod=rmod,th=th,sides=sides);\n\t}\n}\nmodule bandhook(bandd,thick,w,closure){\n\tbandr=bandd/2;\n\ttranslate([0,-w/2,0]){\n\t\tdifference(){\n\t\t\tunion(){\n\t\t\t\ttranslate([-bandd-thick,0,0])cube([2*(bandd+thick),w,bandr+thick]);\n\t\t\t\ttranslate([bandr,0,thick+bandr])rotate([-90,0,0])\n\t\t\t\t\tcylinder(r=bandr+thick,h=w,$fn=20);\n\t\t\t}\n\t\t\tunion(){\n\t\t\t\ttranslate([-bandd-thick,-fudge/2,thick+bandr])\n\t\t\t\t\tcube([bandr+bandd+thick,w+fudge,bandd+thick]);\n\t\t\t\ttranslate([bandr,-fudge/2,thick+bandr])rotate([-90,0,0])\n\t\t\t\t\tcylinder(r=bandr,h=w+fudge,$fn=20);\n\t\t\t\ttranslate([thick+bandr,-fudge/2,0])rotate([0,45,0])cube([2*thick,w+fudge,2*thick]);\n\t\t\t\ttranslate([bandr,-fudge/2,thick+bandr])\n\t\t\t\t\trotate([0,-closure,0])cube([bandr+2*thick,w+fudge,2*thick]);\n\t\t\t}\n\t\t}\n\t\ttranslate([bandr,0,thick+bandr])\n\t\t\trotate([0,-closure,0])translate([bandr+thick/2,0,0])\n\t\t\trotate([-90,0,0])cylinder(r=thick/2,h=w,$fn=20);\n\t}\n}\nmodule 3hooks(w,h,bandd,thick,depth,closure){\n\tscale([-1,1,1])translate([w/2,0,0])bandhook(bandd,thick,depth,2);\n\tfor(i=[1,-1])scale([1,i,1])translate([w/2,h/2,0])bandhook(bandd,thick,depth,closure);\n}",
    "description": "Okay, I'm looking to get a custom iPhone case designed and I'd like to use OpenSCAD. I've been playing around with a couple of existing designs, and I'm hoping you can help me combine and improve upon them.\n\nHere's what I'm after:\n\n**Core Functionality:**\n\n*   **Parametric iPhone Case:** I need a case that fits either an iPhone 4/4S or an iPhone 5. I want to be able to switch between these using a variable, so the dimensions will need to change based on this selection.\n*   **Case Thickness:** Id like to control the thickness of the case. There should be at least two options (maybe \"slim\" and \"sturdy\") with corresponding thickness values that I can modify.\n*   **Design Type:** Id like to be able to choose between three case designs:\n    1.  **Stencil:** I'll provide a path list (like the output from a stencil generator), which should be extruded to create a cut-out design on the back of the case.  I need to be able to scale the design and shift its location on the back of the case. And also the ability to rotate the design.\n    2.  **Geometric Pattern:** I want to generate a repeating geometric pattern on the back. I need to be able to choose the shape (triangle, square, pentagon, hexagon, etc. all the way to a circle), the radius of each element in the pattern, how much they overlap each other, the thickness of the pattern elements and also its rotation.\n    3. **Mashup** a combination of the Stencil and Geometric Pattern with two modes of mashup.\n        1. **Stencil inside base shape:** The stencil will be fit into the base shape of the geometric pattern. And be able to specify which base shape to be used by index number.\n        2. **Stencil on top:** Stencil is overlaid on top of the geometric pattern.\n*  **Rubber band hooks**: I would like the ability to add hooks to the side of the phone case to hold a rubber band to secure cards or cash. I should be able to turn this on or off.\n*  **Tapered Sides:** The case sides should have a slight taper towards the front of the phone for better grip, and I need to control that taper angle with a parameter.\n\n**Specific Dimensions/Parameters:**\n\nI need to be able to set tolerances for the phone fit, both for the perimeter (width and length) and the height.\n\nI have iPhone 4/4S and iPhone 5 specific dimension variables that I'd like to use, specifically including:\n\n*   Width, Length, Height\n*   Corner Radius\n*   Strip Width\n*   Strip Thickness\n\n**User Interface/Customization:**\n\nI would like to have a way to change all the above parameters in the OpenSCAD customizer. For the design patterns, I would like to have options for:\n\n*   **Stencil:** Input for the stencil path list, scaling factor, offset for X and Y and a rotation value.\n*   **Geometric Pattern:** Selection for the base shape, radius, overlap, rotation, and thickness.\n* **Mashup** selection for the type, index variables for Stencil inside base shape mode.\n\n**Technical Details:**\n\n* Im hoping you could create parametric modules for each of the case designs so they can be easily switched out or combined.\n*   I think the design might need to use the `hull()` function, and I've seen that `linear_extrude()` is needed.\n* I'm also going to need to use `difference()` to cut out shapes for the camera and other openings in the phone case design, as well as the case material itself.\n* I'll need to define circles in multiple places for the phone case corners and geometric patterns so please remember `$fn`.\n\n**Libraries:**\n\nI don't need any external libraries at this time.\n\nI believe this captures all of the desired functionality. I'm excited to see what you can do!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Chopper Wheel ",
    "scad": "NUM_Int=40;\nR_OUTER = 30;\nR_INNER = 20;\nR_INNER2 = 9.5;\nR_HOLE = 4;\nBORDER = 2;\nTHICKNESS = 5;\nTHICKNESS_MOUNT = 2;\nINT_MODIFIER = -0.2;\nz=R_HOLE;\na=6;\nb=3;\nc=3;\nNUM_SECTIONS = NUM_Int*2;\nR_MOUNT = 3;\nR_CROSS = 1.9;\nshaft_lock();\nmodule shaft_lock(){\ndifference(){\ncylinder(15,(z*3)/2+3,(z*3)/2+3);\nrotate([90,0,0])translate([0,10,4])hexagon(b,a/2);\ntranslate([0,-5.5,15])cube([a,b,8],center=true);\ntranslate([0,0,10])#rotate([90,0,0])cylinder(100,(c+1)/2,(c+1)/2);\ncylinder(20,(z+1)/2,(z+1)/2);\n}\n}\nmodule reg_polygon(sides,radius)\n{\n  function dia(r) = sqrt(pow(r*2,2)/2);\n  if(sides<2) square([radius,0]);\n  if(sides==3) triangle(radius);\n  if(sides==4) square([dia(radius),dia(radius)],center=true);\n  if(sides>4) circle(r=radius,$fn=sides);\n}\nmodule hexagon_f(radius)\n{\n  reg_polygon(6,radius);\n}\nmodule hexagon(height,radius)\n{\n  linear_extrude(height=height) hexagon_f(radius);\n}\n$fs = 0.01;\nmodule encoder_contour(n,rin,rout,mod){\n\t for (i = [1:2:n])\n    {\n        assign (a1 = i*360/n, a2 = (i+1+mod)*360/n )\n        {\n                polygon(points=[\n\t\t\t\t\t\t[cos(a2)*rin,sin(a2)*rin],\n\t\t\t\t\t\t[cos(a1)*rin,sin(a1)*rin],\n\t\t\t\t\t\t[cos(a1)*rout,sin(a1)*rout],\n\t\t\t\t\t\t[cos(a2)*rout,sin(a2)*rout]\n\t\t\t\t\t]);\n\t\t\t}\n    }\n}\nmodule hole2d(rhole,rcross){\n\t circle(r = rhole);\n\t polygon(points=[[0,0.1],[rcross,0],[0,-0.1],[-rcross,0] ] );\n\t polygon(points=[[0.1,0],[0,rcross],[-0.1,0],[0,-rcross] ] );\n}\nmodule encoder3d(n,rin,rin2,rout,rhole,rmount,border,mod,t,tm) {\n\techo();\n\tdifference(){\n\t\tunion(){\n\t\t\tcylinder(h=t,r=rout);\n\t\t\tcylinder(h=tm,r=rmount);\n\t\t}\n\t\tlinear_extrude(height=5*t,center=true) encoder_contour(n,rin,rin2,mod);\n\t\trotate([0,0,360/(4*n)]) linear_extrude(height=5*t,center=true) encoder_contour(n,rin2-$fs,rout-border,mod);\n\t\tcylinder(h=5*tm,r=rhole,center=true);\n\t}\n}\nmodule encoder2d(rin,rout,rhole,rcross,mod) {\n\thole2d(rhole,rcross);\n\tencoder_contour(rin,rout,mod);\n}\nencoder3d(NUM_SECTIONS,R_INNER,R_INNER2,R_OUTER,R_HOLE,R_MOUNT,BORDER,INT_MODIFIER,THICKNESS,THICKNESS_MOUNT);",
    "description": "Okay, I need a parametric OpenSCAD file for a chopper wheel, similar to the one I already have but with some added flexibility. Im using it for optical experiments, part of an open-source hardware project.\n\nThe existing design (which Ill attach, but I won't paste all the code here - it's a file called `custom-chopper.scad`) has a few key features I need to keep and extend. Here's a breakdown of what Im looking for:\n\n**Core Functionality:**\n\n*   **Rotating Wheel with Interrupters:** The wheel needs to have a set of \"interrupters\" (slots or teeth) around its circumference for interrupting a light beam. The number and width of these interrupters are critical.\n*   **Inner and Outer Radii:** It needs to have configurable inner and outer radii for both the solid wheel portion and the interrupters.\n*   **Dual Phase Interrupters:** I need two sets of interrupters, one slightly phase-shifted from the other, for direction detection. These should be based on two inner radii, one for each interrupter set.\n*   **Center Mounting Hole:** There needs to be a central hole to mount it to a motor shaft.\n*   **Thickness:** The thickness of the wheel and the mounting hub should be configurable.\n*   **M3 Mounting Nut:** It currently has a shaft-lock that is designed to accommodate an M3 nut for securing the wheel to a shaft, which should be retained.\n\n**Desired Parametric Controls:**\n\n1.  **Number of Interrupters (NUM_Int):** A parameter to control the total number of interrupters on the main outer track.\n2.  **Outer Radius (R_OUTER):** A parameter for setting the overall radius of the wheel.\n3.  **Inner Radius (R_INNER):** The radius of the filled inner section of the wheel, defining the first set of interrupters.\n4.  **Inner Radius 2 (R_INNER2):**  The radius of the phase-shifted interrupters for the second track.\n5.  **Mounting Hole Radius (R_HOLE):** The radius of the central hole for the motor shaft.\n6.  **Border Thickness (BORDER):** The thickness of any solid border surrounding the interrupters.\n7.  **Wheel Thickness (THICKNESS):** The thickness of the main wheel.\n8.  **Mounting Hole Outline Thickness (THICKNESS_MOUNT):** The thickness of the mounting hub around the center hole.\n9. **Interrupter Width Modifier (INT_MODIFIER):** A parameter that affects the width of the interrupters (negative values make the interrupters wider than the gaps; positive make them narrower; 0 makes them the same width).\n10. **Shaft Lock Nut Parameters:** I'd like parameters for the M3 nut and screw dimensions for the shaft lock, so I don't have to hardcode them (i.e., nut diameter, nut thickness, screw diameter).\n11. **Mounting Hole Outline Radius (R_MOUNT):** The radius of the outer edge of the mounting hub.\n12. **Center Cross Radius (R_CROSS):** The size of the cross used for 2D encoder representations (for laser cutting).\n\n**New Features and Flexibility:**\n\n1.  **Optional 2D Representation:** I'd like a way to generate a 2D SVG outline of the wheel (for laser cutting or plotting) as well as the 3D model using a switch. This 2D representation should have the mounting hole and the center cross markers.\n2. **Full Radius Control:** Ensure all radii are fully configurable including both interrupter sets so their widths can be controlled separately.\n3.  **Clearer Variable Names:** My current code uses a lot of single-letter variables (like `z`, `a`, `b`, `c`). These should be replaced with more descriptive names for readability.\n4.  **Comments:** It would also be very helpful to have more comprehensive comments throughout the code to explain each section of the code and how the parameters impact the design.\n5.  **Unit Specification:** All parameters are in millimeters (mm), which should be stated in the comments.\n6.  **Dependencies:** Can you please add a library dependency to handle the bolt functionality instead of hardcoding that shape? Please make sure that the license of that library is compatible with GPL-3.0.\n\n**Libraries:**\n\nPlease use the **BOLTS** library for handling the nut and bolt geometries.\n\nI need this to be a fully parametric design, so I can easily change the various dimensions without having to dig into the code. I'm aiming for it to be used for a range of different optical experiments.\n\nI am hoping to have the OpenSCAD file you provide also be compatible with the GPL-3.0 license. Thank you.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Basic Business Card Holder",
    "scad": "name = \"BKNJ\";\ntypeStyle = \"write/Letters.dxf\";\ntypeSize = 12;\ntypeDepth = 3;\nboxWidth = 100;\nboxHeight = 25;\nboxDepth = 20;\nwallThickness = 2;\nuse <write/Write.scad>\ndifference()\n{\ncube([boxWidth, boxDepth, boxHeight]);\ntranslate([wallThickness, wallThickness, wallThickness])\n{\ncube([boxWidth-wallThickness*2, boxDepth-wallThickness*2, boxHeight]);\n}\n}\ntranslate([boxWidth/2,0,boxHeight/2])\nrotate(90,[1,0,0])\nwrite(name,t=typeDepth,h=typeSize,font=typeStyle, center=true);",
    "description": "Okay, I'd like to design a personalized business card holder and I'm having a little trouble getting everything exactly right.\n\nHere's what I'm envisioning:\n\nI need a rectangular box to hold business cards. I want to be able to adjust these dimensions: the width of the box, the height, and the depth. I also need to control the thickness of the walls of the box. Inside the box will be empty, but I want the base to remain. Basically, it's a hollow rectangular prism.\n\nOn the front face of the box, I want to add my name (or some custom text) using an embossed/engraved effect. I'd like to be able to select from several different font styles, adjust the size of the text, and control how deep the text is engraved. I'll need to include a library for text generation. Specifically, I'm using the `Write.scad` library. It also uses a set of dxf files, but those should be provided and not made parametric.\n\nI'm using OpenSCAD, and I'd like the design to be completely parametric. That way I can quickly change the dimensions and text and easily re-render it. The text should be automatically centered on the front face of the holder.\n\nCould you help me write an OpenSCAD file that can do all of this? I've already made an attempt with a basic box and text but am having trouble making it easily configurable with all these adjustments.\n"
  },
  {
    "object": "Hey cadmonkey, make me a build a gasket any size in silicone",
    "scad": "r1=16.5;\nr2=20 ;\ns=2.5;\nrs1=r1-5;\nrs2=r2+5;\nss=s+2;\ndifference()\n{\ncylinder(h=ss,r=rs2,center=true);\ncylinder(h=ss+2,r=rs1,center=true);\ndifference()\n{\ncylinder(h=s,r=r2,center=true+1);\ncylinder(h=s,r=r1,center=true+1);\n}\n}",
    "description": "Okay, I need a custom gasket designed for 3D printing in silicone, and I want to be able to easily adjust the dimensions. I have an existing SCAD file that gives the basic idea, but it's not parametric.\n\nHere's the gist of what I'm looking for:\n\nThe gasket is essentially a hollow cylinder, and it sits inside a support structure, also a hollow cylinder. The support structure is just a bit larger in all dimensions.\n\nRight now, the dimensions in the provided SCAD file are:\n\n*   **Gasket:**\n    *   Inner diameter (r1): 16.5 mm\n    *   Outer diameter (r2): 20 mm\n    *   Thickness (s): 2.5 mm\n*   **Support Structure:**\n    *   Inner diameter (rs1): r1 - 5 mm = 11.5 mm\n    *   Outer diameter (rs2): r2 + 5 mm = 25 mm\n    *   Thickness (ss): s + 2 mm = 4.5 mm\n\nThe current file creates the gasket and the support as a single object using a series of `difference()` operations.\n\nWhat I need from you is a new OpenSCAD file that:\n\n1.  **Is fully parametric.** I want to be able to easily adjust:\n    *   The inner diameter of the gasket (let's call this `gasket_inner_dia`).\n    *   The outer diameter of the gasket (`gasket_outer_dia`).\n    *   The thickness of the gasket (`gasket_thickness`).\n    *   The radial clearance between the gasket and support (`support_clearance`).\n    *   The thickness offset of the support (`support_thickness_offset`).\n2.  **Generates only the gasket.**  I don't need the support structure generated by the file. I only included it in my description to clarify how the gasket is intended to be used.\n3.  **Is properly centered** in the space so I can assemble and place it properly in my slicer.\n4.  **Uses the `difference()`** operation to create the annular shape.\n5.  **Avoids floating point math errors** in the center position when using `center=true`\n6.  **Is well-commented** so it is easy to read and use.\n7.  **Does not require any external libraries**. I would prefer to not use libraries for now, but if it becomes necessary, please let me know.\n\nSo, the output file should allow me to define the five parameters at the beginning, and then a single difference() operation should create the gasket based on those parameters. I want to use this to design silicone gaskets of different sizes.\n\nCould you generate that for me?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Simple Plug and Cap Generator",
    "scad": "End_Thickness = 3;\nEnd_Diameter = 60;\nTube_Inner_Diameter = 40;\nTube_Outer_Diameter = 44;\nTube_Height = 25;\nres = 90;\nmodule plug ()\n{\n\tunion()\n\t{\n\tcylinder(h = End_Thickness, r = End_Diameter/2, center = false, $fn = res);\n\t\tdifference()\n\t\t{\n\t\ttranslate ([0,0,End_Thickness]) cylinder(h = Tube_Height, r = Tube_Outer_Diameter/2, center = false, $fn = res);\n\t\ttranslate ([0,0,End_Thickness]) cylinder(h = Tube_Height+1, r = Tube_Inner_Diameter/2, center = false, $fn = res);\n\t\t}\n\t}\n}\nplug();",
    "description": "Okay, I need an OpenSCAD file that can generate plugs and caps for round holes and tubes. I've already got a basic version but I'd like a parametric version that I can easily adjust using the Customizer. Here's what I want it to do:\n\nThe design consists of two main parts: a solid end portion (like a flat disk) and a hollow tube portion that extends from the center of one side of that disk. The overall shape looks like a plug or a cap depending on the dimensions.\n\nHere are the key parameters I need to control:\n\n*   **End Thickness:** The thickness of the solid disk end, in millimeters.\n*   **End Diameter:** The diameter of the solid disk end, in millimeters. Setting this equal to the *Tube Outer Diameter* creates a smooth cap with no flange.\n*   **Tube Inner Diameter:** The inner diameter of the hollow tube portion, in millimeters. This is critical for a cap where you want to fit *over* the end of a pipe.\n*   **Tube Outer Diameter:** The outer diameter of the hollow tube portion, in millimeters. This is critical for a plug where you want to fit *inside* of a hole.\n*   **Tube Height:** The length of the hollow tube portion, in millimeters.\n\nI'd also like to have:\n\n*   **Resolution Control:** A variable to control the smoothness of the curves (number of segments for the circles).\n*   **Preview toggle:** an option to show or hide the preview using a single global variable called `preview` that is either `true` or `false`.\n*   **Clear Comments:** Please leave clear comments that explain each section of the code. \n*   **Use Standard OpenSCAD:** Please do not use any libraries, just standard OpenSCAD commands.\n*  **Unit of Measure:** I'd like to keep everything in millimeters, so please no conversions or mixing of units.\n\nThe basic idea is to be able to easily create a plug that fits inside a tube/hole or a cap that fits over the outside of a tube/pipe. The most common application will be for filling a hole in something that is already designed, not for joining separate pieces.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Resizable Loose Filament Spool",
    "scad": "part = \"Hub\";\nHub_Type = \"Replicator\";\nCentre_Hole_Diameter = 52;\nHub_Thickness = 15;\nSpoke_Length =  20;\nBracket_Diameter = 50;\nBracket_Thickness = 10;\nBracket_Depth = 8 ;\nBracket_Prong_Length = 1.0;\nAngular_Resolution = 0.1;\nOctagon_Resolution = 45 ;\nDecagon_Resolution = 36 ;\nPlug_Height = 10;\nPlug_Hole_Width = 10;\nPlug_Wall_Thickness = 3;\nPlug_Taper = 0.5;\nPlug_Clearance = 0.15;\nFiliament_Hole = 4;\nprint_part();\nmodule print_part() {\n\tif (part == \"Hub\") {\n\t\tHub();\n\t} else if (part == \"Spoke\") {\n\t\tSpoke();\n\t} else {\n\t\tBracket();\n\t}\n}\nmodule highlight(this_tab) {\n  if (preview_tab == this_tab) {\n    color(\"red\") child(0);\n  } else {\n    child(0);\n  }\n}\nmodule Hub() {\n\tHole_Offset = Hub_Thickness*.5*-1;\n\tPlug_Offset = ((Centre_Hole_Diameter/2) + Plug_Height+1)*-1;\n\tif (Hub_Type == \"Replicator\") {\n\t\ttranslate([0,0,Hub_Thickness-1]) tube(44,(Centre_Hole_Diameter+2)/2.0,1);\n\t}\n\tdifference() {\n\t\ttube(Hub_Thickness,(Centre_Hole_Diameter + 1 + (Plug_Height*2))/2.0,Plug_Height);\n\t\tunion(){\n\t\t\trotate([0,90,0]) translate([Hole_Offset,0,Plug_Offset])   plugHole();\n\t\t\trotate([120,90,0]) translate([Hole_Offset,0,Plug_Offset])   plugHole();\n\t\t\trotate([240,90,0]) translate([Hole_Offset,0,Plug_Offset])   plugHole();\n\t\t}\n\t}\n}\nmodule tube(height, radius, wall) {\n\tdifference(){\n\t\tcylinder(height, radius, radius, $fa=Angular_Resolution);\n\t\tcylinder(height, radius-wall, radius-wall, $fa=Angular_Resolution);\n\t}\n}\nmodule octagontube(height, radius, wall) {\n\tdifference(){\n\t\tcylinder(height, radius, radius, $fa=Octagon_Resolution);\n\t\tcylinder(height, radius-wall, radius-wall, $fa=Octagon_Resolution);\n\t}\n}\nmodule decagontube(height, radius, wall) {\n\tdifference(){\n\t\tcylinder(height, radius, radius, $fa=Decagon_Resolution);\n\t\tcylinder(height, radius-wall, radius-wall, $fa=Decagon_Resolution);\n\t}\n}\nmodule plugHole() {\n      cylinder(Plug_Height,Plug_Hole_Width/2,Plug_Hole_Width/2 - Plug_Taper,$fa=Octagon_Resolution);\n}\nmodule plug() {\n      cylinder(Plug_Height,(Plug_Hole_Width-Plug_Clearance)/2,(Plug_Hole_Width-Plug_Clearance)/2 - Plug_Taper,$fa=Octagon_Resolution);\n}\nmodule Spoke() {\n\tdifference() {\n\t\tunion() {\n  \t\t\toctagontube(Spoke_Length,(Plug_Hole_Width+Plug_Wall_Thickness)/2,Plug_Wall_Thickness*2/2,$fa=Octagon_Resolution);\n  \t\t\ttranslate([0,0,Spoke_Length*0.99]) plug();\n\t\t}\n\t\tplugHole();\n\t}\n}\nmodule Bracket_Build(diameter, thickness, depth, length){\n\tdifference() {\n\t\tunion() {\n\t\t\trotate([90,0,0])\n\t\t\tdifference(){\n\t\t\t\tdecagontube(thickness, diameter, depth) ;\n\t\t\t\ttranslate([diameter*-1,diameter*-1,0]) cube([diameter*2,diameter,thickness]);\n\t\t\t}\n    \t\t\tif (length > 1 ) {\n\t\t\t\ttranslate([diameter*-0.99,thickness*-1,thickness*(length-1)*-0.99]) cube([thickness*0.75,thickness,thickness*(length-1)]);\n   \t \t\t\ttranslate([diameter-(thickness*0.75),thickness*-1,thickness*(length-1)*-0.99]) cube([thickness*0.75,thickness,thickness*(length-1)]);\n    \t\t\t}\n\t\t\trotate([90,0,0]) translate([diameter*-0.91,(thickness*(length-1)*-1) + (thickness*-0.10),0]) cylinder(thickness,thickness/2,thickness/2,$fa=Angular_Resolution);\n\t\t\trotate([90,0,0]) translate([diameter*0.91,(thickness*(length-1)*-1) + (thickness*-0.10),0]) cylinder(thickness,thickness/2,thickness/2,$fa=Angular_Resolution);\n     \t\ttranslate([thickness*-1,thickness*-1,diameter*0.95])cube([thickness*2,thickness,thickness/4]);\n\t\t\ttranslate([0,thickness/2*-1,diameter])plug();\n\t\t}\n\t\tunion() {\n          \trotate([90,0,0]) translate([diameter*-0.91,(thickness*(length-1)*-1) + (thickness*-0.10),0]) cylinder(thickness,Filiament_Hole/2,Filiament_Hole/2,$fa=Angular_Resolution);\n\t\t\trotate([90,0,0]) translate([diameter*0.91,(thickness*(length-1)*-1) + (thickness*-0.10),0]) cylinder(thickness,Filiament_Hole/2,Filiament_Hole/2,$fa=Angular_Resolution);\n\t\t}\n\t}\n}\nmodule Bracket(){\n\trotate([90,0,0]) translate([0,Bracket_Thickness,0]) Bracket_Build(Bracket_Diameter, Bracket_Thickness, Bracket_Depth, Bracket_Prong_Length);\n}",
    "description": "Okay, I've been working with some loose filament spools, and I've found that existing solutions aren't quite flexible enough. I've got a design in mind, and I'd like your help creating a parametric OpenSCAD file for it. \n\nEssentially, I need a spindle that can insert into a loose spool of filament and spin on an axis.  It needs to be adaptable to different spool sizes and mounting options. I'm thinking of this design as having a central \"hub\" with spokes that connect to an outer \"bracket.\" These brackets will then hold the spool. I'd like to avoid stretching the filament when inserting the spindle, so I want a design where the spokes and brackets are inserted individually, not as a pre-assembled unit. I have attached the scad file.\n\nHere's a breakdown of the different parts and parameters I'm envisioning:\n\n**Terminology:**\n\n*   **Hub:** The central support for the spindle, with embedded spoke receptacles.\n*   **Centre Hole:** The hole in the center of the hub, to fit on an axis.\n*   **Spoke:** The connector that joins the hub to the bracket.\n*   **Bracket:** The outer support structure that holds the filament spool.\n*   **Plug:** The nub of plastic that inserts into plug holes in the hub or spokes.\n\n**General Requirements:**\n\n*   **Parametric Design:** Everything should be easily adjustable using variables.\n*   **Assembly:** The design needs to be such that brackets and spokes can be inserted into the hub one by one without stretching the filament. This requires a \"plug\" type fitting for the brackets into spokes, and spokes into the central hub.\n*   **Support Considerations:**  I will need to print Brackets with support (for the plug) and Hubs with support (for the plug holes). Spokes should be printed vertically, with no support.\n*   **Mounting Options:** I'd like to have options for mounting this spindle on a Replicator 1 (or similar) as well as using it with external spool holders.\n\n**Specific Parameters (these are starting values, I'd like them to be configurable):**\n\n**Hub:**\n\n*   `Hub_Type`:  A dropdown or boolean for selecting `Replicator` mounting or `External` mounting.\n*   `Centre_Hole_Diameter`: Diameter of the centre hole. Start with 52 for the Replicator, and make it adjustable to allow any size.\n*   `Hub_Thickness`: Thickness of the hub body. Start with 15.\n\n**Spoke:**\n\n*   `Spoke_Length`: Length of the spoke. Start with 20, but let it be changed to be longer or shorter, depending on the size of the filament coil.\n\n**Bracket:**\n\n*   `Bracket_Diameter`: Diameter of the bracket. Start with 50.\n*   `Bracket_Thickness`: Thickness of the bracket. Start with 10.\n*   `Bracket_Depth`: Depth of the bracket. Start with 8.\n*   `Bracket_Prong_Length`: Length of the fork extensions on the bracket in multiples of `Bracket_Thickness`. Start with 1.\n*   `Filiament_Hole`: Diameter for the holes in the bracket used for storage of loose filament. Start with 4.\n\n**Hidden Parameters:**\n\n*   `Angular_Resolution`: Angular resolution for curves. 0.1 should be fine.\n*   `Octagon_Resolution`: Angular resolution for the octagonal plug shapes. 45 should work.\n*   `Decagon_Resolution`: Angular resolution for the decagon bracket bases. 36 should work.\n*   `Plug_Height`: Height of the plug. Start with 10.\n*   `Plug_Hole_Width`: Width of the plug hole. Start with 10.\n*   `Plug_Wall_Thickness`: Thickness of the plug walls. Start with 3.\n*  `Plug_Taper`: Amount of taper for the plug in mm. Start with 0.5\n*  `Plug_Clearance`: Difference between plug and plughole diameters. Start with 0.15\n\n**Modules:**\n\n*   `print_part()`: controls which part is rendered.\n*   `Hub()`: creates the hub.\n*   `tube()`: creates a tube.\n*   `octagontube()`: creates an octagonal tube.\n*   `decagontube()`: creates a decagonal tube.\n*   `plugHole()`: creates the plug hole.\n*  `plug()`: creates the plug.\n*   `Spoke()`: creates a spoke.\n*   `Bracket_Build()`: creates bracket.\n*   `Bracket()`: constructs a bracket.\n*  `highlight()`: highlights a part - should be removed from final file.\n\n**Output:**\n\n*   I need to be able to select which part I'm rendering (Hub, Spoke, or Bracket) using the dropdown `part = \"Hub\";` etc.\n\nI think that's everything.  Please let me know if you have any questions, and I'm excited to see what you can come up with!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Anything Hook",
    "scad": "width = 80;\nlength = 130;\nclamp_width = 30;\nhook_width = 50;\nthickness = 5;\nheight = 20;\ncatch = 5;\nrounding_radius = 5;\nclamp_offset = 0;\nhook_offset = 0;\nadd_catch = \"true\";\nmodule roundedRect(size, radius)\n{\n\tx = size[0];\n\ty = size[1];\n\tz = size[2];\n\tlinear_extrude(height=z)\n\thull()\n\t{\n\t\ttranslate([(-x/2)+(radius/2), (-y/2)+(radius/2), 0])\n\t\tcircle(r=radius);\n\t\ttranslate([(x/2)-(radius/2), (-y/2)+(radius/2), 0])\n\t\tcircle(r=radius);\n\t\ttranslate([(-x/2)+(radius/2), (y/2)-(radius/2), 0])\n\t\tcircle(r=radius);\n\t\ttranslate([(x/2)-(radius/2), (y/2)-(radius/2), 0])\n\t\tcircle(r=radius);\n\t}\n}\nmodule base()\n{\n\ttranslate([width/2,length/2,0])\n\troundedRect([width-rounding_radius, length, height], rounding_radius, $fn=12);\n}\nmodule clamp()\n{\n\ttranslate([-1,thickness,-2])\n\tcube([width-thickness-clamp_offset+1, clamp_width, height+4]);\n}\nmodule hook()\n{\n\ttranslate([thickness + hook_offset +1, length - hook_width - thickness,-2])\n\tcube([width-thickness+1, hook_width, height+4]);\n}\nmodule top()\n{\n\tdifference()\n\t{\n\t\tbase();\n\t\tclamp();\n\t}\n}\nmodule loop()\n{\n\ttranslate([width - catch,length-thickness,0])\n\tcylinder(h = height, r1 = catch, r2 = catch, center = false);\n}\nmodule final()\n{\n\tdifference()\n\t{\n\t\ttop();\n\t\thook();\n\t}\n}\nif(add_catch == \"true\")\n{\n\tloop();\n}\nfinal();",
    "description": "Okay, I'm looking for an OpenSCAD design for a customizable desk hook. I want it to be parametric so I can easily adjust the dimensions for different uses. Here's what I need:\n\nThe hook should have a base that clamps onto a surface (like the edge of a desk). This base should have a specified width, length, and thickness. I need to be able to adjust the width of the clamping part, as well as the offset of the clamp from the edge of the base.\n\nThen, the hook itself should extend downwards, and this part also needs to have adjustable width, thickness, and height. I also need an adjustable offset for the hook portion from the edge of the base.\n\nI would like to add a small, cylindrical \"catch\" at the very end of the hook, the diameter of which I want to be adjustable. I also need to have the ability to toggle this catch on and off, using a boolean parameter.\n\nFinally, I need rounded corners for the entire base of the hook. I would like a parameter to control the radius of the rounded corners.\n\nSo in short I need these parameters:\n*   **width:** Total width of the hook base.\n*   **length:** Total length of the hook base.\n*   **clamp_width:** Width of the surface the clamp attaches to.\n*  **hook_width:** Width of the hook itself.\n*   **thickness:** Thickness of the hook.\n*   **height:** Height of the hook.\n*   **catch:** Diameter of the cylindrical catch.\n*  **rounding_radius:** Radius of the corners of the base.\n*   **clamp_offset:**  The offset of the clamp from the edge of the base.\n*   **hook_offset:** The offset of the hook from the edge of the base.\n*   **add_catch:**  A boolean parameter that enables/disables the catch cylinder\n\nI think I've pretty much outlined the functionality of the design I need. I'd like you to generate the OpenSCAD code for this. I don't need any external libraries.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Round Clip",
    "scad": "clipNumber = 1;\nclipSpacing = 30;\nclipInnerDiameter = 20;\nclipWidth = 20;\nclipWallThickness = 2;\nclipOpeningAngle = 100;\nbracketThickness = 3;\nmountEarsLength = 20;\nmountHoleOffset = 5;\nmountHoleDiameter = 3;\n$fs = 0.25;\nmodule roundClip() {\ndifference() {\n\tcylinder(r = (clipInnerDiameter/2 + clipWallThickness), h = clipWidth);\n\ttranslate([0,0,-1]) cylinder(r = clipInnerDiameter/2, h = clipWidth + 2);\n\ttranslate([0,0,-1]) union () {\n\t\trotate([0,0,clipOpeningAngle/4-0.05]) intersection() {\n\t\t\trotate([0,0,clipOpeningAngle/4]) cube([clipInnerDiameter+clipWallThickness+1,clipInnerDiameter+clipWallThickness+1,clipWidth+2]);\n\t\t\trotate ([0,0,-clipOpeningAngle/4]) translate([-(clipInnerDiameter+clipWallThickness+1),0,0]) cube([clipInnerDiameter+clipWallThickness+1,clipInnerDiameter+clipWallThickness+1,clipWidth+2]);\n\t\t\tcylinder(r=clipInnerDiameter+clipWallThickness+1,h=clipWidth+2);\n\t\t}\n\t\trotate([0,0,-clipOpeningAngle/4+0.05]) intersection() {\n\t\t\trotate([0,0,clipOpeningAngle/4]) cube([clipInnerDiameter+clipWallThickness+1,clipInnerDiameter+clipWallThickness+1,clipWidth+2]);\n\t\t\trotate ([0,0,-clipOpeningAngle/4]) translate([-(clipInnerDiameter+clipWallThickness+1),0,0]) cube([clipInnerDiameter+clipWallThickness+1,clipInnerDiameter+clipWallThickness+1,clipWidth+2]);\n\t\t\tcylinder(r=clipInnerDiameter+clipWallThickness+1,h=clipWidth+2);\n\t\t}\n\t}\n}\nrotate([0,0,clipOpeningAngle/2]) translate([0,clipInnerDiameter/2+clipWallThickness,0]) cylinder(r = clipWallThickness, h = clipWidth);\nrotate([0,0,-clipOpeningAngle/2]) translate([0,clipInnerDiameter/2+clipWallThickness,0]) cylinder(r = clipWallThickness, h = clipWidth);\n}\ntranslate([-(clipSpacing*(clipNumber-1))/2,0,0]) for (clipPos = [0:clipNumber-1]) {\n\ttranslate([clipPos*clipSpacing,0,0]) roundClip();\n}\ncalcs_bracketLength = clipSpacing*(clipNumber-1)+mountEarsLength*2;\ndifference() {\n\ttranslate([-calcs_bracketLength/2,-clipInnerDiameter/2-bracketThickness,0]) cube([calcs_bracketLength,bracketThickness,clipWidth]);\n\ttranslate([calcs_bracketLength/2-mountHoleOffset,-clipInnerDiameter/2-bracketThickness-1,clipWidth/2]) rotate([-90,0,0]) cylinder(r = mountHoleDiameter/2, h = bracketThickness+2);\n\ttranslate([-calcs_bracketLength/2+mountHoleOffset,-clipInnerDiameter/2-bracketThickness-1,clipWidth/2]) rotate([-90,0,0]) cylinder(r = mountHoleDiameter/2, h = bracketThickness+2);\n}",
    "description": "Okay, I'd like a parametric OpenSCAD design for a round clip bracket, similar to the one described in the attached .scad file. I need to be able to customize the number of clips, their spacing, size, and how open the clips are. The bracket also needs mounting ears with holes.\n\nHere's a breakdown of the parameters I'd like to control:\n\n*   **`clipNumber`**:  The number of round clips on the bracket. I need to be able to specify a range, maybe 1 to 50.\n*   **`clipSpacing`**: The distance between the centers of each clip. I need to set this.\n*   **`clipInnerDiameter`**: The diameter of the inside face of the round clip. I'd like to specify this.\n*   **`clipWidth`**: The width (or height) of the clip. Needs to be adjustable.\n*  **`clipWallThickness`**: The thickness of the walls of the clip itself.\n*   **`clipOpeningAngle`**: The angle of the opening in the clip, basically how much of the circle is cut away to allow things to be snapped in. This should be an angle between 0 and 180 degrees.\n*   **`bracketThickness`**: The thickness of the flat mounting bracket that holds the clips together.\n*   **`mountEarsLength`**: The length of the mounting ears extending from the first and last clip centers.\n*  **`mountHoleOffset`**: How far the mounting holes are from the edges of the mounting ears.\n*   **`mountHoleDiameter`**: The diameter of the mounting holes.\n\nThe design should generate a set of round clips spaced evenly, attached to a rectangular mounting bracket. The mounting bracket should have ears that extend beyond the clips with a mounting hole in each ear.\n\nI'd like to be able to customize all these values in the OpenSCAD customizer.\n\nI'm not sure what libraries would be most efficient, but I'm open to using what you recommend if it makes it easier and more robust. I'm thinking it might be good to use something like BOSL2, but again, please suggest what's best.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Tool Holder Pliers customizable",
    "scad": "screw_holes = 3;\ntool_handle_thickness=11;\ntool_handle_inside_gape=10;\nthickness=3;\n$fn=40;\nrotate([90,45,0]){\ndifference() {\nunion() {\nhull(){\ntranslate([0,0,0])cylinder(h=thickness,r=screw_holes);\ntranslate([(tool_handle_thickness*2)+(screw_holes*1.5)+tool_handle_inside_gape,0,0])cylinder(h=thickness,r=screw_holes);\ntranslate([((tool_handle_thickness*2)+(screw_holes*1.5)+tool_handle_inside_gape)/2,-((tool_handle_thickness*2)+(screw_holes*1.5)+tool_handle_inside_gape)/2,0])cylinder(h=thickness,r=screw_holes);\n}\nhull(){\ntranslate([((tool_handle_thickness*2)+(screw_holes*1.5)+tool_handle_inside_gape)/2,-((tool_handle_thickness*2)+(screw_holes*1.5)+tool_handle_inside_gape)/2,thickness])cylinder(h=tool_handle_thickness,r=screw_holes);\ntranslate([((tool_handle_thickness*2)+(screw_holes*1.5)+tool_handle_inside_gape)/2-tool_handle_inside_gape/2,-((tool_handle_thickness*2)+(screw_holes*1.5)+tool_handle_inside_gape)/2+tool_handle_inside_gape/2,thickness])cylinder(h=tool_handle_thickness,r=screw_holes);\ntranslate([((tool_handle_thickness*2)+(screw_holes*1.5)+tool_handle_inside_gape)/2+tool_handle_inside_gape/2,-((tool_handle_thickness*2)+(screw_holes*1.5)+tool_handle_inside_gape)/2+tool_handle_inside_gape/2,thickness])cylinder(h=tool_handle_thickness,r=screw_holes);\ntranslate([((tool_handle_thickness*2)+(screw_holes*1.5)+tool_handle_inside_gape)/2,-((tool_handle_thickness*2)+(screw_holes*1.5)+tool_handle_inside_gape)/2+tool_handle_inside_gape,thickness])cylinder(h=tool_handle_thickness,r=screw_holes);\n}\nhull(){\ntranslate([screw_holes*2,-screw_holes*2,tool_handle_thickness+thickness])cylinder(h=thickness,r=screw_holes);\ntranslate([(tool_handle_thickness*2)+(screw_holes*1.5)+tool_handle_inside_gape-screw_holes*2,-screw_holes*2,tool_handle_thickness+thickness])cylinder(h=thickness,r=screw_holes);\ntranslate([((tool_handle_thickness*2)+(screw_holes*1.5)+tool_handle_inside_gape)/2,-((tool_handle_thickness*2)+(screw_holes*1.5)+tool_handle_inside_gape)/2,tool_handle_thickness+thickness])cylinder(h=thickness,r=screw_holes);\n}\n}\ntranslate([1,-.8,-1])cylinder(h=thickness+2,r1=screw_holes/2,r2=screw_holes);\ntranslate([(tool_handle_thickness*2)+(screw_holes*1.5)+tool_handle_inside_gape-1,-.8,-1])cylinder(h=thickness+2,r1=screw_holes/2,r2=screw_holes);\n}\n}",
    "description": "Okay, I'd like to design a simple tool holder, specifically for pliers. I envision a sort of skeletal structure with a few key features.\n\nThe basic shape will be like two \"arms\" connected by a middle support, forming a rough \"U\" shape when viewed from above. These arms and the support will have a cylindrical cross-section initially. However, the final shape will be formed using a hull() to create solid and smooth connections between these parts.\n\nI'd like the ability to adjust several parameters:\n\n*   **screw_holes**: This integer will determine the radius of the cylindrical parts, and is used in the design of the whole object.\n*  **tool_handle_thickness**: This will determine how thick the support structure of the \"U\" is, and will also be used to calculate some translation values.\n*  **tool_handle_inside_gape**: This will affect the \"gap\" created inside the \"U\" of the object. It will determine the distance between cylinders which make up the hull of the inner structure.\n*   **thickness**: The thickness of the base of the structure.\n\nEssentially, we will be making a 2D object extruded upwards and then with additional support structure added. The initial cylinders for the arms should be translated along the x axis, with one at x=0 and the other offset by `(tool_handle_thickness*2)+(screw_holes*1.5)+tool_handle_inside_gape` and the middle support translated to the midpoint of those two points. These three initial cylinders should be on the Z=0 plane. Then we will hull these to create the base.\n\nNext, I need the main support structure which supports the pliers to be created, which will use an additional three cylinders, this time placed at a Z-offset of `thickness`. The first cylinder will be placed at the midpoint location we calculated before, and then two further cylinders translated along the x axis, offset by `+/- tool_handle_inside_gape/2` and also offset along the y axis by `tool_handle_inside_gape/2`. A final cylinder will also be placed offset along y by `tool_handle_inside_gape`. These should all be hulled and should use `tool_handle_thickness` as the height of the cylinders.\n\nNext, we add the top structure, which is identical to the base.\n\nFinally, we need some countersunk screw holes so that the device can be easily attached to a surface. There should be two of these, both positioned along the base. They should not be part of the hull so that they can be easily edited later. These should be standard cylinders, extruded, with the radius tapering towards the top. The first screw hole will be slightly translated from the first initial cylinder, the other will be placed near the final base cylinder, with a similar offset.\n\nI'd like the design to be rotated, specifically [90, 45, 0] and I'd like `$fn` to be set to 40.\n\nCould you generate a parametric OpenSCAD file for me, that implements these features?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Playful Rings Necklace",
    "scad": "rings=7;\nmax_thick=3;\nmin_thick=.4;\ninner_max=.7;\nsidestep=12;\nwiggle_room=20;\nring_min=15;\nring_max=50;\ncircle_sizes=rands(ring_min,ring_max,rings+1);\ncircle_smalls=rands(inner_max,.9,rings+1);\ncircle_rotate=rands(.1,1,rings+1);\ncircle_thickness=rands(min_thick,1,rings+2);\ncircle_shift=rands(.5,.8,6);\nwiggle=rands(-1,1,rings+1);\nmodule circle_piece (width,height,shrink,spin,shift){\ndifference() {\n\tcylinder(r=width/2, h=height, center=true, $fn=200);\n\trotate([0,0, spin*360])\n\ttranslate([width*shift*(.9-shrink)/2, 0, 0])\n\tcylinder(r=shrink*width/2, h=height*2, center=true, $fn=200);\n}\n}\nfor (i=[1:rings]) {\n\techo (circle_thickness[i+1]);\n\techo (circle_sizes[i]);\n\ttranslate([sidestep*i,wiggle[i]*wiggle_room,-((1-circle_thickness[i+1])*max_thick)/2])\n\tcircle_piece (circle_sizes[i],max_thick*circle_thickness[i+1],circle_smalls[i],circle_rotate[i]*360,circle_shift[i]);\n}",
    "description": "Okay, I'd like to design a piece made of overlapping rings, kind of like a 3D abstract sculpture. I'm envisioning something that looks like several rings that are staggered in their placement, rotated, and different sizes, giving it a nice organic feel.\n\nHere are the parameters I'd like to be able to control:\n\n*   **Number of Rings:** I want to be able to specify the total number of rings in the piece. Let's start with a default of 7 but I need to be able to change this.\n*   **Ring Thickness:** The rings should have variable thickness, I want to set a *maximum thickness*, and then each ring's actual thickness should be a random value between a fraction (let's say 0.4) of this max thickness up to the max thickness itself.\n*   **Ring Size:** Each ring should also have a random radius. I want to be able to set a *minimum ring size* and a *maximum ring size* so that each ring will have a radius chosen randomly between these two numbers.\n*   **Inner Circle Size:** I want each ring to be \"hollowed out\" by an inner cylinder. The inner cylinder should also have a random radius, where I can set a starting *inner max radius ratio*. I want this to represent the percentage of the outer circle radius to start with for the inner cylinder. For each ring I want to make sure this inner radius ratio is a different random value, up to a number close to 1.\n*   **Ring Rotation:** Each ring should be able to rotate around its Z axis by a random degree.\n*   **Ring Placement (Sidestep):** I want each subsequent ring to be translated along the X axis by a fixed amount, to create an offset.\n*   **Ring Placement (Vertical Wiggle):** Each ring should also have a random displacement on the Y axis. This will give the rings some vertical variation.\n*   **Ring Placement (Z Offset):** I want each ring to be adjusted on the Z axis so that the the rings are sitting on a flat plane at the bottom.\n*   **Ring Shift:** I want each ring to have a different random shift of the inner ring, so it's not always centered.\n\nThe rings should be rendered as cylinders, using a high $fn value for smoothness. Also, the z-placement of the rings needs to be calculated so they all start on the z-plane. The inner circle's radius needs to be a proportion of the outer radius.\n\nCould you create a parametric OpenSCAD file for this? I would like it to be able to generate a different pattern each time you execute it. I expect it to use random number generation, so I'm expecting the results to be different each time, and I'm not expecting it to be the same as what I already have. I would like to avoid explicitly using an external library, but I expect that I may need to use standard OpenSCAD functions. I do _not_ expect you to attach external libraries.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Card Case Customizer",
    "scad": "card_count = 10;\ncard_type = 56;\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nrotate([0,0,90]) build_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\ninput =\"default_TNH\";\nimage_size = 20;\nMove_Image_Left_Right = 30;\nMove_Image_Up_Down = 40;\nimage_rotation = 0;\ntop_text_label = \"\";\ntop_text_font = \"write/orbitron.dxf\";\ntop_text_size = 14;\nMove_Top_Text_Up_Down = 60;\ntop_text_rotation = 0;\nbottom_text_label = \"\";\nbottom_text_font = \"write/orbitron.dxf\";\nbottom_text_size = 14;\nMove_Bottom_Text_Up_Down = 10;\nbottom_text_rotation = 0;\nuse <write/Write.scad>\nuse <MCAD/triangles.scad>\nuse <utils/build_plate.scad>\nstencil_thickness = 1.5;\noffX = 0;\noffY = 0;\nmargin = 10;\ndispo_width = image_size;\npoints_array = (input==\"default_TNH\"? [[133,286],[[234.27,6.02],[231.55,7.45],[227.5,10.88],[222.85,15.67],[218.69,20.35],[214.95,25.17],[211.32,30.24],[208.44,34.98],[206.52,39],[205.31,48.23],[204.14,65.5],[202.43,96.43],[199.95,138.5],[197.65,174.91],[196.37,192.25],[195.44,195.38],[192.95,196],[190.58,196.5],[189.09,197.84],[188.55,199.75],[188.65,201.77],[188.28,204.15],[185.74,207.18],[181.17,210.7],[175.06,214.5],[168.61,218.79],[163.29,223.5],[159.05,228.64],[155.24,233.98],[152.19,239.17],[149.77,243.98],[148.11,250.02],[146.97,258.66],[145.84,267.33],[144.06,272.66],[141.97,276.16],[139.87,279.16],[138.4,281.78],[138.36,284.3],[139.83,286.58],[143.12,288.43],[150.09,289.9],[162.38,291.02],[181.28,291.67],[205.5,291.95],[229.79,291.67],[248.86,291],[261.56,289.87],[267.86,288.28],[270.76,286.27],[271.82,283.7],[271.26,280.36],[268.97,275.96],[266.18,270.14],[264.49,261.76],[263.22,253.76],[262.03,247.53],[260.34,242.46],[257.87,237.27],[254.58,232.07],[250.91,227.01],[246.01,222],[239.74,216.91],[233.89,213.03],[230,210.88],[227.72,209.34],[225.75,206.9],[224.51,204.05],[224,201.5],[223.82,199.39],[223.39,197.58],[222.07,196.41],[219.45,196],[216.94,195.74],[215.57,195.11],[215.61,179.54],[216.5,143.36],[217.84,100.02],[218.98,67.24],[219.99,41.97],[223.5,34.86],[227.01,28.44],[230.51,22.99],[232.97,19.44],[234,17.58],[234.64,16.25],[236.17,13.98],[237.73,11.12],[237.19,8.52],[235.86,6.75],[234.27,6.02]],[[212.84,76.5],[212.5,59.5],[211.74,69.5],[210.48,90.08],[208.53,125.5],[206.63,159.58],[205.5,176.93],[204.81,181.12],[203.95,183.56],[203.18,185.98],[202.73,190.13],[202.5,195.5],[206.22,195.81],[209.36,195.65],[210.42,193.81],[211.09,177.78],[212.04,142.5],[212.75,102.9],[212.84,76.5]],[[206,209],[195.82,209.28],[191.5,210],[194.92,210.74],[206,211],[217.08,210.74],[220.5,210],[216.18,209.28],[206,209]],[[205.86,215.72],[183.79,215.5],[178.37,218.41],[172.58,222.55],[166.23,228.5],[160.29,235.76],[156.27,243.19],[153.68,250.66],[151.96,258.09],[150.89,264.79],[149.83,270.5],[148.37,275.16],[146.32,279.34],[144.69,282.17],[144.25,283.58],[147.3,284.15],[154.07,284.97],[173.01,285.68],[205.29,285.98],[237.8,285.68],[256.79,284.92],[263.77,284.03],[266.92,283.42],[266.23,281.75],[264,278.35],[260.66,273.7],[259.87,264.1],[259.05,256.44],[258.15,251.5],[256.85,248.06],[255.05,244],[252.96,239.81],[250.98,236.07],[248.08,232.07],[243.79,227.28],[238.5,222.61],[233.21,218.93],[227.93,215.94],[205.86,215.72]],[[156.85,278.42],[154.78,278.35],[153.53,278.95],[153.45,279.83],[154.19,280.46],[157.32,281.08],[163,281.96],[173.19,282.99],[187.17,283.97],[203.88,284.41],[220.67,283.98],[234.91,283.01],[245.5,281.96],[251.42,280.91],[254.43,279.94],[254.97,279.17],[254.93,278.6],[251.4,278.77],[243.5,279.76],[228.64,280.99],[205,281.42],[182.42,281.13],[168.5,280.22],[161.36,279.17],[156.85,278.42]]]: input);\ninput_width = points_array[0][0];\ninput_height= points_array[0][1];\nsTrace = dispo_width/input_width;\nstencil_height = input_height*sTrace + 2*margin;\nmodule box_lid() {\n\tdifference(){\n\t\tcube([card_type + 4,4 + card_count,22]);\n\t\ttranslate([1,1,16]) cube([card_type + 2,2 + card_count,22]);\n\t\ttranslate([2,2,2]) cube([card_type,card_count,22]);\n\t}\n}\nmodule box() {\n\ttranslate([4 + card_type,25 + card_count*3,0]) {\n\trotate([0,0,180]){\n\tunion(){\n\t\ttranslate([0,-10 + card_count,0]){\n\t\t\tdifference() {\n\t\t\t\ttranslate([0,20,0]) cube([card_type + 4,4 + card_count,78]);\n\t\t\t\tscale(1.001) translate([card_type + 3.99,19.975,94.2]) rotate([0,180,0]) box_lid();\n\t\t\t\ttranslate([2,22,2]) cube([card_type,card_count,78]);\n\t\t\t\ttranslate([card_type/2-5,25,1]) #write(\"TNH\",h=5,t=.5,font=\"write/orbitron.dxf\");\n\t\t\t}\n\t\t}\n\ttranslate([card_type/2 + 2,9.8 + card_count,Move_Top_Text_Up_Down]) rotate([90,top_text_rotation,0]) write(top_text_label,h=top_text_size,t=1.5, font=top_text_font, center=true);\n\ttranslate([card_type/2 + 2,9.8 + card_count,Move_Bottom_Text_Up_Down]) rotate([90,bottom_text_rotation,0]) write(bottom_text_label,h=bottom_text_size,t=1.5, font=bottom_text_font, center=true);\n\ttranslate([Move_Image_Left_Right,9.8 + card_count+2,Move_Image_Up_Down]) rotate([90,image_rotation,0]) pattern();\n\t}\n}\n}\n}\nmodule pattern(){\n\tunion(){\n\t\ttranslate([0, 0, stencil_thickness/2])\n\t\ttranslate([offX, offY, -stencil_thickness/2])\n\t\tscale([sTrace, -sTrace, 1])\n\t\ttranslate([-200, -150, 0]) {\n\t\t\tunion() {\n\t\t\t\tfor (i = [1:len(points_array) -1] ) {\n\t\t\t\t\tlinear_extrude(height=stencil_thickness*2) {polygon(points_array[i]);}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nrotate([0,0,180]){\n\t\ttranslate([-card_type/2,-card_count-7,0]){\n\t\t\tbox();\n\t\t\tscale([1.02,1.02,1.02]) box_lid();\n\t}\n}",
    "description": "Okay, so I've got this card case I really like, and I want to make it customizable.  I've seen some cool things people are doing with OpenSCAD and the Customizer, and I think that'd be perfect.  I'd like to be able to change a bunch of parameters:\n\nFirst, I need to be able to select how many cards the case should hold.  I'd like to have options in the Customizer like \"10:25 Cards,\" \"20:50 Cards,\" \"30:75 Cards,\" all the way up to maybe \"100:250 Cards\" (increments of 10 cards in the Customizer, representing 25 card steps).  \n\nNext, there should be a setting to choose what kind of cards will be stored in the case.  I want an option for \"Business Cards\" and another one for \"Playing/Collectable Cards\". It looks like in the original, they're using 56 for business cards and 71.1 for playing cards, so you can keep those dimensions I guess.\n\nIt would be nice if there was an option for selecting build plate size - though that doesn't need to affect the dimensions of the case itself. It's mostly for display purposes. Maybe options like \"Replicator 2/2X\", \"Replicator\", \"Thingomatic\" as presets and then also a manual option where I can specify the X and Y build plate dimensions for my specific printer.\n\nThe next big thing I want is the ability to add a custom image.  I know that's kind of tricky, but I saw some people using this \"Stencil-o-Matic\" thing for that, so it should be possible. I need to be able to paste the stencil code into a field in the Customizer.  There should also be parameters for the size, position (left/right and up/down), and rotation of the image.  Maybe size can range from 1 to 50, position adjustments of -50 to 50 for left/right, up/down from 10 to 50, and rotation from 0 to 359.\n\nLastly, I also want to add some custom text, top and bottom.  There should be fields for the text itself, the font (using fonts compatible with the Customizer), text size (1-40), vertical position (10-65), and rotation (0, 90, 180, or 270 degrees).\n\nSo, to recap:\n*   Card Count selection\n*   Card Type selection\n*   Build plate display presets & manual input\n*   Stencil-o-Matic Image input, size, position, rotation\n*   Top Text input, font selection, text size, position, rotation\n*   Bottom Text input, font selection, text size, position, rotation\n\nI think that's everything. The design should use the `write/Write.scad` (for the text), `MCAD/triangles.scad` (for polygon shapes in the image), and `utils/build_plate.scad` libraries. I'm pretty sure that's the right setup for all this. Let me know if you need any more info, but hopefully that's a good starting point!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Loop",
    "scad": "finger_radius = 13;\nring_girth = 5;\nring_width = 18;\nskin_thickness = 1;\nlobes = false;\nprimary_lobe_diameter = 9;\nsecondary_lobe_diameter = 12;\nlobe_length = 5;\ncut=\"none\";\npcb_length=27;\npcb_width=16;\ntop_spacing_for_pcb=1;\npcb_support_strut_count= 4;\ndifference() {\n\t\tcolor(\"deepskyblue\")\n\t\tring(\n\t\t\tfinger=finger_radius,\n\t\t\tgirth=ring_girth,\n\t\t\twidth=ring_width,\n\t\t\tblock=true,\n\t\t\tsingle=lobes,\n\t\t\tthickness=skin_thickness,\n\t\t\tlobe=primary_lobe_diameter,\n\t\t\tlobe2=secondary_lobe_diameter,\n\t\t\tangle=120,\n\t\t\tlobelen=lobe_length,\n\t\t\tcols=pcb_support_strut_count,\n\t\t\tpcbheight=top_spacing_for_pcb,\n\t\t\tpcblen=pcb_length,\n\t\t\tpcbwidth=pcb_width);\n\t\tif(cut==\"side\") {\n\t\t\ttranslate([-ring_width, 0, 0]) cube(size=[ring_width, (finger_radius+ring_girth+lobe_length+primary_lobe_diameter+secondary_lobe_diameter)*2, (finger_radius+ring_girth+lobe_length+primary_lobe_diameter+secondary_lobe_diameter)*2], center=true);\n\t\t}\n\t\tif(cut==\"thru\") {\n\t\t\ttranslate([-ring_width*5/4, 0, 0]) cube(size=[ring_width, (finger_radius+ring_girth+lobe_length+primary_lobe_diameter+secondary_lobe_diameter)*2, (finger_radius+ring_girth+lobe_length+primary_lobe_diameter+secondary_lobe_diameter)*2], center=true);\n\t\t\ttranslate([ring_width*1/4, 0, 0]) cube(size=[ring_width, (finger_radius+ring_girth+lobe_length+primary_lobe_diameter+secondary_lobe_diameter)*2, (finger_radius+ring_girth+lobe_length+primary_lobe_diameter+secondary_lobe_diameter)*2], center=true);\n\t\t}\n}\nmodule ring(\n\tfinger=13,\n\tgirth=5,\n\twidth=18,\n\tlobe=13,\n\tlobe2=13,\n\tlobelen=10,\n\tthickness=2,\n\tblock=true,\n\tsingle=false,\n\tangle=90,\n\tstruts=true,\n\tcols=3,\n\tcolwidth=2,\n\tspacing=1,\n\trows=3,\n\tpcblen=20,\n\tpcbwidth=16,\n\tpcbheight=1,\n)\n{\n\ttranslate([-(width/2), 0, 0])\n\t{\n\t\tdifference()\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\trotate([0, 90, 0])\n\t\t\t\tcylinder(h=width, r1=finger+girth, r2=finger+girth, center=true, $fn=100);\n\t\t\t\tif(block)\n\t\t\t\t{\n\t\t\t\t\tif(single)\n\t\t\t\t\t{\n\t\t\t\t\t\ttranslate([0, (finger+girth)/2, (finger+girth)/2])\n\t\t\t\t\t\tcube([width, finger+girth, (finger+girth)], center=true);\n\t\t\t\t\t\tlip(lobelen=lobelen, lobe=lobe, finger=finger, girth=girth, width=width, center=true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttranslate([0, (finger+girth)/2, (finger+girth)/2])\n\t\t\t\t\t\tcube([width, finger+girth, (finger+girth)], center=true);\n\t\t\t\t\t\tlip(lobelen=lobelen, lobe=lobe, finger=finger, girth=girth, width=width, center=true);\n\t\t\t\t\t\trotate([(90-angle),0,0])\n\t\t\t\t\t\ttranslate([0, (finger+girth)/2, -(finger+girth)/2])\n\t\t\t\t\t\tcube([width, finger+girth, (finger+girth)], center=true);\n\t\t\t\t\t\trotate([-angle,0,0])\n\t\t\t\t\t\tlip(lobelen=lobelen, lobe=lobe2, finger=finger, girth=girth, width=width, center=true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([0, 0, 0])\n\t\t\trotate([0, 90, 0])\n\t\t\tcylinder(h=2*width, r1=finger, r2=finger, center=true, $fn=100);\n\t\t\tdifference()\n\t\t\t{\n\t\t\t\tunion()\n\t\t\t\t{\n\t\t\t\t\tif(lobe-(2*thickness)>=thickness || lobelen > lobe/3) {\n\t\t\t\t\t\tdifference()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tunion()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(single) {\n\t\t\t\t\t\t\t\t\tif(block)\n\t\t\t\t\t\t\t\t\t\tinnerlip(lobelen=lobelen, lobe=lobe, finger=finger, girth=girth, width=width, center=center, thickness=thickness, struts=struts, cols=cols, colwidth=colwidth, pcbheight=pcbheight, rows=rows, block=block);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif(block)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tinnerlip(lobelen=lobelen, lobe=lobe, finger=finger, girth=girth, width=width, center=center, thickness=thickness, struts=struts, cols=cols, colwidth=colwidth, pcbheight=pcbheight, rows=rows);\n\t\t\t\t\t\t\t\t\t\trotate([-angle, 0, 0])\n\t\t\t\t\t\t\t\t\t\tinnerlip(lobelen=lobelen, lobe=lobe2, finger=finger, girth=girth, width=width, center=center, thickness=thickness, struts=struts, cols=cols, colwidth=colwidth, pcbheight=pcbheight, rows=rows);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trotate([0, 90, 0])\n\t\t\t\t\t\t\t\tcylinder(h=width-thickness, r1=(finger+girth)-thickness, r2=(finger+girth)-thickness, center=true, $fn=100);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(block) {\n\t\t\t\t\t\t\t\tif(struts) {\n\t\t\t\t\t\t\t\t\tif(single) {\n\t\t\t\t\t\t\t\t\t\tinnerlipstruts(lobelen=lobelen, lobe=lobe, finger=finger, girth=girth, width=width, thickness=thickness, struts=struts, cols=cols, colwidth=colwidth, pcbheight=pcbheight, pcblen=pcblen, pcbwidth=pcbwidth, rows=rows, spacing=spacing);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tinnerlipstruts(lobelen=lobelen, lobe=lobe, finger=finger, girth=girth, width=width, thickness=thickness, struts=struts, cols=cols, colwidth=colwidth, pcbheight=pcbheight, pcblen=pcblen, pcbwidth=pcbwidth, rows=rows, spacing=spacing);\n\t\t\t\t\t\t\t\t\t\trotate([-angle, 0, 0])\n\t\t\t\t\t\t\t\t\t\tinnerlipstruts(lobelen=lobelen, lobe=lobe2, finger=finger, girth=girth, width=width, thickness=thickness, struts=struts, cols=cols, colwidth=colwidth, pcbheight=pcbheight, pcblen=pcblen, pcbwidth=pcbwidth, rows=rows, spacing=spacing);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trotate([0, 90, 0])\n\t\t\t\t\t\tcylinder(h=width-thickness, r1=(finger+girth)-thickness, r2=(finger+girth)-thickness, center=true, $fn=100);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trotate([0, 90, 0])\n\t\t\t\tcylinder(h=width, r1=finger+thickness, r2=finger+thickness, center=true, $fn=100);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule lip(lobelen, lobe, finger, girth, width, center)\n{\n\tunion() {\n\t\tif(lobelen > lobe/2)\n\t\t{\n\t\t\ttranslate([0, finger+girth+(lobelen/2), finger+girth-(lobe/2)])\n\t\t\tcube([width, lobelen, lobe], center=true);\n\t\t\ttranslate([0, finger+girth+lobelen, finger+girth-(lobe/2)])\n\t\t\trotate([0, 90, 0])\n\t\t\tcylinder(h=width, r1=lobe/2, r2=lobe/2, center=true, $fn=100);\n\t\t} else {\n\t\t\ttranslate([0, finger+girth+lobe/4, finger+girth-lobe/2])\n\t\t\tcube([width, lobe/2, lobe], center=true);\n\t\t\ttranslate([0, finger+girth+lobe/2, finger+girth-(lobe/2)])\n\t\t\trotate([0, 90, 0])\n\t\t\tcylinder(h=width, r1=lobe/2, r2=lobe/2, center=true, $fn=100);\n\t\t}\n\t\tif(lobe<=finger+girth)\n\t\t{\n\t\t\tdifference() {\n\t\t\t\ttranslate([0, finger+girth, finger+girth-lobe])\n\t\t\t\tcube([width, lobe, lobe], center=true);\n\t\t\t\ttranslate([0, finger+girth+lobe/2, finger+girth-3*(lobe/2)])\n\t\t\t\trotate([0, 90, 0])\n\t\t\t\tcylinder(h=width*2, r1=lobe/2, r2=lobe/2, center=true, $fn=100);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule innerlip(lobelen, lobe, finger, girth, width, center, thickness, cols, colwidth, pcbheight, rows, struts)\n{\n  difference() {\n\t  union()\n\t\t{\n\t\t\ttranslate([0,((finger+girth-thickness)/2),((finger+girth-thickness)/2)])\n\t\t\tcube(size=[width-2*thickness,finger+girth-thickness,(finger+girth-thickness)], center=true);\n\t\t\ttranslate([0,finger+girth,finger+girth-(lobe/2)])\n\t\t\tcube(size=[width-2*thickness, lobelen+lobe/2, lobe-2*thickness], center=true);\n\t\t\ttranslate([0,finger+girth+(lobe/2),finger+girth-(lobe/2)])\n\t\t\trotate([0, 90, 0])\n\t\t\tcylinder(h=width-(2*thickness), r1=(lobe/2)-(thickness), r2=(lobe/2)-(thickness), center=true, $fn=100);\n\t\t}\n\t}\n}\nmodule innerlipstruts(lobelen, lobe, finger, girth, width, center, thickness, cols, colwidth, pcbheight, rows, spacing=1, pcblen=20, pcbwidth=16)\n{\n\tif(pcblen > finger+girth+lobelen+lobe/3){echo(\"PCB may be too long!\");}\n\tif(pcbwidth > width-2*thickness){echo(\"PCB may be too wide!\");}\n\ttranslate([0,lobe/3,0])\n\tif(struts)\n\t{\n\t\techo(str(\"strut col span equals \", (finger+girth+lobelen)));\n\t\tif(cols>=2) {\n\t\t\tfor(i = [0 : cols-1]) {\n\t\t\t\ttranslate([\n\t\t\t\t\t(pcbwidth/2),\n\t\t\t\t\t(finger+girth-thickness+lobelen)-(i*pcblen/(cols-1)),\n\t\t\t\t\tfinger+girth-(lobe/3)\n\t\t\t\t])\n\t\t\t\tunion() {\n\t\t\t\t\tdifference() {\n\t\t\t\t\t\tcube(size=[colwidth, colwidth, lobe*2/3-2*thickness+1], center=true);\n\t\t\t\t\t\tif(i==cols-1) {\n\t\t\t\t\t\t\ttranslate([0,0+(1+colwidth/2),((lobe*2/3)-(1*thickness))/2-pcbheight-spacing])\n\t\t\t\t\t\t\tcube(size=[colwidth+2, colwidth+2, pcbheight], center=true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\tif(i==0) {\n\t\t\t\t\t\t\ttranslate([0,0-(1+colwidth/2),((lobe*2/3)-(1*thickness))/2-pcbheight-spacing])\n\t\t\t\t\t\t\tcube(size=[colwidth+2, colwidth+2, pcbheight], center=true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttranslate([0,0,((lobe*2/3)-(1*thickness))/2-pcbheight-spacing])\n\t\t\t\t\t\t\tcube(size=[colwidth+2, colwidth+2, pcbheight], center=true);\n\t\t\t\t\t\t}}\n\t\t\t\t\t}\n\t\t\t\t\ttranslate([colwidth,0,0])\n\t\t\t\t\tcube(size=[colwidth, colwidth, lobe*2/3-2*thickness+1], center=true);\n\t\t\t\t}\n\t\t\t\tif(i == 0 || i == cols-1) {\n\t\t\t\t\ttranslate([0,(finger+girth-thickness+lobelen)-1+1/2-(i*pcblen/(cols-1)),finger+girth-(lobe/3)])\n\t\t\t\t\tdifference() {\n\t\t\t\t\t\tcube(size=[colwidth, colwidth, lobe*2/3-2*thickness+1], center=true);\n\t\t\t\t\t\ttranslate([0,0,((lobe*2/3)-(1*thickness))/2-pcbheight-spacing])\n\t\t\t\t\t\tcube(size=[colwidth+2, colwidth+2, pcbheight], center=true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "description": "Okay, I have this idea for a smart ring, and I've got a basic design in OpenSCAD, but it's a bit rigid and I need to make it parametric and much more flexible. I'd like your help to build a new, more powerful design.\n\nHere's the basic idea: It's a ring with space inside to house some electronics, specifically a small PCB. The current design allows for either a single lobe or a double lobe on the outer part of the ring, and I'd like to keep that. The inside needs to have supports for the PCB.\n\nHere are the key parameters I need to control in the design:\n\n*   **Finger Radius:** This is the inner radius of the ring, where it fits on the finger. I'd like to be able to set this value.\n*   **Ring Girth:** This is the thickness of the ring itself, how far it extends away from the finger.\n*   **Ring Width:** The width of the ring along the finger.\n*   **Skin Thickness:** The thickness of the outer shell of the ring.\n*   **Lobe Type:** A boolean to switch between single or double lobed design.\n*   **Primary Lobe Diameter:** The diameter of the main lobe.\n*   **Secondary Lobe Diameter:** The diameter of the second lobe (if double lobe is chosen).\n*   **Lobe Length:** The length of the lobes extending away from the ring body.\n*   **PCB Length:** Length of the circuit board located within the primary lobe\n*  **PCB Width:** Width of the circuit board located within the primary lobe\n*   **PCB Top Spacing:** The spacing between the outer skin of the ring and the top of the circuit board.\n*  **PCB Support Strut Count**: The number of support struts for the circuit board.\n\nAnd here are some features I would like to add and make parametric:\n*   **Strut Width:** The width of the struts that will support the PCB within the ring.\n*   **Strut Rows:** The amount of support strut aligned through the width of the ring per col.\n*   **Secondary Lobe Angle:** The angle of the secondary lobe in the double lobe version.\n*   **Seam:** The current design is a single piece, but I need the ability to generate a seam so the ring can open to place components within it. This should be configurable and I'd like the type of seam cut to be a parameter. I should be able to chose to have a cut on one side or all the way through with 2 cuts.\n*  **Strut Spacing**: The space between the top of a strut and the PCB.\n\nI'd like to be able to control all these parameters in the OpenSCAD file. Also, please make sure that you use the `rotate_extrude()` function to create the ring body. This helps with parametric changes and makes the design more robust.\n\nAdditionally, the design needs to allow for the internal electronics to be a rectangular block, so the interior space needs to be designed around that.\n\nI'm also thinking of using the `BOSL2` library, as I find its syntax really neat and it provides useful functions for a design like this. I'd like it if you use `BOSL2` for any relevant tasks in the design, especially for any boolean operations.\n\nIn summary, I need a fully parametric smart ring design that incorporates all the parameters and features described above using `BOSL2`, and I'm hoping it can be opened to insert a PCB. Could you please generate the OpenSCAD code?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Dollar coin wallet holder (parametric)",
    "scad": "coin_d\t=\t26.4 + 1;\ncoin_r\t=\tcoin_d / 2;\ncoin_h\t=\t2;\nbuffer\t=\t0.75;\ncard_w\t=\t(3 * coin_d) + (5 * buffer);\ncard_l\t=\t(2 * coin_d) + (3 * buffer);\ncard_h\t=\tcoin_h;\ndifference() {\n\tcube([card_w, card_l, card_h]);\n\ttranslate([coin_r+buffer, coin_r+buffer, -1]){\n\t\tcylinder(r1=coin_r-0.1, r2=coin_r+0.05, h=4);\n\t}\n\ttranslate([coin_r+buffer, card_l-coin_r-buffer, -1]){\n\t\tcylinder(r1=coin_r-0.1, r2=coin_r+0.05, h=4);\n\t}\n\ttranslate([card_w/2, coin_r+buffer, -1]){\n\t\tcylinder(r1=coin_r-0.1, r2=coin_r+0.05, h=4);\n\t}\n\ttranslate([card_w/2, card_l-coin_r-buffer, -1]){\n\t\tcylinder(r1=coin_r-0.1, r2=coin_r+0.05, h=4);\n\t}\n\ttranslate([card_w-coin_r-buffer, coin_r+buffer, -1]){\n\t\tcylinder(r1=coin_r-0.1, r2=coin_r+0.05, h=4);\n\t}\n\ttranslate([card_w-coin_r-buffer, card_l-coin_r-buffer, -1]){\n\t\tcylinder(r1=coin_r-0.1, r2=coin_r+0.05, h=4);\n\t}\n}",
    "description": "Okay, I'd like to design a coin holder that's flat and fits in a wallet, similar to a credit card. I need it to be able to hold multiple US dollar coins, but the design should be easily modified to hold other coin types as well by changing the coin dimensions in the OpenSCAD file.\n\nHeres what Im thinking:\n\nThe basic shape should be a flat rectangular card with circular cutouts for the coins. I want the cutouts to be tapered - wider at the top and narrower at the bottom - so the coins slide in easily from the top and dont fall out the bottom. I also want a slight gap around the coin to make it easy to put them in and take them out.\n\nFor a starting point, I need it to hold six dollar coins arranged in a 3x2 grid. Im using US dollar coins as a starting point. I know these are about 26.5mm in diameter and 2mm thick, so please use these dimensions, including a little extra space so the coins dont fit too tightly.\n\nThe holder itself will be a rectangular card whose dimensions will be determined by the coin arrangement, diameters, and gaps between the coins, so please make these things parameterized. I want to be able to adjust the overall length, width, and height of the holder as well as the size and position of each coin cutout. \n\nI'd like to control the following parameters specifically:\n\n*   `coin_d`: Diameter of the coin (initially 26.5mm, but will likely need an extra 1mm or so space)\n*   `coin_h`: Height of the coin (initially 2mm)\n*   `buffer`: Extra space around each coin (initially perhaps 0.75mm)\n*   `rows`: Number of rows of coins (initially 2)\n*   `cols`: Number of columns of coins (initially 3)\n\nThe cutouts should be created by a difference operation between the card and a cylinder. The cylinder needs to be tapered, and slightly bigger than the coin to start so that they slide in easily, but smaller at the bottom, so the coins stay put once they are fully inserted. This should use the variables above.\n\nCould you please provide me with the OpenSCAD file for this design? I would like to be able to easily change these parameters to experiment with different layouts and coin sizes. It would be great if it would use simple and direct methods and not need any external libraries.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Nexus Galaxy Pogo Pin Charging Dock - Pins",
    "scad": "pinDia=8.2;\npinHt=20;\nthreadDia=3.2;\nthreadLength=13;\nnutDia=6.7;\nnutHeight=2.9;\narrayX=3;\narrayY=3;\nmodule draw_pin (nutDia,nutHeight)\n{\n  pinRad=pinDia/2;\n      difference(){\n        union() {\n          translate([0,0,pinHt-pinRad]) sphere(r=pinRad,$fn=20);\n          cylinder(r=pinRad,h=(pinHt-pinRad), $fn=20);\n         }\n         translate([0,0,-5])cylinder(h=threadLength+5,r=threadDia/2,$fn=20);\n         translate([0,0,-1/nutHeight])cylinder(h=nutHeight, r=nutDia/2,$fn=6);\n      }\n      difference(){\n        translate([0,0,0])cylinder(h=nutHeight, r=nutDia/3, $fn=6);\n        translate([0,0,-2])cylinder(h=nutHeight+4, r=(nutDia/3)-0.2, $fn=6);\n      }\n}\nmodule drawArray()\n{\n  for (i=[0:arrayX-1]){\n    for(j=[0:arrayY-1]){\n      translate([i*(pinDia+3),j*(pinDia+3),0])draw_pin(nutDia,nutHeight);\n    }\n  }\n}\ndrawArray(6.8,3.2);",
    "description": "Okay, I'm working on a charging dock project, and I need to create some 3D printable pins, similar to the ones I saw on Thingiverse (http://www.thingiverse.com/thing:63756). I've already got a basic OpenSCAD file (NG_pins_V2.2.scad) that does most of what I want, but it's not as flexible as I need it to be, and I'd like it to be better structured and more parametric.\n\nHere's a breakdown of what I need:\n\n**Overall Design:**\n\nI need to create a pin with a cylindrical peg on top, a threaded hole running up through it, and a recessed hexagonal area at the base to hold a nut.  The pins should be arranged in a rectangular array.\n\n**Parameters I Need Control Over:**\n\n*   **Pin Diameter:** The diameter of the cylindrical peg part of the pin. (Currently `pinDia`)\n*   **Pin Height:** The overall height of the cylindrical peg portion of the pin. (Currently `pinHt`)\n*   **Thread Diameter:** The diameter of the hole that will be threaded. (Currently `threadDia`)\n*   **Thread Length:** The length of the threaded hole from the bottom of the pin. (Currently `threadLength`)\n*   **Nut Diameter:** The diameter of the hexagonal nut across the corners. (Currently `nutDia`)\n*   **Nut Height:** The height/thickness of the nut. (Currently `nutHeight`)\n*   **Array X:** The number of pins in the X direction. (Currently `arrayX`)\n*   **Array Y:** The number of pins in the Y direction. (Currently `arrayY`)\n*   **Pin Spacing:** I need control over the spacing between pins in both the X and Y direction (currently fixed at `pinDia+3`). I'd prefer individual parameters for spacing along the X axis and along the Y axis (e.g. `spacingX` and `spacingY`).\n*   **Nut Clearance:** I need to control the gap between the nut and the recessed hexagonal area in the pin. It's currently a fixed offset `0.2`, but I need this to be a configurable parameter. I'd prefer to be able to set this directly (e.g., `nutClearance`).\n\n**Specific Requirements:**\n\n*   The pin should be a single module that can be easily instanced.\n*   The pin array should be created by a separate module using a nested loop.\n*   The modules should be well-defined and easy to understand.\n*   I'd like to be able to individually define the \"bolt hole\" size separately from the \"tapping size\", so I need another parameter: `boltClearance` that specifies the size of the hole before tapping\n*   I'd also like a parameter `nutBaseHeight` so that I can adjust the height from the bottom of the pin that the nut recess sits\n\n**Desired Output:**\n\nI would like the output to be a well-commented OpenSCAD file. I'm comfortable with using basic OpenSCAD features. I do not need any complex mathematical functions or use of external libraries, so please use standard OpenSCAD functions only.\n\nCan you create an OpenSCAD file based on these specifications?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Stacking Container",
    "scad": "use <utils/build_plate.scad>\nuse <write/Write.scad>\n_insideDiameter = 18;\n_interiorHeight = 12;\n_rounding = 8;\n_overhangAngle = 45;\n_minimumWallThickness = 1.0;\n_bottomThickness = 0.8;\n_lipHeight = 2.4;\n_bayonetDepth = 0.6;\n_partGap = 0.12;\n_labelText = \"\";\n_labelFont = \"write/orbitron.dxf\";\n_labelHeight = 8;\n_labelDepth = -0.3;\n_labelRotation = 0;\nbuild_plate(0);\nmake();\nmodule make($fn=90) {\n\ttwistAngle = 60;\n\tbayonetAngle = 30;\n\tnumberOfSides  = 3;\n\toutsideDiameter = _insideDiameter + 2*(_minimumWallThickness*2 + _partGap + _bayonetDepth);\n\tseparatorHeight = _interiorHeight + _bottomThickness;\n\tmakePart(outsideDiameter, separatorHeight, numberOfSides, _rounding, _overhangAngle,\n\t\t\t\t\t\t_minimumWallThickness, _bottomThickness,\n\t\t\t\t\t\t_lipHeight, _bayonetDepth, bayonetAngle, _partGap,\n\t\t\t\t\t\ttwistAngle,\n\t\t\t\t\t\t_labelText, _labelFont, _labelHeight, _labelDepth, _labelRotation);\n}\nmodule makePart(diameter, height, sides, rounding, overhang, wall, base, lipHeight, bayonetDepth, bayonetAngle, partGap, twistAngle, label, lfont, lheight, ldepth, lrotation) {\n\theight = max(height, base+lipHeight);\n\tradius = diameter/2;\n\tinnerRadius = radius - wall*2 - bayonetDepth - partGap;\n\tmiddleRadius = radius - wall - bayonetDepth;\n\twallThickness = radius - innerRadius;\n\tfullHeight = height + lipHeight;\n\ttopBayonetAngle = bayonetAngle+3;\n\tchamfer = bayonetDepth;\n\tbayonetHeight = (lipHeight-chamfer)/2;\n\tangledCutDistance = (innerRadius+wall)*1.5;\n\tangledCutHeight = angledCutDistance * tan(overhang);\n\teps = 0.1;\n\tdifference() {\n\t\tunion() {\n\t\t\tdifference() {\n\t\t\t\tunion() {\n\t\t\t\t\tcylinder(r=innerRadius+wall, h=fullHeight);\n\t\t\t\t\ttranslate([0,0,lipHeight]) {\n\t\t\t\t\t\tpolyCylinder(sides, radius, height + angledCutHeight, rounding);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trotate_extrude(convexity = 4) {\n\t\t\t\t\tpolygon(points = [ [innerRadius+wall, lipHeight],\n\t\t\t\t\t\t\t\t\t\t\t [2*angledCutDistance, lipHeight-eps],\n\t\t\t\t\t\t\t\t\t\t\t [2*angledCutDistance,  lipHeight + angledCutHeight] ],\n\t\t\t\t\t\t\t\t\t\t\t paths = [[0,1,2]], convexity = 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\trotate([0,0,-45]) {\n\t\t\t\tthread(innerRadius+wall-eps, innerRadius+wall+bayonetDepth,\n\t\t\t\t\t\tbayonetAngle, bayonetHeight, bayonetHeight/2, 0,\n\t\t\t\t\t\tchamfer, innerRadius, innerRadius+wall);\n\t\t\t}\n\t\t\tif (ldepth > 0) {\n\t\t\t\tlabel(label, lfont, lheight, ldepth, -diameter/2, lipHeight + height/2 + (wall + bayonetDepth)*tan(overhang), lrotation);\n\t\t\t}\n\t\t}\n\t\tif (ldepth < 0) {\n\t\t\tlabel(label, lfont, lheight, ldepth, -diameter/2, lipHeight + height/2 + (wall + bayonetDepth)*tan(overhang), lrotation);\n\t\t}\n\t\ttranslate([0,0,base]) {\n\t\t\tcylinder(r=innerRadius, h=fullHeight + angledCutHeight);\n\t\t}\n\t\thull() {\n\t\t\ttranslate([0,0,lipHeight+max(wall,base)]) {\n\t\t\t\tcylinder(r=innerRadius, h=fullHeight + angledCutHeight);\n\t\t\t}\n\t\t\ttranslate([0,0,height]) {\n\t\t\t\tcylinder(r=middleRadius, h=fullHeight + angledCutHeight);\n\t\t\t}\n\t\t}\n\t\ttranslate([0,0,fullHeight-lipHeight-partGap]) {\n\t\t\tcylinder(r=middleRadius, h=lipHeight+partGap+eps);\n\t\t}\n\t\trotate([0,0,45]) {\n\t\t\tthread(middleRadius-eps, middleRadius+bayonetDepth,\n\t\t\t\t\ttopBayonetAngle, lipHeight*2, fullHeight, twistAngle + topBayonetAngle);\n\t\t\tthread(middleRadius-eps, middleRadius+bayonetDepth,\n\t\t\t\t\ttopBayonetAngle+twistAngle, bayonetHeight + eps,\n\t\t\t\t\tfullHeight - lipHeight + bayonetHeight/2 + eps/2,\n\t\t\t\t\ttwistAngle + topBayonetAngle,\n\t\t\t\t\tchamfer, middleRadius-eps, middleRadius);\n\t\t}\n\t\trotate_extrude(convexity = 4) {\n\t\t\tpolygon(points = [ [innerRadius+wall, fullHeight],\n\t\t\t\t\t\t\t\t [innerRadius+wall, fullHeight + angledCutHeight + eps],\n\t\t\t\t\t\t\t\t [2*angledCutDistance, fullHeight + angledCutHeight] ],\n\t\t\t\t\t\t\t \tpaths = [[0,1,2]], convexity = 2);\n\t\t}\n\t}\n}\nmodule label(text, font, height, depth, y, z, rotate) {\n\teps = 0.1;\n\tif (text != \"\") {\n\t\tfor (r = [0:120:360]) {\n\t\t\trotate([0,0,r])\n\t\t\ttranslate([0,depth > 0 ? y - depth/2 + eps/2: y - depth/2 - eps/2,z])\n\t\t\trotate([90,rotate,0])\n\t\t\twrite(str(text), t=abs(depth)+eps, h=height, font=font, space=1.1, center=true);\n\t\t}\n\t}\n}\nmodule thread(r1, r2, angle, height, yoffset, rotation, chamfer=0, r3=0, r4=0) {\n\tfor(a=[0,120,240])\n\trotate([0,0,a + rotation])\n\ttranslate([0,0,yoffset]) {\n\t\thull() {\n\t\t\tsmallArc(r1, r2, angle, height);\n\t\t\tif (chamfer != 0) {\n\t\t\t\ttranslate([0,0,chamfer]) {\n\t\t\t\t\tsmallArc(r3, r4, angle, height);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule smallArc(radius0, radius1, angle, depth) {\n\tthickness = radius1 - radius0;\n\teps = 0.01;\n\tunion() {\n\t\tdifference() {\n\t\t\tcylinder(r=radius1, h=depth, center=true);\n\t\t\tcylinder(r=radius0, h=depth+2*eps, center=true);\n\t\t\tfor(z=[0, 180 - angle]) {\n\t\t\t\trotate([0,0,z])\n\t\t\t\ttranslate([-radius1,0,0])\n\t\t\t\tcube(size = [radius1*2, radius1*2, depth+eps], center=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule polyCylinder(sides, radius, height, rounding) {\n\tangle = 360/sides;\n\thull() {\n\t\tfor (a=[0:angle:360])\n\t\trotate([0,0,a])\n\t\ttranslate([0,(radius - rounding)/cos(angle/2),0]) {\n\t\t\tcylinder(r=rounding, h=height);\n\t\t}\n\t}\n}",
    "description": "Okay, I'd like a parametric OpenSCAD design for a stacking container, similar to a pill box, but with some key customizations. I want to be able to define the overall dimensions and the locking mechanism parameters.\n\nHere's what I'm thinking:\n\n**General Container Parameters:**\n\n*   **`insideDiameter`**:  The minimum interior diameter of the container. I want to be able to set this in millimeters.\n*   **`interiorHeight`**: The height of the interior space of each container segment, in millimeters. I need each segment to be individually configurable for height.\n*   **`rounding`**: The radius of the rounding on the edges of the container.\n*   **`overhangAngle`**: The angle of the overhang of the container walls.  This will affect whether support material is needed for printing.\n*   **`minimumWallThickness`**:  The minimum thickness of the container walls.\n*   **`bottomThickness`**: The thickness of the bottom of each container segment.\n*   **`lipHeight`**: The height of the lip that provides the connection between segments.\n*   **`bayonetDepth`**: The depth that the bayonet locking mechanism protrudes.\n*   **`partGap`**: The gap between the interlocking parts to adjust how tightly they fit.\n* **`numberOfSides`**: The number of sides for the container. This should allow for not only cylindrical but also triangular/hexagonal/etc containers.\n\n**Locking Mechanism Parameters:**\n\n*   The locking mechanism should be a twist-lock bayonet type.\n*   **`twistAngle`**: The amount of rotation needed to lock/unlock the pieces.\n*   **`bayonetAngle`**: The angular size of each bayonet locking tab.\n* I need the locking mechanism to work such that you can remove the bottom segment and attach it to the top to add additional segments.\n* The user should be able to configure both how far the bayonets stick out and how wide they are.\n*The user should be able to configure the shape of the containers as well as a basic cylinder.\n\n**Label Parameters:**\n\n*   **`labelText`**:  A string for the text to be rendered on each side of each segment. I want to be able to specify a different text string for each segment.\n*   **`labelFont`**: The font used to render the text labels. I'd like to be able to choose a font from a library, like those included in the 'write/Write.scad' library.\n*   **`labelHeight`**:  The height of the text label.\n*   **`labelDepth`**: The depth of the text label.  Positive values should extrude the text, negative should emboss it.\n*   **`labelRotation`**: The rotation angle of the text label.\n\n**Stacking Functionality:**\n\n*   The container should be made of multiple stackable segments.\n*   Each segment should be able to be a different height.\n*   The bottom segment should be able to be attached to the top so that segments can be moved from bottom to top of the stack as needed.\n\n**Output:**\n\n*   The final output should be a single OpenSCAD file.\n*   I will need to use libraries from `utils/build_plate.scad` and `write/Write.scad`. I should not be required to paste in the contents of the libraries as a part of my prompt, and those files should not be part of the response.\n\nCan you provide the OpenSCAD code that implements these features?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable wrench improved...or at least changed",
    "scad": "include <MCAD/shapes.scad>\ninclude <write/Write.scad>\nmessage = \"13mm\";\nFont = \"write/Letters.dxf\";\nNut_Size = 13;\nTool_Height = Nut_Size/2;\nTool_Length = 10;\nDualExtrusion = \"Extruder1\";\nToolOptions = 2;\nkerf = 0.3;\nD = Nut_Size + kerf;\nM = D/4;\nH = Tool_Height;\nLtot = D * Tool_Length;\nText_Height = Nut_Size*0.7 ;\nL = Ltot-2*(D/2+M);\nrotate([0, 0, -45]){\nif (DualExtrusion == \"Extruder1\"){\ndifference() {\n\tunion() {\nif(ToolOptions > 1){\ttranslate([0,L/2,H/2]) rcylinder(r1 = (D*0.85),r2 = (D*0.85), h = H,center = true,b=Nut_Size*0.1);\n\t\t}\n\t\tif(ToolOptions < 3){translate([0,-L/2,H/2]) rcylinder(r1 = (D*1.1),r2 = (D*1.1), h = H,center = true,b=Nut_Size*0.1);}\n\t\ttranslate([0,0,H/2]) rcube([D*1,L,H],b=Nut_Size*0.1);\n\t}\n\tif(ToolOptions < 3){translate([0,-L/2 - D / 4,H/2 - 0.5]) rotate([0,0,30]) hexagon(D, H + 2);}\n\ttranslate([0,-L/2 - D - D / 4,H/2 - 0.5]) {\n\t\tcube([D,2*D,H + 2], center = true);\n\t}\n\tif(ToolOptions > 1){ translate([0,L/2,H/2 - 0.5]) rotate([0,0,30]) hexagon(D, H + 2);\n\t}\n\ttranslate([0, 0, H - .4]){\n\t\trotate([0,0,90]) WriteText();\n\t}\n}\n}\nif (DualExtrusion == \"Extruder2\"){\n\ttranslate([0, 0, H - .4]){\n\t\trotate([0,0,90]) WriteText();}\n}\n}\nmodule WriteText() {minkowski(){cube([0.1,0.1,0.1]);\n\t\twrite(message,t=.5,h=Text_Height,center=true,font=Font);}}\nmodule rcube(Size=[20,20,20],b=1)\n{hull(){for(x=[-(Size[0]/2-b),(Size[0]/2-b)]){for(y=[-(Size[1]/2-b),(Size[1]/2-b)]){for(z=[-(Size[2]/2-b),(Size[2]/2-b)]){ translate([x,y,z]) sphere(b);}}}}}\nmodule rcylinder(r1=10,r2=10,h=10,b=1)\n{translate([0,0,-h/2]) hull(){rotate_extrude() translate([r1-b,b,0]) circle(r = b); rotate_extrude() translate([r2-b, h-b, 0]) circle(r = b);}}",
    "description": "Okay, I'm looking to create a customizable wrench in OpenSCAD, and I'd like it to have some specific features and flexibility. I've seen some designs online, but I want to refine and combine some of the best ideas.\n\nHere's what I'm aiming for:\n\n**Core Functionality:**\n\n*   **Parametric Nut Size:** The wrench should be designed around a specified nut size (in millimeters). This value should drive the dimensions of the wrench opening.\n*   **Automatic Tool Thickness:** The wrench's thickness (height) should be automatically determined based on the nut size, probably something like half the nut size.\n*   **Adjustable Length:** I want a parameter to control the overall length of the wrench, but it should also be somewhat related to the nut size. It'd be great if I could adjust it by a multiplier.\n*   **Open and Closed Ends:** The wrench should have both an open-end and a closed-end, and I want the option to choose: only open end, only closed end or both. \n*   **Text Engraving:**  I need to be able to engrave text on the wrench, specifically the nut size it fits. I'd like the font to be configurable using dxf files, and for the text height to scale with the nut size.\n*   **Dual Extrusion Support:** It needs to support dual extrusion, so that I can print the main body in one color and the text in another if I want to.\n\n**Detailed Design Requests:**\n\n*   **Open End Geometry:** The open-end of the wrench should have a typical jaw shape with an angled entry. The opening should be sized appropriately for the specified nut size, and have rounded edges.\n*   **Closed End Geometry:** The closed-end should be a hexagonal shape sized to fit the nut. This hexagon should also have rounded edges.\n*   **Rounded Edges:** All the edges of the wrench should be rounded, to give it a more refined look.\n*  **Printer Margin:** There should be a parameter to adjust the printer margin, to account for variation in print tolerances on different machines.\n\n**Parameters:**\n\nI want these parameters to be easily adjustable:\n\n*   `Nut_Size`:  (Integer, in millimeters) - The size of the nut the wrench is designed for.\n*   `Tool_Length`: (Integer) - A multiplier that determines overall length based on nut size.\n*   `ToolOptions`: (Integer: 1, 2, or 3) - 1 = Open End Only, 2 = Both Sides, 3 = Closed End Only\n*   `Font`: (String, filename of DXF file) - The font file to use for text engraving.\n*   `DualExtrusion`: (String, \"Extruder1\" or \"Extruder2\") - Which extruder to use for the text.\n*   `kerf`: (Float, in mm) - The margin for printing tolerances\n*  `message`: (String) the message printed on the wrench (ideally the Nut_Size value as a string)\n\n**Libraries:**\nI am expecting that you'll use the `MCAD/shapes.scad` library for basic shapes, and the `write/Write.scad` library for text. I don't expect you to include these files, but I am mentioning them for clarity.\n\nCould you generate the OpenSCAD code to fulfill these requests? I'm looking for a parametric design that I can easily adjust.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Can Stacking Plate",
    "scad": "DiameterOfCan = 75;\n\tHeightOfStacker = 20;\n\tInnerSpacing = 1 * 1;\n\tThicknessOfCylinder = DiameterOfCan/7;\n\tThicknessOfPlate = 2 * 1;\n\tHeightOfPlate = ( HeightOfStacker - ThicknessOfPlate)/2 ;\n\ttranslate([0,HeightOfStacker/2,(DiameterOfCan + InnerSpacing+ThicknessOfCylinder)/2.165 ])\n\trotate([90,45/2,0])\n\tdifference() {\n\t\tcylinder( h=HeightOfStacker, r=(DiameterOfCan + InnerSpacing + ThicknessOfCylinder)/2, $fa = 45);\n \t\tcylinder( h=HeightOfStacker, r=(DiameterOfCan + InnerSpacing)/2, $fs = 1 );\n\t}\n\ttranslate([0,HeightOfStacker/2,(DiameterOfCan + InnerSpacing+ ThicknessOfCylinder)/2.16 ])\n\trotate([90,45/2,0])\n\ttranslate([0,0,HeightOfPlate ])\n\tdifference() {\n\t\tcylinder( h=ThicknessOfPlate, r=(DiameterOfCan + InnerSpacing)/2, $fs = 1);\n\t\tcylinder( h=ThicknessOfPlate, r=(DiameterOfCan + InnerSpacing)/2.2, $fs = 30);\n\t}",
    "description": "Okay, I'm looking for an OpenSCAD design to help me stack cans in my pantry. I've got a bunch of cans that don't have that little indented lip at the bottom, so they're always toppling over. I've made a basic version of this already, but I'd really like something more flexible and user-friendly.\n\nBasically, I need a disc-shaped platform with a raised edge to hold the bottom can and a flat top surface for the next can to sit on. Here's what I'm thinking about for parameters:\n\n*   **Can Diameter:** This should be a variable so I can adjust the platform to fit different sized cans. I'd like to be able to specify this as a single diameter value, and the design should automatically calculate the overall size.\n*   **Stacker Height:**  I need to be able to adjust the overall height of the stacker plate.\n*   **Inner Spacing:** The amount of space between the can and the inner wall of the stacking plate; this is related to the wall thickness. I need to be able to adjust this parameter.\n*   **Wall Thickness:** The thickness of the outer wall that keeps the can from sliding off. I'd like to specify this as a parameter rather than have it calculated.\n*   **Plate Thickness:** The thickness of the supporting plate itself. I'd also like to be able to specify this directly.\n*   **Plate Height:** This is where the flat surface of the plate will be, and it'll also determine the distance between the edge of the container, and the flat surface of the plate.\n\nIt would be great if the design could handle a small amount of overhang by using a gradual angle on the outer walls. I was using a 45-degree angle in my current design, but it's not really necessary to specify this angle. What matters most is the final height and the size of the inner lip.\n\nI'd like the design to be efficient to print, so keeping the inner support simple is important; it doesn't need to be a complex lattice or anything. I was just using a single cylinder for my support structure.\n\nI need the generated file to be well-commented, and make it easy to adjust the dimensions for different cans. I'm thinking I may need to vary the inner spacing and height to fit cans of different sizes.\n\nI'm not using any special libraries, just vanilla OpenSCAD should be fine for this design.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customisable Mini Storage Drawers",
    "scad": "half_row = 1;\nnormal_row = 1;\ndouble_row = 1;\nquad_row = 1;\ngrid();\nmodule grid (){\nrotate(a=[270,0,0]){\n\tif (half_row > 0) {\n\t\tfor (row = [1:half_row]) {\n\t\t\tfor (col = [1 : 4]) {\n\t\t\t\ttranslate(v = [col*30, 0, row*13.5]) {\n\t\t\t\t\t\thalf_box();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (normal_row > 0) {\n\t\tfor (row = [1:normal_row]) {\n\t\t\tfor (col = [1 : 4]) {\n\t\t\t\ttranslate(v = [col*30, 0, row*27+(half_row*13.5-6.75)]) {\n\t\t\t\t\t\tbox();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (double_row > 0) {\n\t\tfor (row = [1:double_row]) {\n\t\t\tfor (col = [1 : 2]) {\n\t\t\t\ttranslate(v = [col*60-15 , 0, row*27+(half_row*13.5-6.75)+(normal_row*27)]) {\n\t\t\t\t\t\tdouble_box();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (quad_row > 0) {\n\t\tfor (row = [1:quad_row]) {\n\t\t\ttranslate(v = [75 , 0, row*27+(half_row*13.5-6.75)+(normal_row*27)+(double_row*27)]) {\n\t\t\t\t\tquad_box();\n\t\t\t}\n\t\t}\n\t}\n}\n}\nmodule half_box(){\n\tdifference() {\n\t\tcube(size = [31,68,14.5], center = true);\n\t\tcube(size = [29,70,12.5], center = true);\n\t}\n\ttranslate(v = [0,33.5,0]) {\n\t\tcube(size = [31,1,3], center=true);\n\t}\n}\nmodule box(){\n\tdifference() {\n\t\tcube(size = [31,68,28], center = true);\n\t\tcube(size = [29,70,26], center = true);\n\t}\n\ttranslate(v = [0,33.5,0]) {\n\t\tcube(size = [31,1,6], center=true);\n\t}\n}\nmodule double_box(){\n\tdifference() {\n\t\tcube(size = [61,68,28], center = true);\n\t\tcube(size = [59,70,26], center = true);\n\t}\n\ttranslate(v = [0,33.5,0]) {\n\t\tcube(size = [61,1,6], center=true);\n\t}\n}\nmodule quad_box(){\n\tdifference() {\n\t\tcube(size = [121,68,28], center = true);\n\t\tcube(size = [119,70,26], center = true);\n\t}\n\ttranslate(v = [0,33.5,0]) {\n\t\tcube(size = [121,1,6], center=true);\n\t}\n}",
    "description": "Okay, so I've got this storage rack system I'm working on, and I'd like to make it more flexible and parametric. Right now, it's a bit rigid.\n\nHere's what I have: I've got a rack that can hold four different types of storage bins: half-height bins, standard height bins, double-width bins, and quad-width bins. The current SCAD code defines how many rows of each type there are, but the number of columns is fixed. I'd like to change this.\n\nHere are the current bin sizes (external, approximately):\n*   Half Bin: 30 x 14 x 68\n*   Bin: 30 x 28 x 68\n*   Double Bin: 60 x 28 x 68\n*   Quad Bin: 120 x 28 x 68\n\nThe current system uses a grid-based approach to position the bins.\n\nHere's what I'd like the parametric design to achieve:\n*   **Adjustable Columns:**  I need to be able to specify the number of *columns* for each type of bin. Currently, there are always 4 columns for half-height and standard bins, 2 columns for double bins and 1 for quad bins and this is set in the for loops. I need to be able to change this.\n*   **Adjustable Rows:** I want to keep being able to set the number of rows for each bin type as I have in my current file, so `half_row`, `normal_row`, `double_row`, and `quad_row`.\n*   **Overall Rack Width:** I'd like to be able to specify an overall rack width. This would ideally determine the column numbers for the various bin types.\n*   **Adjustable Bin Spacing:** I'd like to have a parameter to control spacing between bins and also have a parameter to control the width of each wall between bins. I'd also like to have these parameters for the bottom and sides of the bins for the surrounding frame.\n\nIdeally the code will use the following parameters:\n\n*   `half_row` - Number of rows of half-height bins\n*   `normal_row` - Number of rows of standard height bins\n*   `double_row` - Number of rows of double-width bins\n*   `quad_row` - Number of rows of quad-width bins\n*   `rack_width` - Desired width of the entire rack\n*    `bin_spacing` - Spacing between bins.\n*   `wall_width` - Width of bin walls.\n*   `frame_spacing_x` - Side frame gap\n*   `frame_spacing_z` - bottom frame gap\n\nMy current code uses simple `cube()` commands with some `translate()` and `difference()` operations and doesn't really use any libraries beyond what is included in the basic OpenSCAD installation. I'm happy to keep it like this if it's easier, though I'm comfortable with libraries if they make the code cleaner (like the MCAD library). I have no preference between using BOSL and MCAD, either would be fine. \n\nCould you generate an OpenSCAD file that meets these requirements?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Overhang Test Print",
    "scad": "$width=10;\n$depth=5;\n$innerRadius=30;\n$startAngle=35;\n$baseRadius=8;\n$block1=$innerRadius+$depth+1;\n$block2=$block1*2;\nrotate([-90,0,0])\n difference()\n {\n  translate([0,$innerRadius*sin($startAngle),0])\n  rotate_extrude(convexity=6,$fn=150)\n   translate([$innerRadius,0,0])\n    square([$depth,$width]);\n  translate([-$block1,0,-1])\n   cube([$block2,$block2,$width+2]);\n  translate([0,-$block1,-1])\n   cube([$block1,$block2,$width+2]);\n }\ntranslate([-($innerRadius*cos($startAngle)+$depth/2),\n             $width/2,0])\n  cylinder(h=$baseHeight,r=$baseRadius);",
    "description": "Okay, I'm looking to create a test piece for evaluating 3D printer overhang performance, and I'd like it to be parametric. I've got a starting point in mind, but I want to make it much more flexible.\n\nThe core idea is a hollow, angled, partial torus section attached to a cylindrical base. The torus section is formed by extruding a rectangle along an arc. Here are the key parameters I want to control:\n\n*   **`innerRadius`**:  The radius of the inner edge of the torus.\n*   **`depth`**: The thickness of the torus section (the radial dimension of the rectangle that's extruded).\n*   **`width`**: The height of the rectangular cross-section of the torus.\n*   **`startAngle`**:  The angle in degrees that defines the starting position of the torus section. This will determine how much of a curve is actually created.\n*   **`baseRadius`**: The radius of the cylindrical base.\n*    **`baseHeight`**: The height of the cylindrical base.\n\nThe part needs to be hollow, meaning that after the extrusion, I cut away a large part of the initial torus section. For now, I'm essentially removing everything but the overhanging section, but this should be adjustable in the future.\n\nHere are the important features that should be implemented in the code:\n\n1.  **Parametric Torus Section:** The main body of the model should be generated using a `rotate_extrude` operation on a rectangular `square`.  The rectangle should be properly positioned such that the resulting part represents a section of a torus.\n2.  **Hollowed Body:**  Use `difference` to remove material from the torus section, keeping only the intended overhang.\n3.  **Parametric Base:** Add a cylindrical base to support the overhanging section.  The base needs to be correctly positioned below the start of the torus.\n4.  **Modularity & Comments:** The code should be well-commented to explain what each section of the code does. The parameters should be defined at the top of the file, which makes it easy to modify.\n\nI'd like the code to be clean and easy to modify. I'd also like to use BOSL2 for its `linear_extrude_along` and other functions, so I don't have to figure out all of the math myself. If possible I'd prefer to do the same operation on the cylindrical base with an operation that is less hardcoded with respect to the position in the base. I'd also like you to keep track of the intermediate parts of the object during construction in order to make future debugging easier. \n\nCould you generate a parametric OpenSCAD file that fulfills these requirements?\n"
  },
  {
    "object": "Hey cadmonkey, make me a circular PCB holder for drill",
    "scad": "radpp = 15;\nradholepp = 1;\nthickshell = 0.8;\nradius = radpp + thickshell;\nsidetria = 17;\nradtriacircum = sidetria/sqrt(3);\npart = \"base\";\nlipheight = 2;\ndrill_holder = \"yes\";\ndrill_height = 20;\ndrill_size = 6;\nuse <MCAD/regular_shapes.scad>\nmodule lip()\n{\nintersection()\n  {\n   translate([-1.5*radius, -1.5 *radius, 0])\n           cube(size=[radius * 3, radius * 3, lipheight]);\n   difference(){sphere(radius-thickshell); sphere(radius-2*thickshell);}\n   }\n}\nmodule pin()\n{union(){\n  translate([radtriacircum,0,lipheight-0.4])cylinder(r1=4, r2=4, h=0.4);\n  translate([radtriacircum, 0 , -sqrt(radius*radius-radtriacircum*radtriacircum)])\n    cylinder(r1=3*radholepp, r2=3*radholepp, h=sqrt(radius*radius-radtriacircum*radtriacircum)+lipheight-2-4, $fn=10);\n  translate([radtriacircum, 0 , -5])\n    cylinder(r1=3*radholepp, r2=radholepp, h=5, $fn=10);\n  translate([radtriacircum, 0 , -1])\n    cylinder(r1=radholepp, r2=radholepp, h=lipheight+1, $fn=10);\n  }\n}\nmodule holder()\n{\nunion()\n  {\n  lip();\n  intersection()\n    {\n    translate([-1.5*radius, -1.5 *radius, -2*radius])\n              cube(size=[radius * 3, radius * 3, 2*radius]);\n\t difference(){sphere(radius); sphere(radius-2*thickshell);}\n    }\n  pin();\n  rotate([0,0,120]) pin();\n  rotate([0,0,-120]) pin();\n  if (drill_holder == \"yes\") {\n    translate([0,0,-radius+2*thickshell]) mirror([0,0,-1]) cylinder(r=drill_size/2, h=drill_height, $fn=10);\n    }\n  }\n}\nmodule holderheadbase()\n{\n    intersection()\n    {\n    translate([-1.5*radius, -1.5 *radius, 0])\n      cube(size=[radius * 3, radius * 3, 2*radius]);\n\t difference(){sphere(radius); sphere(radius-thickshell);}\n    }\n}\nmodule holderhead()\n{\n  difference()\n  {holderheadbase();\n   linear_extrude(height=2*radius) hexagon(2);\n   rotate([45,0,0])cylinder(r=2, h=2*radius, $fn=10);\n   rotate([45,0,60])cylinder(r=2, h=2*radius, $fn=10);\n   rotate([45,0,120])cylinder(r=2, h=2*radius, $fn=10);\n   rotate([45,0,180])cylinder(r=2, h=2*radius, $fn=10);\n   rotate([45,0,240])cylinder(r=2, h=2*radius, $fn=10);\n   rotate([45,0,300])cylinder(r=2, h=2*radius, $fn=10);\n  }\n}\nif (part==\"base\")\n{\n  mirror([0,0,1])holder();\n}\nif (part == \"top_1\")\n{\n  holderhead();\n}",
    "description": "Okay, I need a custom PCB holder designed in OpenSCAD. I have a circular PCB with three mounting holes arranged in an equilateral triangle pattern. I've previously used a design (attached, printplateholder_v05.scad), but I need more control over the parameters.\n\nHere's what I need:\n\n**General Shape:**\n\n*   The holder should be a two-part design: a base and a top piece that fits over the PCB. The base will have three pins that fit into the PCB's mounting holes, and a lip around the edge. The top piece will have a lip that interfaces with the base's lip, essentially clamping the PCB in place.\n*   The base and top should each be a shell, forming a hollow dome, with lip on the perimeter. The top should be a more rounded shell while the bottom is flatter, with mounting features.\n\n**Key Parameters:**\n\n*   **`radpp` (Print Plate Radius):** This is the radius of the circular PCB. (currently 15 mm)\n*   **`radholepp` (Hole Radius):** The radius of the mounting holes in the PCB. (currently 1 mm)\n*   **`thickshell` (Shell Thickness):** The thickness of the shell for both the base and top piece and also the lip. (currently 0.8 mm)\n*   **`sidetria` (Triangle Side Length):** The side length of the equilateral triangle formed by the PCB mounting holes. (currently 17 mm)\n*   **`lipheight`:** The height of the lip on both the base and top pieces that lock them together. (currently 2 mm)\n*   **`drill_holder` (Drill Holder):** A boolean option (yes/no) to include a drill bit holder centered on the base, a cylinder that could hold a small drill bit. (currently \"yes\")\n*  **`drill_height` (Drill Holder Height):**  The height of the drill bit holder cylinder, should `drill_holder` be set to \"yes\". (currently 20 mm)\n* **`drill_size` (Drill Bit Diameter):** The diameter of the drill bit the drill holder should be sized for, should `drill_holder` be set to \"yes\". (currently 6 mm)\n\n**Additional Requirements:**\n\n*   The design should use the `MCAD/regular_shapes.scad` library for its hexagon function.\n*   The pins on the base should be centered on the mounting holes, should have 3 separate sections: one that fits into the hole itself, one that guides the pin to the hole and a final section before the lip, with the three sections each having a distinct radius.\n*   The top piece should have features removed to clear the pins on the base and create a form-fitting top piece. I'd like it to have hexagonally cutouts and round cutouts.\n\n**What I need from the OpenSCAD file:**\n\n*   A single OpenSCAD file that defines a module for the base (named something like `base_holder`) and a module for the top (named something like `top_holder`).\n*   All the parameters listed above as variables, each clearly commented so I understand what they do.\n*   Clear usage of the `MCAD/regular_shapes.scad` library where appropriate.\n*   The design should be parametric, so if I change the `radpp`, `radholepp`, etc. parameters, the model adjusts accordingly.\n*   I'd like both the base and top to be oriented with their flat surfaces at z=0.\n\nCan you generate the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable NFC Keyfob",
    "scad": "CavityDiameter=39;\nPart=0;\nShape=0;\nLidThickness=0.8;\nCavityThickness=0.6;\nBottomThickness=0.8;\nSideWidth=2;\nLidSupportWidth=0.7;\nRingOutsideDiameter=8.5;\nRingHoleDiameter=4.5;\nTolerance=0.15;\nRoundingRadius=3;\nOutsideRadius=CavityDiameter/2+SideWidth;\nCavityRadius=CavityDiameter/2;\nRingHoleRadius=RingHoleDiameter/2;\nRingOutsideRadius=RingOutsideDiameter/2;\nTotalThickness=LidThickness+CavityThickness+BottomThickness;\nRingThickness=RingOutsideRadius-RingHoleRadius;\nmodule RoundedBox (X,Y,Z,R)\n{\n\tintersection()\n   {\n\t   minkowski()\n\t\t{\n\t\t cube([X-2*R,Y-2*R,Z],center=true);\n\t\t cylinder(r=R,h=Z,$fn=16,center=true);\n\t\t}\n\t\tcube([2*X,2*Y,Z],center=true);\n\t}\n}\nif (Shape==0)\n{\n\tif (Part==0)\n\t{\n\t\tdifference()\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tcylinder(r=OutsideRadius,h=TotalThickness,center=true,$fn=50);\n\t\t\t\ttranslate([OutsideRadius+RingOutsideRadius-SideWidth,0,0])\n\t\t\t\t\tcylinder(r=RingOutsideRadius,h=TotalThickness,center=true,$fn=20);\n\t\t\t\ttranslate([OutsideRadius-SideWidth,0,0])\n\t\t\t\t\tcube(size=[2*RingOutsideRadius,2*RingOutsideRadius,TotalThickness],center=true);\n\t\t\t}\n\t\t\ttranslate([OutsideRadius+RingOutsideRadius-SideWidth,0,0])\n\t\t\t\tcylinder(r=RingHoleRadius,h=2*TotalThickness,center=true,$fn=20);\n\t\t\ttranslate([0,0,BottomThickness])\n\t\t\t\tcylinder(r=CavityRadius,h=TotalThickness,center=true,$fn=50);\n\t\t\ttranslate([0,0,BottomThickness+CavityThickness])\n\t\t\t\tcylinder(r=CavityRadius+LidSupportWidth,h=TotalThickness,center=true,$fn=50);\n\t\t}\n\t}\n\telse\n\t{\n\t\tcylinder(r=CavityRadius+LidSupportWidth-Tolerance, h=LidThickness);\n\t}\n}\nelse\n{\n\tif (Part==0)\n\t{\n\t\tdifference()\n\t\t{\n\t\t\tunion()\n\t\t\t{\n\t\t\t\tRoundedBox (2*OutsideRadius,2*OutsideRadius,TotalThickness,RoundingRadius);\n\t\t\t\ttranslate([OutsideRadius+RingOutsideRadius-SideWidth,0,0])\n\t\t\t\t\tcylinder(r=RingOutsideRadius,h=TotalThickness,center=true,$fn=20);\n\t\t\t\ttranslate([OutsideRadius-SideWidth,0,0])\n\t\t\t\t\tcube(size=[2*RingOutsideRadius,2*RingOutsideRadius,TotalThickness],center=true);\n\t\t\t}\n\t\t\ttranslate([OutsideRadius+RingOutsideRadius-SideWidth,0,0])\n\t\t\t\tcylinder(r=RingHoleRadius,h=2*TotalThickness,center=true,$fn=20);\n\t\t\ttranslate([0,0,BottomThickness])\n\t\t\t\tRoundedBox(2*CavityRadius,2*CavityRadius,TotalThickness,RoundingRadius);\n\t\t\ttranslate([0,0,BottomThickness+CavityThickness])\n\t\t\t\tRoundedBox(2*(CavityRadius+LidSupportWidth),2*(CavityRadius+LidSupportWidth),TotalThickness,RoundingRadius);\n\t\t}\n\t}\n\telse\n\t{\n\t\tRoundedBox(2*(CavityRadius+LidSupportWidth-Tolerance),2*(CavityRadius+LidSupportWidth-Tolerance),LidThickness,RoundingRadius);\n\t}\n}",
    "description": "Okay, I'm looking to design a parametric NFC keyfob that I can 3D print. I've got an existing design in OpenSCAD (attached: NFCkey-param7.scad) that I've been working with, but I need a more flexible and well-structured version.\n\nThe current design allows for a circular or square fob, and has a cavity to hold an NFC sticker, plus a lid. The main parameters to customize are:\n\n*   **CavityDiameter**: The diameter of the cavity where the NFC sticker sits.\n*   **Part**: An integer, 0 for the case/base, 1 for the lid.\n*   **Shape**: An integer, 0 for circular, 1 for square.\n*   **LidThickness**: Thickness of the lid.\n*   **CavityThickness**: Thickness of the cavity (the depth into the base where the sticker fits).\n*   **BottomThickness**: Thickness of the base below the cavity.\n*   **SideWidth**: Width of the material around the perimeter of the case/base.\n*   **LidSupportWidth**: The extra width added to the lid where it sits on the base\n*   **RingOutsideDiameter**: The outer diameter of the ring for attaching to a keyring.\n*   **RingHoleDiameter**: The diameter of the hole in the ring.\n*   **Tolerance**: The tolerance between the lid and the cavity, to allow the lid to fit.\n*   **RoundingRadius**: Only relevant for square fobs, the radius of the rounded corners.\n\nThe existing code calculates some additional values automatically, like `OutsideRadius`, `CavityRadius`, `RingHoleRadius`, `RingOutsideRadius`, `TotalThickness`, and `RingThickness`.  I'd like those calculations to remain in place.\n\nHere's what I'd like the new design to be capable of:\n\n1.  **Maintain the circular and square options** just like the existing code.\n2.  **Use modules more effectively** for clarity and reusability. The provided `RoundedBox` module is a good start.  I'd like to see things like the ring and it's connection handled with their own modules.\n3.  **Improve the parameter handling.** I'd like to use named variables more directly in the module definitions. For example, if I set  `CavityDiameter` I want that directly used to generate the cavity. I think the existing code sets up the variables, but then uses things like `CavityRadius` which isn't as clear.\n4.  **Make the scad files more modular.**  I'd like a main file that instantiates the case or lid, and a module file that includes all of the core functionality for the ring, cavity, etc... So that if I later want to make a different kind of NFC fob case, I have a solid library I can build on.\n5.  **Use libraries when appropriate**. I've used a few of the BOSL libraries for other projects. If they offer functionality that would help, then that would be great!\n6.  **Include comments**.  Well-commented code is a must!\n7.  **Consider a separate file for parameter definitions.** That might make it easier to manage if I decide to add more.\n\nSo, could you generate the improved parametric OpenSCAD files for me? I'm really hoping to get a more organized structure and make good use of modules, named parameters, and any helpful libraries.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Rosette",
    "scad": "HoleDiameter=24;\nNumberOfSidesForHole=6;\nNumberOfLeaves=12;\nLeafLength=20;\nLeafWidth=15;\nLeafThickness=3;\nLeafPointyness=4;\nHalfOrFull=\"Full\";\n$fn=15;\ndifference(){\nunion(){\ntranslate([0,0,-0.1]) cylinder(r1=28,r2=0,h=17,$fn=12);\ntranslate([0,0,15]) for(i=[1:NumberOfLeaves]){\nrotate([0,27,i*360/NumberOfLeaves])\nintersection(){\nscale([LeafLength,LeafWidth,LeafThickness]) translate([1,-LeafPointyness/10,0])sphere(1);\nscale([LeafLength,LeafWidth,LeafThickness]) translate([1,LeafPointyness/10,0])sphere(1);\n}\n}\n}\ntranslate([0,0,-100]) cube(200,center=true);\nif(HalfOrFull==\"Half\"){\ntranslate([0,-50,0]) cube(100,center=true);}\ntranslate([0,0,-1]) cylinder(r=HoleDiameter/2/cos(180/NumberOfSidesForHole),h=70,$fn=NumberOfSidesForHole);\ntranslate([0,0,-0.1]) cylinder(r1=12/(0.5*sqrt(3))+9,r2=HoleDiameter/2/sin(60),h=9,$fn=NumberOfSidesForHole);\n}",
    "description": "Okay, I'd like to design a rosette for pipes, something that's more visually appealing than what I can find in stores. I've already started experimenting in OpenSCAD, and I have some of the core ideas down, but I'd like to make it more flexible and robust with a design that includes more options, and perhaps a cleaner implementation.\n\nHere's what I'm thinking:\n\nThe rosette should have a central hole that can be customized. Currently I'm using a cylinder with a variable number of sides, but I want a simpler solution that can handle both circular and polygon shapes, specified by side count. I need this to accommodate not just round pipes, but also hexagonal nuts (and potentially square or other polygons) using the flat-to-flat measurement of the polygon. My current code uses a bit of trigonometry to convert the radius to a distance, but I would prefer if I could just specify a *flat-to-flat diameter*.\n\nThe main body of the rosette should consist of a number of leaf-like extensions. I like the visual effect of the overlapping spheres I have used but would like to try an alternative option. Instead of using scaled spheres for the leaf like objects, I would like to use an offset curve for the leaf shape using `offset(r = <curve radius>)` on an underlying polygon. I need parameters for:\n *   The number of leaves (3 or more)\n *   The overall length of each leaf\n *   The width of each leaf at its widest point\n *   The thickness of the leaves.\n *   How \"pointy\" or rounded the tips of the leaves are. This could potentially use a `linear_extrude(height=...)` on some form of spline or bezier curve to have a more flexible tip. \n\nThe base of the rosette is essentially a cylinder with a flat top (the leaves) and a conical lower portion that gives a bit of visual interest.\n\nI want an option to create a full rosette, or only a half rosette (where the main body is cut in half to allow the rosette to be placed against a wall), as I am doing currently with a boolean cut of a cube.\n\nFinally, I need good control over the number of faces used to draw polygons for curves, but I don't want to have to manually adjust `$fn`. \n\nIn summary, I would like a parametric OpenSCAD file with the following features:\n\n*   **Central Hole:**\n    *   Specify the shape using an enum \"round,\" or \"polygon\"\n    *   Specify a flat-to-flat diameter for the hole.\n    *   Specify the number of sides if a polygon shape is desired.\n\n*   **Leaves:**\n    *   Specify the number of leaves.\n    *   Specify the length of each leaf.\n    *   Specify the width of each leaf at the widest point.\n    *   Specify the thickness of the leaves.\n    *   Specify the pointyness of the leaves using a curve generator.\n\n*   **Base:**\n    *   Cylinder with a configurable radius, height, and a conical lower portion.\n\n*   **Full or Half:**\n    *   Option to create a full or half rosette with a toggle\n\n*   **Detail:**\n    *   Allow a simple option to control the level of detail when drawing polygon curves.\n\nI'd like the code to be well-commented and easy to understand. No libraries are needed and any curves or spline functions should be created without external dependencies.\n\nCould you generate that for me?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Post Shoe",
    "scad": "POST_SIDE_LENGTH \t= 23;\nSCREW_HEAD_SIZE  \t= 12;\nWALL_THICKNESS   \t= POST_SIDE_LENGTH / 2 * 1;\nSHOE \t\t\t\t= WALL_THICKNESS * 3 * 1;\nPSL \t\t\t\t= POST_SIDE_LENGTH + 0.5 * 1;\n$fn \t\t\t\t= 100 * 1;\ndifference() {\n\tunion() {\n\t\tcube([PSL + WALL_THICKNESS, PSL + WALL_THICKNESS, PSL + WALL_THICKNESS], true);\n\t\ttranslate([0, 0, -((PSL + WALL_THICKNESS)  / 2)]) {\n\t\t\tpolyhedron(\n\t\t  \t\tpoints=[[SHOE, SHOE, 0], [SHOE, -SHOE, 0], [-SHOE, -SHOE, 0], [-SHOE, SHOE, 0], [0, 0, SHOE* 1.333333]],\n\t\t  \t\ttriangles=[ [0, 1, 4], [1, 2, 4], [2, 3, 4], [3, 0, 4], [1, 0, 3], [2, 1, 3]]\n\t\t   );\n      }\n\t}\n\tunion () {\n\t\t#cube([PSL, PSL, PSL * 4], true);\n\t\ttranslate([(PSL + WALL_THICKNESS * 2) / 2 / 3, -((PSL + WALL_THICKNESS) + SCREW_HEAD_SIZE) / 2, -10]) {\n\t\t\tcylinder(h = PSL * 2, r=(SCREW_HEAD_SIZE / 2));\n\t\t\ttranslate([0, 0, -SHOE]) cylinder(h = PSL * 2, r=1.5);\n\t\t}\n \t\ttranslate([-(PSL + WALL_THICKNESS * 2) / 2 / 3, -((PSL + WALL_THICKNESS) + SCREW_HEAD_SIZE) / 2, -10]) {\n\t\t\tcylinder(h = PSL * 2, r=(SCREW_HEAD_SIZE / 2));\n\t\t\ttranslate([0, 0, -SHOE]) cylinder(h = PSL * 2, r=1.5);\n\t\t}\n\t\ttranslate([-((PSL + WALL_THICKNESS) + SCREW_HEAD_SIZE) / 2, -(PSL + WALL_THICKNESS * 2) / 2 / 3, -10]) {\n\t\t\tcylinder(h = PSL * 2, r=(SCREW_HEAD_SIZE / 2));\n\t\t\ttranslate([0, 0, -SHOE]) cylinder(h = PSL * 2, r=1.5);\n\t\t}\n \t\ttranslate([-((PSL + WALL_THICKNESS) + SCREW_HEAD_SIZE) / 2, (PSL + WALL_THICKNESS * 2) / 2 / 3, -10]) {\n\t\t\tcylinder(h = PSL * 2, r=(SCREW_HEAD_SIZE / 2));\n\t\t\ttranslate([0, 0, -SHOE]) cylinder(h = PSL * 2, r=1.5);\n\t\t}\n\t\ttranslate([(PSL + WALL_THICKNESS) / 2, -SHOE, (-SHOE / 2) - 1]) cube([SHOE* 2, SHOE* 2, SHOE* 2]);\n\t\ttranslate([-SHOE, (PSL + WALL_THICKNESS) / 2, (-SHOE / 2) - 1]) cube([SHOE* 2, SHOE* 2, SHOE* 2]);\n\t}\n}",
    "description": "Okay, I'm looking to create a post shoe for securing a post to a flat surface, like a wooden plate. I want the design to be parametric so I can easily adjust it for different post sizes and screw types.\n\nHere's what I need it to do:\n\nThe core of the design is a box that the post will sit in, but the box will be slightly larger than the post to allow for some wiggle room. The \"shoe\" part should extend outwards from the base of the post box. This \"shoe\" needs to be a truncated pyramid shape with its base on the surface and the top flush with the post box. I'd like some cutouts or counterbores to allow for screws to pass through the shoe into the surface below. It needs to have screw holes on all four sides of the base, with both a through-hole for the shaft of the screw and a larger counterbore for the head of the screw. Finally, I need some screw-holes and a block for more screws to attach the post to the shoe.\n\nI want to be able to control the following parameters:\n\n*   **`post_side_length`**: The side length of the square post that the shoe will be used with.\n*   **`screw_head_size`**: The diameter of the screw head to accommodate.\n*  **`wall_thickness`**: The wall thickness of the box part of the shoe.\n*  **`shoe_length`**: The distance the shoe part extends out from the post's cube on the surface.\n*   **`shoe_height`**:  The height of the shoe part at the post.\n*   **`screw_hole_diameter`**: The diameter of the screw's shaft.\n*   **`post_screw_block_offset`**: The amount that the post-to-shoe screw block is offset from the center.\n*  **`post_screw_block_length`**: The length and width of the block for the post-to-shoe screws.\n\nI'm imagining that the final object will use a `difference()` between a main body and various cylinders and cubes, which will make up the cutouts.\n\nI don't need any fancy libraries for this. Just basic OpenSCAD functionality should be enough.\n\nThanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable water turbine",
    "scad": "part = \"fan\";\nnumber_of_blades = 6;\nla=axel_length;\nuse <MCAD/involute_gears.scad>\nprint_part();\nmodule print_part() {\n\tif (part == \"fan\") {\n\t\tform_fan();\n\t} else if (part == \"turbine\") {\n\t\tform_turbine();\n\t}else if (part == \"axel\") {\n\t\tform_axel();\n\t}else if (part == \"Print all\") {\n\t\tform_all();\n\t}\n}\nmodule form_fan() {\n\tguts();\n}\nmodule form_turbine() {\n\tturb();\n}\nmodule form_axel() {\n\tscale ([3/4*.425,3/4*.425,3/4*.425]) makeEm();\n}\nmodule form_fountain() {\n\tscale([4,4,4]) rotate ([90,0,0]) fount();\n}\nmodule form_float() {\n\tbuild_float_many();\n}\nmodule form_leo_bear() {\n\tleo_bear();\n}\nmodule form_all() {\n}\nmodule form_whole() {\ntest_bevel_gear_pair();\n}\nholeSize=5;\nbladeNum=number_of_blades;\nmodule barr() {\n\tunion() {\n\ttranslate ([20,10]) circle (r=10);\n\tscale ([]) square(20);\n\t}\n}\nmodule barrelSpace() {\n\t\ttranslate ([0,0,-10]) rotate_extrude() barr();\n\t\ttranslate ([0,0,-50]) cylinder (r=holeSize*1.5, h=70);\n\t}\nmodule guts() {\n\tintersection() {\n\ttranslate ([0,0,10]) barrelSpace();\n\t\tdifference () {\n\t\t\tunion() {\n\t\t\t\tfor (i = [0:bladeNum]) {\n\t\t\t\t\t rotate ([0,0,360/bladeNum*i]) scale ([1,8/bladeNum,1]) fanBlade();\n\t\t\t\t\t}\n\t\t\t\tcylinder (r=12, h=20);\n\t\t\t\t}\n\t\t\tcylinder (r=holeSize*1.2, h=70, $fa=60);\n\t}\n}\n}\nmodule fanBlade() {\n\tdifference () {\n\t\tunion() {\n\t\ttranslate ([0,1.5,0]) rotate ([90,0,0])  linear_extrude(height=3) barr();\n\t\tscale ([1.5,.8,1]) rotate ([0,90,-10]) translate ([-10,1,10]) sphere (8, $fa=16);\n}\n\t\t\tscale ([1.43,.7,1]) rotate ([0,90,-10]) translate ([-10,5,10]) sphere (8, $fa=24);\n\t\t\ttranslate ([0,4.5,0]) rotate ([90,0,0])  linear_extrude(height=3) barr();\n\t\t\trotate ([0,0,25]) translate ([16,-27.5-bladeNum/8,15]) cube(31, center=true);\n}\n}\nmodule turbine (offset) {\n\t\ttranslate ([offset-2,101,0]) rotate ([90,0,0]) cylinder (r=10, h=100);\n\t\ttranslate ([-44,0,0]) rotate ([90,0,90]) translate ([-20,0,-offset*2])  cylinder (r=10, h=88);\n\t\ttranslate ([0,0,-117]) cube (200, center=true);\n\t\tbarrelSpace ();\n\t}\nmodule tb1(offt) {\n\tdifference () {\n\t\tscale ([.55,.55,1]) translate ([-10,20,-100]) cube (200, center=true);\n\t\ttranslate ([-64,80,-50]) cylinder (r=60, h=60);\n\t\tscale ([1,1,1]) turbine(offt);\n\t}\n}\nmodule pegs() {\n\tcylinder (r=holeSize*1.1, h=45, $fa=60);\n}\nmodule turb() {\ncolor ([.5,.5,1]) tb1(22);\ncolor (\"salmon\") translate ([-130,0,0]) mirror() tb1(22);\n difference() {\n\tcolor ([.6,1,.6]) translate ([0,0,-10]) scale ([.95,.95,.93]) guts();\n\t translate ([0,0,-10]) cylinder (r=holeSize*1.2, h=70, $fa=60);\n\t}\n}\nmodule cir1() {\n\tcircle(10);\n}\nmodule cir2() {\n\ttranslate ([0,10,0]) sphere(r, $fa=1);\n\tintersection () {\n\t\tunion () {\n\t\t\ttranslate ([0,10,0])  cylinder (r=r, h=10);\n\t\t\trotate ([0,0,60]) translate ([0,10,0])  cylinder (r=r, h=20);\n\t\t\t}\n\t\tcylinder (r=2*r, h=20);\n\t\t}\n\t}\nmodule axelh1(l,w) {\n\trotate ([0,180,0]) translate ([0,0,1]) cylinder (r1=.1, r2=w/1.15, h=15, $fa=1);\n\trotate ([0,180,0]) translate ([0,0,16]) cylinder (r=w/1.15,  h=15);\n\trotate ([0,180,0]) translate ([0,0,31]) scale ([1,1,-1]) cylinder (r1=w, r2=.1, h=l, $fa=60);\n\trotate ([0,180,0]) translate ([0,0,31]) cylinder (r=w,  h=l, $fa=60);\n}\nmodule axelWhole(l,w) {\n\taxelh1(l,w);\n\ttranslate ([0,0,-(2*l+45)]) scale ([1,1,-1]) axelh1(l,w);\n}\nl=sin(60)*20;\nr=l/2;\nmodule braces1() {\n\tdifference() {\n\t\tunion() {\n\t\t\ttranslate([-20,0,-50]) scale([.5,2,12]) cube(10, center=true);\n\t\t\ttranslate([0,0,20]) scale([4.5,4.5,3]) cube(10, center=true);\n\t\t\ttranslate([0,0,-115]) scale([4.5,4.5,3]) cube(10, center=true);\n\t\t}\n\tcircsDual();\n\ttranslate ([0,0,-116]) cylinder (r=8, h=136);\n\t}\n}\nmodule circs() {\n\tintersection () {\n\t\tunion() {\n\t\t\tcir2();\n\t\t\trotate ([0,0,120]) cir2();\n\t\t\trotate ([0,0,240]) cir2();\n\t\t}\n\t\ttranslate ([0,0,-13]) cylinder (r1=4*r, r2=.1, h=40);\n\t}\n}\nmodule circsDual() {\n\tcircs();\n\ttranslate ([0,0,-(2*l+60)]) scale ([1,1,-1]) circs();\n}\nmodule makeEm() {\n\tcolor (\"light blue\") circsDual();\n\tcolor (\"light green\")  axelWhole(25,10);\n\t\tbraces1();\n}",
    "description": "Okay, I'm looking to create a water turbine and its axel, and I'd like to use OpenSCAD. I've got some basic ideas, but I'd like you to help me generate a parametric design that's more flexible. \n\nEssentially, I need a design that includes:\n\n1.  **Turbine Blades (Fan):** A fan-like component with a central hub and radial blades. I'd like to be able to control the number of blades, the overall diameter and depth of the fan. I want the fan blades to be curved and not just straight wedges.\n\n2.  **Turbine Housing (BarrelSpace):** A housing that surrounds the fan, but allows water to enter. It needs to be hollow and could be made using a rotate_extrude. I also need a through hole in the middle of this housing for the axel.\n\n3.  **Axel:** This should have a central shaft and two larger diameter areas, one on each side of the fan blades, for securing the turbine. There should also be support structures at the top and bottom to provide stability in the assembly.\n\nHere are the specific parameters I'd like to control through variables:\n\n*   `number_of_blades`: How many blades on the turbine fan (default is 6).\n*   `axel_length`: The overall length of the axel (default is 25).\n*   `holeSize`: The diameter of the central hole that goes through the housing, turbine fan and axel.\n\nI'm also using the `involute_gears.scad` library from the MCAD library. I'd like the generated code to have separate modules to control the design, so I can change and build each part. I would like a module called `form_fan` to generate the fan, `form_turbine` to make the turbine housing, and `form_axel` to generate the axel. Additionally, I would like a module called `print_part` which can select which part to build using the string variable called `part` (which can be \"fan\", \"turbine\", \"axel\" or \"Print all\"). If \"Print all\" is selected, it will just call every other module.\n\nCould you help me generate this OpenSCAD code?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Projector height booster",
    "scad": "part=\"base\";\nd=40;\nh=12;\nlayer_height=.25;\nlogo_height=1.5;\n$fs=1/10;\n$fa=10/10;\nmodule gear_tooth_2d(d) {\n\tpolygon( points=[\n\t\t\t[0.0,10.0*d/72.0], [0.5*d,d/15.0],\n\t\t\t[0.5*d,-d/15.0], [0.0,-10.0*d/72.0] ] );\n}\nmodule oshw_logo_2d(d=10.0) {\n\trotate(-135) {\n\t\tdifference() {\n\t\t\tunion() {\n\t\t\t\tcircle(r=14.0*d/36.0,$fn=20);\n\t\t\t\tfor(i=[1:7]) assign(rotAngle=45*i+45)\n\t\t\t\t\trotate(rotAngle) gear_tooth_2d(d);\n\t\t\t}\n\t\t\tcircle(r=10.0*d/72.0,$fn=20);\n\t\t\tintersection() {\n\t  \t\t\trotate(-20) square(size=[10.0*d/18.0,10.0*d/18.0]);\n\t  \t\t\trotate(20)  square(size=[10.0*d/18.0,10.0*d/18.0]);\n\t\t\t}\n    \t\t}\n  \t}\n}\nlogo_layers = ceil(logo_height / layer_height);\ndifference(){\n\tcylinder(r=d/2, h=h+logo_height);\n\tunion(){\n\t\tfor(i =  [0:logo_layers-1])\n\t\t\ttranslate([0,0,h+layer_height*i])\n\t\t\t\tlinear_extrude(height=-layer_height)\n\t\t\t\t\toshw_logo_2d(d/1.2 + (5/logo_layers)*i);\n\t}\n}",
    "description": "Okay, I've been playing around with OpenSCAD and made a little cylinder to use as a projector booster, and I'm pretty happy with how it's turning out, but it feels like the code could be better organized, and Id like to make it more parametric.  I'm not super happy with my hardcoding of the logo size either, so I think that could be better.\n\nHeres what I want:\n\nI need a cylinder that can be used as a booster, so its primary function is to raise something up by a certain amount. It needs to be a simple cylinder with a diameter and height, but I also want to be able to easily add a circular cutout on the top for holding whatever I am boosting -- like a projector leg.  I also want to add the OSHW logo to the side of the cylinder. I want to be able to control the depth of this logo cutout with a parameter, including turning the logo cutout off completely with a zero value.\n\nHere's a breakdown of the parameters I think I need to control:\n\n*   **`d`**: The diameter of the main cylinder.\n*   **`h`**: The height of the main cylinder.\n*   **`cutout_diameter`**: The diameter of the circular cutout on the top of the cylinder. If this is 0, then no cutout should be made.\n*    **`cutout_depth`**: The depth of the circular cutout on the top of the cylinder.\n*   **`logo_height`**: The depth of the OSHW logo cutout. Setting this to 0 would mean the logo is not included.\n*   **`layer_height`**:  The layer height of the printer I am using. This should be used to determine the number of layers for the logo cutout.\n*   **`logo_offset`**: The offset from the bottom of the cylinder where the logo starts.\n\nI want to make sure the logo's size is proportional to the main cylinder diameter.  So I think the logo's diameter should scale to be roughly 80% of the `d` parameter if the logo_height is set. The final logo cutout should be made with a series of stacked 2D cutouts at varying diameters, growing larger and larger the deeper the cutout is. I think I'm okay with the linear extrusion method to cut out the logo with that scaling, though I'm open to suggestions. Id like it if I didnt need to manually calculate how big the logo gets at each layer.\n\nI'm currently using the following code to generate the logo:\n\n```openscad\nmodule gear_tooth_2d(d) {\n\tpolygon( points=[ \n\t\t\t[0.0,10.0*d/72.0], [0.5*d,d/15.0], \n\t\t\t[0.5*d,-d/15.0], [0.0,-10.0*d/72.0] ] );\n}\n\nmodule oshw_logo_2d(d=10.0) {\n\trotate(-135) {\n\t\tdifference() {\n\t\t\tunion() {\n\t\t\t\tcircle(r=14.0*d/36.0,$fn=20);\n\t\t\t\tfor(i=[1:7]) assign(rotAngle=45*i+45)\n\t\t\t\t\trotate(rotAngle) gear_tooth_2d(d);\n\t\t\t}\n\t\t\tcircle(r=10.0*d/72.0,$fn=20);\n\t\t\tintersection() {\n\t  \t\t\trotate(-20) square(size=[10.0*d/18.0,10.0*d/18.0]);\n\t  \t\t\trotate(20)  square(size=[10.0*d/18.0,10.0*d/18.0]);\n\t\t\t}\n    \t\t}\n  \t}\n}\n\n```\n\nI'd like to use the BOSL2 library, but if another is more appropriate I'm open to that too. I'd also like the code to be well-documented and easy to understand.  I prefer that `$fs` and `$fa` be set in the parametric parameters using the BOSL2 options for `set_global_detail()` module.\n\nCan you help me rewrite my code to be more organized, parametric, and use the BOSL2 library?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Cartoon Character Maker - Now with dualstrusion!",
    "scad": "resolution=8;\npart=\"Solid\";\nprimary_color=\"silver\";\nsecondary_color=\"sienna\";\nheight=100;\nhead_tilt=20;\ntop_width= 4;\nbottom_width = 3;\nneck = 4;\nhair_type=\"average guy\";\nhair_length = 3;\neye_type=\"eye roll\";\neye_size= 6;\neye_angle=-8;\neye_spacing=4;\nglasses=\"hipster\";\neyebrow_thickness=7;\neyebrow_length=7;\neyebrow_tilt=15;\nfacial_hair=\"full beard\";\nfacial_hair_length=1;\nnose_type=\"average\";\nnose_size=5;\nnose_width=5;\nnose_height=5;\nmouth_type=\"agape\";\nmouth_size=5;\nmouth_height=7;\near_type=\"average\";\near_size=5;\near_angle=2;\nrec=resolution;\nres=resolution*2;\nh=100*1;\nrs=h/4.1*(top_width+10)/10;\nrc=h/4.1*(bottom_width+10)/10;\nrn=rc*(neck+3)/15;\nhm=h-rs-rc;\ntheta=asin((rs-rc)/hm);\neyer=(eye_size/10)*(rs*3/10);\neyemax=rs*3/10;\neyesp=eyer+(eye_spacing/10)*(rs*3/5-2*eyer);\neyex=pow(pow(rs,2)-pow(eyesp,2),1/2)-rs+rc;\nnosez=(1/2)*rc+(h/2-(1/2)*rc)*(nose_height-1)/9;\nmouthmax=(h/2-eyemax)/2*.8;\nmouthd=mouthmax*(mouth_size+5)/15;\nmouthr=mouthd/2;\nmouthz=nosez*(mouth_height+3)/13;\nif(part==\"Solid\"){\n\trotate([0,0,-90])scale([height/100,height/100,height/100])difference(){\n\t\ttranslate([0,0,-rc*(1-cos(head_tilt))])union(){\n\t\t\ttranslate([0,0,rc])\n\t\t\trotate([0,(-head_tilt+theta),0])\n\t\t\ttranslate([0,0,-rc])\n\t\t\tunion(){\n\t\t\t\tcolor(primary_color)difference(){\n\t\t\t\t\thead();\n\t\t\t\t\tmouth_blank();\n\t\t\t\t}\n\t\t\t\tcolor(primary_color)eyes();\n\t\t\t\tcolor(primary_color)mouth();\n\t\t\t\tcolor(primary_color)ears();\n\t\t\t\tcolor(primary_color)nose();\n\t\t\t\tcolor(secondary_color)glasses();\n\t\t\t\tcolor(secondary_color)hair();\n\t\t\t\tcolor(secondary_color)beard();\n\t\t\t\tcolor(secondary_color)brows();\n\t\t\t}\n\t\t\tcolor(primary_color)translate([-rc*2/3+rn,0,0])cylinder(r=rn,h=rc+hm,$fn=rec);\n\t\t}\n\t\ttranslate([0,0,-50])cube(100,center=true);\n\t}\n}\nif(part==\"Dual1\"){\n\trotate([0,0,-90])scale([height/100,height/100,height/100])difference(){\n\t\ttranslate([0,0,-rc*(1-cos(head_tilt))])union(){\n\t\t\ttranslate([0,0,rc])\n\t\t\trotate([0,(-head_tilt+theta),0])\n\t\t\ttranslate([0,0,-rc])\n\t\t\tunion(){\n\t\t\t\tdifference(){\n\t\t\t\t\thead();\n\t\t\t\t\tmouth_blank();\n\t\t\t\t}\n\t\t\t\teyes();\n\t\t\t\tmouth();\n\t\t\t\tears();\n\t\t\t\tnose();\n\t\t\t}\n\t\t\ttranslate([-rc*2/3+rn,0,0])cylinder(r=rn,h=rc+hm,$fn=rec);\n\t\t}\n\t\ttranslate([0,0,-rc*(1-cos(head_tilt))]){\n\t\t\ttranslate([0,0,rc])\n\t\t\trotate([0,(-head_tilt+theta),0])\n\t\t\ttranslate([0,0,-rc])\n\t\t\tunion(){\n\t\t\t\tglasses();\n\t\t\t\thair();\n\t\t\t\tbeard();\n\t\t\t\tbrows();\n\t\t\t}\n\t\t}\n\t\ttranslate([0,0,-50])cube(100,center=true);\n\t}\n}\nif(part==\"Dual2\"){\n\trotate([0,0,-90])scale([height/100,height/100,height/100])difference(){\n\t\ttranslate([0,0,-rc*(1-cos(head_tilt))]){\n\t\t\ttranslate([0,0,rc])\n\t\t\trotate([0,(-head_tilt+theta),0])\n\t\t\ttranslate([0,0,-rc])\n\t\t\tunion(){\n\t\t\t\tglasses();\n\t\t\t\thair();\n\t\t\t\tbeard();\n\t\t\t\tbrows();\n\t\t\t}\n\t\t}\n\t\ttranslate([0,0,-50])cube(100,center=true);\n\t}\n}\nmodule head(){\n\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\ttranslate([0,0,hm])sphere(rs,$fn=res);\n\t\tsphere(rc,$fn=res);\n\t}\n}\nmodule eye_blank(){\n\tintersection(){\n\t\ttranslate([0,0,h/2])rotate([0,90,0])linear_extrude(h=rs+10)for(i=[1,-1])hull(){\n\t\t\ttranslate([0,eyemax*i])circle(eyemax,$fn=rec);\n\t\t\ttranslate([-eyemax/2,-eyemax*i])circle(eyemax/2,$fn=rec);\n\t\t}\n\t\thead();\n\t}\n}\nmodule mouth_blank(){\n\tintersection(){\n\t\ttranslate([0,0,mouthz])rotate([0,90,0])scale([1,1.25,1])cylinder(r=mouthmax,h=rc+10,$fn=rec);\n\t\thead();\n\t}\n}\nmodule eyes(){\n\t\tif(glasses!=\"coke bottle\")\n\t\tfor(i=[1,-1])translate([eyex-eyer/2,eyesp*i,h/2])rotate([eye_angle*i,0,0]){\n\t\t\tif(eye_type==\"average\")eyeball(eyer,6);\n\t\t\tif(eye_type==\"surprised\")eyeball(eyer,15);\n\t\t\tif(eye_type==\"sleepy\")eyeball(eyer,2);\n\t\t\tif(eye_type==\"eye roll\")rotate([0,-30,-30])eyeball(eyer,5);\n\t\t}\n}\nmodule glasses(){\n\t\tif(glasses==\"hipster\")translate([eyex+2,0,h/2])rotate([0,5,0])square_glasses();\n\t\tif(glasses==\"circle\")translate([eyex+2,0,h/2])rotate([0,5,0])circle_glasses();\n\t\tif(glasses==\"coke bottle\")translate([eyex+2,0,h/2])rotate([0,5,0])coke_bottle();\n}\nmodule mouth(){\n\tdifference(){\n\t\tmouth_blank();\n\t\tif(mouth_type==\"agape\"){\n\t\t\t\tif(mouthz<rc)translate([pow(pow(rc,2)-pow(rc-mouthz,2),.5),0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])intersection(){\n\t\t\t\tscale([1,1,.7])sphere(10,$fn=res);\n\t\t\t\ttranslate([0,0,-28])sphere(30,$fn=res);}\n\t\t\tif(mouthz>=rc)translate([rc,0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])intersection(){\n\t\t\t\tscale([1,1,.7])sphere(10,$fn=res);\n\t\t\t\ttranslate([0,0,-28])sphere(30,$fn=res);}\n\t\t}\n\t\tif(mouth_type==\"smiling\"){\n\t\t\tif(mouthz<rc)translate([pow(pow(rc,2)-pow(rc-mouthz,2),.5),0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])difference(){\n\t\t\t\tscale([1,1,.7])sphere(10,$fn=res);\n\t\t\t\ttranslate([0,7,20])sphere(20,$fn=res);}\n\t\t\tif(mouthz>=rc)translate([rc,0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])difference(){\n\t\t\t\tscale([1,1,.7])sphere(10,$fn=res);\n\t\t\t\ttranslate([0,7,20])sphere(20,$fn=res);}\n\t\t}\n\t\tif(mouth_type==\"oh no\"){\n\t\t\tif(mouthz<rc)translate([pow(pow(rc,2)-pow(rc-mouthz,2),.5),0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])difference(){\n\t\t\t\tscale([1,1,.7])sphere(10,$fn=res);\n\t\t\t\ttranslate([0,-7,-20])sphere(20,$fn=res);}\n\t\t\tif(mouthz>=rc)translate([rc,0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])difference(){\n\t\t\t\tscale([1,1,.7])sphere(10,$fn=res);\n\t\t\t\ttranslate([0,-7,-20])sphere(20,$fn=res);}\n\t\t}\n\t\tif(mouth_type==\"not feeling well\"){\n\t\t\ttranslate([rc,0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])rotate([0,90,0])rotate([0,0,90])linear_extrude(height=50,center=true){\n\t\t\t\tintersection(){\n\t\t\t\t\ttranslate([-5,-3.5])difference(){\n\t\t\t\t\t\tcircle(5,$fn=20);\n\t\t\t\t\t\tcircle(2,$fn=20);\n\t\t\t\t\t}\n\t\t\t\t\ttranslate([-15,-3.5])square(10);\n\t\t\t\t}\n\t\t\t\thull(){\n\t\t\t\t\ttranslate([-5,0])circle(1.5,$fn=20);\n\t\t\t\t\ttranslate([6,0])circle(1.5,$fn=20);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mouth_type==\"um...\"){\n\t\t\ttranslate([rc,0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])rotate([0,90,0])rotate([0,0,90])linear_extrude(height=50,center=true){\n\t\t\t\thull(){\n\t\t\t\t\ttranslate([-5,0])circle(1.5,$fn=20);\n\t\t\t\t\ttranslate([6,0])circle(1.5,$fn=20);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mouth_type==\"half smile\"){\n\t\t\ttranslate([rc,0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])rotate([0,90,0])rotate([0,0,90])linear_extrude(height=50,center=true){\n\t\t\t\tintersection(){\n\t\t\t\t\ttranslate([-5,3.5])difference(){\n\t\t\t\t\t\tcircle(5,$fn=20);\n\t\t\t\t\t\tcircle(2,$fn=20);\n\t\t\t\t\t}\n\t\t\t\t\ttranslate([-15,-6.5])square(10);\n\t\t\t\t}\n\t\t\t\thull(){\n\t\t\t\t\ttranslate([-5,0])circle(1.5,$fn=20);\n\t\t\t\t\ttranslate([6,0])circle(1.5,$fn=20);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mouth_type==\"chiclet teeth\"){\n\t\t\tif(mouthz<rc)translate([pow(pow(rc,2)-pow(rc-mouthz,2),.5),0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])difference(){\n\t\t\t\tintersection(){\n\t\t\t\t\tscale([1,1,.7])sphere(10,$fn=res);\n\t\t\t\t\ttranslate([0,0,-28])sphere(30,$fn=res);}\n\t\t\t\tfor(j=[0,1])translate([-1*j-5,0,-4.5*j-3])\n\t\t\t\t\tfor(i=[-10.5,-7.5,-4.5,-1.5,1.5,4.5,7.5,10.5])translate([0,i,0])hull(){\n\t\t\t\t\t\ttranslate([0,.5,1])sphere(1,$fn=10);\n\t\t\t\t\t\ttranslate([0,-.5,1])sphere(1,$fn=10);\n\t\t\t\t\t\ttranslate([0,.5,5])sphere(1,$fn=10);\n\t\t\t\t\t\ttranslate([0,-.5,5])sphere(1,$fn=10);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mouthz>=rc)translate([rc,0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])difference(){\n\t\t\t\tintersection(){\n\t\t\t\t\tscale([1,1,.7])sphere(10,$fn=res);\n\t\t\t\t\ttranslate([0,0,-28])sphere(30,$fn=res);}\n\t\t\t\tfor(j=[0,1])translate([-1*j-5,0,-4.5*j-3])\n\t\t\t\t\tfor(i=[-10.5,-7.5,-4.5,-1.5,1.5,4.5,7.5,10.5])translate([0,i,0])hull(){\n\t\t\t\t\t\ttranslate([0,.5,1])sphere(1,$fn=10);\n\t\t\t\t\t\ttranslate([0,-.5,1])sphere(1,$fn=10);\n\t\t\t\t\t\ttranslate([0,.5,5])sphere(1,$fn=10);\n\t\t\t\t\t\ttranslate([0,-.5,5])sphere(1,$fn=10);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(mouth_type==\"lipstick\"){\n\t\tintersection(){\n\t\t\ttranslate([rc,0,mouthz])scale([mouth_size/5,mouth_size/5,mouth_size/5])scale([.6,.6,.6])rotate([0,270,0])linear_extrude(height=50,center=true){\n\t\t\t\tdifference(){\n\t\t\t\t\tintersection(){\n\t\t\t\t\t\ttranslate([30,0])circle(40,$fn=30);\n\t\t\t\t\t\tfor(i=[1,-1])translate([3,0])rotate([0,0,15*i])translate([-30,0])circle(30,$fn=30);\n\t\t\t\t\t}\n\t\t\t\t\tfor(i=[1,-1])translate([-2,0])rotate([0,0,15*i])translate([-50,0])circle(50,$fn=30);\n\t\t\t\t}\n\t\t\t\ttranslate([-1,0])intersection(){\n\t\t\t\t\ttranslate([30,0])circle(40,$fn=30);\n\t\t\t\t\tfor(i=[1,-1])translate([3,0])rotate([0,0,15*i])translate([-30,0])circle(30,$fn=30);\n\t\t\t\t\tfor(i=[1,-1])translate([-2,0])rotate([0,0,15*i])translate([-50,0])circle(50,$fn=30);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([3,0,0])mouth_blank();\n\t\t}\n\t}\n\tif(mouth_type==\"just stache\"){\n\t\ttranslate([rc,0,mouthz+5])\n\t\tscale([mouth_size/5,mouth_size/5,mouth_size/5])scale([.7,.7,.7])\n\t\tdifference(){\n\t\t\ttranslate([0,0,5])cube([10,30,10],center=true);\n\t\t\ttranslate([8,0,0])rotate([0,-15,0])translate([0,0,25])cube([10,30,50],center=true);\n\t\t\tfor(i=[-15:3:15]){\n\t\t\t\ttranslate([3,i*pow(2,.5),0])rotate([0,-15,0])rotate([0,0,45])translate([0,0,6])cube([1,1,12],center=true);\n\t\t\t\ttranslate([0,i*pow(2,.5),10])rotate([45,0,0])cube([10,1,1],center=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule ears(){\n\tfor(i=[1,-1])\n\t\tscale([1,i,1])\n\t\ttranslate([0,0,rc])\n\t\trotate([0,-theta,0])\n\t\ttranslate([0,rs,hm])\n\t\trotate([-theta,0,0])\n\t\ttranslate([0,0,h/2-rc-hm])\n\t\tscale([ear_size/4,ear_size/4,ear_size/4]){\n\t\t\tif(ear_type==\"average\")ear_model(Ear_Length=15,Ear_Shape=60,ear_thickness=3,taper=70);\n\t\t\tif(ear_type==\"monkey\")ear_model(Ear_Length=9,Ear_Shape=10,ear_thickness=3,taper=70);\n\t\t\tif(ear_type==\"long\")ear_model(Ear_Length=25,Ear_Shape=30,ear_thickness=3,taper=70);\n\t\t\tif(ear_type==\"pill shaped\")ear_model(Ear_Length=15,Ear_Shape=100,ear_thickness=3,taper=70);\n\t\t\tif(ear_type==\"viking horn\")rotate([15+theta,0,0])horn(hornrad=45,hornshaft=8,hornsweep=60,horncut=5);\n\t\t}\n}\nmodule nose(){\n\ttranslate([rc,0,nosez])scale([nose_size/5,nose_size/5*nose_width/5,nose_size/5]){\n\t\tif(nose_type==\"pointy\")\n\t\t\tnose_model(\n\t\t\t\tnwidth=12,\n\t\t\t\tbridge_width=1,\n\t\t\t\tbridge_prominance=1,\n\t\t\t\ttip_width=1,\n\t\t\t\ttip_height=0,\n\t\t\t\tnheight=16,\n\t\t\t\tnose_length=8,\n\t\t\t\tsoftness=4,\n\t\t\t\tnostril_length=4,\n\t\t\t\tnostril_weight=3,\n\t\t\t\tnostril_width=7,\n\t\t\t\tnostril_bulge=0);\n\t\tif(nose_type==\"upturned\")\n\t\t\tnose_model(\n\t\t\t\tnwidth=10,\n\t\t\t\tbridge_width=3,\n\t\t\t\tbridge_prominance=-4,\n\t\t\t\ttip_width=3,\n\t\t\t\ttip_height=3,\n\t\t\t\tnheight=16,\n\t\t\t\tnose_length=6,\n\t\t\t\tsoftness=9,\n\t\t\t\tnostril_length=4,\n\t\t\t\tnostril_weight=3,\n\t\t\t\tnostril_width=9,\n\t\t\t\tnostril_bulge=0);\n \t\tif(nose_type==\"wide\")\n\t\t\tnose_model(\n\t\t\t\tnwidth=18,\n\t\t\t\tbridge_width=4,\n\t\t\t\tbridge_prominance=1,\n\t\t\t\ttip_width=5,\n\t\t\t\ttip_height=1,\n\t\t\t\tnheight=16,\n\t\t\t\tnose_length=8,\n\t\t\t\tsoftness=7,\n\t\t\t\tnostril_length=8,\n\t\t\t\tnostril_weight=5,\n\t\t\t\tnostril_width=9,\n\t\t\t\tnostril_bulge=.2);\n \t\tif(nose_type==\"average\")\n\t\t\tnose_model(\n\t\t\t\tnwidth=14,\n\t\t\t\tbridge_width=4,\n\t\t\t\tbridge_prominance=-3,\n\t\t\t\ttip_width=6,\n\t\t\t\ttip_height=0,\n\t\t\t\tnheight=16,\n\t\t\t\tnose_length=7,\n\t\t\t\tsoftness=8,\n\t\t\t\tnostril_length=5,\n\t\t\t\tnostril_weight=7,\n\t\t\t\tnostril_width=9,\n\t\t\t\tnostril_bulge=.2);\n \t\tif(nose_type==\"high bridge\")\n\t\t\tnose_model(\n\t\t\t\tnwidth=12,\n\t\t\t\tbridge_width=2,\n\t\t\t\tbridge_prominance=3,\n\t\t\t\ttip_width=4,\n\t\t\t\ttip_height=0,\n\t\t\t\tnheight=16,\n\t\t\t\tnose_length=10,\n\t\t\t\tsoftness=8,\n\t\t\t\tnostril_length=4,\n\t\t\t\tnostril_weight=4,\n\t\t\t\tnostril_width=7,\n\t\t\t\tnostril_bulge=.2);\n \t\tif(nose_type==\"button\")\n\t\t\tnose_model(\n\t\t\t\tnwidth=12,\n\t\t\t\tbridge_width=2,\n\t\t\t\tbridge_prominance=-8,\n\t\t\t\ttip_width=6,\n\t\t\t\ttip_height=1,\n\t\t\t\tnheight=10,\n\t\t\t\tnose_length=5,\n\t\t\t\tsoftness=8,\n\t\t\t\tnostril_length=4,\n\t\t\t\tnostril_weight=4,\n\t\t\t\tnostril_width=7,\n\t\t\t\tnostril_bulge=0);\n\t\tif(nose_type==\"piggy\")scale([1,5/nose_width,1])translate([0,0,7])rotate([0,90,0])difference(){\n\t\t\t\t\tintersection(){\n\t\t\t\t\t\tcylinder(r=7,h=14,center=true,$fn=rec);\n\t\t\t\t\t\tscale([7/14,7/14,1])sphere(r=14,$fn=res);\n\t\t\t\t\t}\n\t\t\t\t\tfor(i=[1,-1])scale([1,i,1])translate([0,2,7])scale([1,.5,1])sphere(r=2.5,$fn=res);\n\t\t\t\t}\n \t\tif(nose_type==\"clown\")scale([1,1,nose_width/5])translate([3,0,10])sphere(r=10,$fn=res);\n\t}\n}\nmodule hair(){\n\tif(hair_type==\"bowl cut\")bowlcut(hairlen=4);\n\tif(hair_type==\"bob\")bob(hairlen=4);\n\tif(hair_type==\"long\")long(hairlen=4);\n\tif(hair_type==\"buzz\")buzz(hairlen=hair_length);\n\tif(hair_type==\"mullet\")mullet(hairlen=hair_length,toplen=5/7*rs,topwidth=0.9);\n\tif(hair_type==\"fro\")buzz(hairlen=20);\n\tif(hair_type==\"monster fro\")buzz(hairlen=30);\n\tif(hair_type==\"male pattern\")intersection(){\n\t\tbuzz(hairlen=hair_length);\n\t\trotate([0,-theta,0])cylinder(r=100,h=h/2+13,$fn=rec);\n\t}\n\tif(hair_type==\"flattop\")flattop(hairlen=hair_length,toplen=rs,topwidth=.95);\n\tif(hair_type==\"average guy\")flattop(hairlen=hair_length,toplen=4/7*rs,topwidth=0.9);\n\tif(hair_type==\"top bun\")topbun(hairlen=1);\n\tif(hair_type==\"pony\")pony(hairlen=1);\n}\nmodule beard(){\n\tif(facial_hair==\"full beard\")fullbeard(facial_hair_length);\n\tif(facial_hair==\"chin strap\")chinstrap(facial_hair_length);\n\tif(facial_hair==\"chops\")chops(facial_hair_length);\n\tif(facial_hair==\"stache\")stache(facial_hair_length);\n\tif(facial_hair==\"soul patch\")soulpatch(facial_hair_length);\n\tif(facial_hair==\"goatee\")goatee(facial_hair_length);\n}\nmodule eyeball(eye_radius,awake){\n\ttheta1=55*awake/10-10;\n\ttheta2=45*awake/10+10;\n\tunion(){\n\t\tdifference(){\n\t\t\tsphere(eye_radius*9/10,$fn=res);\n\t\t\trotate([0,90,0])cylinder(r1=0,r2=eye_radius/1.5,h=eye_radius,$fn=res);\n\t\t}\n\t\tdifference(){\n\t\t\tsphere(eye_radius*8/10,$fn=res);\n\t\t\trotate([0,90,0])cylinder(r1=0,r2=eye_radius/4,h=eye_radius,$fn=res);\n\t\t}\n\t\trotate([0,theta2,0])difference(){\n\t\t\tsphere(eye_radius,$fn=res);\n\t\t\ttranslate([-eye_radius,-eye_radius,0])cube(2*eye_radius);\n\t\t}\n\t\trotate([0,-180-theta1,0])difference(){\n\t\t\tsphere(eye_radius,$fn=res);\n\t\t\ttranslate([-eye_radius,-eye_radius,0])cube(2*eye_radius);\n\t\t}\n\t}\n}\nmodule square_glasses(){\n\trotate([90,0,-90])union(){\n\t\tlinear_extrude(height=2){\n\t\t\tfor(i=[1,-1])scale([i,1])translate([6,-6])difference(){\n\t\t\t\tminkowski(){\n\t\t\t\t\tsquare([16,12]);\n\t\t\t\t\tcircle(r=2.5,$fn=rec);\n\t\t\t\t}\n\t\t\t\tminkowski(){\n\t\t\t\t\tsquare([16,12]);\n\t\t\t\t\tcircle(r=1,$fn=rec);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdifference(){\n\t\t\t\ttranslate([0,1.5])square([7,9],center=true);\n\t\t\t\ttranslate([0,6])circle(r=3.5,$fn=rec);\n\t\t\t\ttranslate([0,-3])circle(r=3.5,$fn=rec);\n\t\t\t}\n\t\t}\n\t\tlinear_extrude(height=20)intersection(){\n\t\t\tfor(i=[1,-1])scale([i,1])translate([6,-6])difference(){\n\t\t\t\tminkowski(){\n\t\t\t\t\tsquare([16,12]);\n\t\t\t\t\tcircle(r=2.5,$fn=rec);\n\t\t\t\t}\n\t\t\t\tminkowski(){\n\t\t\t\t\tsquare([16,12]);\n\t\t\t\t\tcircle(r=1,$fn=rec);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([0,-57])square([100,100],center=true);\n\t\t}\n\t\tlinear_extrude(height=40){\n\t\t\tfor(i=[1,-1])scale([i,1])translate([25.5,0]){\n\t\t\t\ttranslate([0,1.5])square([2,6],center=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule circle_glasses(){\n\trotate([90,0,-90])union(){\n\t\tlinear_extrude(height=2){\n\t\t\tfor(i=[1,-1])scale([i,1])translate([14,1])difference(){\n\t\t\t\tcircle(r=12,$fn=rec);\n\t\t\t\tcircle(r=9,$fn=rec);\n\t\t\t}\n\t\t\tintersection(){\n\t\t\t\tdifference(){\n\t\t\t\t\ttranslate([0,-2])circle(r=6.5,$fn=rec);\n\t\t\t\t\ttranslate([0,-2])circle(r=3.5,$fn=rec);\n\t\t\t\t}\n\t\t\t\ttranslate([-4,0])square([8,10]);\n\t\t\t}\n\t\t}\n\t\tlinear_extrude(height=20)intersection(){\n\t\t\tfor(i=[1,-1])scale([i,1])translate([14,1])difference(){\n\t\t\t\tcircle(r=12,$fn=rec);\n\t\t\t\tcircle(r=9,$fn=rec);\n\t\t\t}\n\t\t\ttranslate([0,-58])square([100,100],center=true);\n\t\t}\n\t\tlinear_extrude(height=40){\n\t\t\tfor(i=[1,-1])scale([i,1])translate([25.5,0]){\n\t\t\t\ttranslate([0,1.5])square([2,6],center=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule coke_bottle(){\n\tcircle_glasses();\n\tfor(i=[1,-1])translate([-2,14*i,1])rotate([0,90,0])cylinder(r=10,h=1,$fn=rec);\n\tintersection(){\n\t\tfor(i=[1,-1])translate([-9,14*i,1])rotate([eye_angle*i,0,0])eyeball(13,5);\n\t\ttranslate([48,0,0])cube(100,center=true);\n\t}\n}\nmodule nose_model(nwidth,bridge_width,bridge_prominance,tip_width,tip_height,nheight,nose_length,softness,nostril_length,nostril_weight,nostril_width,nostril_bulge){\n\tnrad=pow(pow(nose_length,2)+pow(tip_height,2)+pow(nwidth/2,2),1/2)*nostril_length/20;\n\tnostrad=nostril_width/10*nwidth/4;\n\trtop=bridge_width/2*softness/10;\n\trtip=tip_width/2*softness/10;\n\tresnose=10;\n\tnthtz=atan(-nwidth/2/nose_length);\n\tnthty=atan(-tip_height/nose_length);\n\ttranslate([0,0,nrad*nostril_weight/10])difference(){\n\t\tunion(){\n\t\t\thull(){\n\t\t\t\tfor(i=[1,-1])scale([1,i,1])translate([0,nwidth/2,0])rotate([0,nthty,nthtz])translate([nrad,0,0])scale([1,nostril_weight/10,nostril_weight/10])sphere(nrad,$fn=resnose);\n\t\t\t\tfor(i=[1,-1])scale([1,i,1])translate([-nrad,nwidth/2-nrad,0])sphere(r=rtip,$fn=resnose);\n\t\t\t\tfor(i=[1,-1])scale([1,i,1])translate([nose_length-rtip,tip_width/2-rtip,tip_height])sphere(r=rtip,$fn=resnose);\n\t\t\t\tfor(i=[1,-1])scale([1,i,1])translate([(nose_length-rtip)/3+(nose_length-rtip)*2/3*bridge_prominance/10,bridge_width/2-rtop,tip_height+(nheight-tip_height)*2/3])sphere(r=rtop,$fn=resnose);\n\t\t\t\ttranslate([-rtop,0,nheight-rtop])sphere(r=rtop,$fn=resnose);\n\t\t\t}\n\t\t\tfor(i=[1,-1])scale([1,i,1])translate([0,nwidth/2,0])rotate([0,nthty,nthtz])translate([nrad,0,0])scale([1,nostril_weight/10,nostril_weight/10])sphere(nrad+nostril_bulge,$fn=resnose);\n\t\t}\n\t\tfor(i=[-1,1])scale([1,i,1])translate([nostrad/2+(nose_length-nostrad)/10,nostrad+(nwidth/2-nostrad)/10,-nheight/4])rotate([0,-atan(nose_length/2/nheight),0])cylinder(r1=nostrad,r2=0,h=nheight*2/3,$fn=rec);\n\t}\n}\nmodule ear_model(Ear_Length,Ear_Shape,ear_thickness,taper){\n\tTop_Radius=5;\n\tsoft=ear_thickness/6;\n\tBottom_Radius=1+(Top_Radius-1)*Ear_Shape/100;\n\ttopr=Top_Radius;\n\tbotr=Bottom_Radius;\n\teart=ear_thickness;\n\tcutr=(Ear_Length-topr-botr)/2;\n\trotate([0,0,-45*ear_angle/10])translate([-topr*2/3,0,0])rotate([270,0,0])difference(){\n\t\thull(){\n\t\t\t\tcylinder(r1=topr*taper/100,r2=topr,h=eart,$fn=rec*2,center=true);\n\t\t\t\ttranslate([topr-botr,Ear_Length-topr-botr,0])cylinder(r1=botr*taper/100,r2=botr,h=eart,$fn=rec*2,center=true);\n\t\t\t\ttranslate([(topr-botr)/2,Ear_Length-topr,-eart/2])cylinder(r1=botr*taper/200,r2=0,h=eart*3/2,$fn=rec*2,center=true);\n\t\t\t\ttranslate([0,0,ear_thickness/2])scale([1,1,ear_thickness/3/topr])sphere(topr,$fn=res);\n\t\t\t\ttranslate([topr-botr,Ear_Length-topr-botr,ear_thickness/2])scale([1,1,ear_thickness/5/botr])sphere(botr,$fn=res);\n\t\t}\n\t\thull(){\n\t\t\ttranslate([0,0,ear_thickness/2+ear_thickness/3/topr])scale([1,1,ear_thickness/2/topr])sphere(topr-soft,$fn=res);\n\t\t\ttranslate([topr-botr,Ear_Length-topr-botr,ear_thickness/2+ear_thickness/5/topr])scale([1,1,ear_thickness/4/botr])sphere(botr-soft,$fn=res);\n\t\t}\n\t\ttranslate([topr,(Ear_Length-topr-botr)/2,ear_thickness*(1/2+1/3)])scale([1,1,ear_thickness*(1/2+1/3)/cutr])sphere(cutr,$fn=res);\n\t}\n}\nmodule horn(hornrad,hornshaft,hornsweep,horncut){\n\tradstep=hornshaft/(horncut);\n\trotstep=hornsweep/(horncut);\n\trotate([0,0,-90])\n\trotate([0,-90,0])\n\ttranslate([hornrad+hornshaft,0,0])\n\tfor(i=[1:1:horncut]){\n\t\thull(){\n\t\t\trotate([0,rotstep*(i-1),0])translate([-hornrad,0,0])cylinder(r1=hornshaft-radstep*(i-1),r2=0,h=.1);\n\t\t\trotate([0,rotstep*i,0])translate([-hornrad,0,-.1])cylinder(r1=radstep/5,r2=hornshaft-radstep*i,h=.1);\n\t\t}\n\t}\n}\nmodule bob(hairlen){\n\tdifference(){\n\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\ttranslate([0,0,hm])sphere(rs+hairlen,$fn=res);\n\t\t\tsphere(max(rc,rs)+hairlen,$fn=res);\n\t\t}\n\t\trotate([0,-theta,0])translate([50,0,eyer*1.8-rs])cube([100,100,h],center=true);\n\t\trotate([0,-theta,0])translate([50+rs,0,h/2-50+eyer*1.8])cube([100,100,h],center=true);\n\t\trotate([0,-theta,0])translate([rs,0,h/2+eyer*1.8-rs])rotate([90,0,0])cylinder(r=rs,h=125,center=true,$fn=rec);\n\t\tcube([100,100,rc],center=true);\n\t}\n}\nmodule long(hairlen){\n\tdifference(){\n\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\ttranslate([0,0,hm])sphere(rs+hairlen,$fn=res);\n\t\t\ttranslate([0,0,-rc])sphere(max(rc+hairlen,rs+hairlen)+hairlen,$fn=res);\n\t\t}\n\t\trotate([0,-theta,0])translate([50,0,eyer*1.8-rs])cube([100,100,h],center=true);\n\t\trotate([0,-theta,0])translate([50+rs,0,h/2-50+eyer*1.8])cube([100,100,h],center=true);\n\t\trotate([0,-theta,0])translate([rs,0,h/2+eyer*1.8-rs])rotate([90,0,0])cylinder(r=rs,h=125,center=true,$fn=rec);\n\t\ttranslate([0,0,-rc/2])cube([100,100,rc],center=true);\n\t}\n}\nmodule bowlcut(hairlen){\n\tdifference(){\n\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\ttranslate([0,0,hm])sphere(rs+hairlen,$fn=res);\n\t\t\tsphere(rc+hairlen,$fn=res);\n\t\t}\n\t\trotate([0,-theta,0])translate([0,0,eyer*1.2])cube([100,100,h],center=true);\n\t}\n}\nmodule buzz(hairlen){\n\tintersection(){\n\t\ttranslate([0,0,h+hairlen-rs/2])rotate([0,75,0])cylinder(r=rs*1.5+hairlen,h=150,$fn=res,center=true);\n\t\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,hm])sphere(rs+hairlen,$fn=res);\n\t\t\t\tsphere(rc+hairlen,$fn=res);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([50+rs*2/5,0,-h/2+rs/6+rc+hm])cube([100,125,h],center=true);\n\t\t\t\ttranslate([50+rs*(2/5+1/4),0,-h/2+rs/4+rs/6+rc+hm])cube([100,125,h],center=true);\n\t\t\t\ttranslate([rs*(2/5+1/4),0,rc+hm+rs/6])rotate([90,0,0])cylinder(r=rs/4,h=125,center=true,$fn=rec);\n\t\t\t\ttranslate([50-5*2/3*ear_size/4-2-5*ear_size/4,0,.1])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-5*2/3*ear_size/4,0,h/2])rotate([90,0,0])cylinder(r=2+5*ear_size/4,h=125,center=true,$fn=rec);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule mullet(hairlen,toplen,topwidth){\n\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,hm])sphere(rs+hairlen,$fn=res);\n\t\t\t\ttranslate([0,0,hm])cylinder(r=(rs+hairlen)*topwidth,h=toplen,$fn=res);\n\t\t\t\ttranslate([0,0,-rc])cylinder(r=max(rc,rs)+hairlen,h=1,$fn=rec);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([50+rs*2/5,0,-h/2+rs/6+rc+hm])cube([100,125,h],center=true);\n\t\t\t\ttranslate([50+rs*(2/5+1/4),0,-h/2+rs/4+rs/6+rc+hm])cube([100,125,h],center=true);\n\t\t\t\ttranslate([rs*(2/5+1/4),0,rc+hm+rs/6])rotate([90,0,0])cylinder(r=rs/4,h=125,center=true,$fn=rec);\n\t\t\t\ttranslate([50-5*2/3*ear_size/4-2-5*ear_size/4,0,.1])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-5*2/3*ear_size/4,0,h/2])rotate([90,0,0])cylinder(r=2+5*ear_size/4,h=125,center=true,$fn=rec);\n\t\t\t}\n\t}\n}\nmodule flattop(hairlen,toplen,topwidth){\n\tintersection(){\n\t\ttranslate([0,0,h+hairlen-rs/2])rotate([0,75,0])cylinder(r=rs*1.5+hairlen,h=125,$fn=res,center=true);\n\t\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,hm])sphere(rs+hairlen,$fn=res);\n\t\t\t\ttranslate([0,0,hm])cylinder(r=(rs+hairlen)*topwidth,h=toplen,$fn=res);\n\t\t\t\tsphere(rc+hairlen,$fn=res);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([50+rs*2/5,0,-h/2+rs/6+rc+hm])cube([100,125,h],center=true);\n\t\t\t\ttranslate([50+rs*(2/5+1/4),0,-h/2+rs/4+rs/6+rc+hm])cube([100,125,h],center=true);\n\t\t\t\ttranslate([rs*(2/5+1/4),0,rc+hm+rs/6])rotate([90,0,0])cylinder(r=rs/4,h=125,center=true,$fn=rec);\n\t\t\t\ttranslate([50-5*2/3*ear_size/4-2-5*ear_size/4,0,.1])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-5*2/3*ear_size/4,0,h/2])rotate([90,0,0])cylinder(r=2+5*ear_size/4,h=125,center=true,$fn=rec);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule topbun(hairlen){\n\trotate([0,-theta*1.5,0])translate([0,0,h])scale([1,1,.7])sphere(r=rs/2,$fn=res);\n\tbuzz(hairlen);\n}\nmodule pony(hairlen){\n\trotate([0,0,0])translate([-rs,0,rc+hm])rotate([0,-90-theta,0])union(){\n\t\ttranslate([0,0,rs/7])sphere(r=rs/5,$fn=res);\n\t\thull(){\n\t\t\ttranslate([-rs/3,0,rs/3.5])sphere(r=rs/4.5,$fn=res);\n\t\t\ttranslate([-rs/3-rs/2,0,rs/5])sphere(r=rs/6,$fn=res);\n\t\t}\n\t\thull(){\n\t\t\ttranslate([-rs/3-rs/2,0,rs/5])sphere(r=rs/6,$fn=res);\n\t\t\ttranslate([-rc-hm,0,rs/3])sphere(r=2,$fn=res);\n\t\t}\n\t}\n\tbuzz(hairlen);\n}\nmodule fullbeard(beardlen){\n\trbcut=h/2-nosez+4;\n\trbscale=(rc+beardlen-rs*2/5)/rbcut;\n\tintersection(){\n\t\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,(h/2-rc)])sphere(beardlen+rc+(rs-rc)*((h/2-rc)/hm),$fn=res);\n\t\t\t\ttranslate([rc/3,0,0])scale([2/3,.9,1])sphere(rc+beardlen,$fn=res);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([0,0,h])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-50+3+5*1/3*ear_size/4,0,0])translate([0,0,h/2])rotate([0,theta,0])translate([0,0,-h/2])cube([100,125,1.5*h],center=true);\n\t\t\t\ttranslate([rbcut*rbscale+rs*(2/5),0,h/2])scale([rbscale,1,1])rotate([90,0,0])cylinder(r=rbcut,h=125,center=true,$fn=rec);\n\t\t\t\ttranslate([0,0,mouthz-rc*sin(theta)])scale([1,1.7,1])rotate([0,90,0])intersection(){\n\t\t\t\t\tcylinder(r=rc/4,h=50,$fn=rec);\n\t\t\t\t\ttranslate([rc/2-rc/10,0,0])cylinder(r=rc/2,h=50,$fn=rec*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule chinstrap(beardlen){\n\trbcut=h/2+beardlen;\n\trbscale=(rc+beardlen-rs*2/5)/rbcut;\n\tintersection(){\n\t\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,(h/2-rc)])sphere(beardlen+rc+(rs-rc)*((h/2-rc)/hm),$fn=res);\n\t\t\t\ttranslate([rc/3,0,0])scale([2/3,.9,1])sphere(rc+beardlen,$fn=res);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([0,0,h])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-50+3+5*1/3*ear_size/4,0,0])translate([0,0,h/2])rotate([0,theta,0])translate([0,0,-h/2])cube([100,125,1.5*h],center=true);\n\t\t\t\ttranslate([rbcut*rbscale+rs*(2/5),0,h/2])scale([rbscale,1,1])rotate([90,0,0])cylinder(r=rbcut,h=125,center=true,$fn=rec);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule chops(beardlen){\n\trbcut=h/2-nosez+4;\n\trbscale=(rc+beardlen-rs*2/5)/rbcut;\n\tintersection(){\n\t\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,(h/2-rc)])sphere(beardlen+rc+(rs-rc)*((h/2-rc)/hm),$fn=res);\n\t\t\t\ttranslate([rc/3,0,0])scale([2/3,.9,1])sphere(rc+beardlen,$fn=res);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([0,0,h])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-50+3+5*1/3*ear_size/4,0,0])translate([0,0,h/2])rotate([0,theta,0])translate([0,0,-h/2])cube([100,125,1.5*h],center=true);\n\t\t\t\ttranslate([rbcut*rbscale+rs*(2/5),0,h/2])scale([rbscale,1,1])rotate([90,0,0])cylinder(r=rbcut,h=125,center=true,$fn=rec);\n\t\t\t\ttranslate([0,0,.15*h])rotate([0,-30,0])translate([0,0,-h/4])cube([100,100,h/2],center=true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule soulpatch(beardlen){\n\trbcut=h/2-nosez+4;\n\trbscale=(rc+beardlen-rs*2/5)/rbcut;\n\tintersection(){\n\t\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,(h/2-rc)])sphere(beardlen+rc+(rs-rc)*((h/2-rc)/hm),$fn=res);\n\t\t\t\ttranslate([rc/3,0,0])scale([2/3,.9,1])sphere(rc+beardlen,$fn=res);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([0,0,h])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-50+3+5*1/3*ear_size/4,0,0])translate([0,0,h/2])rotate([0,theta,0])translate([0,0,-h/2])cube([100,125,1.5*h],center=true);\n\t\t\t\ttranslate([rbcut*rbscale+rs*(2/5),0,h/2])scale([rbscale,1,1])rotate([90,0,0])cylinder(r=rbcut,h=125,center=true,$fn=rec);\n\t\t\t\ttranslate([0,0,mouthz-rc*sin(theta)])scale([1,1.7,1])rotate([0,90,0])intersection(){\n\t\t\t\t\tcylinder(r=rc/4,h=50,$fn=rec);\n\t\t\t\t\ttranslate([rc/2-rc/10,0,0])cylinder(r=rc/2,h=50,$fn=rec*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate([0,0,nosez-4-rc/4])scale([1,.5,1])rotate([0,90,0])intersection(){\n\t\t\tcylinder(r=rc/4,h=50,$fn=rec);\n\t\t\ttranslate([rc/2-rc/10,0,0])cylinder(r=rc/2,h=50,$fn=rec*2);\n\t\t}\n\t}\n}\nmodule stache(beardlen){\n\trbcut=h/2-nosez+4;\n\trbscale=(rc+beardlen-rs*2/5)/rbcut;\n\tintersection(){\n\t\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,(h/2-rc)])sphere(beardlen+rc+(rs-rc)*((h/2-rc)/hm),$fn=res);\n\t\t\t\ttranslate([rc/3,0,0])scale([2/3,.9,1])sphere(rc+beardlen,$fn=res);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([0,0,h])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-50+3+5*1/3*ear_size/4,0,0])translate([0,0,h/2])rotate([0,theta,0])translate([0,0,-h/2])cube([100,125,1.5*h],center=true);\n\t\t\t\ttranslate([rbcut*rbscale+rs*(2/5),0,h/2])scale([rbscale,1,1])rotate([90,0,0])cylinder(r=rbcut,h=125,center=true,$fn=rec);\n\t\t\t\ttranslate([0,0,mouthz-rc*sin(theta)])scale([1,1.7,1])rotate([0,90,0])intersection(){\n\t\t\t\t\tcylinder(r=rc/4,h=50,$fn=rec);\n\t\t\t\t\ttranslate([rc/2-rc/10,0,0])cylinder(r=rc/2,h=50,$fn=rec*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate([0,0,nosez-4])scale([1,1.7,1])rotate([0,90,0])intersection(){\n\t\t\tcylinder(r=rc/4,h=50,$fn=rec);\n\t\t\ttranslate([rc/2-rc/10,0,0])cylinder(r=rc/2,h=50,$fn=rec*2);\n\t\t}\n\t}\n}\nmodule goatee(beardlen){\n\trbcut=h/2-nosez+4;\n\trbscale=(rc+beardlen-rs*2/5)/rbcut;\n\tintersection(){\n\t\tdifference(){\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])hull(){\n\t\t\t\ttranslate([0,0,(h/2-rc)])scale([1,.7,1])sphere(beardlen+rc+(rs-rc)*((h/2-rc)/hm),$fn=res);\n\t\t\t\ttranslate([rc/3,0,0])scale([2/3,.7,1])sphere(rc+beardlen,$fn=res);\n\t\t\t}\n\t\t\ttranslate([0,0,rc])rotate([0,-theta,0])translate([0,0,-rc]){\n\t\t\t\ttranslate([0,0,h])cube([100,125,h],center=true);\n\t\t\t\ttranslate([-50+3+5*1/3*ear_size/4,0,0])translate([0,0,h/2])rotate([0,theta,0])translate([0,0,-h/2])cube([100,125,1.5*h],center=true);\n\t\t\t\ttranslate([rbcut*rbscale+rs*(2/5),0,h/2])scale([rbscale,1,1])rotate([90,0,0])cylinder(r=rbcut,h=125,center=true,$fn=rec);\n\t\t\t\ttranslate([0,0,mouthz-rc*sin(theta)])scale([1,1.7,1])rotate([0,90,0])intersection(){\n\t\t\t\t\tcylinder(r=rc/4,h=50,$fn=rec);\n\t\t\t\t\ttranslate([rc/2-rc/10,0,0])cylinder(r=rc/2,h=50,$fn=rec*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trotate([0,90,0])cylinder(r=nosez,h=50,$fn=rec*2);\n\t}\n}\nmodule brows(){\n\ttranslate([0,0,h/2+eyer-hm])rotate([0,-theta,0])translate([0,0,hm])\n\tfor(i=[1,-1])scale([1,i,1])\n\trotate([0,0,atan(-1.2*eyesp/rs)])\n\trotate([eyebrow_tilt,0,0])\n\tintersection(){\n\t\trotate_extrude(convexity=10,$fn=res)translate([rs-eyebrow_thickness/30*3,0,0])circle(r=eyebrow_thickness/10*3,$fn=rec);\n\t\trotate([0,90,0])cylinder(r1=0,r2=rs*eyebrow_length/14,h=2*rs,$fn=rec*2);\n\t}\n}",
    "description": "Okay, I'd like to design a customizable avatar head that can be 3D printed. I want it to be parametric, so I can easily change the size and features. I'd like a few different options for how the model is output; primarily I want a single solid head, but I also want the option to print it in two parts, for dual-extrusion printers. \n\nHere are some features I'd like to be able to control:\n\n**Overall Head Shape:**\n*   **Resolution:** I need a way to control the smoothness of the curves, something like a preview vs. high quality setting.\n*   **Dual Extrusion:** I need three output options - a \"Solid\" head, a \"Dual1\" partial head, and a \"Dual2\" partial head. This allows users with dual-extrusion printers to print two colors in one object\n*   **Height:** A total height parameter (excluding hair)\n*   **Head Tilt:** How far back the head should be tilted. \n*   **Face Width:** Separate parameters for the width of the face at the top and the bottom.\n*   **Neck Thickness:**  A parameter for the thickness of the neck.\n\n**Hair:**\n*   **Hair Type:** I want a dropdown to select from several hair styles (e.g., \"average guy\", \"bald\", \"bowl cut\", \"bob\", \"long\", \"top bun\", \"pony\", \"buzz\", \"fro\", \"monster fro\", \"male pattern\", \"flattop\")\n*   **Hair Length:** A parameter to control hair length, but only for the buzz, male pattern, flattop, and average guy styles.\n\n**Eyes:**\n*   **Eye Type:** A dropdown to choose from eye expressions (e.g., \"average\", \"surprised\", \"sleepy\", \"eye roll\")\n*   **Eye Size:** A parameter to control the eye size.\n*   **Eye Angle:** A parameter to tilt the eyes.\n*   **Eye Spacing:**  A parameter for the distance between the eyes.\n\n**Glasses:**\n*   **Glasses Type:** A dropdown for the type of glasses (e.g., \"none\", \"hipster\", \"circle\", \"coke bottle\")\n\n**Eyebrows:**\n*   **Eyebrow Thickness:** A parameter to set the thickness of the eyebrows.\n*   **Eyebrow Length:** A parameter to set the length of the eyebrows.\n*  **Eyebrow Tilt:** A parameter to control the tilt of the eyebrows.\n\n**Facial Hair:**\n*   **Facial Hair Type:**  A dropdown for facial hair (e.g., \"none\", \"full beard\", \"chin strap\", \"goatee\", \"stache\", \"chops\", \"soul patch\")\n*   **Facial Hair Length:**  A parameter for the length of the facial hair.\n\n**Nose:**\n*   **Nose Type:** A dropdown for nose styles (e.g., \"pointy\", \"upturned\", \"high bridge\", \"wide\", \"average\", \"button\", \"piggy\", \"clown\").\n*   **Nose Size:** A parameter for the overall size of the nose.\n*   **Nose Width:** A parameter for the width of the nose.\n*   **Nose Height:** A parameter for how high the nose sits on the face.\n\n**Mouth:**\n*   **Mouth Type:**  A dropdown for mouth expressions (e.g., \"agape\", \"smiling\", \"chiclet teeth\", \"lipstick\", \"half smile\", \"um...\", \"not feeling well\", \"just stache\", \"oh no\")\n*   **Mouth Size:**  A parameter for the size of the mouth.\n*   **Mouth Height:**  A parameter for the vertical position of the mouth.\n\n**Ears:**\n*   **Ear Type:** A dropdown for ear styles (e.g., \"average\", \"monkey\", \"long\", \"pill shaped\", \"viking horn\")\n*   **Ear Size:** A parameter for the size of the ears.\n*   **Ear Angle:**  A parameter for how far the ears stick out.\n\n**Color:**\n*   **Primary Color:** A dropdown for the primary color of the head.\n*   **Secondary Color:** A dropdown for a secondary color of the head, to be used for hair, beard, glasses and eyebrows.\n\nI'd like to use OpenSCAD for this, and I'd like to use the built-in OpenSCAD functions rather than libraries, if possible. Can you help me with this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parameterised tube coupling generator",
    "scad": "thickness=1.5;\nd1=69;\nh1=5;\nd2=90;\nh2=10;\nc_ht=25;\n$fn=90;\nassemble();\nmodule tube(d,h) {\nrad=d/2;\ndifference() {\ncylinder(h=h,r=rad);\ncylinder(h=h,r=rad-thickness);\n}\n}\nmodule connector(){\ndifference() {\n cylinder (h=c_ht,r1=d1/2,r2=d2/2);\n cylinder (h=c_ht,r1=d1/2-thickness,r2=d2/2-thickness);\n}\n}\nmodule assemble() {\nunion() {\n\ttube(d1,h1);\n\ttranslate([0,0,h1]) connector();\n\ttranslate([0,0,h1+c_ht])  tube(d2,h2);\n\t}\n};",
    "description": "Okay, I need some help designing a flexible coupling generator using OpenSCAD. I've got a new vacuum cleaner and want to be able to connect it to various power tools, and I think a parametric OpenSCAD design is the way to go. I've also realised this might be useful for creating custom lens hoods too, so that's a bonus.\n\nThe basic idea is to create a coupling that consists of three sections: a bottom tube, a connector section, and a top tube. The top and bottom tubes will connect to the vacuum and power tool, and the connector section will join them together.\n\nHere's how I envision the parameters:\n\n*   **`thickness`**: This controls the thickness of the tube walls. It should be consistent for all parts.\n*   **`d1`**: The outside diameter of the bottom tube.\n*   **`h1`**: The height of the bottom tube.\n*   **`d2`**: The outside diameter of the top tube.\n*   **`h2`**: The height of the top tube.\n*   **`c_ht`**: The height of the connector section.\n*   **`$fn`**:  The resolution for the curves, and it should be adjustable.\n\nThe coupling should have these characteristics:\n\n1.  **Tube Sections:** The top and bottom tubes are simple cylinders with a defined outer diameter and wall thickness.\n2.  **Connector Section:** The connector should smoothly transition between the diameters of the top and bottom tubes. It would therefore be a truncated cone. It should also have the same wall thickness as the tubes.\n3.  **Assembly:** The final assembly should seamlessly join the three parts together, i.e. the bottom tube will sit directly on the build plate, then the connector on top of that and then the top tube on top of that.\n\nI think the basic shapes can be done with `cylinder()` and `difference()`, that's how I was trying to do it in a previous attempt. I'm not sure how to smoothly connect the cone section though, so I'd really appreciate some help with that. I think I'll just want a standard OpenSCAD setup, I'm not trying to do anything too fancy, so I shouldn't need any libraries, but please let me know if you think there's a good reason to use one.\n\nCan you generate an OpenSCAD file that achieves this? I'm hoping that by adjusting these parameters I'll be able to generate a variety of custom couplings for my workshop.\n"
  },
  {
    "object": "Hey cadmonkey, make me a FlashSCAD flash diffuser",
    "scad": "flashWidth = 76.7;\nflashDepth = 44.7;\nresolution = 5;\nflashHeight = flashDepth*0.75;\nht = flashWidth*1;\nwd = flashDepth*0.65;\nfn = resolution*2+3;\nsaddle = 2;\nmodule diffuser() {\n\tdifference() {\n\t\tunion() {\n\t\t\ttranslate( [-wd,0,0] )\n\t\t\t\tcylinder( h=ht, r1=wd, r2=wd*.75,$fn=fn );\n\t\t\ttranslate( [wd,0,0] )\n\t\t\t\tcylinder( h=ht, r1=wd, r2=wd*.75, $fn=fn );\n\t\t\ttranslate( [0,-wd/4,0] )\n\t\t\t\tscale( [1,0.7,1] )\n\t\t\t\t\tcylinder( h=ht, r1=wd*2, r2=wd*1.75, $fn=fn*2 );\n\t\t\ttranslate( [0,-wd/3,ht] )\n\t\t\t\trotate( 90,[0,1,0] )\n\t\t\t\t\tscale( [1.7,1.5,1.94] )\n\t\t\t\t\t\tsphere( r=wd, $fn=fn*4 );\n\t\t\t}\n\t\ttranslate( [-wd*5,wd*2.5,wd*.8] )\n\t\t\trotate( 45,[1,0,0] )\n\t\t\t\tcube( [wd*10,wd*10,wd*10] );\n\t}\n}\ndifference() {\n\tunion() {\n\t\tdiffuser();\n\t}\n\t\ttranslate( [-flashWidth/2,-flashDepth/1.6,0] )\n\t\tcube([flashWidth,flashDepth,flashHeight]);\n}",
    "description": "Okay, I'm looking for a more customizable flash diffuser for my camera flash, and I'd like to use OpenSCAD so I can easily tweak the parameters. I've been playing around with a design I found, but I need a more flexible parametric version.\n\nHere's what I'm trying to achieve, based on the existing design I've been modifying:\n\n**Core Design Idea:** The diffuser should essentially be a hollow, rounded shell that slides onto the flash. The light will bounce off the interior surfaces. The key features are:\n\n*   **Main Body:** The main body should have a rounded, almost pill-shaped form, achieved by combining cylinders and a sphere, like in my current attempt. Think of two rounded-edge cylinders joined together, with a central section that's also rounded, and a spherical top.\n*   **Flash Mount:**  There needs to be a rectangular opening that matches the dimensions of my flash unit, so the diffuser can slide onto it. The opening needs to have some tolerance built in (I used `saddle` in my test code, but it could be made more controllable).\n*   **Bounce Plane:** Inside the diffuser, I'd like a large surface tilted to act as a bounce plane. This will direct the light forward in a more diffused manner, not just letting it blast out the front.\n*   **Parametric Dimensions:**  All dimensions need to be easily controlled via variables: flash width, flash depth, diffuser overall width and depth, mounting tolerance (saddle), and a resolution setting for the curvature.\n\n**Specific Parameters:**\n\n*   `flashWidth`: The width of the flash unit.\n*   `flashDepth`: The depth of the flash unit.\n*   `flashHeight`: (Derived, but important) Height of the flash unit section the diffuser needs to fit over.\n*   `diffuserWidth`: Overall width of the diffuser (can be linked or not to flashWidth, but it needs to be variable.)\n*   `diffuserDepth`: Overall depth of the diffuser (also variable).\n*   `diffuserHeight`: Overall height of the diffuser, may be linked to other vars (should be tunable).\n*   `saddle`: Tolerance around flash opening for easy mounting.\n*   `resolution`: Controls the smoothness/fineness of the curves (number of facets).\n*   `bouncePlaneAngle`: Angle of the internal bounce plane.\n*   `bouncePlaneOffset`: Offset of the bounce plane from the center.\n*   `bouncePlaneSize`: Size of the bounce plane.\n\n**Current Issues with my Attempt:**\n\n*   The way I'm joining the cylinders and the sphere isn't that flexible; I'd like to be able to tweak their dimensions and positions more easily.\n*   Id like the ability to control the tilt of the bounce plane and how much of the flash is enclosed.\n*   The overall look of the diffuser needs to be more adjustable.\n*   My original idea had some internal scaling to make the diffuser slightly thicker than the exterior shape that I'd like to reintroduce. This will also need to be controlled by a variable.\n\n**Libraries:**\n\nI don't think I need any special libraries, just standard OpenSCAD functions, but please let me know if you think a specific library might be useful.\n\n**Request:**\n\nCould you design a parametric OpenSCAD file that implements this functionality? I need to be able to change all the parameters I've listed and see the resulting diffuser shape update automatically. The code should be well-commented so I can understand how the design is built up, and it should be easy to modify the overall look of the diffuser later on if I need to.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Carabiner",
    "scad": "radius1 = 6;\nradius2 = 11;\nlength = 36;\nwidth = 6;\nheight = 6;\ngap = 0.39;\noverhang = 40;\nrounded = 1;\n$fs=0.3*1;\n$fa=5*1;\nmodule loop( height, length, width, radius1, radius2 )\n{\n\tminkowski()\n\t{\n\t\ttranslate([0,0,rounded])\n\t\tdifference()\n\t\t{\n\t\t\tswept_cylinder( height-2*rounded, length, radius1+width-rounded, radius2+width-rounded );\n\t\t\tswept_cylinder( height-2*rounded, length, radius1+rounded, radius2+rounded );\n\t\t}\n\t\tdiamond();\n\t}\n}\nthick = 1.2*1;\ndifference()\n{\n\tdifference()\n\t{\n\t\tloop( height, length, width, radius1, radius2 );\n\t\tdifference()\n\t\t{\n\t\t\ttranslate([0,0,thick])\n\t\t\tloop( height-2*thick, length, width-2*thick, radius1+thick, radius2+thick );\n\t\t\tcube([3*radius1+width,3*radius1+width,3*radius1+width],true);\n\t\t\ttranslate([length-(thick/cos(60)),radius2-width,height*0.5])\n\t\t\trotate([0,45,60])\n\t\t\t{\n\t\t\t\tcube([height*2, length, gap+2*thick]);\n\t\t\t\tcube([gap+2*thick, length, height*2]);\n\t\t\t}\n\t\t}\n\t}\n\ttranslate([length,radius2-width,height*0.5])\n\trotate([0,45,60])\n\t{\n\t\tcube([height*2, length, gap]);\n\t\tcube([gap, length, height*2]);\n\t}\n}\nmodule swept_cylinder( height, length, radius1, radius2 )\n{\n\thull()\n\t{\n\t\tcylinder( height, radius1, radius1 );\n\t\ttranslate( [length,0,0] )\n\t\tcylinder( height, radius2, radius2 );\n\t}\n}\nmodule cutter(dist, overhang)\n{\n\tsize = dist*2;\n\ttranslate([dist,-dist,-dist])\n\tcube([size,size,size]);\n\ttranslate([-dist-size,-dist,-dist])\n\tcube([size,size,size]);\n\ttranslate([dist,-dist,0])\n\trotate([0,-overhang,0])\n\tcube([size,size,size]);\n\ttranslate([-dist,-dist,0])\n\trotate([0,-90+overhang,0])\n\tcube([size,size,size]);\n\ttranslate([dist,-dist,0])\n\trotate([0,90+overhang,0])\n\tcube([size,size,size]);\n\ttranslate([-dist,-dist,0])\n\trotate([0,180-overhang,0])\n\tcube([size,size,size]);\n}\nmodule diamond()\n{\n\tdist = rounded;\n\tdifference()\n\t{\n\t\tcube([2*rounded,2*rounded,2*rounded], true);\n\t\tfor(i=[0:45:179])\n\t\t{\n\t\t\trotate([0,0,i])\n\t\t\tcutter(dist, overhang);\n\t\t}\n\t}\n}",
    "description": "Okay, I'm looking to create a custom carabiner for my keyring, similar to one I saw online. I'd like to be able to adjust several key dimensions and have it be relatively smooth.\n\nHere are the features I'm looking for:\n\n1.  **Shape:** The basic shape should be a loop formed by connecting two cylinders of different radii.  The smaller cylinder radius will be at one end, and the larger radius at the other. These cylinders are not complete circles, rather they are partial cylinders that combine to form a C-shape with a constant height.\n\n2.  **Parameters:** I want to control these parameters:\n    *   `radius1`: The radius of the smaller cylinder.\n    *   `radius2`: The radius of the larger cylinder.\n    *   `length`: The distance between the centers of the two cylinders.\n    *   `width`:  The thickness of the carabiner body.\n    *   `height`: The height of the carabiner body.\n    *   `gap`: The width of a gap that cuts through the carabiner to allow it to be opened. This gap should be implemented by two rectangular cuts through the body, angled at 45/60 degrees in the X/Y/Z plane of rotation so the gap is diagonal through the body.\n    *   `overhang`: An angle (in degrees) that specifies how much of an overhang the printer should be able to manage when making the bevels. The bevels will be generated using Minkowski sums.\n    *   `rounded`: The width (in mm) of the rounded, bevelled edge.\n\n3.  **Construction:**\n    * The main body should be created with a `minkowski()` to add rounded bevels to the carabiner's edges. The bevel should be subtracted from the original shape to create rounded edges at the ends of the extruded body.\n    * The base shape is constructed using a `swept_cylinder()` module, which is really a hull of two cylinders to create a smooth curve connecting the radii. This module will need parameters for height, length, and the two radii.\n    * The gap should be a subtractive cut, and should use rotated cubes so the gap is diagonal through the body.\n\n4.  **Hollow Core:** I'd like the final design to be hollow to reduce material usage, leaving the solid shell of the carabiner. This should be achieved by a difference of a slightly smaller copy of the main shape. The shell thickness will need to be an additional parameter, `thick`, so that the body is hollowed out.\n\n5. **Bevel Details:** The edges should have a bevelled profile. This should be created with a `diamond()` module, which uses a `cutter()` module to make the bevels. The `cutter()` module uses several rotated cubes with respect to the bevel angle to create the bevel on the Minkowski operation.\n\n6.  **Libraries:** I am not aware of any specific libraries that would be helpful, so no library usage is required. I would like you to provide all necessary modules.\n\n7.  **Smoothness:** I'd like the resulting model to be smooth. Using `$fs` and `$fa` variables to manage the smoothness of the generation would be preferable.\n\nCan you provide an OpenSCAD file that implements these features?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Child Safety Latch",
    "scad": "$fn=30*1;\nuse <utils/build_plate.scad>\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nknob_diameter=10;\nknob_distance=80;\ntranslate([0,0,2.5]) safety_clip(length=knob_distance, knob_d=knob_diameter);\nmodule safety_clip(length, knob_d=9) {\n  knob_r=(knob_d+1)/2;\n  difference() {\n    union() {\n      difference(){\n        linear_extrude(height=5,center=true)\n            polygon(points=[[-length/2-knob_r,-knob_d],[-length/2-knob_r,knob_d-1],[length/2+knob_r,knob_d+1],[length/2+knob_r,-(knob_d+2)]]);\n        hull(){\n          translate([-(length/2-knob_d),-(knob_d-6),-4]) cylinder(r=2,h=8);\n          translate([-(length/2-knob_d/1.58),knob_d-6,-4]) cylinder(r=2,h=8);\n          translate([length/2-knob_d/1.465,knob_d-6,-4]) cylinder(r=2,h=8);\n          translate([length/2-knob_d,-(knob_d-6),-4]) cylinder(r=2,h=8);\n        }\n      }\n      translate([-length/2-knob_r,0,0]) cylinder(r=knob_d,h=5,center=true);\n      translate([length/2+knob_r,0,0]) cylinder(r=knob_d+2,h=5,center=true);\n    }\n    translate([-length/2-knob_r,0,0]) cylinder(r=knob_r,h=7,center=true);\n    translate([-length/2-knob_r,5,0]) linear_extrude(height=9,center=true)\n        polygon(points=[[-knob_r,-5],[knob_r,-5],[knob_r/1.58,knob_r+3],[-knob_r/1.58,knob_r+3]]);\n    translate([length/2+knob_r,0,0]) cylinder(r=knob_r,h=7,center=true);\n    translate([length/2+knob_r,5,0]) linear_extrude(height=9,center=true)\n        polygon(points=[[-knob_r,-5],[knob_r,-5],[knob_r/1.465,knob_r+5],[-knob_r/1.465,knob_r+5]]);\n  }\n}",
    "description": "Okay, I'm looking to create a customizable child safety latch that I can 3D print. I want it to work by having two knobs on either side of a door or cabinet, and a clip that slides onto those knobs to hold the door closed.\n\nThe design should consist of a main body that is essentially a flat bar with cylindrical ends. One end needs to be a slightly tighter fit than the other, allowing that end to act as a hinge when the latch is used. The other end will act as the hook or latch, sliding onto the second knob.\n\nHere's a more detailed breakdown of what I need:\n\n*   **Knobs:** The latch attaches to two knob-like protrusions. I need to be able to customize the diameter of these knobs (the `knob_diameter` parameter in the provided code), but the hole in the latch for the 'hinge' knob should be slightly larger than the hole for the 'latch' knob to allow it to move. The latch should slide on to the knobs and only be released from the knobs with the latch rotated to it's maximum range of motion.\n*   **Distance:** I need to be able to specify the distance between the knob centers (the `knob_distance` parameter in the provided code).\n*   **Main Body:** The main body of the latch should be a flat extrusion that connects the cylindrical ends. It needs to be strong enough to resist a child's attempts to open it. The width and height should scale with the knob diameter to ensure a secure fit.\n*   **Hole Creation:** The holes for the knobs should be created by subtracting cylindrical volumes from the body of the latch. The 'hinge' hole should be slightly larger than the 'latch' hole as noted above.\n*   **No Additional Hardware:** The entire latch should be 3D printable in one piece, with no need for any extra parts like screws or springs.\n*   **Build Plate:** Since this is to be 3D printed, I need to make sure to make the build plate selection is available as a configurable parameter and can change size based on selections. I need to be able to select between a Replicator 2, Replicator, Thingomatic, and Manual build plates. The manual build plate selection needs to have configuration options for the build plate's x and y dimensions.\n\nI'd like an OpenSCAD file that I can modify to adjust all of these parameters. I also need to be able to render the object with a build plate for visualization purposes. Please include the `utils/build_plate.scad` library.\n\nAlso include safety considerations in the comment section of the generated code to make sure users know that it's not baby proof but can be used as a baby resistant solution.\n\nCould you generate the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Parametric Round Box",
    "scad": "part = \"both\";\nDiameter = 80;\nHeight = 20;\nNumber_of_Sections = 6;\nPin_or_Hole = \"Pin\";\ndiameter = Diameter;\nheight = Height;\nsections = Number_of_Sections;\nwall_thickness = 1.2;\npin = Pin_or_Hole;\nif (part == \"first\") {\n\t\tround_box(diameter, height, sections, wall_thickness, pin);\n\t} else if (part == \"second\") {\n\t\tround_box_cover(diameter, sections, wall_thickness, pin);\n\t} else if (part == \"both\") {\n      round_box(diameter, height, sections, wall_thickness, pin);\n\t\ttranslate([0, diameter+10, 0]) round_box_cover(diameter, sections, wall_thickness, pin);\n\t} else {\n\t\tboth();\n\t}\nmodule round_box(diameter, height, sections, wall_thickness, pin) {\n\tdifference() {\n\t\tcylinder(h=height, r=diameter/2);\n\t\tif (pin == \"Hole\") {\n\t\t\tcylinder(h=height, r=1.25);\n\t\t}\n\t\tdifference() {\n\t\t\ttranslate([0, 0, wall_thickness]) cylinder(h=height, r=diameter/2-wall_thickness);\n\t\t\tcylinder(h=height, r=4);\n\t\t}\n\t}\n\tfor(i=[1:sections]) {\n\t\trotate([0, 0, i * 360/sections]) translate([-wall_thickness/2, wall_thickness*2, 0]) cube([wall_thickness, diameter/2-wall_thickness*3, height]);\n\t}\n\tif (pin == \"Pin\") {\n\t\ttranslate([0, 0, height]) pin(h=wall_thickness*3);\n\t}\n}\nmodule round_box_cover(diameter, sections, wall_thickness, pin) {\n\tdifference() { union() {\n\t\tdifference() {\n\t\t\tcylinder(h=wall_thickness*3, r=diameter/2);\n\t\t\tdifference() {\n\t\t\t\tcube([diameter, diameter, wall_thickness*3]);\n\t\t\t\trotate([0, 0, 360/sections]) cube([diameter, diameter, wall_thickness*3]);\n\t\t\t}\n\t\t}\n\t\t\tcylinder(h=wall_thickness*3, r=6);\n\t\t}\n\t\tif (pin == \"Pin\") {\n\t\t\tpinhole(h=wall_thickness*3);\n\t\t} else {\n\t\t\tcylinder(h=wall_thickness*3, r=1.5);\n\t\t}\n\t}\n}\nmodule test() {\n  tolerance = 0.3;\n  translate([-12, 12, 0]) pinpeg(h=20);\n  translate([12, 12, 0]) pintack(h=10);\n  difference() {\n    union() {\n      translate([0, -12, 2.5]) cube(size = [59, 20, 5], center = true);\n      translate([24, -12, 7.5]) cube(size = [12, 20, 15], center = true);\n    }\n    translate([-24, -12, 0]) pinhole(h=5, t=tolerance);\n    translate([-12, -12, 0]) pinhole(h=5, t=tolerance, tight=false);\n    translate([0, -12, 0]) pinhole(h=10, t=tolerance);\n    translate([12, -12, 0]) pinhole(h=10, t=tolerance, tight=false);\n    translate([24, -12, 15]) rotate([0, 180, 0]) pinhole(h=10, t=tolerance);\n  }\n}\nmodule pinhole(h=10, r=4, lh=3, lt=1, t=0.3, tight=true) {\n  union() {\n    pin_solid(h, r+(t/2), lh, lt);\n    cylinder(h=h+0.2, r=r);\n    if (tight == false) {\n      cylinder(h=h+0.2, r=r+(t/2)+0.25);\n    }\n    translate([0, 0, -0.1]) cylinder(h=lh/3, r2=r, r1=r+(t/2)+(lt/2));\n  }\n}\nmodule pin(h=10, r=4, lh=3, lt=1, side=false) {\n  if (side) {\n    pin_horizontal(h, r, lh, lt);\n  } else {\n    pin_vertical(h, r, lh, lt);\n  }\n}\nmodule pintack(h=10, r=4, lh=3, lt=1, bh=3, br=8.75) {\n  union() {\n    cylinder(h=bh, r=br);\n    translate([0, 0, bh]) pin(h, r, lh, lt);\n  }\n}\nmodule pinpeg(h=20, r=4, lh=3, lt=1) {\n  union() {\n    translate([0, -h/4+0.05, 0]) pin(h/2+0.1, r, lh, lt, side=true);\n    translate([0, h/4-0.05, 0]) rotate([0, 0, 180]) pin(h/2+0.1, r, lh, lt, side=true);\n  }\n}\nmodule pin_vertical(h=10, r=4, lh=3, lt=1) {\n  difference() {\n    pin_solid(h, r, lh, lt);\n    translate([-r*0.5/2, -(r*2+lt*2)/2, h/4]) cube([r*0.5, r*2+lt*2, h]);\n    translate([0, 0, h/4]) cylinder(h=h+lh, r=r/2.5, $fn=20);\n    translate([-r*2, -lt-r*1.125, -1]) cube([r*4, lt*2, h+2]);\n    translate([-r*2, -lt+r*1.125, -1]) cube([r*4, lt*2, h+2]);\n  }\n}\nmodule pin_horizontal(h=10, r=4, lh=3, lt=1) {\n  translate([0, h/2, r*1.125-lt]) rotate([90, 0, 0]) pin_vertical(h, r, lh, lt);\n}\nmodule pin_solid(h=10, r=4, lh=3, lt=1) {\n  union() {\n    cylinder(h=h-lh, r=r, $fn=30);\n    translate([0, 0, h-lh]) cylinder(h=lh*0.25, r1=r, r2=r+(lt/2), $fn=30);\n    translate([0, 0, h-lh+lh*0.25]) cylinder(h=lh*0.25, r=r+(lt/2), $fn=30);\n    translate([0, 0, h-lh+lh*0.50]) cylinder(h=lh*0.50, r1=r+(lt/2), r2=r-(lt/2), $fn=30);\n  }\n}",
    "description": "Okay, I'd like to design a parametric round box and lid using OpenSCAD. I've found a good starting point, but it needs some improvements and I need a few more options.\n\nHere's what I want:\n\n**Core Functionality:**\n\n*   **Parametric Round Box and Lid:** I need a design for a round box and a matching lid. Both parts should be parametric, meaning I can adjust their dimensions using variables.\n*   **Customizable Dimensions:** I need to be able to control the following:\n    *   **Diameter:** The overall diameter of the box and lid.\n    *   **Height:** The height of the box (the lid's height should be related to the wall thickness).\n    *   **Number of Sections:** This should control how many \"ribs\" or supports are around the inside of the box.\n    *  **Wall Thickness**: The thickness of the walls of the box, which should also drive the lid's height.\n*   **Lid Attachment Options:**\n    *   **Pin Connector:** A \"click\" style pin connector for the lid, like the one from the included code.\n    *   **M3 Screw Option:** The option for a hole sized for an M3 screw if I don't want to use the pin connector.\n\n**Specific Design Requirements:**\n\n*   **Pin Connector Dimensions:** The pin connector and hole should be parametric based on the wall thickness. The pin should be 3 times the wall thickness.\n*   **Pin Connector Improvements:**\n    *   **Tolerance Control:** I'd like a way to easily adjust the tolerance for the pin and hole connection, maybe with a global variable. I want to be able to choose a tight fit or a loose fit.\n    *   **Improved Pin Design:** I'd like to use the improved pin connector design from the included code, which includes the lip and cutouts.\n*   **Customizer Compatibility:** The design should be fully customizable using OpenSCAD's customizer.\n\n**User Interface:**\n\n*   **Dropdown for Part:**  I need a dropdown menu to select if I want to render just the box, just the lid, or both together.\n*   **Input fields:**  I need number input fields for the Diameter, Height, and Number_of_Sections.\n*   **Dropdown for Pin/Hole:**  I need a dropdown to select between the \"pin\" connector and the screw \"hole\" for the lid.\n\n**Libraries:**\n\nI'm providing the pin connector code, so we don't need to pull that from a library, but I'm *not* providing a `pins.scad` file; this code is self contained.  There are no other libraries to include.\n\nCould you generate the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Phone Tripod Mount",
    "scad": "phone_width=7.05;\nbase_width=43.25;\nbase_height=9.1;\nbase_inset=4.1;\nbase_cutout = 0.8;\nholder_width=10;\nholder_height=20;\nbase_width_2 = base_width + base_cutout;\nphone_width_2 = phone_width + 0.05;\nunion() {\nintersection() {\n\tpolyhedron(points=[[-base_cutout,-base_cutout,0],\n                   [base_inset,base_inset,base_height],\n                   [-base_cutout,base_width+base_cutout,0],\n                   [base_inset,base_width-base_inset,base_height],\n                   [base_width+base_cutout,base_width+base_cutout,0],\n                   [base_width-base_inset,base_width-base_inset,base_height],\n                   [base_width+base_cutout,-base_cutout,0],\n                   [base_width-base_inset,base_inset,base_height]],\n           triangles=[[2,1,0],[1,2,3],[4,3,2],[3,4,5],[6,5,4],[5,6,7],[0,7,6],[7,0,1],\n\t\t\t\t     [4,2,0],[0,6,4],[1,3,5],[5,7,1]]\n           );\n\tcube([base_width,base_width,50]);\n}\ntranslate([base_inset,base_width-base_width/2-holder_width-phone_width/2,base_height])\n\tcube([base_width-base_inset*2,holder_width,holder_height]);\ntranslate([base_inset,base_width-base_width/2+phone_width/2,base_height])\n\tcube([base_width-base_inset*2,holder_width,holder_height]);\n}",
    "description": "Okay, I need help designing a phone mount for my tripod. I've seen a design on Thingiverse that's close, but I need to make it parametric so I can easily adjust it for different phone and tripod sizes. I'd like the design to be in OpenSCAD.\n\nBasically, the mount needs to have a base that fits my tripod's quick-release plate, and a top section that holds a phone securely. The phone is held in place by two parallel rectangular bars, creating a slot for the phone to slide into.\n\nHere are the key features and parameters I need to control:\n\n*   **`phone_width`**: The thickness of the phone, so I can set the correct gap between the holder bars.\n*   **`base_width`**: The width of my tripod's quick-release plate base.\n*   **`base_height`**: The height of the slanted part of the tripod mount base.\n*   **`base_inset`**: The horizontal distance between the edge of the base and where the slope starts.\n*   **`base_cutout`**: An additional amount to add to the bottom width before clipping the base, essentially how far the mount's base extends beyond the width of the tripod base.\n*   **`holder_width`**: The width of the rectangular bars that hold the phone.\n*   **`holder_height`**: The height of those same holding bars.\n\nThe base of the mount should have a slanted shape. Think of it like a squashed trapezoid, where the bottom is wider than the top. The code should generate this slanted shape using the `base_width`, `base_height`, `base_inset`, and `base_cutout` parameters. It then needs to be cut so that it is limited to the width of the tripod base `base_width`.\n\nThe phone holder consists of two parallel rectangular bars positioned on top of the base to create the slot for the phone. Their position is determined by the `base_inset` parameter and `phone_width`. I'd like to make sure there is a tiny bit of extra space between the holder bars so the phone can easily slide in (like maybe 0.05mm extra, you can call that `phone_width_2` to keep it separate).\n\nI'd like this to be built using OpenSCAD with parametric variables at the start of the file so I can easily customize it without modifying the core code logic. I do not need any specific libraries.\n\nCan you please provide me with the OpenSCAD code for this design? Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Bracket generator parameterized",
    "scad": "length = 70;\nwidth = 10;\nthickness = 2.5;\nholecount=3;\nholediameter=2.5;\nouters=1;\nmodule Bracket(l,w,t) {\n$fn=35;\nintersection(){\n\tdifference() {\n\t\tunion() {\n\t\t\ttranslate([-t,-t,0]) cube( size=[t,t+1,w]);\n\t\t\ttranslate([0,-t,0]) cube( size=[l,t,w]);\n\t\t\trotate ([0,0,90]) cube( size=[l,t,w]);\n\t\t\ttranslate ([l-t,l-t,0]) hoop(l,w,t);\n\t\t\t}\n\t\tsmallholes();\n\t\tif (outers) largeholes();\n\t\t}\n\ttranslate([-t,-t,-1]) cube ( size=[l+t,l+t,w+2]);\n\t}\n}\nmodule hoop(l,w,t) {\nn=20;\ndifference(){\n\t\t\tcylinder(h=w,r1=l,r2=l) ;\n\t\t\tcylinder(h=w,r1=l-t,r2=l-t) ;\n\t\t}\n}\nmodule smallholes() {\n\tn=length/(holecount+1);\n   for (i=[0:holecount-1]) {\n\t\ttranslate ([n-thickness+i*n,0,width/2]) rotate(a=[90,90,0]) cylinder(h=thickness+1,r1=holediameter/2,r2=holediameter/2);\n\t\ttranslate ([-thickness,n-thickness+i*n,width/2]) rotate([90,0,90]) cylinder(h=thickness,r1=holediameter/2,r2=holediameter/2);\n\t}\n}\nmodule largeholes() {\n\tlhm=1.4;\n\tn=length/(holecount+1);\n   for (i=[0:holecount-1]) {\n\t\ttranslate ([n-thickness+i*n,length,width/2]) rotate(a=[90,90,0]) cylinder(h=length,r1=holediameter/lhm,r2=holediameter/lhm);\n\t\ttranslate ([0,n-thickness+i*n,width/2]) rotate([90,0,90]) cylinder(h=length,r1=holediameter/lhm,r2=holediameter/lhm);\n\t}\n}\nBracket(length-thickness,width,thickness);",
    "description": "Okay, I'm looking to generate some corner brackets for shelves and other projects. I've got a basic idea, but I want the design to be easily customizable. I'm thinking of a bracket with two perpendicular arms and a curved reinforcing section at the corner. I need to be able to adjust the length and width of the arms, as well as the thickness of the material. I'd like a variable number of holes along both arms, and the holes should be a specific diameter. I'm also thinking about a slightly smaller hole size for the holes on the curved bit, maybe based on a fraction of the main hole diameter. Finally, I want an option to make the holes in the arms either through-holes or just indentations.\n\nSo, to summarize:\n\n*   **Bracket Shape:**  Two perpendicular arms joined by a curved corner section.\n*   **Adjustable Parameters:**\n    *   `length`: Length of each arm (both arms are the same length).\n    *   `width`: Width of the bracket (same for both arms and the curve).\n    *   `thickness`: Thickness of the bracket.\n    *   `holecount`: Number of holes along each arm.\n    *   `holediameter`: Diameter of the main holes.\n    *   `outers`: Boolean to switch between thru holes or indentations on the arms.\n\n*   **Hole Features:**\n    *   Holes along each arm, evenly spaced, with `holediameter`.\n    *   Holes in the curved corner section that are a smaller diameter, say `holediameter / 1.4`.\n\n*   **Libraries:** I don't want any external libraries used.\n\nCould you generate an OpenSCAD file that produces this bracket, allowing me to adjust all of these parameters easily?\n"
  },
  {
    "object": "Hey cadmonkey, make me a custiomizable servo pulley",
    "scad": "pulley_diameter = 25;\ngrove_size=3;\nOpeningAngle = 100;\ncutout=5;\nhole_diam=2;\nhorn_type = 1;\nhorn_drill_diam = 1.5;\nhorn_height = 6;\nhorn_plate_height = 2;\nwheel_or_idiam = pulley_diameter;\nwheel_or_diam = grove_size;\nwheel_height = 2*wheel_or_diam+0;\nrh_diam1 = 8.5;\nrh_diam2 = 21.5;\nrounded_horn_drill_distance = 7.3;\na4h_end_diam = 5;\na4h_center_diam = 10;\na4h_arm_length = 15;\na4h_drill_distance = 13.3;\na6h_end_diam = 5;\na6h_center_diam = 10;\na6h_arm_length=10;\na6h_arm_base_diam=7.5;\na6h_drill_distance = 10.9;\nmodule raw_wheel(or_idiam=50, or_diam=3, h=6)\n{\n   r = or_idiam/2 + or_diam;\n  l = or_diam*sqrt(2)/2;\n  difference() {\n    cylinder (r=r, h=h, $fn=100,center=true);\n difference() {\n    rotate_extrude($fn=100)\n      translate([r-or_diam/2,0,0])\n      polygon( [ [0,0],[l,l],[l,-l] ] , [ [0,1,2] ]);\nrotate([0,0,-OpeningAngle/2]) translate([-1,wheel_or_idiam/2-hole_diam/2,-wheel_height/2]) cube([wheel_height/2+1,wheel_height,wheel_height]);\nrotate([0,0,OpeningAngle/2]) translate([-wheel_height/2+1,wheel_or_idiam/2-hole_diam/2,-wheel_height/2]) cube([wheel_height/2+1,wheel_height,wheel_height]);\n}\n translate([0,0,-wheel_height/2-1]){\nrotate([0,0,OpeningAngle/4-0.05]) intersection() {\n\t\t\trotate([0,0,OpeningAngle/4]) cube([wheel_or_idiam+wheel_or_diam+1,wheel_or_idiam+wheel_or_diam+1,wheel_height+2]);\n\t\t\trotate ([0,0,-OpeningAngle/4]) translate([-(wheel_or_idiam+wheel_or_diam+1),0,0]) cube([wheel_or_idiam+wheel_or_diam+1,wheel_or_idiam+wheel_or_diam+1,wheel_height+2]);\ndifference() {\n\t\t\tcylinder(r=wheel_or_idiam/2+wheel_or_diam+1,h=wheel_height+2);\ncylinder(r=(wheel_or_idiam/2+wheel_or_diam+1)-cutout,h=wheel_height+2);\n}\n\t\t}\nrotate([0,0,-OpeningAngle/4+0.05]) intersection() {\n\t\t\trotate([0,0,OpeningAngle/4]) cube([wheel_or_idiam+wheel_or_diam+1,wheel_or_idiam+wheel_or_diam+1,wheel_height+2]);\n\t\t\trotate ([0,0,-OpeningAngle/4]) translate([-(wheel_or_idiam+wheel_or_diam+1),0,0]) cube([wheel_or_idiam+wheel_or_diam+1,wheel_or_idiam+wheel_or_diam+1,wheel_height+2]);\ndifference() {\n\t\t\tcylinder(r=wheel_or_idiam/2+wheel_or_diam+1,h=wheel_height+2);\ncylinder(r=(wheel_or_idiam/2+wheel_or_diam+1)-cutout,h=wheel_height+2);\n}\n\t\t}\n}\nrotate([0,-90,OpeningAngle/2]) translate([0,wheel_or_idiam/2+hole_diam/2,-1]) cylinder(r = hole_diam/2, h = wheel_or_idiam,$fn=100);\nrotate([0,90,-OpeningAngle/2]) translate([0,wheel_or_idiam/2+hole_diam/2,-1]) cylinder(r = hole_diam/2, h = wheel_or_idiam,$fn=100);\n  }\n}\nmodule horn_drills(d,n,h)\n{\n  union() {\n    for ( i = [0 : n-1] ) {\n        rotate([0,0,i*360/n])\n        translate([0,d,0])\n        cylinder(r=horn_drill_diam/2, h=h+10,center=true, $fn=6);\n      }\n  }\n}\nmodule horn4_arm(h=5)\n{\n  translate([0,a4h_arm_length-a4h_end_diam/2,0])\n  hull() {\n    cylinder(r=a4h_end_diam/2, h=h, center=true, $fn=20);\n    translate([0,1-a4h_arm_length+a4h_end_diam/2,0])\n      cube([a4h_center_diam,2,h],center=true);\n  }\n}\nmodule horn6_arm(h=5)\n{\n  translate([0,a6h_arm_length-a6h_end_diam/2,0])\n  hull() {\n    cylinder(r=a6h_end_diam/2, h=h, center=true, $fn=20);\n    translate([0,-a6h_arm_length+a6h_end_diam/2,0])\n    cube([a6h_arm_base_diam,0.1,h],center=true);\n  }\n}\nmodule horn4(h=5)\n{\n  union() {\n    cube([a4h_center_diam+0.2,a4h_center_diam+0.2,h],center=true);\n    for ( i = [0 : 3] ) {\n      rotate( [0,0,i*90])\n      translate([0, a4h_center_diam/2, 0])\n      horn4_arm(h);\n    }\n  }\n}\nmodule horn6(h=5)\n{\n  union() {\n    cylinder(r=15/2,h=h,center=true);\n    for ( i = [0 : 5] ) {\n      rotate( [0,0,i*60])\n      translate([0, 15/2*cos(30), 0])\n      horn6_arm(h);\n    }\n  }\n}\nmodule Servo_wheel_rounded_horn()\n{\n  difference() {\n      raw_wheel(or_idiam=wheel_or_idiam, or_diam=wheel_or_diam, h=wheel_height);\n      cylinder(center=true, h=2*wheel_height + 10, r=rh_diam1/2+0.2,$fn=100);\n      translate([0,0,-wheel_height/2+horn_height-horn_plate_height])\n       cylinder(r=rh_diam2/2+0.25, h=2*wheel_height+10,$fn=30);\n      horn_drills(d=rounded_horn_drill_distance, n=4, h=wheel_height);\n  }\n}\nmodule Servo_wheel_4_arm_horn()\n{\n  difference() {\n      raw_wheel(or_idiam=wheel_or_idiam, or_diam=wheel_or_diam, h=wheel_height);\n      cylinder(center=true, h=2*wheel_height + 10, r=a4h_center_diam/2,$fn=20);\n      translate([0,0,horn_height-horn_plate_height])\n        horn4(h=wheel_height);\n      horn_drills(d=a4h_drill_distance, n=4, h=wheel_height);\n  }\n}\nmodule Servo_wheel_6_arm_horn()\n{\n  difference() {\n      raw_wheel(or_idiam=wheel_or_idiam, or_diam=wheel_or_diam, h=wheel_height);\n      cylinder(center=true, h=2*wheel_height + 10, r=a6h_center_diam/2,$fn=20);\n      translate([0,0,horn_height-horn_plate_height])\n      horn6(h=wheel_height);\n      horn_drills(d=a6h_drill_distance, n=6, h=wheel_height);\n  }\n}\nif( horn_type== 1) Servo_wheel_rounded_horn();\nif( horn_type== 2) Servo_wheel_4_arm_horn();\nif( horn_type== 3) Servo_wheel_6_arm_horn();",
    "description": "Okay, I'm looking for a customizable servo pulley design in OpenSCAD. I need it to have a few key features:\n\n1.  **Pulley Parameters:**\n    *   I need to be able to specify the *pulley diameter*.\n    *   I need to control the *size of the groove* where the string or cable will sit.\n    *   There should be a cutout section on the pulley that allows the string to exit or enter. I need to be able to adjust the *angle of this cutout* and also its *depth*.\n    *   I need to specify the *diameter of the hole* where the string passes through the side of the pulley.\n \n2. **Servo Horn Compatibility:**\n    *   I need the design to be able to accommodate different styles of servo horns, specifically:\n        *   Rounded horns (like on the Futaba 3003)\n        *   4-arm horns (Futaba 3003 style)\n        *   6-arm horns (Futaba 3003 style)\n    *   There should be parameters for things like the *drill diameter* used on the servo horns, the overall *horn height*, and the *height of the mounting plate*.\n\n3. **Detailed Parametric Control:**\n    *   I need parameters to control the specific dimensions for each horn style:\n        *   For rounded horns: Small and large diameters, and the drill distance.\n        *   For 4-arm horns: end diameter, center diameter, arm length, and drill distance.\n        *   For 6-arm horns: end diameter, center diameter, arm length, base diameter, and drill distance.\n    *   I want to be able to specify the *overall wheel height*.\n\n4.  **OpenSCAD Implementation**\n    * I expect this to be a single file, and I will expect to be able to render it as is, without needing to include additional code from any external libraries, though I understand you may use functions within OpenSCAD itself.\n\nCan you generate a parametric OpenSCAD file that implements all of these features?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Lithopane",
    "scad": "use <utils/build_plate.scad>\nuse <write/Write.scad>\npicture_shape = \"standard\";\npicture_orientation = \"horizontal\";\npane_size = \"large\";\nimage_file = \"image-surface.dat\";\ninclude_hole = \"yes\";\nhole_diameter = 10;\nlayer_height = 0.2;\nnumber_of_layers = 12;\ntext_line_1 = \"\";\ntext_line_2 = \"\";\ntext_line_3 = \"\";\ntext_line_4 = \"\";\ntext_line_5 = \"\";\ntext_size = 10;\ntext_vertical_position = 0;\ntext_reverse = \"no\";\nmin_layer_height = layer_height*2;\nhole_radius = hole_diameter/2;\nheight = layer_height*number_of_layers;\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\npreview_tab = \"\";\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nif (picture_shape == \"square\") {\n  if (pane_size == \"large\") {\n    lithopane(100, 100, 1, 1);\n  } else {\n    lithopane(50, 50, 0.5, 0.5);\n  }\n} else if (picture_shape == \"standard\") {\n  if (picture_orientation == \"horizontal\") {\n    if (pane_size == \"large\") {\n      lithopane(133, 100, 4/3, 1);\n    } else {\n      lithopane(133/2, 100/2, (4/3)/2, 1/2);\n    }\n  } else {\n    if (pane_size == \"large\") {\n      rotate([0,0,90]) lithopane(100, 133, 1, 4/3);\n    } else {\n      rotate([0,0,90]) lithopane(100/2, 133/2, 1/2, (4/3)/2);\n    }\n  }\n} else if (picture_shape == \"hd\") {\n  if (picture_orientation == \"horizontal\") {\n    if (pane_size == \"large\") {\n      lithopane(177, 100, 16/9, 1);\n    } else {\n      lithopane(177/2, 100/2, (16/9)/2, 1/2);\n    }\n  } else {\n    if (pane_size == \"large\") {\n      rotate([0,0,90]) lithopane(100, 177, 1, 16/9);\n    } else {\n      rotate([0,0,90]) lithopane(100/2, 177/2, 1/2, (16/9)/2);\n    }\n  }\n}\nmodule lithopane(length, width, x_scale, y_scale) {\n  union() {\n    difference() {\n      translate([0, 0, min_layer_height]) scale([x_scale,y_scale,height]) surface(file=image_file, center=true, convexity=5);\n      translate([0,0,-(height+min_layer_height)]) linear_extrude(height=height+min_layer_height) square([length, width], center=true);\n    }\n    linear_extrude(height=layer_height*2) square([length+4, width+4], center=true);\n    linear_extrude(height=height+min_layer_height) {\n  \t  difference() {\n  \t\t  union() {\n  \t      square([length+4, width+4], center=true);\n  \t      if (include_hole == \"yes\") {\n            translate([0, width/2+hole_radius+2, 0]) circle(r=hole_radius+5);\n          }\n  \t\t  }\n        union() {\n          square([length, width], center=true);\n  \t      if (include_hole == \"yes\") {\n            translate([0, width/2+hole_radius+2, 0]) circle(r=hole_radius);\n          }\n        }\n  \t  }\n    }\n    rotate_text() translate([0, text_vertical_position, height/2]) union() {\n      translate([0, 30, 0])  write(text_line_1, t=height, h=text_size, center=true);\n      translate([0, 15, 0])  write(text_line_2, t=height, h=text_size, center=true);\n      translate([0, 0, 0])   write(text_line_3, t=height, h=text_size, center=true);\n      translate([0, -15, 0]) write(text_line_4, t=height, h=text_size, center=true);\n      translate([0, -30, 0]) write(text_line_5, t=height, h=text_size, center=true);\n    }\n  }\n}\nmodule rotate_text() {\n  if (text_reverse == \"yes\") {\n    translate([0, 0, height]) rotate([0, 180, 0]) child(0);\n  } else {\n    translate([0, 0, 0]) rotate([0, 0, 0]) child(0);\n  }\n}",
    "description": "Okay, I'm looking to create a parametric OpenSCAD file that generates a lithophane from an image. I've seen some examples online, and I'd like something similar but with more customization options. I have an example file I'm working off of, and it has some features that I'd like to include, so I'll explain those to give you a better idea of what I want.\n\nThe basic idea is that the lithophane will be generated by extruding a surface derived from a grayscale image. The brighter parts of the image will be thicker in the extrusion, and the darker parts will be thinner.\n\nHere are the specific features that I want to be able to customize:\n\n**Image Settings:**\n\n*   **Image File:** I need to be able to specify the file path of the image I want to use. It should handle grayscale images.\n*   **Aspect Ratio:** I want options for square, standard (4:3), and HD (16:9) aspect ratios, with horizontal or vertical orientations.\n*   **Pane Size:** I want to be able to choose between \"large\" and \"small\" sizes for the lithophane.\n*   **Image Inversion:** It should be clear to the user that the image might need to be inverted for a proper lithophane.\n\n**General Settings:**\n\n*   **Layer Height:**  This determines the z-resolution of the lithophane.\n*   **Number of Layers:** This determines the height of the lithophane. This is used in conjunction with layer height.\n*   **Base Thickness:** The base of the lithopane should always be a specific thickness (2 * layer_height)\n*  **Hole:** I want an optional hole for hanging on the top edge of the lithopane, with a customizable diameter. The hole should be created using a difference operation.\n\n**Text Settings:**\n\n*   **Multiple Text Lines:**  I want to be able to add up to 5 lines of text to the lithophane.\n*   **Text Size:** I need to be able to control the size of the text.\n*  **Text Position:**  Vertical position of the text should be configurable.\n*   **Text Reverse:** The user should be able to choose if the text should be reversed (for viewing on the opposite side).\n\n**Build Plate Settings:**\n\n*   **Build Plate Size:** I'd like the option to select from pre-defined build plate sizes (like \"Replicator 2,\" \"Replicator,\" etc.) or enter a custom size (x and y dimensions). The \"Build Plate\" should be displayed in the preview.\n\n**Libraries:**\n\nThe example uses a `utils/build_plate.scad` and `write/Write.scad`, so I assume there are custom modules that do those things (though I'm not attaching any such libraries). I would want those functions to be encapsulated in my code so that I can modify and move them easily.\n\n**Functionality and Logic:**\n\n*   The lithophane should be generated using a `surface()` function for the image, scaled appropriately, and then using a `difference` to create the 3D extruded shape.\n*   There should be a base with a two-layer thickness, and an optional hole that is also extruded.\n*   Text should be added to the main object using the `Write` library, and its position should be controlled by another function called `rotate_text` that flips the text if the `text_reverse` setting is enabled.\n*   A `lithopane` module should be called with the correct size parameters according to the chosen aspect ratio, orientation, and size.\n\nI am looking for a fully parameterized OpenSCAD file that I can easily customize. Please make sure to use clear variable names, use comments, and make the code easy to follow. Please also try to create the modules used by the original code rather than relying on an external .scad files.\n\nCan you help me create this OpenSCAD file?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Custiomizable Name Tag",
    "scad": "include <write/Write.scad>\nText = \"Claudia\";\nPlate_width=58;\nPlate_Height =15;\nPlate_thickness=2;\nText_Height=12;\nText_depth=.8;\nPlate_Border=2;\nFoot = \"yes\";\nFoot_angle = 45;\nFont = \"orbitron.dxf\";\npart=\"back\";\nmodule label(Text_Height,Plate_Border,Font,Plate_thickness,Plate_Height,Plate_width,Text,Text_depth) {\ncolor(\"red\") {\nunion() {\ndifference() {\nhull(){\ntranslate([Plate_width/2,Plate_Height/2,0])cylinder(h=Text_depth,r=5);\ntranslate([-Plate_width/2,Plate_Height/2,0])cylinder(h=Text_depth,r=5);\ntranslate([-Plate_width/2,-Plate_Height/2,0])cylinder(h=Text_depth,r=5);\ntranslate([Plate_width/2,-Plate_Height/2,0])cylinder(h=Text_depth,r=5);\n}\nhull(){\ntranslate([Plate_width/2-Plate_Border,Plate_Height/2-Plate_Border,0])cylinder(h=Text_depth,r=5);\ntranslate([-Plate_width/2+Plate_Border,Plate_Height/2-Plate_Border,0])cylinder(h=Text_depth,r=5);\ntranslate([-Plate_width/2+Plate_Border,-Plate_Height/2+Plate_Border,0])cylinder(h=Text_depth,r=5);\ntranslate([Plate_width/2-Plate_Border,-Plate_Height/2+Plate_Border,0])cylinder(h=Text_depth,r=5);\n}\n}\ntranslate([0,0,Text_depth/2])rotate([0,180,0])write(Text,h=Text_Height,t=Text_depth, font = Font,center=true);\n}\n}\n}\nmodule back(Plate_thickness,Plate_Height,Plate_width,Foot,Foot_angle){\nhull(){\ntranslate([Plate_width/2,Plate_Height/2,0])cylinder(h=Plate_thickness,r=5);\ntranslate([-Plate_width/2,Plate_Height/2,0])cylinder(h=Plate_thickness,r=5);\ntranslate([-Plate_width/2,-Plate_Height/2,0])cylinder(h=Plate_thickness,r=5);\ntranslate([Plate_width/2,-Plate_Height/2,0])cylinder(h=Plate_thickness,r=5);\n}\nif ( Foot==\"yes\") {\ntranslate([-Plate_width/2,-Plate_Height/2-5,Plate_thickness])rotate([-Foot_angle,0,0])cube([Plate_width,Plate_thickness,Plate_Height]);\n}\n}\nif ( part==\"back\") {\ndifference() {\nback(Plate_thickness,Plate_Height,Plate_width,Foot,Foot_angle);\ntranslate([0,0,-.1])label(Text_Height+.1,Plate_Border,Font,Plate_thickness,Plate_Height,Plate_width,Text,Text_depth+.1);\n}\n}\nif ( part==\"text\") {\nlabel(Text_Height,Plate_Border,Font,Plate_thickness,Plate_Height,Plate_width,Text,Text_depth);\n}",
    "description": "Okay, I'm looking to design a name tag that I can print on my Makerbot Replicator 2, and I want to make it parametric so I can easily adjust it for different names and sizes. I've got a basic design in mind, but I'd like help making it a proper OpenSCAD file.\n\nEssentially, I want a rectangular plate with the name raised on top. The name should be a separate printable part so I can print it in a different color for a dual color effect, that way the lettering stands out. The plate should have a slight border to give it a clean look.  I would also like an optional foot or stand, extending backwards at an angle from the bottom so the tag can stand upright on a flat surface.\n\nHere are the specific parameters I'd like to control:\n\n*   **Text:** The name to be displayed on the tag (e.g., \"Claudia\").\n*   **Plate Width:** The width of the rectangular base.\n*   **Plate Height:** The height of the rectangular base.\n*   **Plate Thickness:** The thickness of the rectangular base.\n*   **Text Height:** The height of the raised text letters.\n*   **Text Depth:** The depth of the raised text (how much it sticks out from the base).\n*   **Plate Border:** The width of the border around the plate.\n*   **Foot:** A boolean to turn on or off the support foot.\n*   **Foot Angle:** The angle of the support foot relative to the base plate.\n*   **Font:**  The font to be used for the text. I want to be able to specify font files, for example \"orbitron.dxf\" to use a specific font, it should also support fonts included in the \"write\" library.\n*   **Part:** A selector that specifies whether I want to render the \"back\" (base plate with the text cut out from it) or the \"text\" part (just the raised lettering).\n\nI'd like the design to use the \"write\" library for text rendering. I want to be able to select which part to render so that I can export the base and the text as separate STL files for the dual-color print.\n\nCan you generate the OpenSCAD file based on these parameters, using the write library? Also, make sure it generates proper separate printable pieces for both \"back\" and \"text\".\n"
  },
  {
    "object": "Hey cadmonkey, make me a Holesphere",
    "scad": "sphere_radius = 10;\nhole_radius = 5;\ndifference(){\n translate([sphere_radius,0,sphere_radius])\n  sphere(sphere_radius);\n union(){\n  translate([sphere_radius,0,0])\n   cylinder(2*sphere_radius,hole_radius,hole_radius);\n  translate([sphere_radius,sphere_radius,sphere_radius]) rotate([90,0,0])\n   cylinder(2*sphere_radius,hole_radius,hole_radius);\n  translate([0,0,sphere_radius]) rotate([0,90,0])\n   cylinder(2*sphere_radius,hole_radius,hole_radius);\n }\n}",
    "description": "Okay, I'd like to design a sphere with cylindrical holes going through it. I need an OpenSCAD file that can generate this. \n\nHere are the specifics:\n\n*   **Core Shape:** The base object is a sphere.\n*   **Holes:** There are three cylindrical holes going completely through the sphere. These holes are perpendicular to each other and all intersect at the center of the sphere. Essentially, imagine a sphere with holes along the X, Y, and Z axes.\n*   **Parametric Design:** I need to be able to adjust the following parameters:\n    *   `sphere_radius`: The radius of the main sphere.\n    *   `hole_radius`: The radius of the cylindrical holes.\n\nI'd like to be able to change these two values easily in OpenSCAD's customizer. Please provide the complete OpenSCAD code that does this. I do not need any libraries in addition to the default library.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Sortimo Insert Boxx for T-Boxx, L-Boxx and I-Boxx",
    "scad": "what = \"both\";\nmodulesH = 1;\nmodulesV = 1;\nwallThickness = 1.7;\npegDiameter = 7.4;\npegDistance = 39.5;\nbaseCornerDiameter = 5;\ntopCornerDiameter = 10;\ntopWidth = 52.5;\ntopLowerWidth = 51.5;\ntopInnerDiameter = 48.5;\nbottomWidth = 49.5;\nheight = 60.7;\npegSlackH = (modulesH - 1) * ((topWidth - pegDistance));\npegSlackV = (modulesV - 1) * ((topWidth - pegDistance));\nblPosX = 0;\nblPosY = 0;\nbrPosX = modulesH * pegDistance + pegSlackH;\nbrPosY = 0;\ntlPosX = 0;\ntlPosY = modulesV * pegDistance + pegSlackH;\ntrPosX = modulesH * pegDistance + pegSlackH;\ntrPosY = modulesV * pegDistance + pegSlackH;\nmodule boxx()\n{\ndifference()\n{\nunion()\n{\nhull()\n{\ntranslate([-(bottomWidth - pegDistance) / 2 + baseCornerDiameter / 2, -(bottomWidth - pegDistance) / 2 + baseCornerDiameter / 2, baseCornerDiameter / 2]) sphere(baseCornerDiameter/2, $fn = 20);\ntranslate([brPosX, brPosY, 0]) translate([(bottomWidth - pegDistance) / 2 - baseCornerDiameter / 2, -(bottomWidth - pegDistance) / 2 + baseCornerDiameter / 2, baseCornerDiameter / 2]) sphere(baseCornerDiameter/2, $fn = 20);\ntranslate([tlPosX, tlPosY, 0]) translate([-(bottomWidth - pegDistance) / 2 + baseCornerDiameter / 2, (bottomWidth - pegDistance) / 2 - baseCornerDiameter / 2, baseCornerDiameter / 2]) sphere(baseCornerDiameter/2, $fn = 20);\ntranslate([trPosX, trPosY, 0]) translate([(bottomWidth - pegDistance) / 2 - baseCornerDiameter / 2, (bottomWidth - pegDistance) / 2 - baseCornerDiameter / 2, baseCornerDiameter / 2]) sphere(baseCornerDiameter/2, $fn = 20);\ntranslate([blPosX, blPosY, height]) translate([-(topLowerWidth - pegDistance) / 2 + topCornerDiameter / 2, -(topLowerWidth - pegDistance) / 2 + topCornerDiameter / 2, -4]) cylinder(4, topCornerDiameter / 2, topCornerDiameter / 2, $fn = 30);\ntranslate([brPosX, brPosY, height]) translate([(topLowerWidth - pegDistance) / 2 - topCornerDiameter / 2, -(topLowerWidth - pegDistance) / 2 + topCornerDiameter / 2, -4]) cylinder(4, topCornerDiameter / 2, topCornerDiameter / 2, $fn = 30);\ntranslate([tlPosX, tlPosY, height]) translate([-(topLowerWidth - pegDistance) / 2 + topCornerDiameter / 2, (topLowerWidth - pegDistance) / 2 - topCornerDiameter / 2, -4]) cylinder(4, topCornerDiameter / 2, topCornerDiameter / 2, $fn = 30);\ntranslate([trPosX, trPosY, height]) translate([(topLowerWidth - pegDistance) / 2 - topCornerDiameter / 2, (topLowerWidth - pegDistance) / 2 - topCornerDiameter / 2, -4]) cylinder(4, topCornerDiameter / 2, topCornerDiameter / 2, $fn = 30);\n}\nhull()\n{\ntranslate([blPosX, blPosY, height]) translate([-(topWidth - pegDistance) / 2 + topCornerDiameter / 2, -(topWidth - pegDistance) / 2 + topCornerDiameter / 2, -4]) cylinder(4, topCornerDiameter / 2 -0.2, topCornerDiameter / 2, $fn = 30);\ntranslate([brPosX, brPosY, height]) translate([(topWidth - pegDistance) / 2 - topCornerDiameter / 2, -(topWidth - pegDistance) / 2 + topCornerDiameter / 2, -4]) cylinder(4, topCornerDiameter / 2 -0.2, topCornerDiameter / 2, $fn = 30);\ntranslate([tlPosX, tlPosY, height]) translate([-(topWidth - pegDistance) / 2 + topCornerDiameter / 2, (topWidth - pegDistance) / 2 - topCornerDiameter / 2, -4]) cylinder(4, topCornerDiameter / 2 -0.2, topCornerDiameter / 2, $fn = 30);\ntranslate([trPosX, trPosY, height]) translate([(topWidth - pegDistance) / 2 - topCornerDiameter / 2, (topWidth - pegDistance) / 2 - topCornerDiameter / 2, -4]) cylinder(4, topCornerDiameter / 2 -0.2, topCornerDiameter / 2, $fn = 30);\n}\n}\nhull()\n{\ntranslate([blPosX +wallThickness, blPosY + wallThickness, 1]) translate([-(bottomWidth - pegDistance) / 2 + baseCornerDiameter / 2, -(bottomWidth - pegDistance) / 2 + baseCornerDiameter / 2, baseCornerDiameter / 2]) sphere(baseCornerDiameter/2, $fn = 20);\ntranslate([brPosX - wallThickness, brPosY + wallThickness, 1]) translate([(bottomWidth - pegDistance) / 2 - baseCornerDiameter / 2, -(bottomWidth - pegDistance) / 2 + baseCornerDiameter / 2, baseCornerDiameter / 2]) sphere(baseCornerDiameter/2, $fn = 20);\ntranslate([tlPosX + wallThickness, tlPosY - wallThickness, 1]) translate([-(bottomWidth - pegDistance) / 2 + baseCornerDiameter / 2, (bottomWidth - pegDistance) / 2 - baseCornerDiameter / 2, baseCornerDiameter / 2]) sphere(baseCornerDiameter/2, $fn = 20);\ntranslate([trPosX - wallThickness, trPosY - wallThickness, 1]) translate([(bottomWidth - pegDistance) / 2 - baseCornerDiameter / 2, (bottomWidth - pegDistance) / 2 - baseCornerDiameter / 2, baseCornerDiameter / 2]) sphere(baseCornerDiameter/2, $fn = 20);\ntranslate([blPosX + wallThickness, blPosY + wallThickness, height]) translate([-(topLowerWidth - pegDistance) / 2 + topCornerDiameter / 2, -(topLowerWidth - pegDistance) / 2 + topCornerDiameter / 2, -4]) cylinder(5, topCornerDiameter / 2, topCornerDiameter / 2, $fn = 30);\ntranslate([brPosX - wallThickness, brPosY + wallThickness, height]) translate([(topLowerWidth - pegDistance) / 2 - topCornerDiameter / 2, -(topLowerWidth - pegDistance) / 2 + topCornerDiameter / 2, -4]) cylinder(5, topCornerDiameter / 2, topCornerDiameter / 2, $fn = 30);\ntranslate([tlPosX + wallThickness, tlPosY - wallThickness, height]) translate([-(topLowerWidth - pegDistance) / 2 + topCornerDiameter / 2, (topLowerWidth - pegDistance) / 2 - topCornerDiameter / 2, -4]) cylinder(5, topCornerDiameter / 2, topCornerDiameter / 2, $fn = 30);\ntranslate([trPosX - wallThickness, trPosY- wallThickness, height]) translate([(topLowerWidth - pegDistance) / 2 - topCornerDiameter / 2, (topLowerWidth - pegDistance) / 2 - topCornerDiameter / 2, -4]) cylinder(5, topCornerDiameter / 2, topCornerDiameter / 2, $fn = 30);\n}\ncylinder(20, 2, 2, $fn = 20);\ntranslate([brPosX, 0, 0]) cylinder(20, 2, 2, $fn = 20);\ntranslate([0, tlPosY, 0]) cylinder(20, 2, 2, $fn = 20);\ntranslate([trPosX, trPosY, 0]) cylinder(20, 2, 2, $fn = 20);\n}\n}\nmodule peg() {\nunion()\n{\ncylinder(2, pegDiameter/2, pegDiameter/2, $fn = 20);\ntranslate([0,0,1]) cylinder(2, 1.8, 1.8, $fn = 20);\n}\n}\nif (what == \"boxx\" || what == \"both\")\n{\nboxx();\n}\nif (what == \"pegs\" || what == \"both\")\n{\ntranslate([-20,0,0]) {\ntranslate([0, 0, 0]) peg();\ntranslate([0, pegDiameter + 2, 0]) peg();\ntranslate([0, (pegDiameter+2)*2, 0]) peg();\ntranslate([0, (pegDiameter+2)*3, 0]) peg();\n}\n}",
    "description": "Okay, I'm looking to design a custom insert for my Sortimo T-Boxx, and I'd like to use OpenSCAD to make it parametric. I've seen some designs online (I'll include them below) that are a good starting point, but I need something more flexible. I really want to be able to control the dimensions and make it exactly fit my needs, as well as customize peg layouts for different tools. I'm new to OpenSCAD, and I need something where I can change some parameters and easily generate different sizes. Here's what I'm aiming for:\n\n**Basic Structure:**\n\n*   The insert should consist of a rectangular box with rounded corners at the base and top. I want to control the roundness of both independently.\n*   The insert should have a hollow inside, creating a wall of a specified thickness.\n*   The insert should have holes in its base that can be used to mount it on the T-Boxx using pegs. These pegs are mounted on the base of the T-Boxx itself.\n*   I need to be able to adjust the number of \"modules\" (sort of like the grid-spacing) wide and deep the insert is.\n*   The size of the pegs (diameter) that slot into the T-Boxx base should be adjustable.\n\n**Parametric Controls (the core of my needs):**\n\n*   **Modules Wide (modulesH):**  This controls how many units wide the insert is. Imagine a grid system, this is the number of columns.\n*   **Modules Deep (modulesV):** This controls how many units deep the insert is, the number of rows on the grid.\n*   **Wall Thickness (wallThickness):**  Thickness of the walls of the insert, allowing me to control the sturdiness.\n*   **Peg Diameter (pegDiameter):** Diameter of the pegs that fit into the T-Boxx base.\n*    **Base Corner Diameter (baseCornerDiameter):** The size of the radius for the rounded corners on the bottom.\n*    **Top Corner Diameter (topCornerDiameter):**  The size of the radius for the rounded corners at the top.\n*   **Total Height (height):** The overall height of the insert. This is related to the top and bottom corner diameters.\n*   **Peg Distance (pegDistance):**  The distance between the peg positions for the base, this is also a type of grid spacing that defines each unit. The overall width and depth of the insert will be the number of modules multiplied by the peg distance. This _should_ be a configurable parameter.\n*   **Top Width, Top Lower Width, Bottom Width:** Parameters that define the top and bottom perimeters of the insert.\n\n**Additional Requirements:**\n\n*   I need the code to be relatively easy to understand. I'm a beginner, so commented code would be appreciated.\n*   The code should be well-structured and use modules where appropriate.\n*   I'd like to be able to render just the insert, or just the pegs or both. So I would need to have a selection of \"boxx\", \"pegs\", or \"both\"\n*   I'd like to use the hull function to create smooth rounded corners between the different cylinders.\n*   It looks like the original design was using spheres for some corners - I would be happy if this could be replaced by cylinders as well, or have the option to use cylinders, to simplify printing.\n\n**Example Files:**\n\nI have attached two files, `T-Boxx_Insert.scad` and `Boxx_Insert_v2.scad`, that are similar to what I want. I am including them for reference.\nI think that these do not use any external libraries, but if you know of some that would simplify my design that would be amazing.\n\nCould you help me create this OpenSCAD file?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Centrifugal / Blower / Squirell Fan",
    "scad": "FAN_WIDTH = 40;\nFAN_HEIGHT = 13;\nRING_HEIGHT = 2;\nRING_WIDTH = 4;\nBLADE_COUNT = 35;\nBLADE_WIDTH = 1;\nBLADE_ANGLE = -45;\nSHAFT_DIAMETER = 2;\nbottomRadius = FAN_WIDTH / 2;\ntopRadius = bottomRadius * 0.25;\nringCenterRadius = bottomRadius - RING_WIDTH;\nshaftRadius = SHAFT_DIAMETER / 2;\ndifference()\n{\n\tcylinder(r1 = bottomRadius, r2 = topRadius, h = FAN_HEIGHT, $fn = 100);\n\tcylinder(r1 = shaftRadius, r2 = shaftRadius, h = FAN_HEIGHT, $fn = 100);\n}\ntranslate([0, 0, FAN_HEIGHT - RING_HEIGHT])\ndifference()\n{\n\tcylinder(r1 = bottomRadius, r2 = bottomRadius, h = RING_HEIGHT, $fn = 100);\n\tcylinder(r1 = ringCenterRadius, r2 = ringCenterRadius, h = RING_HEIGHT, $fn = 100);\n}\ndifference()\n{\n\tcylinder(r1 = bottomRadius, r2 = bottomRadius, h = RING_HEIGHT, $fn = 100);\n\tcylinder(r1 = ringCenterRadius, r2 = ringCenterRadius, h = RING_HEIGHT, $fn = 100);\n}\nrotate( 90, [0, 1, 0] )\nfor ( i = [0 : BLADE_COUNT - 1] )\n{\n    rotate(i * 360 / BLADE_COUNT, [1, 0, 0])\n    translate([-FAN_HEIGHT, bottomRadius - RING_WIDTH, 0])\n\t rotate(BLADE_ANGLE, [1, 0, 0])\n    cube([FAN_HEIGHT, RING_WIDTH, BLADE_WIDTH], center = false);\n}",
    "description": "Okay, I'd like to design a centrifugal fan for 3D printing, and I'm looking for a parametric OpenSCAD file. I'd like to control several aspects of the fan through variables.\n\nHere's a breakdown of what I'm after:\n\n**General Shape:** The fan will essentially be a truncated cone, with a smaller circle at the top than the bottom. This will act as the main structural component to which the blades are attached.\n\n**Dimensions:** I need to control the following dimensions through variables:\n\n*   `FAN_WIDTH`: The diameter of the base of the cone in millimeters.\n*   `FAN_HEIGHT`: The overall height of the cone in millimeters.\n*   `RING_HEIGHT`: The height of the reinforcing rings at the top and bottom in millimeters.\n*   `RING_WIDTH`: The width of the reinforcing rings at the top and bottom in millimeters.\n*   `SHAFT_DIAMETER`: The diameter of the central shaft hole in millimeters.\n\n**Rings:** There should be two reinforcing rings, one at the top and one at the bottom of the cone. These will have the same width and height and should be concentric with the cone, i.e., they will follow the same cylindrical shape. The rings should be positioned such that their outer edge is aligned with the edge of the cone, and their inner edge forms a circular channel to make the structure more rigid.\n\n**Blades:** I need a series of curved blades attached to the inside of the bottom ring. The blades should:\n\n*   `BLADE_COUNT`: Have a variable number of blades.\n*   `BLADE_WIDTH`: Have a variable width for each blade.\n*   `BLADE_ANGLE`: Have a variable angle in degrees to control blade curvature. The angle should be relative to the radius. A negative angle will indicate a blade that curves backward relative to the direction of rotation.\n*   Be oriented such that they attach to the center of the bottom ring and are flush with it in the Z direction. They should extend vertically to the top of the cone.\n*   Be attached along the inner circumference of the channel created by the ring.\n\n**Parameter Behavior:** I want to be able to change these variables and have the design update appropriately. For example, if I increase the `FAN_WIDTH`, the entire cone and ring diameters need to grow proportionally.  Also, the number of blades should be variable.\n\n**Output:** I'd like the output to be a single 3D solid model, suitable for 3D printing, with all features properly merged. I'm using OpenSCAD, so I don't expect to have to import any external CAD files. I do not want to use any external libraries.\n\nCould you provide me with an OpenSCAD file that accomplishes this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a PixSCAD iOS App",
    "scad": "rotation = 45;\ntranslate([-15.50,-0.50,0]) cube([16,16,2]);\nvalue_0 = 0;\nvalue_1 = 1;\nvalue_2 = 2;\nvalue_3 = 3;\nvalue_4 = 4;\nvalue_5 = 5;\nvalue_6 = 6;\nvalue_7 = 7;\ntranslate([-0,0,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-1,0,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-2,0,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-3,0,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-4,0,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-5,0,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-6,0,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-7,0,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-8,0,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-9,0,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-10,0,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-11,0,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-12,0,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-13,0,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-14,0,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-15,0,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-0,1,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-1,1,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-2,1,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-3,1,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-4,1,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-5,1,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-6,1,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-7,1,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-8,1,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-9,1,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-10,1,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-11,1,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-12,1,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-13,1,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-14,1,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-15,1,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-0,2,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-1,2,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-2,2,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-3,2,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-4,2,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-5,2,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-6,2,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-7,2,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-8,2,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-9,2,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-10,2,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-11,2,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-12,2,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-13,2,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-14,2,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-15,2,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-0,3,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-1,3,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-2,3,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-3,3,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-4,3,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-5,3,2]) rotate([0,0,rotation]) cylinder(h=value_3,r=0.490,$fn=4);\ntranslate([-6,3,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-7,3,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-8,3,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-9,3,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-10,3,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-11,3,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-12,3,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-13,3,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-14,3,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-15,3,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-0,4,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-1,4,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-2,4,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-3,4,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-4,4,2]) rotate([0,0,rotation]) cylinder(h=value_3,r=0.490,$fn=4);\ntranslate([-5,4,2]) rotate([0,0,rotation]) cylinder(h=value_3,r=0.490,$fn=4);\ntranslate([-6,4,2]) rotate([0,0,rotation]) cylinder(h=value_3,r=0.490,$fn=4);\ntranslate([-7,4,2]) rotate([0,0,rotation]) cylinder(h=value_3,r=0.490,$fn=4);\ntranslate([-8,4,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-9,4,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-10,4,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-11,4,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-12,4,2]) rotate([0,0,rotation]) cylinder(h=value_3,r=0.490,$fn=4);\ntranslate([-13,4,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-14,4,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-15,4,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-0,5,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-1,5,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-2,5,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-3,5,2]) rotate([0,0,rotation]) cylinder(h=value_3,r=0.490,$fn=4);\ntranslate([-4,5,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-5,5,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-6,5,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-7,5,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-8,5,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-9,5,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-10,5,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-11,5,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-12,5,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-13,5,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-14,5,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-15,5,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-0,6,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-1,6,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-2,6,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-3,6,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-4,6,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-5,6,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-6,6,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-7,6,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-8,6,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-9,6,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-10,6,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-11,6,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-12,6,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-13,6,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-14,6,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-15,6,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-0,7,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-1,7,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-2,7,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-3,7,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-4,7,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-5,7,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-6,7,2]) rotate([0,0,rotation]) cylinder(h=value_3,r=0.490,$fn=4);\ntranslate([-7,7,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-8,7,2]) rotate([0,0,rotation]) cylinder(h=value_3,r=0.490,$fn=4);\ntranslate([-9,7,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-10,7,2]) rotate([0,0,rotation]) cylinder(h=value_3,r=0.490,$fn=4);\ntranslate([-11,7,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-12,7,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-13,7,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-14,7,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-15,7,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-0,8,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-1,8,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-2,8,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-3,8,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-4,8,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-5,8,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-6,8,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-7,8,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-8,8,2]) rotate([0,0,rotation]) cylinder(h=value_3,r=0.490,$fn=4);\ntranslate([-9,8,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-10,8,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-11,8,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-12,8,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-13,8,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-14,8,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-15,8,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-0,9,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-1,9,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-2,9,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-3,9,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-4,9,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-5,9,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-6,9,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-7,9,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-8,9,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-9,9,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-10,9,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-11,9,2]) rotate([0,0,rotation]) cylinder(h=value_3,r=0.490,$fn=4);\ntranslate([-12,9,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-13,9,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-14,9,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-15,9,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-0,10,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-1,10,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-2,10,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-3,10,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-4,10,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-5,10,2]) rotate([0,0,rotation]) cylinder(h=value_6,r=0.490,$fn=4);\ntranslate([-6,10,2]) rotate([0,0,rotation]) cylinder(h=value_6,r=0.490,$fn=4);\ntranslate([-7,10,2]) rotate([0,0,rotation]) cylinder(h=value_6,r=0.490,$fn=4);\ntranslate([-8,10,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-9,10,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-10,10,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-11,10,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-12,10,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-13,10,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-14,10,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-15,10,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-0,11,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-1,11,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-2,11,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-3,11,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-4,11,2]) rotate([0,0,rotation]) cylinder(h=value_6,r=0.490,$fn=4);\ntranslate([-5,11,2]) rotate([0,0,rotation]) cylinder(h=value_7,r=0.490,$fn=4);\ntranslate([-6,11,2]) rotate([0,0,rotation]) cylinder(h=value_7,r=0.490,$fn=4);\ntranslate([-7,11,2]) rotate([0,0,rotation]) cylinder(h=value_7,r=0.490,$fn=4);\ntranslate([-8,11,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-9,11,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-10,11,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-11,11,2]) rotate([0,0,rotation]) cylinder(h=value_3,r=0.490,$fn=4);\ntranslate([-12,11,2]) rotate([0,0,rotation]) cylinder(h=value_3,r=0.490,$fn=4);\ntranslate([-13,11,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-14,11,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-15,11,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-0,12,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-1,12,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-2,12,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-3,12,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-4,12,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-5,12,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-6,12,2]) rotate([0,0,rotation]) cylinder(h=value_7,r=0.490,$fn=4);\ntranslate([-7,12,2]) rotate([0,0,rotation]) cylinder(h=value_7,r=0.490,$fn=4);\ntranslate([-8,12,2]) rotate([0,0,rotation]) cylinder(h=value_7,r=0.490,$fn=4);\ntranslate([-9,12,2]) rotate([0,0,rotation]) cylinder(h=value_7,r=0.490,$fn=4);\ntranslate([-10,12,2]) rotate([0,0,rotation]) cylinder(h=value_7,r=0.490,$fn=4);\ntranslate([-11,12,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-12,12,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-13,12,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-14,12,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-15,12,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-0,13,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-1,13,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-2,13,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-3,13,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-4,13,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-5,13,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-6,13,2]) rotate([0,0,rotation]) cylinder(h=value_3,r=0.490,$fn=4);\ntranslate([-7,13,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-8,13,2]) rotate([0,0,rotation]) cylinder(h=value_5,r=0.490,$fn=4);\ntranslate([-9,13,2]) rotate([0,0,rotation]) cylinder(h=value_4,r=0.490,$fn=4);\ntranslate([-10,13,2]) rotate([0,0,rotation]) cylinder(h=value_2,r=0.490,$fn=4);\ntranslate([-11,13,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-12,13,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-13,13,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-14,13,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-15,13,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-0,14,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-1,14,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-2,14,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-3,14,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-4,14,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-5,14,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-6,14,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-7,14,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-8,14,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-9,14,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-10,14,2]) rotate([0,0,rotation]) cylinder(h=value_0,r=0.490,$fn=4);\ntranslate([-11,14,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-12,14,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-13,14,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-14,14,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-15,14,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-0,15,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-1,15,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-2,15,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-3,15,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-4,15,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-5,15,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-6,15,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-7,15,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-8,15,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-9,15,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-10,15,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-11,15,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-12,15,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-13,15,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-14,15,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);\ntranslate([-15,15,2]) rotate([0,0,rotation]) cylinder(h=value_1,r=0.490,$fn=4);",
    "description": "Okay, I'm looking to create a parametric version of this OpenSCAD code I have, which essentially turns a pixelated image into a 3D relief. I want to be able to control the overall dimensions, the pixel size (which controls the resolution), and the height scale. Also, it'd be great if I could control the rotation and base thickness easily.\n\nHere's what I'm thinking:\n\n**Core Functionality**\n\n*   **Image Data:** The original code uses hardcoded \"value\\_\" variables which are then used as heights. I'd like to be able to replace this with an external data source. I assume this would have to come from an array or a text file.\n*   **Image Dimensions:** I need to set the image's width and height. Currently, it looks like it's hardcoded to 16x16, but I want that flexible.\n*   **Pixel Size:** The distance between the cylinders should be a variable, to control how detailed the output becomes.\n*   **Base Thickness:** The thickness of the base cube should be adjustable, which is currently set to 2.\n*   **Height Scale:** There needs to be a way to multiply the height values to scale the z-axis of the relief. I'd like this to be a variable.\n*   **Rotation:** The rotation of the relief around the Z-axis should be a parameter.\n*   **Pixel Shape:** Instead of just using cylinders, it should have options for other pixel shapes - like squares.\n\n**Parameters I want to control (as variables):**\n\n*   `image_width`:  Integer, the width of the image in pixels.\n*   `image_height`: Integer, the height of the image in pixels.\n*   `pixel_size`: Float, the size of each pixel (and the distance between cylinders).\n*   `base_thickness`: Float, thickness of the base cube.\n*   `height_scale`: Float, multiplies each height value to scale z-axis.\n*   `rotation_angle`: Float, rotation angle around the Z-axis in degrees.\n*  `pixel_shape`: string, should have at least \"cylinder\" and \"square\" as options for now.\n*  `image_data`: Array of numbers representing the pixel heights. I'd prefer to input a comma-separated string of values, and then have the code parse it into a 2D array based on `image_width` and `image_height`.\n\n**Libraries**\n\nIm not explicitly using any external libraries in my current code, but if you need to use something to help with array manipulation or other processing, I'm fine with that. Just let me know which ones you are using.\n\n**Output**\n\nI'd like an OpenSCAD file that generates the 3D relief based on the parameters I set.\n\nCould you help me create an OpenSCAD file that does this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customisable Lithophane with More",
    "scad": "image_file = \"image-surface.dat\";\nhole_diameter = 0;\nhole_border = 0;\nlithophane_border = 0;\nlayer_height = 0.2;\nnumber_of_layers = 12;\ns=0.01;\nlength = 99;\nwidth = 99;\nmin_layer_height = layer_height*2;\nhole_radius = hole_diameter/2;\nheight = layer_height*number_of_layers;\nunion() {\n  difference() {\n    translate([0, 0, min_layer_height]) scale([1,1,height]) surface(file=image_file, center=true, convexity=5);\n    translate([0,0,-(height+min_layer_height)]) linear_extrude(height=height+min_layer_height) square([length+s, width+s], center=true);\n  }\n  linear_extrude(height=layer_height*2) square([length+lithophane_border, width+lithophane_border], center=true);\n  linear_extrude(height=height+min_layer_height){\n\t  difference(){\n\t\tunion(){\n\t      square([length+lithophane_border, width+lithophane_border], center=true);\n\t\t  translate([0, width/2+hole_radius+lithophane_border/2, 0])\n\t\t    circle(r=hole_radius+ hole_border);\n\t\t}\n\t    union(){\n\t      square([length, width], center=true);\n\t\t  translate([0, width/2+hole_radius+lithophane_border/2, 0])\n\t        circle(r=hole_radius);\n\t    }\n\t  }\n  }\n}",
    "description": "Okay, I'm looking to design a customizable lithophane generator in OpenSCAD. I've found a good starting point, but I want something more flexible and parametric. Heres what I'm aiming for, based on this existing SCAD file:\n\n**Core Functionality:**\n\n*   **Image Input:** I need to be able to load a grayscale image file (like the `.dat` files in the example) which will be used as the basis for the lithophane's varying thickness.\n*   **Lithophane Base:** The lithophane should have a base layer of a specified thickness (two layers in the provided code but I want to parametrize this) - this is the 'white' part of the final lithophane.\n*   **Thickness Mapping:** The grayscale values in the image should map to the thickness of the lithophane, with lighter areas being thinner. I'd like to control the number of layers to achieve the maximum thickness.\n*   **Border:** I want an option to add a border around the lithophane, with customizable border width and height (the height currently is always the same as the base, but I want to be able to specify this).\n*   **Hole Feature:** I need a customizable hole for hanging, which I can enable/disable. I'd like to be able to control the hole's diameter and the size of the rim/border around the hole.\n*   **File size constraints:** I would like to be able to control the width and height of the input image and have the final product scaled accordingly. I would like to control the number of pixels width and height, not just the width/height in mm\n\n**Parametric Control:**\n\nI'd like to be able to control the following parameters:\n\n*   `image_file`: The path to the grayscale image file.\n*   `base_layer_thickness`: The thickness of the base layer. This should be able to be set to a specific layer number, and the final height should be based on `layer_height`.\n*   `number_of_layers`: The total number of layers used for the thickness variation in the image.\n*   `layer_height`: The height of each layer.\n*   `lithophane_border`: The width of the border around the lithophane.\n*   `border_height`: The height of the border\n*   `hole_diameter`: The diameter of the hanging hole.\n*   `hole_border`: The width of the border around the hanging hole.\n*  `image_width_pixels`: Width of the image in pixels\n*  `image_height_pixels`: Height of the image in pixels\n*  `output_width_mm`: Width of the generated part in mm\n*  `output_height_mm`: Height of the generated part in mm\n\n\n**Specific Request**\n\nCould you design an OpenSCAD file that implements all of these features? It doesn't need to depend on any external libraries like MCAD, BOSL, etc. The focus should be on clear, well-commented code that is easy to understand and modify. Also, remember to document your code.\n\nIt would be great if the code handles the edge cases - like not adding a border or a hole - gracefully.\n\nThe description mentions that the surface object loses the edge pixels, and workarounds were used. I don't want to lose any pixels from the source image and I want to control the scale, not rely on stretching.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Garden Sign",
    "scad": "label_text = \"Seeds\";\nfont = \"write/Letters.dxf\";\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nuse <write/Write.scad>\nuse <utils/build_plate.scad>\ntranslate([len(label_text) * 14.5/-2,0,0]) {\n\tdifference() {\n\tunion() {\n\t\twrite(label_text,h=20,t=3,font=font, space=.9);\n\t\ttranslate([0,-1.5,0]) cube([len(label_text) * 12, 3, 3]);\n\t\ttranslate([5,-35,0]) cube([2, 35, 3]);\n\t\ttranslate([len(label_text) * 12 - 7.5,-35,0]) cube([2, 35, 3]);\n\t\t}\n\ttranslate([-1,-35,0]) rotate([45,0,0]) cube([10, 10, 10]);\n\ttranslate([len(label_text) * 12 - 14,-35,0]) rotate([45,0,0]) cube([10, 10, 10]);\n\t}\n}",
    "description": "Okay, I'd like to create a customizable garden sign, something similar to the \"Vegetable garden signs\" on Thingiverse, but more focused on being easy to customize with text. I'm not too worried about stylistic flourishes; I just need a functional sign that I can generate with different labels.\n\nHere's what I'm envisioning:\n\n*   **Text Customization:** The primary feature needs to be the ability to change the text on the sign.  I'll need a variable to specify the text string.\n*   **Font Selection:** I'd like to be able to pick the font used for the text. The code I have uses a 'font' variable and references .dxf font files in a 'write' folder, which seems to work well, so that should be kept. So I'll need a way to chose between different font options.\n*   **Sign Body:** The sign needs a simple rectangular body behind the text to make it look solid.  It should be long enough to contain the text plus a bit extra. The text should appear to sit just above a thin rectangle that represents the \"body\".\n*   **Stakes:** The sign needs two stakes to stick into the ground. I like the basic stakes in the existing design, but maybe they can be a little more robust and not intersect with the main body?\n*   **Customizable Size:** Ideally I would like to control the height of the text to make the signs of a bigger or smaller scale.\n\nI am also including the current code. This includes the `write/Write.scad` and `utils/build_plate.scad` files; I understand I'm not going to get those files from you since they are not part of my main code.\n\n```\n// Customizable Garden Sign v1.0\n// by TheNewHobbyist 2013 (http://thenewhobbyist.com)\n// http://www.thingiverse.com/thing:78727\n//\n// This is a derivative of paulhoover's (http://www.thingiverse.com/paulhoover)\n// Vegetable garden signs (http://www.thingiverse.com/thing:78340).\n//\n// This doesn't have quite as much style as Paul's but it seemed like something\n// that would bennifit from being customizer enabled. \n//\n// Change Log:\n//\n// v1.0\n// Initial Release\n//\n\n/////////////////////////\n//  Customizer Stuff  //\n///////////////////////\n\n/* [Let's grow something awesome] */\n\n// What are we planting?\nlabel_text = \"Seeds\";\n\nfont = \"write/Letters.dxf\"; // [\"write/BlackRose.dxf\":Black Rose,\"write/knewave.dxf\":Knewave,\"write/Letters.dxf\":Letters,\"write/orbitron.dxf\":Orbitron]\n\n//For display only, not part of final model\nbuild_plate_selector = 0; //[0:Replicator 2/2X,1: Replicator,2:Thingomatic,3:Manual]\n\n// \"Manual\" build plate X dimension\nbuild_plate_manual_x = 100; //[100:400]\n\n// \"Manual\" build plate Y dimension\nbuild_plate_manual_y = 100; //[100:400]\n\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\n\n// preview[view:south, tilt:top]\n\n/////////////////////////\n// Beat it Customizer //\n///////////////////////\n\n/* [Hidden] */\n\nuse <write/Write.scad>\nuse <utils/build_plate.scad>\t\n\ntranslate([len(label_text) * 14.5/-2,0,0]) {\n\tdifference() {\n\tunion() {\n\t\twrite(label_text,h=20,t=3,font=font, space=.9);\n\t\ttranslate([0,-1.5,0]) cube([len(label_text) * 12, 3, 3]);\n\t\ttranslate([5,-35,0]) cube([2, 35, 3]);\n\t\ttranslate([len(label_text) * 12 - 7.5,-35,0]) cube([2, 35, 3]);\n\t\t}\n\ttranslate([-1,-35,0]) rotate([45,0,0]) cube([10, 10, 10]);\n\ttranslate([len(label_text) * 12 - 14,-35,0]) rotate([45,0,0]) cube([10, 10, 10]);\n\t}\n}\n```\n\nCould you write a parametric OpenSCAD file that allows me to do this? I'd like to keep the usage of the `write()` module for rendering the text; it looks like it comes from the `write/Write.scad` file that I am already using.\n"
  },
  {
    "object": "Hey cadmonkey, make me a 3D Printing Text Plate",
    "scad": "use <MCAD/shapes.scad>\nuse <MCAD/fonts.scad>\nthickness = 15;\ntext = \"HELLO WORLD\";\ntext_space = 10;\nextruder_xpos = 68;\nextruder_ypos = 54;\nnozzle_resolution = 6;\nenable_hole = 0;\nstyle = 1;\nbase_style = 2;\noutput_style = 2;\ntext_font = 8bit_polyfont();\nindicies = search(text,text_font[2],1,1);\nwidth = len(indicies)*32+text_space*2;\nheight = 67;\nround_dia = 30;\nrod_height = 5;\nrod_thick = 10;\nextruder_width = 28;\nextruder_height = 18;\nextruder_thick = thickness;\nnozzle_dia = 7;\nnozzle_height = 10;\ntext_scale = [4,5,3];\nbuild_plate_width = len(indicies)*32;\nbuild_plate_height = 8;\nhanging_hole_size = 18;\nplate_color = \"Grey\";\ntext_color = \"Red\";\nprinter_color = \"Silver\";\nscale([0.2666,0.2666,0.3333]) {\nif(output_style == 1 || output_style == 2) {\n\tdifference() {\n\t\tunion() {\n\t\t\ttranslate([0, height/2, 0])\n\t\t\tdifference() {\n\t\t\t\tcolor(plate_color)\n\t\t\t\ttranslate([-(width-round_dia)/2, -(height-round_dia)/2, -thickness/2])\n\t\t\t\t\tminkowski()\n\t\t\t\t\t{\n \t\t\t\t\t\tcube([width-round_dia,height-round_dia,thickness/2]);\n \t\t\t\t\t\tcylinder(r=round_dia,h=thickness/2);\n\t\t\t\t\t}\n\t\t\t\ttranslate([-(width)/2, -(height)/2, -thickness])\n\t\t\t\t\tcube([width,height,thickness*2]);\n\t\t\t}\n\t\t\ttranslate([-width/2, extruder_ypos, -rod_thick/2]) color (printer_color)\n\t\t\t\tcube([width, rod_height, rod_thick]);\n\t\t\ttranslate([extruder_xpos, 0, 0]) color(printer_color) {\n\t\t\t\ttranslate([0,extruder_ypos+rod_height/2, 0])\n\t\t\t\t\ttranslate([-extruder_width/2,-extruder_height/2,-extruder_thick/2])\n\t\t\t\t\tcube([extruder_width,extruder_height,extruder_thick]);\n\t\t\t\ttranslate([0,extruder_ypos-extruder_height/2-nozzle_height/4,0])\n\t\t\t\trotate([90,0,0]) {\n\t\t\t\t\tcylinder(h = nozzle_height/2, r1 = nozzle_dia, r2 = nozzle_dia/4);\n\t\t\t\t\ttranslate([0,0,-nozzle_height/2])\n\t\t\t\t\t\tcylinder(h = nozzle_height/2, r = nozzle_dia);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([-build_plate_width/2,-0.2,-thickness/2]) color(printer_color){\n\t\t\t\tcube([build_plate_width,build_plate_height,thickness*.9]);\n\t\t\t}\n\t\t\tif(enable_hole == 1) {\n\t\t\t\ttranslate([0,height+round_dia/2-hanging_hole_size/10,-thickness/2])\n\t\t\t\tcolor(plate_color) difference() {\n\t\t\t\t\tcylinder(h = thickness, r=hanging_hole_size);\n\t\t\t\t\ttranslate([-hanging_hole_size,-hanging_hole_size, -thickness/2])\n\t\t\t\t\t\tcube([hanging_hole_size*2,hanging_hole_size,thickness*2]);\n\t\t\t\t\ttranslate([0,hanging_hole_size/3,-thickness/2])\n\t\t\t\t\tcylinder(h = thickness*2, r=hanging_hole_size/4);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(style == 1) {\n\t\t\t\ttranslate([-(width)/2, 0, -thickness/2]) color(plate_color)\n\t\t\t\t\tcube([width,height,thickness/4]);\n\t\t\t}\n\t\t\tif(base_style == 1 ) {\n\t\t\t\ttranslate([-width/2-round_dia/2,-round_dia,-thickness/2]) color(plate_color) {\n\t\t\t\t\tcube([width+round_dia,round_dia,thickness]);\n\t\t\t\t}\n\t\t\t\ttranslate([-width/2-round_dia/2,-round_dia/2,-thickness/2]) color(plate_color) {\n\t\t\t\t\tcube([round_dia/2,round_dia,thickness]);\n\t\t\t\t}\n\t\t\t\ttranslate([width/2,-round_dia/2,-thickness/2]) color(plate_color) {\n\t\t\t\t\tcube([round_dia/2,round_dia,thickness]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(base_style == 2 ) {\n\t\t\t\tdifference() {\n\t\t\t\t\tunion() {\n\t\t\t\t\t\ttranslate([-width/2-round_dia/2,-round_dia,-thickness/2]) color(plate_color) {\n\t\t\t\t\t\t\tcube([width+round_dia,round_dia,thickness]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttranslate([-width/2-round_dia/2,-round_dia/2,-thickness/2]) color(plate_color) {\n\t\t\t\t\t\t\tcube([round_dia/2,round_dia,thickness]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttranslate([width/2,-round_dia/2,-thickness/2]) color(plate_color) {\n\t\t\t\t\t\t\tcube([round_dia/2,round_dia,thickness]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttranslate([-width/2+thickness,-round_dia-round_dia/2-round_dia/4,-thickness])\n\t\t\t\t\t\tcube([width-thickness*2,round_dia,thickness*2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttext();\n\t}\n}\nif(output_style == 0 || output_style == 2) {\n\ttext();\n}\n}\nmodule text() {\n\tdifference() {\n\t\tunion() {\n\t\t\tscale(text_scale)\n\t\t\t\ttranslate([-len(indicies)*text_font[0][0]/2,text_font[0][1]/2+.5-.05, -3])\n\t\t\t\t{\n\t\t\t\t\tfor(i=[0:(len(indicies)-1)] )\n\t\t\t\t\t\ttranslate([ i*text_font[0][0], -text_font[0][1]/2 ,1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlinear_extrude(height=4) polygon(points=text_font[2][indicies[i]][6][0],paths=text_font[2][indicies[i]][6][1]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\ttranslate([extruder_xpos+nozzle_resolution/4,extruder_ypos-extruder_height/2-nozzle_height+rod_height/2-nozzle_resolution,-thickness])\n\t\t\tcube([width,height,thickness*2]);\n\t\ttranslate([-width+extruder_xpos+nozzle_resolution/4,extruder_ypos-extruder_height/2-nozzle_height+rod_height/2,-thickness])\n\t\t\tcube([width,height,thickness*2]);\n\t}\n}",
    "description": "Okay, I'm trying to design a 3D printable text plate using OpenSCAD, and I'm hoping you can help me create a parametric design. I want something that's like a \"Hello World\" plaque but with the ability to customize the text and some other aspects. I want to be able to simulate what a printer nozzle would be doing on the plate, too.\n\nHere's a breakdown of the features I'd like, based on what I've seen in another design:\n\n**Core Features:**\n\n*   **Text Input:** I need to be able to specify the text that's printed on the plate. It should handle different lengths of text, and the plate width should adjust accordingly.\n*   **Plate Thickness:** I need to control the thickness of the base plate.\n*   **Text Spacing:** I need some space on the sides of the text, so the text is not right at the edges of the plate.\n*   **Extruder Simulation:** I want to be able to visualize the position of the 3D printer extruder and nozzle. I should be able to set the X and Y position of the extruder on the plate. This is just for visual reference, not for printing itself (it's not actual gcode generation)\n*   **Nozzle Resolution:** The nozzle will need a configurable resolution - for visualization, just like the extruder position.\n*   **Hanging Hole:** I'd like an option to include a hole for hanging the plate, and be able to turn this option on or off.\n*  **Style (Hollow or Solid):** I would like a parameter to control whether the plate underneath the text is a hollow base or a solid single-sided base.\n\n*   **Base Style (None, Solid, or Foot):** I want three base style options, where the default is none, but I can also have a simple solid base or \"feet\" on the bottom of the plate.\n*   **Output Style:** I want to be able to choose what gets rendered between: \"text only\", \"plate only\", or \"both text and plate.\"\n\n**Specific Details**\n\n*   **Text Font:** I'd like to use the `8bit_polyfont()` found in the MCAD library, which I understand is a standard font library for OpenSCAD.\n*   **Units:** Millimeters, ideally.\n*   **Plate Shape:** A rectangular plate with rounded edges, kind of like a capsule shape.\n\n**MCAD Library Usage:**\n\nI know the existing design uses the `MCAD/shapes.scad` and `MCAD/fonts.scad` from the MCAD library. I believe I need `shapes` for making the plate itself and `fonts` for working with the text.\n\n**Parameters to Control:**\n\nI would like to control all of the following as parameters in the file:\n\n*   `thickness`: The thickness of the plate.\n*   `text`: The text to be printed.\n*   `text_space`: The space between the text and the plate edges.\n*   `extruder_xpos`: The x-coordinate of the extruder for visualization purposes.\n*   `extruder_ypos`: The y-coordinate of the extruder for visualization purposes.\n*   `nozzle_resolution`: The resolution of the nozzle for visualization.\n*   `enable_hole`: A boolean to enable/disable the hanging hole.\n*   `style`: An integer to choose between \"hollow\" and \"single side\" styles.\n*   `base_style`: An integer to choose between \"none\", \"solid\", or \"foot\" styles.\n*    `output_style`: An integer to choose between \"text only\", \"plate only\", or \"both\".\n*    `plate_color`: Color of the plate.\n*   `text_color`: Color of the text.\n*   `printer_color`: Color of the printer elements (extruder, rod, build plate).\n\nI think I covered everything. If you have questions, I'm happy to answer them. I'm looking forward to seeing the parametric OpenSCAD file you create.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Portion Size Box",
    "scad": "container_size_dimension=61;\ncontainer_size_z=61;\nserving();\nmodule serving(){\ncontainer_x=container_size_dimension;\ncontainer_y=container_size_dimension;\ncontainer_z= container_size_z;\nhandle_x=2*container_x/3;\nhandle_y=15;\nhandle_z=2;\ndifference(){\n\tcube([container_x,container_y,container_z], center=true);\n\tcube([container_x-2,container_x-2,container_z+1], center=true);\n}\ntranslate([0,-container_y/2-handle_y/2,container_z/2-1])\ncube([handle_x,handle_y,handle_z], center=true);\ntranslate([0,container_y/2+handle_y/2,container_z/2-1])\ncube([handle_x,handle_y,handle_z], center=true);\n}",
    "description": "Okay, I need help designing a customizable portion control container using OpenSCAD. I'm looking for something where I can easily adjust the size of the box and also how tall it is. I'd also like two handles on the sides, which should be a little shorter than the box and relatively thin.\n\nHere are the specific parameters I'd like to control:\n\n*   **`container_size_dimension`**: This will control the width and depth of the container (it'll be a cube in those dimensions). I want to be able to set this value, and I want the container to be centered.\n*   **`container_size_z`**: This will control the height of the container. This should also be adjustable and the container should be centered in the Z direction.\n*   **`handle_x`**: This should be dependent on the `container_size_dimension` I set. It should be 2/3 the length of the `container_size_dimension`.\n*   **`handle_y`**: This should be a constant dimension for the width of the handle. Perhaps 15 units as a good default.\n*   **`handle_z`**: This will control the height of the handle. Perhaps 2 units for a good default.\n\nThe basic design should be a cube with a slightly smaller cube subtracted to create an interior cavity. Then the two handles are placed on the sides. \n\nSo, to summarize, I need an OpenSCAD file that defines a parametric portion control box with adjustable dimensions and handles. The container should have a hollowed-out interior. The handles should be on opposite sides of the box and their dimensions should be dependent on the container dimensions. Please also use comments in the code to explain how all of the code works.\n\nCan you help me with this? I'd prefer it if we didn't use any external libraries.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Crown generator",
    "scad": "include <write.scad>\ninner_radius=4.1;\nbody_height=10;\ntext=\"name\";\nfacet_radius=1;\naantal_spikes=6;\nhoogte_spikes=10;\nouter_radius=inner_radius+2;\n$fn=20;\npi=3.1415926;\npi2=pi*2;\ntranslate([0,0,-(body_height/2)+facet_radius]){\n\tdifference(){\n\t\trotate_extrude()\n\t\ttranslate([outer_radius, 0, 0])\n\t\t\tcircle(r = facet_radius,$fn=15);\n\t\t\trotate_extrude()\n\t\t\t\ttranslate([outer_radius-(2*facet_radius), -facet_radius, 0])\n\t\t\t\tsquare(2*facet_radius);\n\t\t\t\t}\n\t}\ntranslate([0,0,(body_height/2)-facet_radius]){\n\tdifference(){\n\t\trotate_extrude()\n\t\ttranslate([outer_radius, 0, 0])\n\t\t\tcircle(r = facet_radius,$fn=15);\n\t\t\trotate_extrude()\n\t\t\t\ttranslate([outer_radius-(2*facet_radius), -facet_radius, 0])\n\t\t\t\tsquare(2*facet_radius);\n\t\t\t\t}\n\t}\nfor (i = [5:7]) {\n\ttranslate([sin(360*i/6)*(outer_radius-.5), cos(360*i/6)*(outer_radius-.5), 0 ]) sphere(r = body_height/7.5,$fn=6);\n}\ndifference(){\ntranslate([0,0,0]){\ncylinder(r=outer_radius,h=body_height,center=true);\nwritecylinder(text,[0,0,0],t=1.5,outer_radius,center=true);\n}\ncylinder(r=inner_radius,h=body_height,center=true);\ntranslate([0,0,-0.5*body_height+6.35]) cylinder(r=4.7,h=4);\n}\ndifference(){\ntranslate([0, 0, .499*body_height]) {\n\tfor (i = [0:aantal_spikes]) {\n\t\trotate([90,0,360/aantal_spikes*i])\n\t\tlinear_extrude(height = outer_radius, center = false)\n\t\t\tpolygon(points=[[-pi*inner_radius/aantal_spikes,0],[pi*inner_radius/aantal_spikes,0],[0,hoogte_spikes]]);\n\t\t}\n\t}\ncylinder(r=inner_radius,h=body_height+3*hoogte_spikes,center=true);\ndifference(){cube(200,center=true);cylinder(h=50,r=outer_radius,$fn=20);}\n}\npos=(outer_radius-inner_radius)/2+inner_radius;\ntranslate([0, 0, 0]) {\n\tfor (i = [0:aantal_spikes]) {\ntranslate([sin(360*i/aantal_spikes)*(pos), cos(360*i/aantal_spikes)*(pos),.5*body_height+hoogte_spikes-1])\nsphere(1.5,$fn=10);\n}}",
    "description": "Okay, I'd like to design a crown in OpenSCAD, and it needs to be compatible with Ring-A-Thing. I'm thinking something that looks regal but also printable.\n\nHere's what I have in mind:\n\n**Basic Structure:**\n\n*   **Body:** A cylindrical base for the crown. The height and inner/outer radius should be parametric.\n*   **Flanges:** I'd like decorative flanges on both the top and bottom edges. I was thinking of using a series of circular extrudes with an overlapping square cutout to give a sort of scalloped effect. I need the radius of the circular extrudes to be a parameter.\n*   **Spikes:** A number of spike-like protrusions extending upwards from the top of the body. The number, height, and profile of these spikes should all be adjustable. The base of each spike should be a slightly rounded triangular shape, not a sharp point.\n*   **Pearls:** Small spherical \"pearls\" on the top of each spike. Their radius should be a parameter as well.\n*   **Gems:** Several small sphere-like \"gems\" embedded into the cylindrical body of the crown, probably around the \"equator.\" The placement of these should be parametric, probably based on the number of spikes, to help give the feeling of balance.\n*   **Text:** I want to have my name engraved into the body of the crown, using the `writecylinder()` function from the `write.scad` library.\n\n**Ring-A-Thing Compatibility:**\n\n*   A small cutout needs to be added to the inside of the crown, at the bottom, that would act as a connector for Ring-A-Thing. This is especially important for smaller crowns. I would want the size and location to be configurable.\n\n**Parametric Requirements:**\n\n*   Inner radius of the crown's body.\n*   Outer radius of the crown's body.\n*   Height of the crown's body.\n*   Text to be written on the crown.\n*   Radius of the flange's circular feature.\n*   Number of spikes.\n*   Height of the spikes.\n*   Radius of the pearls on top of spikes.\n*   Number of gems.\n*   Radius of the gems.\n*  The size of the Ring-A-Thing connector cutout\n\n**Specific Library Used:**\n\n*   I'll be using the `write.scad` library for the `writecylinder` function.\n\n**Additional Notes:**\n\n*   I want to make sure all the important parts are parameterized and easy to adjust. Id also prefer if the code is readable, with comments to explain what's going on.\n\nCould you help me generate a parametric OpenSCAD file based on these specifications?\n"
  },
  {
    "object": "Hey cadmonkey, make me a PixSCAD Proof-Of-Concept",
    "scad": "grid_height = 8;\ngrid_width = 8;\ngrid_overall_diameter = 4;\ngrid_lower_diameter = 3.5;\ngrid_upper_diameter = 2;\ngrid_maximum_height = 5;\ngrid_polygons = 3;\ngrid_base_height = 1;\ntranslate( [-grid_overall_diameter/2, -grid_overall_diameter/2,0] )\n\tcube( [grid_overall_diameter*(grid_width+1), grid_overall_diameter*(grid_height+1),grid_base_height] );\nfor ( x=[0:1:grid_height] ) {\n\tfor( y=[0:1:grid_width] ) {\n\t\ttranslate( [x*grid_overall_diameter,y*grid_overall_diameter,grid_base_height] )\n\t\t\tcylinder( h=(x+y)/4, r1=grid_lower_diameter/2, r2=grid_upper_diameter/2, $fn=grid_polygons+x/2+y/2 );\n\t}\n}",
    "description": "Okay, I have a basic OpenSCAD file that I'm using to explore generating 3D height maps from pixel data, and I'd like to take it a few steps further. I'm essentially using a grid of cylinders where the height of each cylinder is based on the x and y coordinates of its position on the grid.\n\nCurrently, I have a `grid_height` and `grid_width` that define the size of the grid in terms of the number of cylinders, and `grid_overall_diameter`, `grid_lower_diameter`, `grid_upper_diameter`, and `grid_maximum_height` that set the dimensions of the cylinders themselves. The number of sides to each cylinder, `$fn`, is dynamically set based on position, too. Finally, I also have `grid_base_height` for an underlying base.\n\nWhat I'd like is to create a parametric module that will allow me to import a PNG file, use its grayscale values to control the height of each cylinder, and further customize the result. Here are my specific needs and requests for the new module:\n\n1. **Image Input:** I need to be able to specify an image file path. The module should read a PNG file and treat each pixel as a point in the grid, using the pixel's grayscale value (0-255) to determine the cylinder's height within a maximum height range.\n2. **Height Mapping:** The grayscale values should be mapped to the height of each cylinder. Ideally, I would have a parameter to control the maximum height so a grayscale value of 255 maps to `max_cylinder_height`.\n3. **Grid Resolution:** The grid should be automatically generated based on the image dimensions. If the image is 64x64, my grid should be 64x64, with each cylinder representing a pixel. I shouldn't need `grid_height` or `grid_width` parameters anymore.\n4. **Cylinder Parameters:** The cylinder dimensions should be parametric. I should be able to control `cylinder_lower_diameter`, `cylinder_upper_diameter`, and `cylinder_polygon_count` with a single value that sets the polygon count for all cylinders. The `cylinder_base_height` should be separate, as well.\n5. **Scaling and Offset:** I need parameters to scale the size of the grid (`grid_scale`) and provide an x/y offset (`grid_offset`) for positioning the result.\n6.  **Optional Base:** I'd like an optional base underneath the cylinder array. I should have a `base_height` to control the thickness of the base, and a `draw_base` boolean to enable/disable it.\n7. **Image Preprocessing:** Ideally, I could specify a `grayscale_invert` boolean that would invert the grayscale values of the image (so 0 becomes 255 and vice-versa), and a `grayscale_offset` which would shift the grayscale value from 0-255 to a new starting point in the range of -255 to 255. I'd also like a `grayscale_scale` to amplify or attenuate the height of the cylinders based on the image's pixel values. The overall math should look like `final_grayscale_value = (original_grayscale_value * grayscale_invert * grayscale_scale) + grayscale_offset`.\n8. **Module Output:** The result should be a single module, that would allow me to render the final model. This module would handle all the parameters above.\n\nSo, to summarize, I would like a parametric module that takes an image, converts its grayscale values into a height map, and renders that as an array of cylinders, with adjustable scale, offset, height mapping parameters, and cylinder dimensions. I'd also like an optional base beneath the cylinders. I think it would be appropriate to use the `images` library for this, but I don't have that included with my current code. Could you help me implement this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Shelf Talker",
    "scad": "label_text = \"fiction\";\nfont_size = 20;\nletter_spacing = 1;\nfont = \"write/Letters.dxf\";\nshelf_thickness = 20;\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nuse <write/Write.scad>\nuse <utils/build_plate.scad>\nwidth = (.6875*font_size*letter_spacing);\ntotalwidth = width * (len(label_text) - 1);\nmodule full_talker() {\n\tunion() {\n\t\ttranslate([-3,0,0]) write(label_text,h=font_size,t=3,font=font, space=letter_spacing);\n\t\ttranslate([-5,-1.5,0]) cube([totalwidth, 3, 3]);\n\t\ttranslate([totalwidth - 5,shelf_thickness * -1 - 3,0]) cube([2, shelf_thickness + 3, 20]);\n\t\ttranslate([totalwidth - 5,shelf_thickness * -1 - 3,0]) rotate([0,0,5]) cube([25, 2, 20]);\n\t\ttranslate([totalwidth - 5,-1.5,0]) cube([20, 3, 20]);\n\t\t}\n}\ntranslate([totalwidth / -2,font_size + shelf_thickness / -2,0]) full_talker();",
    "description": "Okay, I'd like to design a customizable shelf talker, similar to the one I found online, but with some added flexibility. I've seen some designs that are okay, but I want something that lets me really tweak the look and feel. \n\nHeres what Im looking for:\n\n**Core Functionality:**\n\n*   **Text Label:** The shelf talker should prominently display a text label. This text should be customizable.\n*   **Font Control:** I need to be able to change the font style, font size, and letter spacing. The design I saw online used DXF fonts (which is fine), but I should also be able to use built-in fonts if I want.\n*   **Shelf Thickness:** The design should accommodate different shelf thicknesses. I need a parameter to control the thickness of the shelf the talker is designed to grip.\n*   **Attachment:** It should securely attach to the shelf edge, probably with a hook or lip at the back.\n\n**Additional Customization Features:**\n\n*   **Text Alignment:** I'd like to be able to control the text alignment  left, center, or right justified, within the available space.\n*   **Text Rotation:** Ability to rotate the text, for example, to make the label vertical instead of horizontal.\n*   **Overall Width:** Id like to have a parameter for the total length/width of the talker, not just based on the length of the text. I might want a specific length, and want the text to fit within it. The width could be auto-calculated too if the width parameter is not explicitly defined. \n*   **Text Placement:** Option to adjust the placement of the text block within the overall talker width.\n\n**General Design Considerations:**\n\n*   **Parametric Design:** It should be entirely parametric using OpenSCAD so I can easily change all of these parameters.\n*   **Robustness:** I'd like the design to be reasonably sturdy, so some thought about support and thickness of the plastic elements should be taken into account.\n*   **Ease of Use:** The parameters should be relatively intuitive to use.\n*   **Use Libraries:** Please use the write library that the original example used so that I have the DXF font support. I am happy to use any other library that makes the code cleaner or more functional.\n\n**Here's some inspiration from the design I found:**\n\nThe design I'm basing this on uses these libraries:\n\n*   `write/Write.scad` (for DXF font support)\n*   `utils/build_plate.scad` (though I don't need the build plate preview itself - it is just a convenience feature to define the size of the bed)\n\nId like to get something with similar functionality, but with the added flexibility I mentioned above. Can you please help me create an OpenSCAD file for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Solar Light Base",
    "scad": "D=21;\nH=21;\nH2 = 2;\nD2 = 36;\ntolerance = 0.2;\ndelta=0.5;\nB=6.3;\nResolution = 60;\n$fn=Resolution;\nnumber_of_ribs = 6;\nrib_thickness = 3;\ndifference(){\n\tunion() {\n\t\ttranslate([0,0,H2]) cylinder(h=H, r=(D+tolerance-delta)/2);\n\t\tcylinder(h=H2, r=D2/2);\n\t\tribs(number_of_ribs);\n\t\t}\n\tcylinder(h=H+H2, r=B/2);\n\t}\nmodule ribs(n){\n\tR=D/2+tolerance;\n\tthickness = rib_thickness;\n\tif (n > 0){\n\t\tfor ( i = [0 : 5] ){\n    \t\t\trotate( i * 360 / n, [0, 0, 1])\n    \t\t\ttranslate([-R, -thickness/2, H2])\n\t\t\tcube([R, thickness, H]);\n\t\t\t}\n\t}\n}",
    "description": "Okay, I need help designing a replacement base for my solar lights. The original bases always seem to break, and I'm tired of throwing away perfectly good lights. I'm thinking of making something that I can just hammer a landscaping nail through and then slide the light pole onto.\n\nHere's what I have in mind:\n\n**Overall Shape:** It should be cylindrical, with a wider base at the bottom for stability and a narrower \"male\" part on top that the solar light's pole will slide onto.\n\n**Specific Dimensions (these should be adjustable parameters):**\n\n*   **`male_diameter` (D):** The outer diameter of the \"male\" part that the light pole slides onto. I've been using 21mm for my lights, but I'd like to be able to adjust it.\n*   **`male_height` (H):** The height of the male part. I've found that a height similar to the diameter works well (so about 21mm initially).\n*   **`base_height` (H2):** The height of the base section. I think 2mm is enough for a base, but I'd like to be able to change it.\n*   **`base_diameter` (D2):** The diameter of the base section. I've been using 36mm, but this should also be adjustable.\n*   **`bore_diameter` (B):** This is the diameter of the hole for the landscaping nail, should be 6.3mm, but we should parameterize it just in case. 1/4 inch landscaping nail is very typical.\n*   **`rib_tolerance`:** This is how much the ribs will extend past the `male_diameter` before being filleted or rounded.\n*  **`rib_delta`**: This is the difference in radius before a rib extends out for the given `male_diameter`\n*   **`number_of_ribs`:** The number of ribs on the male part. Six seems to work.\n*   **`rib_thickness`:** How thick the ribs should be. 3mm seems okay.\n\n**Additional Design Notes:**\n\n*   **Bore:** The hole for the landscaping nail needs to go all the way through the base and the male part.\n*   **Ribs:** I want to add vertical ribs on the \"male\" part to help the light pole grip better. These ribs should be equally spaced around the circumference.\n*   **Resolution:** It should use a variable for `$fn` to control the resolution of rendering; call it `Resolution`, set to 60.\n\n**Request:**\n\nI'd like a parametric OpenSCAD file that allows me to easily adjust all the parameters listed above. Please use comments in the code so I can easily see what each variable does. It would be helpful if the code was also well organized and easy to follow.\n\nI don't need any fancy libraries. Just the standard OpenSCAD language is great.\n\nThanks for your help!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Mobile Phone Stand v2",
    "scad": "base_width = 70;\nbase_length = 70;\nwall_thickness= 3;\nsa_height = 80;\nsa_angle = 110;\nsv_height = 60;\nsv_angle = 75;\nto_length = 20;\nto_angle = 340;\ntv_length = 10;\nprint_mode = \"preview\";\nfuzz = 0.1;\nstart();\nmodule start(){\n\tif (print_mode == \"preview\"){\n\t\tstand();\n\t} else {\n\t\trotate(-90,[0,1,0])\n\t\tstand();\n\t}\n}\nmodule stand(){\n\tdifference(){\n \t\tding();\n\t\ttranslate([-300,-300,-600 + fuzz]) cube([600,600,600]);\n\t}\n}\nmodule ding(){\n\tcube([base_width,base_length,wall_thickness]);\n\t translate([0,base_length,0])\n\trotate(sa_angle,[1,0,0])\n\tcube([base_width,sa_height,wall_thickness]);\n\ttranslate([0,base_length+cos(sa_angle)*sa_height,sin(sa_angle)*sa_height])\n\trotate(sv_angle,[1,0,0])\n\ttranslate([0,-sv_height,0])\n\tcube([base_width,sv_height,wall_thickness]);\n\ttranslate([0,-cos(sv_angle)*sv_height,-sin(sv_angle)*sv_height])\n\ttranslate([0,base_length+cos(sa_angle)*sa_height,sin(sa_angle)*sa_height])\n\trotate(to_angle,[1,0,0])\n\ttranslate([0,-to_length,0])\n\tcube([base_width,to_length,wall_thickness]);\n\ttranslate([0,-cos(to_angle)*to_length,,-sin(to_angle)*to_length])\n\ttranslate([0,-cos(sv_angle)*sv_height,-sin(sv_angle)*sv_height])\n\ttranslate([0,base_length+cos(sa_angle)*sa_height,sin(sa_angle)*sa_height])\n\trotate(to_angle+90,[1,0,0])\n\tcube([base_width,tv_length,wall_thickness]);\n}\nmodule oud(){\ncube([base_width,base_length,base_height]);\nback_length = 110;\nback_thickness = 3;\nback_angle = 23;\ntranslate([0,base_length,0])\nrotate(back_angle,[1,0,0])\ncube([base_width,back_thickness,back_length]);\nfront_length = 62;\nfront_thickness = 3;\nfront_transY = sin(back_angle) * back_length;\nfront_transZ = cos(back_angle) * back_length;\nfront_angle = 240;\ntranslate([0,front_transY, front_transZ])\nrotate(front_angle, [1,0,0])\ncube([base_width,front_length,front_thickness]);\nh_length = 22;\ntranslate([0,16,49])\nrotate(150,[1,0,0])\ncube([base_width,h_length,base_height]);\ns_length  = 10;\ntranslate([0,-2,56])\nrotate(60,[1,0,0])\ncube([base_width,s_length,base_height]);\n}",
    "description": "Okay, I need a customizable phone stand designed in OpenSCAD. I want to be able to print it on its side without needing supports.\n\nHere are the key features I'd like:\n\n*   **Base:** The base should be a rectangular flat surface. I need to be able to control the width and length of this base. I also need to set the thickness of the material (wall thickness).\n*   **Back Support:** I want a sloped back support that extends upwards from the back edge of the base. I should be able to control the height of this support and the angle of its slope.\n*   **Front Support:** Similar to the back, I need a sloped front support extending from where the back support ends. I should be able to control the height and angle of this front support. It should come down to approximately the same y-level as the base.\n*   **Tray:**  There should be a tray to hold the phone. This tray will be formed by a flat, angled section extending from the bottom of the front support. I should be able to control the length of this flat tray portion and the angle it makes with the vertical (the angle should be settable beyond the normal 90 degrees so you have a way to invert it to hold a phone, so 340 degrees instead of -20, for example). Then, there needs to be a small lip at the end of the tray, which acts as a stop. I need to control the length of the tray lip.\n\nAlso, its really important that I can export this to an STL that prints *on its side*. To achieve this, Id like a parameter that switches between preview mode and print mode. When I select \"print\" mode, the whole model should be rotated 90 degrees around the y-axis before rendering. That way, I can print it without supports, with all the flat surfaces touching the build plate.  \n\nFinally, I need a small \"fuzz\" parameter to prevent rendering glitches.\n\nI've included my existing .scad file for reference. Please create an improved version.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Universal Art Frame",
    "scad": "T=1.5;\nw=60;\nwall=4;\nminT=5;\nmaxT=10;\nr=2;\nDhole=T+2;\nuse <MCAD/boxes.scad>\ndifference(){\n\ttranslate([0,0,maxT/2+T])roundedBox([w,w,maxT+2*T],r,$fn=16);\n\tdifference(){\n\t\ttranslate([0,0,maxT+2*T])cube([w-2*wall,w-2*wall,2*maxT],center=true);\n\t\ttranslate([-w/2,-w/2+wall,2*T+minT])rotate([45,0,0])cube([w,maxT,maxT]);\n\t\ttranslate([-w/2+wall,-w/2,2*T+minT])rotate([0,-45,0])cube([maxT,w,maxT]);\n\t}\n\trotate([0,0,45])translate([0,-w,-1])cube(2*w);\n\ttranslate([Dhole/2,0,w/4+T])cube(w/2,center=true);\n\ttranslate([0,Dhole/2,w/4+T])cube(w/2,center=true);\n\ttranslate(-(w/4-Dhole/2)*[1,1,0])cylinder(r=Dhole/2,h=2*maxT,center=true,$fs=1);\n\ttranslate([0,-w/2,(maxT+2*T)/2])rotate([90,0,0])monogram(h=0.6);\n}\nmodule monogram(h=1)\nlinear_extrude(height=h,center=true)\ntranslate(-[3,2.5])union(){\n\tdifference(){\n\t\tsquare([4,5]);\n\t\ttranslate([1,1])square([2,3]);\n\t}\n\tsquare([6,1]);\n\ttranslate([0,2])square([2,1]);\n}",
    "description": "Okay, I've got a pretty good idea for a picture frame, and I'd like to get an OpenSCAD file that I can easily adjust for different picture sizes.  I'm not looking for a full border frame, but more like a set of brackets that will hold a picture sandwich (picture + backing) against the wall.\n\nHere's the basic idea:  I want a bracket that has a rounded rectangular shape, mostly flat, with a lip that comes up a little to hold the picture and backing in place. The bracket will essentially sandwich the picture between the bracket itself and the wall. The main body of the bracket needs to be thick enough to be strong, but not too bulky. I'd also like a hole for a cord to thread through so I can hang the picture, and maybe a little monogram on one side.\n\nHere are the parameters I'd like to control, and their approximate current values:\n\n*   **`T`**: Thickness of the cord used for hanging. Let's start with 1.5 mm.\n*   **`w`**:  The overall width and depth of the bracket. This should be a square for symmetry. I'm thinking around 60 mm.\n*   **`wall`**:  The thickness of the lip/wall that holds the picture in place.  Around 4 mm seems good.\n*   **`minT`**: The minimum thickness of the picture \"sandwich\" (picture + backing). Let's say 5 mm to start.\n*   **`maxT`**: The maximum thickness of the picture sandwich. Let's start with 10 mm.\n*   **`r`**:  The radius of the rounded corners on the bracket. 2 mm should be nice.\n*   **`Dhole`**:  The diameter of the hole for the hanging cord. It should be slightly larger than the cord thickness, say `T+2` mm, as a default value.\n\nI need the bracket to have the following features:\n1.  A rounded rectangular base, that is basically flat.\n2. A lip, or raised wall, around the perimeter of the base to hold the picture. The inner area of the bracket should be wide enough for pictures and backing to fit.\n3.  Two holes along the y and x axis to allow for hanging via a cord (or maybe a nail). I'd like these holes to be the same diameter. The hole location should be automatically derived such that a hole is located in the middle of each side of the base along the x and y axis, located slightly above the plane of the bracket.\n4.  A small monogram/symbol on the bottom of the bracket. Let's try a stylized \"M\".\n5.  The bracket needs to have sufficient depth to accommodate a reasonable depth of backing+picture.\n\nRegarding libraries, I'd like to use the `MCAD/boxes.scad` library.\n\nCould you create a parametric OpenSCAD file based on this description? I'd also like it to be easy to adjust the various parameters, so include all the parameters as defined variables at the start of the file, and add plenty of descriptive comments. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Coin Battery holder",
    "scad": "nr = 10;\nbattery = \"CR2032\";\ncustom_radius = 10;\ncustom_width = 3;\nsizedivider = 0.8;\nmodule divider(radius) {\n  translate([radius, 0,radius])\n  rotate([-90,0,0]) {\n    difference() {\n      cylinder(r=radius, h=sizedivider,$fn=50);\n      translate([0,0,-0.01]) cylinder(r=radius-3, h=sizedivider +0.02);\n    }\n  translate([-radius,0,0]) cube([2*radius,radius,sizedivider]);\n  }\n}\nmodule holder(radius, width) {\n  length = nr*(sizedivider+width) + sizedivider;\n  rotate([0S,0,45])\n  union() {\n  for (i=[0:nr]) {\n    translate([0,i*(sizedivider+width),0]) divider(radius);\n  }\n  cube([2*radius, length, sizedivider]);\n  translate([-sizedivider+0.01,0,0]) cube([sizedivider, length, radius]);\n  translate([2*radius-0.01,0,0]) cube([sizedivider, length, radius]);\n  }\n}\nif (battery == \"CR2032\") {\n    holder(10,3);\n}\nif (battery == \"AG13\") {\n    holder(6,6.3);\n}\nif (battery == \"custom\") {\n    holder(custom_radius,custom_width);\n}",
    "description": "Okay, I'm looking to create a customizable battery holder for coin cell batteries, similar to the one found on Thingiverse (http://www.thingiverse.com/thing:21041) but much more flexible. \n\nI need a design that lets me specify:\n\n*   **Number of slots:** The number of coin cell batteries the holder should hold, let's call this `nr`. I'd like to be able to specify a value between, say, 5 and 25.\n*   **Battery type:** I need to be able to select a standard battery type from a dropdown list, specifically `CR2032` and `AG13`, or choose a custom size. Let's call this variable `battery`.\n*   **Custom battery dimensions:** If `custom` is selected for the `battery` variable, I need two additional parameters: `custom_radius` and `custom_width`, which define the radius and width of the custom battery.\n*   **Divider width:** The width of the dividers between each battery slot should also be adjustable, let's call this `sizedivider`. I'd suggest using this to be twice the nozzle diameter of the 3D printer.\n\nThe design should have these features:\n\n*   A base with dividers to separate the batteries.\n*   The dividers should be circular sections oriented such that the flat side makes contact with the base and provides a sort of shelf to support the batteries. \n*   The design should have walls on the long sides of the divider to ensure the batteries don't escape.\n\nCould you please write an OpenSCAD file that is parameterized like this?\n\nI'm not specifying the MCAD, BOSL, BOSL2, dotSCAD, NopSCADlib, or BOLTS libraries. I would prefer to do it all with vanilla OpenSCAD if possible. I'm also not specifying any specific file names for the included libraries.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Optics Table Servo Mount",
    "scad": "mount_hole = \"slot\";\nscrew_space = 28.3;\nmount_screw_diameter = 2.1;\nshaft_offset = 3.6;\nshaft_height = 25;\npost_thick = 1.5;\npost_width = 5;\nbreadboard_grid = 25.4;\nbreadboard_hole_diameter = 6.75;\nholes_x = 2;\nholes_y =3;\nbase_thick = 2;\nbase_clearance = 5;\n$fa=1;\n$fs=0.5;\nmount_screw_radius = mount_screw_diameter/2;\nbreadboard_hole_radius = breadboard_hole_diameter/2;\nmodule mounting_holes() {\n\tfor (i=[0:holes_x-1:holes_x-1]) {\n\t\tfor (t=[0:holes_y-1:holes_y-1]) {\n\t\t\ttranslate([i*breadboard_grid, t*breadboard_grid, 0]) {\n\t\t\t\tcylinder(r=breadboard_hole_radius, h=base_thick+1, center=false);\n\t\t\t}\n\t\t}\n\t}\n\tfor (j=[0:holes_y-1:holes_y-1]) {\n\t\ttranslate([0, j*breadboard_grid-breadboard_hole_diameter/2, 0]) {\n\t\t\tcube(size=[(holes_x-1)*breadboard_grid, breadboard_hole_diameter, base_thick+1], center=false);\n\t\t}\n\t}\n}\nmodule mounting_plate() {\n\tdifference() {\n\t\tcube(size=[(holes_x-1)*breadboard_grid+2*base_clearance+breadboard_hole_diameter,\n\t\t    (holes_y-1)*breadboard_grid+2*base_clearance+breadboard_hole_diameter, base_thick], center=false);\n\t\ttranslate([base_clearance+breadboard_hole_radius, base_clearance+breadboard_hole_radius, -0.5]) {\n\t\t\tmounting_holes();\n\t\t}\n\t}\n}\nmodule mount_post() {\n\tif (mount_hole == \"hole\") {\n\t\tdifference() {\n\t\t\tcube(size=[post_width, mount_screw_diameter+2*post_thick, shaft_height-base_thick+mount_screw_radius+post_thick], center=true);\n\t\t\ttranslate([0, 0, (shaft_height-base_thick+mount_screw_radius+post_thick)/2-(mount_screw_radius+post_thick)]) {\n\t\t\t\trotate([0, 90, 0]) {\n\t\t\t\t\tcylinder(r=mount_screw_radius, h=post_width+1, center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (mount_hole == \"slot\") {\n\t\tdifference() {\n\t\t\tcube(size=[post_width, mount_screw_diameter+2*post_thick, shaft_height-base_thick+mount_screw_radius+post_thick], center=true);\n\t\t\tcube(size=[post_width+1, mount_screw_diameter, shaft_height-base_thick-mount_screw_radius-post_thick], center=true);\n\t\t\ttranslate([0, 0, (shaft_height-base_thick-mount_screw_radius-post_thick)/2]) {\n\t\t\t\trotate([0, 90, 0]) {\n\t\t\t\t\tcylinder(r=mount_screw_radius, h=post_width+1, center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([0, 0, -(shaft_height-base_thick-mount_screw_radius-post_thick)/2]) {\n\t\t\t\trotate([0, 90, 0]) {\n\t\t\t\t\tcylinder(r=mount_screw_radius, h=post_width+1, center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule servo_mount() {\n\tunion() {\n\t\ttranslate([0, screw_space/2, (shaft_height-base_thick+mount_screw_radius+post_thick)/2+base_thick]) {\n\t\t\tmount_post();\n\t\t}\n\t\ttranslate([0, -screw_space/2, (shaft_height-base_thick+mount_screw_radius+post_thick)/2+base_thick]) {\n\t\t\tmount_post();\n\t\t}\n\t\ttranslate([0, 0, base_thick/2]) {\n\t\t\tcube(size=[post_width, screw_space+mount_screw_diameter+2*post_thick, base_thick], center=true);\n\t\t}\n\t}\n}\nmodule bb_servo_mount() {\n\tunion() {\n\t\ttranslate([-post_width/2, ((holes_y-1)*breadboard_grid+2*base_clearance+breadboard_hole_diameter)/2 + shaft_offset, 0]) {\n\t\t\tservo_mount();\n\t\t}\n\t\tmounting_plate();\n\t}\n}\nbb_servo_mount();",
    "description": "Okay, I need a parametric OpenSCAD design for mounting hobby servos to an optics breadboard, but I'd like a few specific changes and to make it more flexible.\n\nHere's what I'm looking for:\n\n**Core Functionality:**\n\n*   The design should mount a standard hobby servo to an optics breadboard.\n*   The base will attach to the breadboard via slots that are a multiple of the breadboard grid spacing. The slots should be long enough to allow for some adjustment.\n*   The servo is mounted on posts connected to the base.\n*   The servo mounting holes should be parametric and allow for both hole and slot shapes.\n\n**Specific Requirements based on the example I have:**\n\n*   **Breadboard Compatibility:**\n    *   The breadboard grid spacing should be parametric.\n    *   The clearance hole diameter for the breadboard mounting screws should be parametric.\n    *   The number of mounting holes to be covered in both X and Y directions should be parametric.\n    *   The clearance around the mounting slots should be parametric.\n*   **Servo Mounting:**\n    *   The distance between the servo mounting holes should be parametric.\n    *   The mounting screw diameter should be parametric.\n    *   The offset of the servo spline from the center of the mounting screws should be parametric.\n    *   The desired height of the servo spline should be parametric (assuming the mounting screws are at a reference height)\n    *   The thickness around mounting holes on posts should be parametric.\n    *   The post width should be parametric.\n*   **Base:**\n    *   The base thickness should be parametric.\n*   **General:**\n    *   The design should use reasonable OpenSCAD best practices for maintainability and customizability.\n    *   I'd like to be able to change the render resolution through `$fa` and `$fs`.\n\n**Desired Changes/Additions:**\n\n*   **Servo Orientation:** I'd like to be able to specify an additional parameter for the servo orientation, so the whole mounting assembly can be rotated in the XY plane. This should allow us to mount servos on all four sides of a breadboard.\n*   **Base Shape:** Instead of a simple rectangle, I'd like the base shape to be more customizable, possibly having a set of predefined shapes (rectangle, circle, rounded rectangle). If possible, allow a custom shape to be imported as a DXF.\n*   **Multiple Servos:**  It would be great if the design could be easily modified to mount multiple servos on a single base.  Maybe this could be an additional parameter or function, letting me place multiple servo mounts on the base and adjust their positions relative to each other.\n*   **Library Usage:** I'm open to using standard OpenSCAD libraries if that would improve the design, such as the BOSL libraries, or others you may recommend.\n\n**Summary:**\n\nI need a highly parametric OpenSCAD module for mounting hobby servos to optics breadboards, with the flexibility to handle different servos, breadboards, mounting positions, base shapes, and the ability to mount multiple servos. I'd also like to add the capability for servo mount rotation in the XY plane, a customizable base shape (or a set of base shapes) and to be able to import a custom base shape using DXF. I'd also like to be able to place multiple mounts on the base. Please use any useful libraries you deem appropriate.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Thermos Donut & Coffee Shop Marker",
    "scad": "use <write/Write.scad>\nFont = \"write/orbitron.dxf\";\nfavorite_donut=\"Boston Cream\";\nfavorite_coffee_place=\"Starbucks\";\nheight_of_donut_letters=10;\nheight_of_coffee_place_letters=8;\nthermos();\nmodule thermos(){\nrad1=70.3/2;\nrad2=76.88/2;\nwritecylinder(favorite_donut,[0,0,0],rad1+4,20,rotate=0, h=height_of_donut_letters, font=Font);\nwritecylinder(favorite_coffee_place,[0,0,-15],rad1+3,20,rotate=0, h=height_of_coffee_place_letters, font=Font);\ndifference(){\ncylinder(r1=rad1+1.5,r2=rad2+1.5,h=40,$fn=128, center=true);\ntranslate([0,0,0])\ncylinder(r1=rad1,r2=rad2,h=41,$fn=128, center=true);\n}\n}",
    "description": "Okay, I'm looking for an OpenSCAD design for a personalized thermos accessory. I have an Oxo thermos, and I want a way to easily tell it apart from others, kind of like a name tag. I'd like it to wrap around the thermos and display my favorite donut flavor and my favorite coffee shop.\n\nHere are the specifics:\n\n1.  **Shape:** The main part should be a hollow cylinder that sits on the thermos. It should have a consistent inner diameter that matches the thermos near the base and a slightly larger outer diameter. The top and bottom of the hollow cylinder should be slightly beveled, so they are not a sharp edge, rather they should curve slightly. The inner diameter of the cylinder should grow from the bottom to the top and the outer diameter should grow at the same rate. \n\n2. **Text:**\n    *   I want two lines of text, both curved around the cylinder.\n    *   The first line should display my favorite donut flavor. I should be able to customize this via a variable.\n    *   The second line should display my favorite coffee shop. This should also be customizable with a variable.\n    *   The donut flavor text should be closer to the top of the thermos, and the coffee shop text should be below it.\n    *   The height of the letters for the donut flavor should be configurable via a variable.\n    *   The height of the letters for the coffee shop should be configurable via a variable.\n\n3.  **Customization:**\n    *   I need variables for the donut flavor text, coffee shop text, the height of the donut flavor text, and the height of the coffee shop text.\n    *   It should use a font from the `Write` library in OpenSCAD. I'd like the default font to be \"orbitron.dxf\", but I would like to be able to change it. So, it would be nice to have a variable for the font.\n    * I'd like to be able to change the radius at the base of the thermos and the radius at the top of the thermos. These will affect the diameter of the internal and external cylinder.\n\n4.  **Libraries:** I'd like this design to use the `Write` library for the text and include comments on what is being done.\n\nCould you generate a parametric OpenSCAD file for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Glass Plate clips parametric-now customizable",
    "scad": "bed_thick=3.2;\nglass_thick=2.25;\nwidth=5;\nclip_thick=4;\ndepth=5;\nnub=.25;\nunion(){\n\tdifference(){\n\t\tcube([bed_thick+glass_thick+2*clip_thick,depth+clip_thick,width]);\n\t\ttranslate([clip_thick,clip_thick,-0.1])\n\t\t\tcube([bed_thick+glass_thick,depth+0.1,width+0.2]);\n\t\tdifference(){\n\t\t\ttranslate([-0.1,-0.1,-0.1])\n\t\t\t\tcube([bed_thick+glass_thick+2*clip_thick+0.2,clip_thick+0.2,width+0.2]);\n\t\t\ttranslate([clip_thick,clip_thick,0])\n\t\t\t\tcylinder(h=width,r=clip_thick);\n\t\t\ttranslate([clip_thick+glass_thick+bed_thick,clip_thick,0])\n\t\t\t\tcylinder(h=width,r=clip_thick);\n\t\t\ttranslate([clip_thick,0,-0.1])\n\t\t\t\tcube([glass_thick+bed_thick,clip_thick,width+0.2]);\n\t\t}\n\t}\n\tdifference(){\n\t\ttranslate([0,clip_thick+depth,0])\n\t\t\tcylinder(h=width,r=clip_thick+nub);\n\t\ttranslate([-clip_thick-nub,0,-0.1])\n\t\t\tcube([clip_thick+nub,100,width+0.2]);\n\t}\n\tdifference(){\n\t\ttranslate([bed_thick+glass_thick+2*clip_thick,clip_thick+depth,0])\n\t\t\tcylinder(h=width,r=clip_thick+nub);\n\t\ttranslate([bed_thick+glass_thick+2*clip_thick,0,-0.1])\n\t\t\tcube([clip_thick+nub,100,width+0.2]);\n\t}\n}",
    "description": "Okay, I'm looking to design some small clips for holding a glass plate onto a bed, like on a 3D printer. I've got a basic design in mind, and I'd like to make it fully parametric in OpenSCAD so I can easily adjust it for different thicknesses.\n\nHere's what I'm trying to achieve:\n\n*   **The basic shape:** The clip should be a sort of \"U\" shape. One side of the \"U\" will clamp down on the bed, and the other side will clamp down on the glass. \n*   **Parametric variables:** I need to be able to adjust these values:\n    *   `bed_thick`: The thickness of the bed.\n    *   `glass_thick`: The thickness of the glass.\n    *   `width`: The width of the clip.\n    *   `clip_thick`: The thickness of the clip's bars.\n    *   `depth`: How far the clip extends onto the glass and bed.\n    *   `nub`: The \"tightness\" factor. This will control how much smaller the clamping nubs are compared to the combined thickness of the bed and glass. This should be a small value (e.g., 0.25).\n*   **Construction details:**\n    * The main body should have the \"U\" shape described above, creating a channel for the bed and glass.\n    * There should be small circular nubs that extend from the inside edges of the U-shape. These nubs will actually grab and hold the glass and bed. These need to be smaller than the combined thickness by the 'nub' variable.\n    * I want to ensure that the overall clip extends beyond the bed and glass to allow for full clamping.\n*   **Final design:**\n    * I'd like the clip to be fairly simple in design and should be fully 3D printable.\n\nCould you generate an OpenSCAD file that takes these parameters and constructs this clip design?  I'd like to avoid using any external libraries if possible to keep it simple. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Wrench with Nut holding Cap",
    "scad": "include <MCAD/shapes.scad>\ninclude <write/Write.scad>\nNut_Size = 5.5;\nTool_Height = 2.5;\nTool_Length = 10;\nHas_holding_cap = 1;\nmessage = \"My Wrench\";\nFont = \"write/Letters.dxf\";\n$fs=0.1;\nkerf = 0.3 + 0;\nD = Nut_Size + kerf;\nM = D/2;\nH = Tool_Height;\nLtot = D * Tool_Length;\nText_Height = Nut_Size*0.7 ;\nL = Ltot-2*(D/2+M);\nrotate([0, 0, -45])\ndifference() {\n\tunion() {\n\t\tif (Has_holding_cap == 1) {\n\t\t\ttranslate([0,L/2,0]) {\n\t\t\t\tcylinder(r=(D/2+M), h= 0.5);\n\t\t\t}\n\t\t}\n\t\tdifference() {\n\t\t\tunion() {\n\t\t\t\ttranslate([0,L/2,H/2]) {\n\t\t\t\t\tcylinder(r = (D/2+M), h = H,center = true);\n\t\t\t\t}\n\t\t\t\ttranslate([0,-L/2,H/2]) {\n\t\t\t\t\tcylinder(r = (D/2+M), h = H,center = true);\n\t\t\t\t}\n\t\t\t\ttranslate([-1*D/2,-L/2,0]) {\n\t\t\t\t\tcube([D,L,H], center=false);\n\t\t\t\t}\n\t\t\t\tif (Has_holding_cap == 1) {\n\t\t\t\t\ttranslate([0,L/2,H]) {\n\t\t\t\t\t\tcylinder(r=(D/2+M), h= 0.5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([0,-L/2 - D / 4,H/2 - 1]) {\n\t\t\t\trotate([0,0,30]) {\n\t\t\t\t\thexagon(D, H + 4);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([0,-L/2 - D - D / 4,H/2 - 1]) {\n\t\t\t\tcube([D,2*D,H + 2], center = true);\n\t\t\t}\n\t\t\ttranslate([0,L/2,H/2 - 1]) {\n\t\t\t\trotate([0,0,30]) {\n\t\t\t\t\thexagon(D, H + 4);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([0, 0, H - .1]){\n\t\t\t\trotate([0,0,90]) {\n\t\t\t\twrite(message,t=.6,h=Text_Height,center=true,font=Font);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (Has_holding_cap == 1) {\n\t\ttranslate([0,L/2,H/2-1]) {\n\t\t\tcylinder(r=(Nut_Size-2)/2, h= H+2, center=true);\n\t\t}\n\t}\n}",
    "description": "Okay, I'd like to design a parametric mini wrench in OpenSCAD, similar to the one I found on Thingiverse (http://www.thingiverse.com/thing:82067), but with a few tweaks and improvements.\n\nThe basic wrench design is a flat tool with a hexagonal opening on one end for a nut, and a handle extending from the other side. It's essentially a modified version of a design that I have seen before (http://www.thingiverse.com/thing:47842 and it in turn references http://www.thingiverse.com/thing:11647 and http://www.thingiverse.com/thing:4137). I want to make it customizable, so I can adjust the nut size, tool thickness, and overall length.\n\nHere's what I'm looking for in terms of parameters:\n\n*   **Nut Size:** The size of the nut it's designed to fit, in millimeters. This determines the size of the hexagonal opening.\n*   **Tool Height:** The thickness of the tool itself, in millimeters.\n*   **Tool Length:** I'd like to specify the total length as a multiple of the nut diameter. So, if the nut diameter is 5mm, and I set the length to 10, the total length would be 50mm.\n*  **Holding Cap:** I would like a boolean variable to determine whether the closed end of the wrench is designed to hold a nut in place, using a small cylindrical cutout.\n*   **Text Message:** I want to be able to engrave a custom message on the tool. I'd like to control the actual string here, and have it be relatively short (max. 12 characters, for now).\n*   **Font:** I would like to choose the font.\n\nI want a hexagonal nut opening, and I also want a small amount of kerf built into the design, so the wrench actually fits the nut snugly but not too tight. I'd like it to be relatively high resolution, with the text engraved deeply. I also want to be able to choose the text font.\n\nFor libraries, I expect I will need to use `MCAD/shapes.scad` and `write/Write.scad`.\n\nThe main feature I'd like, that I haven't seen elsewhere, is the option for a holding cap. This will create a small cylindrical recess on the \"handle\" side to allow the user to capture a nut. The user can then position this nut easily, so it is held in place while screwing another screw/bolt in.\n\nCould you create this parametric OpenSCAD file for me?\n"
  },
  {
    "object": "Hey cadmonkey, make me a [With polygonal frame] Customizable Lithophane",
    "scad": "image_file = \"image-surface.dat\";\nhole_diameter = 10;\nimage_angle = 0;\nframe_side_number = 6;\nlayer_height = 0.2;\nnumber_of_layers = 15;\nlength = 100;\nwidth = 100;\nmin_layer_height = layer_height*2;\nhole_radius = hole_diameter/2;\nheight = layer_height*number_of_layers;\nunion() {\nintersection() {\n  difference() {\n    rotate([0,0,image_angle]) translate([0, 0, min_layer_height]) scale([100/150,100/150,height]) surface(file=image_file, center=true, convexity=5);\n    translate([0,0,-(height+min_layer_height)]) linear_extrude(height=height+min_layer_height) square([length, width], center=true);\n  }\n    rotate([0,0,90])\n      cylinder(r=length/2,h=height*2,$fn=frame_side_number);\n}\n  linear_extrude(height=layer_height*2)\n    rotate([0,0,90])\n      circle(r=(length+4)/2, center=true, $fn=frame_side_number);\n  linear_extrude(height=height+min_layer_height){\n\t  difference(){\n\t\tunion(){\n\t     rotate([0,0,90])\n          circle(r=(length+4)/2, center=true, $fn=frame_side_number);\n\t\t  translate([0, width/2+hole_radius+2, 0])\n\t\t    circle(r=hole_radius+5);\n\t\t}\n\t    union(){\n\t     rotate([0,0,90])\n          circle(r=length/2, center=true, $fn=frame_side_number);\n\t\t  translate([0, width/2+hole_radius+2, 0])\n\t        circle(r=hole_radius);\n\t    }\n\t  }\n  }\n}",
    "description": "Okay, I've been playing around with some lithophane generators, and I really like the idea of a polygonal frame like the one in \"uploads-12-c4-26-17-3d-lithophaneV2.scad\". I want to create a new version with even more flexibility.\n\nHere's what I'm looking for:\n\n**Core Functionality:**\n\n*   **Image Loading:** I need to be able to load a 2D grayscale image (like a .dat file or similar that OpenSCAD's `surface()` function can use). The image should be stretched to fit within the frame, similar to how the example works. The image should be able to be rotated and scaled independently of the frame.\n*   **Lithophane Generation:**  The image data will be converted to a 3D surface using the `surface()` function, with the height of the surface determined by the grayscale value in the image. This should be a standard lithophane creation process. The lithophane should have a base that provides some thickness, just like in the example.\n*   **Polygonal Frame:** Instead of a fixed number of sides, I want a variable-sided polygon for the frame. I'd like to specify the number of sides. The frame should also have adjustable thickness.\n*   **Mounting Hole:** Similar to the example, I want a mounting hole near the top of the frame. I'd like to be able to control the position (angle) and size of this hole.\n* **Frame Customization:** I'd like to be able to specify the overall size of the frame, in terms of diameter of a circle it circumscribes, and specify its thickness.\n* **Layer Height Control**: I'd like to specify the printing layer height, and number of layers, similar to the existing code. The base should always be 2 layers high.\n\n**Parameters I'd like to control:**\n\n*   `image_file`: The path to the image file.\n*   `image_angle`: Rotation of the image within the frame (in degrees).\n*   `image_scale_x`: Scaling factor for the image in the x-direction.\n*   `image_scale_y`: Scaling factor for the image in the y-direction.\n*   `frame_sides`: Number of sides for the polygon frame.\n*   `frame_thickness`: Thickness of the frame (extrusion height)\n*   `frame_diameter`: Diameter of the circle which circumscribes the polygon frame.\n*   `hole_diameter`: Diameter of the mounting hole.\n*   `hole_angle`: Angle (in degrees, relative to the center of the frame) where the hole will be placed. 0 degrees is the 'top' or 'north' of the circle in a normal polar coordinate system.\n*  `layer_height`: Layer height for the lithophane printing.\n* `number_of_layers`: Number of layers for the lithophane image data.\n\n**How it should work:**\n\nThe script should first create the lithophane image data, then create the frame. The frame should be made of a union of the polygonal base (circumscribed around the lithophane), a base ring for support, and a mounting hole.\n\n**Libraries:**\n\nI don't think I need any special libraries for this, but please let me know if you think it would make things easier.\n\nCould you generate a parametric OpenSCAD file that does all of this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Battery Tray with full/empty label ",
    "scad": "use <write/Write.scad>\n_label = \"full\";\n_diameter = 14.6;\n_height = 15;\n_columns = 3;\n_rows = 1;\n_spacing = 1.2;\n_base = 1;\n_cornerRounding = 4.0;\nmodule batteryQuad(diameter, height) {\n\tangle = 35;\n\tr = diameter/2;\n\tcut = 2*r*sin(angle);\n\ttan = tan(angle);\n\tfilletCenter = r - r * tan;\n\tfilletCenter2 = r + r * tan;\n\tfilletOffset = r * tan;\n\tfilletRadius = r/cos(angle) - r;\n\teps = 0.1;\n\tdifference() {\n\t\tunion() {\n\t\t\tfor (x=[-r,r]) {\n\t\t\t\tfor (y=[-r,r]) {\n\t\t\t\t\ttranslate([x,y,0]) {\n\t\t\t\t\t\tcylinder(r=r, h=height, center=true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (t=[ [ r, 0, 0],\n\t\t\t\t\t[-r, 0, 0],\n\t\t\t\t\t[ 0, r, 0],\n\t\t\t\t\t[ 0,-r, 0] ]) {\n\t\t\t\ttranslate(t) {\n\t\t\t\t\tcube(size=[cut,cut,height], center=true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (z=[0:90:270]) {\n\t\t\trotate([0,0,z]) {\n\t\t\t\tfor(y=[filletOffset, -filletOffset]) {\n\t\t\t\t\ttranslate([0, r+y,0]) {\n\t\t\t\t\t\tcylinder(r=filletRadius, h=height+eps, center=true, $fn=30);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule makeTray(diameter, height, rows, columns, spacing, base, rounding) {\n\teps = 0.1;\n\trounding = min(rounding, diameter/2 + spacing*2);\n\tquadSize = 2 * diameter;\n\twidth = (quadSize + spacing) * columns + spacing*2;\n\tdepth = (quadSize + spacing) * rows + spacing*2;\n\txstart = -width/2 + spacing*1.5 + quadSize/2;\n\tystart = -depth/2 + spacing*1.5 + quadSize/2;\n\tdifference() {\n\t\thull()\n\t\tfor (x=[-width/2 + rounding, width/2 - rounding])\n\t\tfor (y=[-depth/2 + rounding, depth/2 - rounding]) {\n\t\t\ttranslate([x,y])\n\t\t\tcylinder(r=rounding, h=height);\n\t\t}\n\t\ttranslate([0,0,height/2 + base]) {\n\t\t\tfor (x=[0:1:columns-1])\n\t\t\tfor (y=[0:1:rows-1]) {\n\t\t\t\ttranslate([xstart + (quadSize + spacing)*x,\n\t\t\t\t\t\t\t ystart + (quadSize + spacing)*y,0]) {\n\t\t\t\t\tbatteryQuad(diameter, height);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule battery_icon(thickness=1, empty=true) {\n\twidth = 19;\n\theight = 8;\n\teps = 0.1;\n\tscale(1/height) union() {\n\t\tdifference() {\n\t\t\tcube([width, height, thickness], center=true);\n\t\t\tcube([width-2, height-2, thickness+2*eps], center=true);\n\t\t}\n\t\ttranslate([width/2 + 1/2 - eps, 0, 0])\n\t\t\tcube([1+eps, height/2, thickness], center=true);\n\t\tif(empty) {\n\t\t\ttranslate([-7, 0, 0])\n\t\t\t\tcube([1, height-4, thickness], center=true);\n\t\t} else {\n\t\t\tfor (i = [-3:4]) {\n\t\t\t\ttranslate([2*i-1, 0, 0])\n\t\t\t\t\tcube([1, height-4, thickness], center=true);\n\t\t\t}\n\t\t}\n\t}\n}\ntotal_depth=((2*_diameter + _spacing) * _rows + _spacing*2);\ntotal_width=((2*_diameter + _spacing) * _columns + _spacing*2);\nmakeTray(_diameter, _height, _rows, _columns, _spacing, _base, _cornerRounding, $fn=90);\nif(_label == \"empty\") {\n\ttranslate([0, -total_depth/2, _height/2])\n\t\trotate([90,0,0])\n\t\twrite(\"empty\", h=_height/2, t=1.5, center=true, font=\"write/orbitron.dxf\");\n\ttranslate([0, total_depth/2, _height/2])\n\t\trotate([90,0,180])\n\t\tscale([_height/2, _height/2, _height/2*1.5])\n\t\t#battery_icon(empty=true);\n} else {\n\ttranslate([0, -total_depth/2, _height/2])\n\t\trotate([90,0,0])\n\t\twrite(\"full\", h=_height/2, t=1.5, center=true, font=\"write/orbitron.dxf\");\n\ttranslate([0, total_depth/2, _height/2])\n\t\trotate([90,0,180])\n\t\tscale([_height/2, _height/2, _height/2*1.5])\n\t\t#battery_icon(empty=false);\n}",
    "description": "Okay, I'd like a parametric OpenSCAD design for a battery tray, similar to the one I found online but with a few adjustments and more flexibility.\n\nHere's what I'm looking for:\n\n**Core Functionality:**\n\n*   **Battery Pockets:** The design should create pockets to hold cylindrical batteries, arranged in a grid. Each pocket should be able to accommodate a range of battery sizes, specified by their diameter.\n*   **Labeling:** The tray should have a label on one side indicating whether the tray is for \"full\" or \"empty\" batteries. This label should use text and a battery icon. The text should be readable, perhaps using the \"write\" library and a font like \"orbitron.dxf.\" The icon should be a simple representation of a battery, filled to varying degrees to symbolize full or empty.\n*   **Parametric Design:** The entire design must be parametric, allowing the user to easily adjust key parameters.\n\n**Specific Parameters:**\n\n*   **`_label`:** A dropdown menu with two options: \"empty\" or \"full\". This will control what text is used on the tray and how the battery icon is displayed.\n*   **`_diameter`:** The diameter of the batteries that the tray will hold (e.g. 14.5 for AA, 10.6 for AAA, 16.8 for 123A, 15.5 for CR2).\n*   **`_height`:** The overall height of the tray, including the base.\n*   **`_columns`:** The number of battery clusters in a row.\n*   **`_rows`:** The number of battery clusters in a column (depth).\n*   **`_spacing`:** The spacing between battery clusters and the tray edges.\n*   **`_base`:** The thickness of the base under the battery pockets.\n*   **`_cornerRounding`:** The radius of the corner rounding of the tray.\n\n**Details:**\n\n*   **Battery Pocket Shape:** I like how the reference design uses a slightly rounded square pocket shape, like a cylinder with cut-offs, not just a perfect circle. The rounding adds a nice touch and helps retain the batteries.\n*   **Label Placement:** The text label should be on the bottom edge of the tray, and the icon on the opposite (top) edge, both centered horizontally and a small distance outside the main tray body. The text and the icon should be raised from the surface for visibility, at a level similar to or a little thicker than the original design.\n*   **Library Usage:** Please include the `write/Write.scad` library for the text label, and be sure to use a suitable font such as the given `orbitron.dxf` if possible.\n\n**Desired Outcome:**\n\nThe OpenSCAD file should be easy to use, with clearly defined parameters at the beginning. The resulting 3D model should be a functional and aesthetically pleasing battery tray. It should be easy to generate trays for different battery sizes and label them for storage.\n\nI think that covers everything. Please let me know if you need any additional clarification!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Coin battery backpack - No soldering needed",
    "scad": "battery = \"CR2032\";\ncustom_radius = 10;\ncustom_width = 3;\nedge = 0.8;\nradwire = 0.6;\nrack_x = 1;\nrack_dist_x = 20;\nrack_y = 1;\nrack_dist_y = 15;\nuse <utils/build_plate.scad>;\nuse <MCAD/fonts.scad>\nbuild_plate_selector = 0;\nbuild_plate_manual_x = 100;\nbuild_plate_manual_y = 100;\nbuild_plate(build_plate_selector,build_plate_manual_x,build_plate_manual_y);\nmodule divider(radius,width) {\n  difference() {\n    cylinder(r=radius+edge, h=edge+radwire,$fn=50);\n    translate([-radius/2,1,0]) cylinder(r=radwire, h=edge+10,center=true,$fn=50);\n    translate([radius/2,1,0]) cylinder(r=radwire, h=edge+10,center=true,$fn=50);\n    translate([-radius/2, 1-radwire,edge]) cube([radius,2*radwire,2*radwire]);\n    }\n  difference() {\n    cylinder(r=radius+edge, h=edge+radwire+width,$fn=50);\n    cylinder(r=radius, h=4*(edge+0.8+width),$fn=50, center=true);\n    translate([0, 2*radius, width+edge+radwire]) cube([4*radius, 4*radius,2*width], center = true);\n    }\n}\nmodule cap(radius,width) {\n  difference() {\n    translate([0,0,width+edge+radwire-0.01]) cylinder(r=radius+edge, h=edge+radwire,$fn=50);\n    translate([-radius/2,-2,width]) cylinder(r=radwire, h=edge+10,center=true,$fn=50);\n    translate([radius/2,-2,width]) cylinder(r=radwire, h=edge+10,center=true,$fn=50);\n    translate([-radius/2-radwire,-2,width]) cube([2*radwire, 2+radius,2*(edge+radwire)]);\n    translate([+radius/2-radwire,-2,width]) cube([2*radwire, 2+radius,2*(edge+radwire)]);\n    translate([0, 2*radius, width+2*(edge+radwire)-0.1]) cube([4*radius, 4*radius,2*(edge+radwire)], center = true);\n    translate([-radius/2, -2-radwire,edge+width]) cube([radius,2*radwire,2*radwire]);\n    }\n}\nmodule holder(radius, width) {\n  translate([0,0,4+radius])\n  rotate([90,0,45])\n  union() {\n    difference() {\n      translate([-radius/2,-radius-4,0]) cube([radius, 4, width+2*(edge+radwire)]);\n      translate([radius/4, -radius-edge-1.5,0])cylinder(r=radwire, h=2*(width+edge+10),center=true,$fn=50);\n      translate([-radius/4, -radius-edge-1.5,0])cylinder(r=radwire, h=2*(width+edge+10),center=true,$fn=50);\n      }\n    divider(radius,width);\n    cap(radius, width);\n    difference() {\n      translate([0,radius+0.4+2*edge,0]) cylinder(r=0.4+2*edge, h=edge+radwire,$fn=50);\n      translate([0,radius+0.4+2*edge,-0.8]) cylinder(r=radwire, h=2*(edge+0.8),$fn=50);\n    }\n  }\n}\nif (battery == \"CR2032\") {\n translate([-(rack_x-1)/2 * rack_dist_x,-(rack_y-1)/2 * rack_dist_y,0])\n for (i=[1:rack_x]) {\n   for (j=[1:rack_y]) {\n     translate([(i-1)*rack_dist_x, (j-1)*rack_dist_y, 0])\n       holder(10.8, 3.2);\n   }\n }\n}\nif (battery == \"AG13\") {\n translate([-(rack_x-1)/2 * rack_dist_x,-(rack_y-1)/2 * rack_dist_y,0])\n for (i=[1:rack_x]) {\n   for (j=[1:rack_y]) {\n     translate([(i-1)*rack_dist_x, (j-1)*rack_dist_y, 0])\n    holder(6, 6.3);\n   }\n }\n}\nif (battery == \"custom\") {\n translate([-(rack_x-1)/2 * rack_dist_x,-(rack_y-1)/2 * rack_dist_y,0])\n for (i=[1:rack_x]) {\n   for (j=[1:rack_y]) {\n     translate([(i-1)*rack_dist_x, (j-1)*rack_dist_y, 0])\n    holder(custom_radius,custom_width);\n   }\n }\n}",
    "description": "Okay, I need a customizable button battery holder for my electronics projects, and I'd like it to be parametric so I can easily adjust it for different battery sizes and mounting configurations.\n\nHere's what I'm looking for:\n\n**Core Functionality:**\n\n*   **Battery Compatibility:** I need to support multiple button battery sizes. Specifically, I'd like to predefine it for common sizes like CR2032 and AG13, but I also need a way to specify *custom* battery sizes. When a custom size is selected, I'd like to specify the radius and width of the battery.\n*   **Wire Connections:** The design should have integrated holes for wires, allowing them to make contact with the battery without soldering. I envision a design where a wire can be looped through a set of back holes and a second wire is then threaded through a set of front holes, pressing against the battery faces.\n*   **Parametric Design:** Everything should be adjustable via parameters. This includes:\n    *   The battery type (CR2032, AG13, custom).\n    *   If custom, the battery radius and width.\n    *   The width of the edges/walls of the holder.\n    *   The radius of the wire holes.\n    *   The number of holders in the x and y directions (for creating arrays/racks of holders).\n    *   The distance between holders in the x and y directions.\n\n**Detailed Design Considerations:**\n\n*   **Wire Holes:** It looks like there should be two wire holes in the back, and two on the face for the second wire (per the description). The holes should be large enough to pass wire through, but not so large as to interfere with the battery's electrical contact points.\n*   **Battery Retention:** The design needs to hold the battery securely while allowing it to be inserted and removed with relative ease.\n*   **\"Ring to hang\":** There is a \"ring to hang it to something\" near the wire hole. Please include this feature.\n*   **Build Plate Display:** This is optional, but it would be nice if the design also included a way to display the build plate for reference. This is mostly for design purposes, and does not contribute to the final object. I would need options for Replicator 2, Replicator, Thingomatic, and manual. For manual, I will need to be able to specify the x and y dimensions.\n*   **Units:** I'm working with millimeters (mm).\n*   **Libraries**: I would like to use the MCAD library for font support, and I am also using utils/build_plate.scad, though I don't think that's a part of any standard library.\n\n**Output**\n\nI am looking for a single OpenSCAD file that encapsulates the entire design and utilizes the libraries specified.\n\nCould you generate the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Hayrack",
    "scad": "main_height = 95;\nwall_width = 20;\nbar_height = 6;\nbar_width = 6;\nfixation_height = 18;\ndepth = 5;\nfixation_width=3;\nmodule fixation () {\n  linear_extrude(height=depth)polygon(points=[\n\t[0,0],\n\t[-wall_width,0],\n   [-wall_width+0.8, -fixation_height],\n   [-wall_width-fixation_width-bar_width-fixation_width,-fixation_height],\n   [-wall_width-fixation_width-bar_width-fixation_width,-fixation_height+fixation_width],\n   [-wall_width-fixation_width-bar_width-fixation_width/2, -fixation_height+fixation_width+fixation_width*0.25],\n   [-wall_width-fixation_width-bar_width,-fixation_height+fixation_width],\n   [-wall_width-fixation_width,-fixation_height+fixation_width],\n   [-wall_width-fixation_width,-fixation_height+fixation_width+bar_height],\n   [-wall_width-fixation_width-bar_width-fixation_width/2,-fixation_height+fixation_width+bar_height],\n   [-wall_width-fixation_width-bar_width-fixation_width,-fixation_height+fixation_width+bar_height+fixation_width/2],\n   [-wall_width-fixation_width-bar_width-fixation_width,-fixation_height+fixation_width+bar_height+fixation_width],\n   [-wall_width-fixation_width,-fixation_height+2*fixation_width+bar_height],\n   [-wall_width-fixation_width,fixation_width],\n   [0, fixation_width],\n]);\n}\nmodule rack () {\n  lower_curve_radius = 10;\n  lower_curve_center = [fixation_width*1.8+lower_curve_radius,-main_height+16.8,0];\n  inner_hook_center = [8.26,-main_height+78.97,0];\n  inner_hook_radius = 72.18;\n  outer_hook_center = [7.51, -main_height+74.03,0];\n  outer_hook_radius = 74.41;\n  hook_x = 81.7;\n  hook_y = 69;\n  linear_extrude(height=depth)polygon(points=[\n\t[0,fixation_width],\n   [0,-main_height],\n   [fixation_width*2,-main_height],\n   [fixation_width*1.5,fixation_width]\n]);\n  intersection(){\n    difference() {\n      translate([0,-main_height,0])cube([hook_x, hook_y, depth]);\n      translate([0,0,-0.5])translate(inner_hook_center)cylinder(r=inner_hook_radius,depth+1, $fn=80);\n    }\n    translate(outer_hook_center)cylinder(r=outer_hook_radius, depth, $fn=80);\n  }\n  translate(lower_curve_center)difference(){\n    translate([-lower_curve_radius,-lower_curve_radius,0])cube([lower_curve_radius,lower_curve_radius,depth]);\n    translate([0,0,-0.5])cylinder(r=lower_curve_radius, h=depth+1);\n  }\n}\nfixation();\nrack();",
    "description": "Okay, I'm looking to design a hayrack for my guinea pig cage. It needs to be able to clip onto the side of the cage, which is essentially a wall of a certain thickness. I want to be able to customize the dimensions so it fits my setup.\n\nHere's what I'm envisioning:\n\n*   **Mounting/Fixation:** It needs a clip-like mounting system that hooks over the cage wall.\n    *   I want to be able to specify the thickness of the cage wall.\n    *   The clip should include a wooden bar that is glued into place for additional grip and to create a small shelf.\n    *   I need to control the height of the part of the clip that sits below the wall.\n\n*   **Hayrack:** The hayrack portion itself should be a simple structure that holds hay.\n    *   It needs to have a rounded lower corner.\n    *   The main body of the rack should have a curved shape to keep the hay from falling out. The curved shape should be adjustable and should roughly match the shape shown in the example file, but I would like to adjust the radius and position of those curves.\n    *   I need to control the overall height of the rack from the top of the cage wall mount down to the bottom of the rack.\n\n*   **General Customization:**\n    *   I need to be able to specify the thickness of the material for the whole structure\n    *   I would like all major dimensions to be parameterized.\n*   **Libraries:** I am not using any external libraries.\n\nCould you generate an OpenSCAD file that meets these requirements? Id like to be able to adjust:\n\n*   `wall_width`: Thickness of the wall/cage the rack will mount on.\n*   `bar_height`: Height of the wooden bar in the clip.\n*   `bar_width`: Width of the wooden bar in the clip.\n*  `fixation_height`: Height of the main section of the clip that sits below the wall.\n*  `fixation_width`: The width of the various \"tabs\" on the clip.\n*   `depth`: Overall thickness of the printed part.\n*   `main_height`: Height from the top of the wall to the bottom of the rack.\n*   `lower_curve_radius`: Radius of the rounded lower corner of the rack.\n*   `lower_curve_center`: Position of the center of the rounded lower corner.\n*    `inner_hook_center`: Position of the center of the inner hook.\n*    `inner_hook_radius`: Radius of the inner hook.\n*   `outer_hook_center`: Position of the center of the outer hook.\n*   `outer_hook_radius`: Radius of the outer hook.\n*   `hook_x`: The total width of the back of the rack body.\n*   `hook_y`: The total height of the back of the rack body.\n\nEssentially, I want the attached code, but parametric.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Polygon Cutter parametric",
    "scad": "polysides=6;\ncutterheight=30;\ncutterradius = 40;\nwallthick = 3;\nbaseheight = 5;\n$fn=60;\ncutterradius_o = cutterradius+wallthick;\ndifference() {\n\tunion() {\n\t\tlinear_extrude(height=cutterheight) circle(r=cutterradius_o,$fn=polysides);\n\t\tcylinder(h=baseheight,r=cutterradius_o);\n\t}\ntranslate([0,0,-10]) linear_extrude(height=cutterheight+20) circle(r=cutterradius,$fn=polysides);\n}",
    "description": "Okay, I'm looking to create a parametric cutter that I can use for things like cookies or cake. I want a base shape that's a polygon, but I also want the *cutting* edge to be that same polygon, just a bit smaller. So, imagine a cookie cutter where there's a raised wall that does the cutting, and then a flat part on the bottom to press down on the dough.\n\nHere are the things I want to control:\n\n*   **Number of sides on the polygon:** I'd like a parameter to adjust this, and I'm thinking a reasonable range would be from 5 sides up to 20 sides.\n*   **Height of the cutting wall:** This should also be adjustable, maybe from 5mm to 50mm high?\n*   **Radius of the inner (cutting) polygon:** I need to be able to change this, too; maybe 5mm to 100mm would cover it?\n*   **Thickness of the cutting wall:** This will determine how sturdy the cutter is, so I'd need to control that, perhaps from 1mm to 10mm.\n*   **Height of the flat base:** This is the part that helps push the dough out, so maybe 0 to 10mm would be a good range.\n\nI'd like the code to generate two things, effectively. First, it needs to make the overall shape -- that's the polygon with the base and the wall. Then it needs to subtract out a slightly smaller, but taller, version of that same polygon to create the cut out.\n\nI'm not trying to do anything too fancy, but I'd like the code to be well-commented so I can understand what's going on and also make any tweaks later on. I think it's important for this to be a single file, and I don't need to include any special libraries like MCAD or anything like that.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Clip",
    "scad": "ClipThick = 3;\nClipGap = 5;\nClipHeight = 20;\nClipLength = 7.5;\nmodule Clip (Thickness, Gap, Height, Length)\n{\n\tdifference()\n\t{\n\tcube([Gap+2*Thickness, Length, Height]);\n\ttranslate([Thickness, 0-0.5, Thickness]) cube([Gap, Length+1, Height-Thickness+1]);\n\t}\n}\nClip (ClipThick, ClipGap, ClipHeight, ClipLength);",
    "description": "Okay, I need a parametric OpenSCAD design for a simple clip. I've already created a basic version, and I'll provide that for context, but I want the new one to be more flexible and allow for a few more parameters.\n\nHere's what I have currently:\n\n```\n// How many mm thick the clip is\nClipThick = 3;\n//How many mm of gap\nClipGap = 5;\n//How many mm tall the clip is\nClipHeight = 20;\n//How many mm long the clip is\nClipLength = 7.5;\n\n\nmodule Clip (Thickness, Gap, Height, Length)\n{\n\tdifference()\n\t{\n\tcube([Gap+2*Thickness, Length, Height]);\n\ttranslate([Thickness, 0-0.5, Thickness]) cube([Gap, Length+1, Height-Thickness+1]);\n\t}\n}\n\nClip (ClipThick, ClipGap, ClipHeight, ClipLength);\n```\n\nThis code creates a clip that is essentially a rectangular prism with a smaller, offset prism subtracted from it to create a channel or gap.\n\nHere are the parameters I need to be able to control:\n\n*   **Clip Thickness:** The thickness of the material used to make the clip, currently `ClipThick`.\n*   **Clip Gap:** The width of the gap or channel in the clip, currently `ClipGap`.\n*   **Clip Height:** The overall height of the clip, currently `ClipHeight`.\n*   **Clip Length:** The length of the clip (the dimension parallel to the channel), currently `ClipLength`.\n\nAdditionally, I'd like these extra parameters:\n\n*   **Chamfer Radius:** I want to be able to add a chamfer to the *top* edges of the clip. So, the four edges along the top of the clip (where it is `ClipHeight` tall) should have chamfers. This should be a parameter controlling the radius of the chamfer.\n*   **Rounding Radius:** I want to be able to add a rounding to the *bottom* edges of the clip. So, the four edges along the bottom of the clip (where it is at z=0) should have a radius added. This should be a parameter controlling the radius of the rounding.\n*   **Leg Angle:** I want to be able to add an angle to the legs of the clip (the area below the gap). This angle should be able to point inwards toward the center, or outwards away from the center. This parameter should control the angle of these leg slopes.\n*   **Leg Length:** I want to be able to modify the length of the legs. This should be the distance from the bottom of the gap to the lowest point of the leg (before the round).\n\nI'd like to make sure this is flexible enough to where if either radius is set to zero, no rounding or chamfer is created.\n\nI'd prefer to implement this in a single module, named `parametricClip`, so that I can use it in multiple parts.\n\nFinally, I am not using any external libraries, so there is no need for any extra includes.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable coin battery pack",
    "scad": "battery = \"CR2032\";\ncustom_radius = 10;\ncustom_width = 3;\nedge = 0.8;\nmodule divider(radius,width) {\n  difference() {\n    cylinder(r=radius+edge, h=edge+0.8,$fn=50);\n    translate([-radius/2,-2,0]) cylinder(r=0.4, h=edge+10,center=true,$fn=50);\n    translate([radius/2,-2,0]) cylinder(r=0.4, h=edge+10,center=true,$fn=50);\n    translate([-radius/2, -2-0.8/2,edge]) cube([radius,0.8,2*0.8]);\n    }\n  difference() {\n    cylinder(r=radius+edge, h=edge+0.8+width,$fn=50);\n    cylinder(r=radius, h=4*(edge+0.8+width),$fn=50, center=true);\n    translate([0,2*radius+radius/2,width+edge+0.8]) cube([4*radius, 4*radius,2*width], center = true);\n    }\n}\nmodule holder(radius, width) {\n  union() {\n    difference() {\n      translate([-radius/2,-radius-4,0]) cube([radius, 4, width+edge+0.8]);\n      translate([radius/4, -radius-edge-1.5,0])cylinder(r=0.4, h=2*(width+edge+10),center=true,$fn=50);\n      translate([-radius/4, -radius-edge-1.5,0])cylinder(r=0.4, h=2*(width+edge+10),center=true,$fn=50);\n      }\n    divider(radius,width);\n    difference() {\n      translate([0,radius+0.4+2*edge,0]) cylinder(r=0.4+2*edge, h=edge+0.8,$fn=50);\n      translate([0,radius+0.4+2*edge,-0.8]) cylinder(r=0.4, h=2*(edge+0.8),$fn=50);\n    }\n  }\n}\nif (battery == \"CR2032\") {\n    holder(10, 3);\n}\nif (battery == \"AG13\") {\n    holder(6, 6.3);\n}\nif (battery == \"custom\") {\n    holder(custom_radius,custom_width);\n}",
    "description": "Okay, I'm looking to design a parametric button battery clip holder, and I've found a good starting point but need some changes and would like to have the whole thing be driven by parameters.\n\nThe current design, which I've included in `buttonbatterypack.scad`, is pretty close. It creates a holder for button batteries, specifically either CR2032 or AG13, or a custom size, with a way to connect leads to the battery. I like that it includes a small ring to attach it to things. \n\nHere's what I need from you:\n\n1.  **Make it fully parametric.** I want to be able to control the battery size (radius and width), the edge thickness of the plastic, and the size of the attachment ring, all with clearly defined variables. The current file uses `custom_radius`, `custom_width`, and `edge` but these aren't very descriptive and could be improved. It'd be nice if there were a consistent naming scheme for this too.\n\n2.  **Clear Parameter Definitions**: When I specify the battery size, I want to specify the `battery_radius` and `battery_width`, and not have them hard coded. Right now, it uses some hard coded values for `radius` and `width` inside the holder module which is less than ideal. When using predefined battery types, those sizes should override the custom sizes. For example, if I choose a CR2032 it should automatically use those dimensions, even if I've set custom sizes.\n\n3. **Modular Design:** The holder is composed of several different pieces: the base, the divider, the attachment ring, and the clips. I would like each of these to be in its own module so I can reuse these for future designs. I would like each of these modules to expose their own unique parameters that make them customizable and allow for easy modifications.\n\n4. **Consistent variable names**: In the current file I have some inconsistencies in naming for the modules that could be improved. Specifically, `radius` and `width` are used in the `divider` module and the `holder` module. I would like the use of a more consistent naming scheme with descriptive variable names to avoid any ambiguity.\n\n5. **Improved Clip Design:** The method for holding the battery is fairly basic, just a gap to wedge the battery in. I would like for this to be slightly more aggressive, maybe with angled clips that actively grip the battery. The current way has the clips as a rectangle, which does not promote gripping, and also has those extra cylinders within the clips, and that looks inefficient and not clean.\n\n6.  **Attachment Ring Customization:** The current ring is pretty simple and doesn't have any customization. I want to specify not just the ring radius but also the ring thickness. And for modularity, I'd also like to have the ring be in it's own module as well.\n\n7.  **Use BOSL2:** I would like for the new design to use the BOSL2 library for any helpful functions or module and provide the proper imports.\n\n8.  **Provide comments.** Be sure to comment the code to make it easy to read and understand.\n\nSo, to summarize, I need a parametric OpenSCAD file for a button battery clip holder using BOSL2, with modules for each part, well-defined variables and clear definitions for them, improved clips for holding the battery, and a customizable attachment ring. Also, ensure that pre-defined battery options use the correct size.\n\nCan you create that for me?\n"
  },
  {
    "object": "Hey cadmonkey, make me a StampMaker",
    "scad": "image_file = \"img.dat\";\nlayer_height = 0.5;\nnumber_of_layers = 10;\nhandle_height = 30;\nscale = 1.0;\n$fn = 50;\nlength = 100;\nwidth = 100;\nmin_layer_height = layer_height*2;\nhole_radius = hole_diameter/2;\nheight = layer_height*number_of_layers;\nmodule stamp() {\n  difference() {\n    translate([0, 0, min_layer_height]) scale([1,1,height]) surface(file=image_file, center=true, convexity=5);\n    translate([0,0,-(height+min_layer_height)]) linear_extrude(height=height+min_layer_height) square([length, width], center=true);\n  }\n}\nmodule handle() {\n\tdifference() {\n\t\ttranslate([0,0,-handle_height/2+1])\n\t\tcube([width, length, handle_height], center=true);\n\t\ttranslate([width/2+handle_height/8,0,-handle_height/2])\n\t\trotate([0,25,0])cube([handle_height/2, width+2, handle_height/2], center=true);\n\t\ttranslate([-width/2-handle_height/8,0,-handle_height/2])\n\t\trotate([0,-25,0])cube([handle_height/2, width+2, handle_height/2], center=true);\n\t}\n}\nscale(scale)\nunion() {\n\ttranslate([0,0,-stamph/2])stamp();\n\thandle();\n};",
    "description": "Okay, I'd like to create a parametric OpenSCAD script for making custom image-based stamps. I've been playing around with the attached `StampMaker_v03.scad` file, and I'd like to improve upon it.\n\nHere's what I want the new script to do, and what parameters I'd like to be able to adjust:\n\n**Core Functionality:**\n\n1.  **Image Input:** The script should take a black and white image file as input. This file will define the surface of the stamp. I'd like to specify the file path using a variable.\n2.  **Image Size:** The image will be scaled to fit within a specified maximum size (e.g. 100x100). The stamp should automatically adjust itself to fit around it. I'd like to parameterize this max size.\n3.  **Layered Stamp:** Instead of just extruding, the stamp should be made of discrete layers, like in the attached code. The number of layers and the height of each layer should be parameterized. I need to specify layer height directly, not just derived from the number of layers.\n4.  **Stamp Base:** The layered stamp portion should be mounted on a solid base. This base can be just a rectangular prism, as in the attached, but I'd like its thickness to be controlled by a variable. Also, the base needs to fully enclose the entire layered surface.\n5.  **Handle:** The script should generate a handle for the stamp. I'd like a similar style to the one provided in the attached file (angled struts), but I'd like to control the handle height, strut angle, and strut width/depth.\n\n**Parameters I'd Like To Control:**\n\n*   `image_file`: String, the path to the black and white image file.\n*   `image_max_size`: Number, the maximum width/height of the scaled image.\n*   `layer_height`: Number, the height of each stamp layer.\n*   `number_of_layers`: Integer, the number of stamp layers.\n*   `base_thickness`: Number, the thickness of the base underneath the layered stamp.\n*   `handle_height`: Number, the total height of the handle.\n*   `handle_strut_angle`: Number, the angle of the handle's support struts.\n*   `handle_strut_width`: Number, the width of the handle's support struts.\n*   `handle_strut_depth`: Number, the depth of the handle's support struts.\n*   `overall_scale`: Number, a scale factor applied to the entire stamp.\n\n**Additional Requirements**\n\n*   I'd like the stamp to be centered on the origin for easy placement in other projects.\n\n**Libraries:**\n\nI'm not using any special libraries, the `surface()` function is from the base OpenSCAD language. I also used `linear_extrude()`.\n\nCan you help me create this parametric OpenSCAD file?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable, parametric, frog display stand for single or multiple frogs (up to five)",
    "scad": "pedestal=1;\nbox=1;\ntextHeight=2;\nfrogs=1;\nfrog1=\"0.3 mm\";\nfrog2=\"0.15 mm\";\nfrog3=\"0.05 mm\";\nfrog4=\"0.1 mm\";\nfrog5=\"0.05 mm\";\ninclude <write/Write.scad>\nunion(){\ntranslate([0,0,-1])\ncube([60,60,2],center=true);\ntranslate([55,0,0])\nscale([1,1,pedestal])\nimport(\"Frog Feet.stl\");\ntranslate([-25,-28.5,0])\n\tcube([50,11,box]);\ntranslate([0,-23,box])\nwrite(frog1,t=textHeight,h=10,center=true);\nif(frogs>1){\ntranslate([60,0,0]){\ntranslate([0,0,-1])\ncube([60,60,2],center=true);\ntranslate([55,0,0])\nscale([1,1,pedestal])\nimport(\"Frog Feet.stl\");\ntranslate([-25,-28.5,0])\n\tcube([50,11,box]);\ntranslate([0,-23,box])\nwrite(frog2,t=textHeight,h=10,center=true);\n}\n}\nif(frogs>2){\ntranslate([120,0,0]){\ntranslate([0,0,-1])\ncube([60,60,2],center=true);\ntranslate([55,0,0])\nscale([1,1,pedestal])\nimport(\"Frog Feet.stl\");\ntranslate([-25,-28.5,0])\n\tcube([50,11,box]);\ntranslate([0,-23,box])\nwrite(frog3,t=textHeight,h=10,center=true);\n}\n}\nif(frogs>3){\ntranslate([180,0,0]){\ntranslate([0,0,-1])\ncube([60,60,2],center=true);\ntranslate([55,0,0])\nscale([1,1,pedestal])\nimport(\"Frog Feet.stl\");\ntranslate([-25,-28.5,0])\n\tcube([50,11,box]);\ntranslate([0,-23,box])\nwrite(frog4,t=textHeight,h=10,center=true);\n}\n}\nif(frogs>4){\ntranslate([240,0,0]){\ntranslate([0,0,-1])\ncube([60,60,2],center=true);\ntranslate([55,0,0])\nscale([1,1,pedestal])\nimport(\"Frog Feet.stl\");\ntranslate([-25,-28.5,0])\n\tcube([50,11,box]);\ntranslate([0,-23,box])\nwrite(frog5,t=textHeight,h=10,center=true);\n}\n}\n}",
    "description": "Okay, so I'm trying to create a display stand for some 3D-printed frog models I have. I currently have a design in OpenSCAD, but it's a bit clunky and inflexible, and I'd like to make it more parametric and easier to customize.\n\nHere's what I'm aiming for:\n\n**Core Functionality:**\n\n*   **Individual Frog Stands:** The stand should be designed to hold multiple frog models, each with its own base and text label. I envision a row of these stands side-by-side.\n*   **Parametric Dimensions:** I want to be able to adjust things like the pedestal height, the base height under the text, the text height, and the overall spacing between each frog stand.\n*   **Text Labels:** Each frog stand should have a text label, allowing me to easily identify different frog versions and/or different printing parameters.\n*   **Foot Pedestals:** I'd like to include the \"foot\" pedestals I have modeled separately. I have them in an STL format that can be imported.\n*   **Multi-Frog Support:** I need to be able to adjust the number of frog stands, in case I want to add more frogs in the future.\n\n**Specific Parameters I'd like to control:**\n\n*   `pedestal`: The height of the foot pedestal (where the frog model actually sits), using the values [1,2,3,4,5]\n*   `box`: The height of the base cube for each frog's label area (the box under the text). Values should be [0,1,2,3,4,5].\n*   `textHeight`: The height of the text labels for each frog. Should use values [1,2,3,4,5].\n*   `frogs`: The number of frog stands in the row. Should use values [1,2,3,4,5].\n*   `frog_layer_thickness_1`, `frog_layer_thickness_2`, etc.: The text to display on each stand. The current values for these are `\"0.3 mm\"`, `\"0.15 mm\"`, `\"0.05 mm\"`, `\"0.1 mm\"`, and `\"0.05 mm\"`.\n*   `base_width`: Overall width of the stand base for each frog (currently `60`)\n*  `base_depth`: Overall depth of the stand base for each frog (currently `60`)\n*   `label_width`:  The width of the rectangular base underneath the text label (currently `50`)\n*   `label_depth`: The depth of the rectangular base underneath the text label (currently `11`)\n* `label_x_offset`: The x offset of the label box from the center (currently `-25`)\n* `label_y_offset`: The y offset of the label box from the center (currently `-28.5`)\n* `text_y_offset`: The y offset of the text label from the base of the text box(currently `-23`)\n* `foot_x_offset`: The x offset of the foot from the center (currently `55`)\n* `frog_spacing`: The distance between the left edge of one frog stand and the left edge of the next one. This can default to `60` but should be modifiable.\n\n**Additional Considerations:**\n\n*   I'm using the `write/Write.scad` library for text, so please make sure to use it in the new file, and the values `t=textHeight` and `h=10` should be passed to `write` for each text label.\n*   The current design has a thin 2mm base, that I would like to keep. The base should be centered behind all of the stands, which are evenly distributed along the x axis, and extend one mm beyond the top and bottom.\n*  The base should have a height of `2`.\n*   The text should always be centered.\n*   The file is currently using `translate` and hard-coded numbers for placement. This should use variables for better control.\n\n**Ideally, the output should:**\n\n*   Be a single, parametric OpenSCAD file.\n*   Be well-commented to understand how each component is constructed and how the parameters work.\n*   Include the proper imports from any required libraries (in this case, `write/Write.scad`).\n* Use the following constants as specified (if not specified, assume the current values from my file): base width, `60`, base depth `60`, label width `50`, label depth `11`, label x offset `25`, label y offset `28.5`, text y offset `23`, foot x offset `55`, base height `2`, text height `2`, label base height `1`, pedestal height `1`, spacing `60`\n*   Use variables in the `write` function instead of hard-coded values (I should be able to change text size for example)\n\nI'd like the design to be as flexible as possible so I can easily modify it for different print parameters and frog quantities. Could you help me create a parametric OpenSCAD file that does all this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Astro Bot",
    "scad": "include<Write.scad>\nheadLetter=\"M\";\nfont=\"orbitron.dxf\";\nemb=1;\nif(emb==0){\n\tdifference(){\n\t\tunion(){\n\t\t\timport(\"AstroBotM_010.stl\");\n\t\t\ttranslate([3,-2.25,12.25]){\n\t\t\t\tsphere(11,$fn=200);\n\t\t\t}\n\t\t}\n\t\ttranslate([3,-2.25,12.25])\n\t\t\twritesphere(text=headLetter,where=[0,0,0],radius=11, north=10, east=2, rounded=true, $fn=100,h=7,font=font);\n\t}\n}\nif(emb==1){\n\tunion(){\n\t\timport(\"AstroBotM_010.stl\");\n\t\ttranslate([3,-2.25,12.25]){\n\t\t\tsphere(11,$fn=200);\n\t\t\twritesphere(text=headLetter,where=[0,0,0],radius=11, north=10, east=2, rounded=true, $fn=100,h=7,font=font);\n\t\t}\n\t}\n}",
    "description": "Okay, I'd like to design a customizable robot toy where the head can display any letter. I have an existing robot model (\"AstroBotM_010.stl\") that I'd like to use as a base, and I want to add a spherical head with a letter on it, either embossed or engraved.\n\nHere's what I need:\n\n1.  **Base Model:** Use the provided \"AstroBotM_010.stl\" file as the base body of the robot.\n\n2.  **Spherical Head:** Add a sphere to the top of the robot's body.  The sphere should be centered at approximately [3,-2.25,12.25]. The sphere radius should be 11.\n\n3.  **Letter Customization:**  I need to be able to specify a single letter that will be displayed on the sphere.  It should be a parameter that I can set. I should be able to set the font as well.  I would like it to utilize the `Write.scad` file that I am providing to add the letters.\n\n4.  **Embossed or Engraved:**  I'd like to be able to choose whether the letter is embossed (protruding out from the sphere) or engraved (cut into the sphere). This should also be a parameter.\n\n5. **Font Selection** I need to be able to choose from several fonts. I am providing `Write.scad` with several font options, but I'd like it to be a parameter\n\nThe `Write.scad` file handles the text generation on the sphere as well as font selection. It has the following functionality:\n\n*   **Writesphere module:**  This module takes text, location, radius, and several other parameters to place text on a sphere.  It also handles the embossed or engraved selection, but needs to be called in a specific way in the main script. The key parameters I need to pass are `text`, `where`, `radius`, `north`, `east`, `rounded` , `$fn`, `h` and `font`\n*   **Font support:**  This module supports multiple fonts which are included in the `Write.scad` module. The font parameter will specify which font to use, so I need to be able to access this in my main file.\n\nThe OpenSCAD file should have the following parameters:\n\n*   `headLetter`:  A string that specifies the single letter to be displayed.\n*   `font`: A string that specifies which font to use.\n*   `emb`:  A boolean (0 or 1) to indicate whether the letter is engraved (0) or embossed (1).\n\nCan you generate the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Lithophane Gallery Panes",
    "scad": "image1 = \"image-surface.dat\";\nimage2 = \"image-surface.dat\";\nimage3 = \"image-surface.dat\";\nimage4 = \"image-surface.dat\";\nimage5 = \"image-surface.dat\";\nimage6 = \"image-surface.dat\";\nimage7 = \"image-surface.dat\";\nimage8 = \"image-surface.dat\";\nText_Lines = 0;\nTop_Text = \"First Line\";\nBottom_Text = \"Second Line\";\nShade=2;\nfont = \"write/knewave.dxf\";\nText_Height=6;\nLetter_Spacing=12;\nspace=Letter_Spacing/10;\ntop_row = 2;\nbottom_row = 0;\nhangers = 2;\nhanger_opening = 5;\nhanger_thickness = 2;\npane_border = 1;\nlayer_height = 0.2;\nnumber_of_layers = 16;\nhelper_disks=0;\nimages = [image1, image2, image3, image4, image5, image6, image7, image8];\ns = 0.01;\nlength = 50;\nmin_height = layer_height*2;\ninhole_radius = hanger_opening/2;\nouthole_radius = inhole_radius+hanger_thickness;\nheight = layer_height*number_of_layers+min_height;\nhang_length = top_row*(length+pane_border)+pane_border-outhole_radius*2;\nhang_height = length/2+pane_border;\ntopboxlen=top_row*(length+pane_border)+pane_border;\nbottomboxlen=bottom_row*(length+pane_border)+pane_border;\nlonger=(topboxlen>bottomboxlen)?topboxlen:bottomboxlen;\nassembly();\nmodule assembly(){\n\tunion(){\n\t\tif (bottom_row<1){\n\t\t\ttoplayout(top_row);\n\t\t\thangers();\n\t\t\tmessage(topboxlen);\n\t\t\thelpers(topboxlen,topboxlen);\n\t\t}\n\t\telse{\n\t\t\ttranslate([0,(length+pane_border)/2,0]){\n\t\t\t\ttoplayout(top_row);\n\t\t\t\thangers();\n\t\t\t\thelpers(topboxlen,longer);\n\t\t\t}\n\t\t\ttranslate([0,-(length+pane_border)/2,0]){\n\t\t\t\tbottomlayout(bottom_row);\n\t\t\t\tmessage(bottomboxlen);\n\t\t\t\thelpers(longer,bottomboxlen);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule toplayout(row){\n\ttranslate([-(row-1)*(length+pane_border)/2,0,0]){\n\t\tfor(i=[1:row])translate([(i-1)*(length+pane_border),0,0])pane(images[i-1]);\n\t}\n}\nmodule bottomlayout(row){\n\ttranslate([-(row-1)*(length+pane_border)/2,0,0]){\n\t\tfor(i=[1:row])translate([(i-1)*(length+pane_border),0,0])pane(images[i+3]);\n\t}\n}\nmodule pane(image){\n\tunion() {\n\t\tdifference(){\n    \t\ttranslate([0,0,min_height]) scale([.5,.5,height-min_height]) surface(file=image,center=true,convexity=5);\n\t\t\ttranslate([0,0,-height+min_height-s])linear_extrude(height=height-min_height+s)square(length+s,center=true);\n\t\t}\n\t\tdifference(){\n\t\t\tlinear_extrude(height=height) square(length+(pane_border*2),center=true);\n\t\t\ttranslate([0,0,min_height])linear_extrude(height=layer_height*number_of_layers) square(length+s,center=true);\n\t\t}\n\t}\n}\nmodule hangers(){\nif (hangers==1){u();}\nif (hangers>1){\n\ttranslate([-(hang_length)/2,0,0]){\n\t\tfor(i=[1:hangers])translate([(i-1)*(hang_length)/(hangers-1),0,0])\n\t\t\tu();\n\t}\n}\n}\nmodule u(){\nrender()\n\ttranslate([0,hang_height,0]){\n\t\ttranslate([0,hanger_thickness,0])disk();\n\t\tdifference(){\n\t\t\tunion(){\n\t\t\t\ttranslate([0,outhole_radius/2,height/4])cube([outhole_radius*2,outhole_radius,height/2],center=true);\n\t\t\t\ttranslate([0,outhole_radius,height/4])cylinder(h=height/2,r=outhole_radius,center=true,$fn=50);\n\t\t\t}\n\t\t\ttranslate([0,outhole_radius/2,height/4-s])cube([inhole_radius*2,outhole_radius,height/2+2*s],center=true);\n\t\t\ttranslate([0,outhole_radius,height/4-s])cylinder(h=height/2+2*s,r=inhole_radius,center=true,$fn=50);\n\t\t}\n\t}\n}\nmodule message(len){\n\tif (Text_Lines>0){\n\t\tdifference(){\n\t\t\ttranslate([0,-hang_height-Text_Lines*Text_Height/2-1,height/2])cube([len,Text_Lines*Text_Height+2+2*pane_border,height],center=true);\n\t\t\ttranslate([0,-hang_height-Text_Lines*Text_Height/2-1+s,height/2+min_height])cube([len-2*pane_border+s,Text_Lines*Text_Height+2+s,height],center=true);\n\t\t}\n\t\ttranslate([space,-hang_height-(Text_Height/2+1/Text_Lines)+pane_border/2,height/Shade/2])write(Top_Text,font=font,t=height/Shade,h=Text_Height,space=space,center=true);\n\t\tif (Text_Lines>1){\n\t\t\ttranslate([space,-hang_height-0.5-Text_Height*1.5,height/Shade/2])write(Bottom_Text,font=font,t=height/Shade,h=Text_Height,space=space,center=true);\n\t\t}\n\t}\n}\nmodule helpers(up,down){\n\tfor(a=[0,1]){\n\t\tmirror([a,0,0]){\n\t\t\ttranslate([up/2,hang_height,0])disk();\n\t\t\ttranslate([down/2,-hang_height,0])disk();\n\t\t}\n\t}\n}\nmodule disk(){\n\ttranslate([0,0,layer_height/2])cylinder(h=layer_height*helper_disks,r=hanger_opening+3*hanger_thickness,center=true,$fn=50);\n}",
    "description": "Okay, I'm looking to create a customizable lithophane gallery, similar to the one I found on Thingiverse, but I'd like more flexibility and a cleaner code structure. I need an OpenSCAD file that allows me to arrange multiple lithophane images in a gallery format, with the option to add a text pane at the bottom, and control a few more parameters.\n\nHere are the specific features I need:\n\n**1. Image Panes:**\n\n*   I need to be able to specify up to 8 different images.  I'll provide the image data files, similar to how the original `Lithophane_Gallery_Rev3.scad` uses `.dat` files created with `image-surface`.\n*   The images should be arranged in a grid of up to 2 rows and up to 4 columns.  I need to be able to specify how many images are in the top row and bottom row separately, so I could have 2 on top and 3 on the bottom, for example.\n*   The images should stretch to fit the pane size, like the original design does.\n\n**2. Text Pane:**\n\n*   I want an optional text pane at the bottom that can accommodate either one or two lines of text.\n*   I need to be able to specify the text for each line, the text height, letter spacing, and the \"shade\" or thickness of the text in the final output.\n*   It would be great to specify the font to use for the text. I'd like to use fonts from the `write.scad` library to support custom fonts.\n\n**3. Hangers:**\n\n*   I'd like to include hanger loops at the top of the gallery. I need to be able to choose the number of hangers and have them evenly spaced.\n*   The hanger depth (how far it protrudes from the main print) should be at half the total print height.\n*   I need control over the hanger opening size, and the thickness of the hanger material.\n\n**4. Borders:**\n\n*   I need a border around each image pane, and the text pane. I need to be able to specify the thickness of this border. Setting the border to 0 should also remove it entirely.\n\n**5. Slicing and Printing:**\n\n*   I need to specify the layer height I will use for printing.\n*   I also need to specify how many layers are used to represent the greyscale image.\n*  I'd like to add optional helper disks at each corner and under each hanger to help prevent lifting during printing. This should be an on/off option.\n\n**6. Parametric Design:**\n\n*   Everything above should be fully parametric and easily adjustable through OpenSCAD's customizer interface.\n*   I would prefer to calculate the required lengths based on the parameters defined in the customizer. The design should avoid using hardcoded lengths when possible.\n\n**7. Libraries:**\n*  I need you to use `write.scad`. I will supply this or use the local copy if required.\n\n**In summary, I want a robust and flexible design that generates a lithophane gallery using a similar logic to the provided design, but with cleaner code and more customizability. Can you provide me with an OpenSCAD file that meets these requirements?**\n"
  },
  {
    "object": "Hey cadmonkey, make me a Honey Spoon parametric ",
    "scad": "spoon_height = 20;\nspoon_twist = 45;\nspoon_radius = 10;\nspoon_fan = 2.5;\nhandle_height = 60;\nhandle_radius = 5;\nhandle_height_t= spoon_height+handle_height;\n$fn=60;\nmodule spoon() {\n union() {\n\tlinear_extrude(height=spoon_height, twist=spoon_twist) {\n\t\tpolygon(points=[[0,0],[spoon_radius,0],[spoon_radius,spoon_fan],[0,spoon_fan]]);\n\t\trotate([0,0,30]) polygon(points=[[0,0],[spoon_radius,0],[spoon_radius,spoon_fan],[0,spoon_fan]]);\n\t\trotate([0,0,60]) polygon(points=[[0,0],[spoon_radius,0],[spoon_radius,spoon_fan],[0,spoon_fan]]);\n\t\trotate([0,0,90]) polygon(points=[[0,0],[spoon_radius,0],[spoon_radius,spoon_fan],[0,spoon_fan]]);\n\t\trotate([0,0,120]) polygon(points=[[0,0],[spoon_radius,0],[spoon_radius,spoon_fan],[0,spoon_fan]]);\n\t\trotate([0,0,150]) polygon(points=[[0,0],[spoon_radius,0],[spoon_radius,spoon_fan],[0,spoon_fan]]);\n\t\trotate([0,0,180]) polygon(points=[[0,0],[spoon_radius,0],[spoon_radius,spoon_fan],[0,spoon_fan]]);\n\t\trotate([0,0,210]) polygon(points=[[0,0],[spoon_radius,0],[spoon_radius,spoon_fan],[0,spoon_fan]]);\n\t\trotate([0,0,240]) polygon(points=[[0,0],[spoon_radius,0],[spoon_radius,spoon_fan],[0,spoon_fan]]);\n\t\trotate([0,0,270]) polygon(points=[[0,0],[spoon_radius,0],[spoon_radius,spoon_fan],[0,spoon_fan]]);\n\t\trotate([0,0,300]) polygon(points=[[0,0],[spoon_radius,0],[spoon_radius,spoon_fan],[0,spoon_fan]]);\n\t\trotate([0,0,330]) polygon(points=[[0,0],[spoon_radius,0],[spoon_radius,spoon_fan],[0,spoon_fan]]);\n\t\trotate([0,0,60]) polygon(points=[[0,0],[spoon_radius,0],[spoon_radius,spoon_fan],[0,spoon_fan]]);\n\t}\n}\n}\nmodule holder() {\nunion() {\ncylinder(h=handle_height_t,r=handle_radius);\ntranslate([0,0,handle_height_t]) sphere(r=handle_radius);\n}\n}\nunion() {\nspoon();\nholder();\n}",
    "description": "Okay, I need help designing a honey spoon in OpenSCAD, and I'm looking for something parametric so I can easily adjust it for my Printrbot Jr. I've seen some designs, but I want to make one from scratch.\n\nHere's what I'm envisioning:\n\n*   **Spoon Head:**\n    *   It should have a sort of fanned or twisted head, not a simple bowl shape.  I'd like to control the height of the spoon head, the amount of twist along that height, the radius of the head and the \"fan\" size.  Think of it like a series of flat, fanned polygons stacked and twisted.\n    *   I want to be able to control the overall height of this fanned part, its twist, the radius, and the length of the fan. So parameters for height, twist angle, radius, and fan length (how far the polygon extends from the radius) are needed.\n    * I want a rounded fan, I do not know how to do that, I just know I want the fan on the spoon to be rounded and not sharp.\n*   **Handle:**\n    *   The handle should be cylindrical and connect to the base of the spoon head.\n    *   I need to control both the length of the handle and its radius. It should have a rounded tip as well.\n    *   The handle length will be from the base of the spoon and should extend away from the spoon.\n    *   The handle should smoothly connect to the bottom of the spoon head. I'd like the handle's connection to the bottom of the spoon to be completely smooth and not have any harsh angles or corners.\n\n*   **Overall:**\n    *   The overall design should be made up of two main modules: one for the fanned spoon head and another for the cylindrical handle.\n    *   I need parameters for all the dimensions described above: spoon height, spoon twist angle, spoon radius, spoon fan length, handle height, and handle radius. I also need to be able to change how many sides the polygons will have.\n    *   I'd also like the final rendering to be smooth so I don't see the polygon edges.\n     \n\nI need the code to be efficient, easy to read and modify. I would prefer to not use any external libraries, but if you feel it's beneficial, please let me know which ones you're using. I don't use external libraries, but If you are going to include a library please make sure to call out the name of that library so I can make sure I install it correctly.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Pencil name tag",
    "scad": "use <write/Write.scad>\ntext_on_pencil_identifier=\"cool story bro\";\nletter_height=5;\nangle=10;\ndifference(){\ntranslate([0,0,0])\ncylinder(r1=6,r2=7,h=25,center=true, $fn=128);\ncylinder(r1=3.5,r2=4,h=50,center=true,$fn=6);\n}\ncolor([1,0,1])\nwritecylinder(text_on_pencil_identifier,[0,0,0],h=letter_height,6.5,25,space=1.2,rotate=angle,east=90,center=true );",
    "description": "Okay, I'd like to design a customizable pencil attachment that I can 3D print. It should be a kind of sleeve that fits around a standard pencil, and I want to be able to put text on the outside.\n\nHere are the specific details I have in mind:\n\n**Shape:**\nThe core of the attachment should be a cylindrical shape with a slight taper, sort of like a truncated cone. It should have a hollow center to fit the pencil. So, the outside diameter will be slightly bigger at one end than the other, and the inside diameter will match that taper but be smaller to allow for the wall thickness. The cylinder should be hollow.\n\n**Customization:**\n*   **Text:** I want to be able to write some text on the outside of the attachment. This text should wrap around the cylinder.\n*   **Text Height:** The height of the text should be adjustable.\n*   **Text Angle:** The angle of the text (relative to the vertical axis of the cylinder) should be adjustable, allowing for slanted text.\n* **Text Spacing:** The spacing between the characters in the text should be adjustable.\n*   **Overall length:** I'd also like to be able to adjust the length of the pencil sleeve itself, so I can make it as long or short as needed.\n\n**Parameters:**\n\nI'm thinking these parameters will be important to control in the OpenSCAD file:\n*   `outer_radius_top` - the outer radius at the top of the sleeve.\n*   `outer_radius_bottom` - the outer radius at the bottom of the sleeve.\n*   `inner_radius_top` - the inner radius at the top of the sleeve\n*   `inner_radius_bottom` - the inner radius at the bottom of the sleeve.\n*   `sleeve_length` - The overall length of the pencil sleeve\n*   `text_string` - the text to display on the sleeve\n*   `text_height` - The height of the text\n*   `text_angle` - the angle of the text in degrees (around the z axis).\n* `text_spacing` - the space between characters\n* `text_x_offset` - an x offset to start the text at.\n* `text_z_offset` - a z offset to place the text at.\n\n**Libraries:**\n\nI'd like to use the `write/Write.scad` library to write the text on the cylinder if that's possible.\n\nEssentially, I need a parametric OpenSCAD file that creates the described pencil sleeve with customizable text. Could you help me generate the code for that?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Spool Adapter",
    "scad": "spool_hole_diameter=31.5;\nspool_hole_depth=15;\naxel_diameter=10.4;\nspacer=12.7;\nspacer_diameter=10;\nseparation=2;\n$fa=1;\n$fs=1;\ntranslate([-spool_hole_diameter/2-5-separation/2, 0, 0]) {\n\tdifference() {\n\t\tunion() {\n\t\t\tcylinder(r=spool_hole_diameter/2+5, h=spacer, center=false);\n\t\t\ttranslate([0, 0, spacer]) cylinder(r=spool_hole_diameter/2, h=spool_hole_depth/2, center=false);\n\t\t}\n\t\ttranslate([0, 0, -1]) cylinder(r=axel_diameter/2, h=(spacer+spool_hole_depth/2+2), center=false);\n\t}\n}\ntranslate([spool_hole_diameter/2+5+separation/2, 0, 0]) {\n\tdifference() {\n\t\tunion() {\n\t\t\tcylinder(r=spool_hole_diameter/2+5, h=spacer, center=false);\n\t\t\ttranslate([0, 0, spacer]) cylinder(r=spool_hole_diameter/2, h=spool_hole_depth/2, center=false);\n\t\t}\n\t\ttranslate([0, 0, -1]) cylinder(r=axel_diameter/2, h=(spacer+spool_hole_depth/2+2), center=false);\n\t}\n}",
    "description": "Okay, I have a 3D printing question. I've got a spool of filament with a large center hole, and I want to mount it on a rod that's much thinner than the spool's hole. I've seen some designs for adapter pieces that fit inside the spool and around the rod, but I'd like to generate something custom.\n\nI need a design for two identical, symmetric adapter pieces. Each piece should have the following features:\n\n*   **Spool Interface:** A cylindrical section that fits snugly inside the spool's center hole. I need to be able to specify the diameter of this hole and the depth of the adapter that goes into the spool.\n*   **Axel Interface:** A hole in the center of the adapter to fit the axel. I need to be able to specify the diameter of this hole.\n*   **Spacer:** There should also be an optional spacer section that extends outwards from the spool interface. This can help center the spool on the axel and prevent the adapters from sliding too far into the spool.  I'd like to specify both the height of this spacer and its diameter (which could be wider or the same width as the spool interface). If the spacer height is set to 0, the spacer will not exist.\n*   **Bearing Spacing:** There should be a settable distance between the two bearing interfaces when they're mounted on an axel.\n*   **Symmetry:** The two adapters should be mirror images of each other.\n\nI would also like the design to be parametric, so I can easily adjust the dimensions. I'd like the following parameters exposed so I can modify them:\n\n*   `spool_hole_diameter`: The diameter of the spool's center hole (in mm).\n*   `spool_hole_depth`: The depth that the adapter goes into the spool hole (in mm).\n*   `axel_diameter`: The diameter of the axel the spool will be mounted on (in mm).\n*   `spacer`: The height of the spacer section of the adapter (in mm). If set to 0, no spacer should be created.\n*   `spacer_diameter`: The diameter of the spacer section (in mm). This can be larger or the same size as the spool interface.\n*   `separation`: The minimum distance between the two adapter pieces when mounted on the axel (in mm).\n\nCould you generate an OpenSCAD file that does this? I would like the file to use only basic primitives and simple transformations.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Hinged Box With Latch, Somewhat Parametric and Printable In One Piece",
    "scad": "$fn = 100;\nwidth = 40;\ndepth = 40;\nheight = 15;\nwallThickness = 1.5;\nhingeOuter = 7;\nhingeInner = 4;\nhingeInnerSlop = .4;\nhingeFingerSlop = .4;\nfingerLength = hingeOuter/1.65;\nfingerSize = 6.5;\ntopFingerSize = fingerSize;\npos = -depth/2;\nlatchWidth = 8;\nz = 0;\nbottom();\ntop();\nmodule bottom() {\n\tunion() {\n\t\tdifference() {\n\t\t\ttranslate([-width - fingerLength, -depth/2, 0]) {\n\t\t\t\tcube([width,depth,height]);\n\t\t\t}\n\t\t\ttranslate([(-width - fingerLength) + wallThickness, -depth/2 + wallThickness, wallThickness]) {\n\t\t\t\tcube([width - (wallThickness * 2), depth - (wallThickness * 2), height]);\n\t\t\t}\n\t\t\ttranslate([-width - fingerLength + (wallThickness/2), (-latchWidth/2) - (hingeFingerSlop/2), wallThickness]) {\n\t\t\t\tcube([wallThickness/2 + .1, latchWidth + hingeFingerSlop, height]);\n\t\t\t}\n\t\t}\n\t\tdifference() {\n\t\t\ttranslate([-width - fingerLength + (wallThickness/2), -latchWidth/2, height - 1]) {\n\t\t\t\trotate([-90,0,0]) {\n\t\t\t\t\tcylinder(r = 1, h = latchWidth);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([-width - fingerLength - 5, -depth/2,0]) {\n\t\t\t\tcube([5,depth,height]);\n\t\t\t}\n\t\t}\n\t\tdifference() {\n\t\t\thull() {\n\t\t\t\ttranslate([0,-depth/2,height]) {\n\t\t\t\t\trotate([-90,0,0]) {\n\t\t\t\t\t\tcylinder(r = hingeOuter/2, h = depth);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttranslate([-fingerLength - .1, -depth/2,height - hingeOuter]){\n\t\t\t\t\tcube([.1,depth,hingeOuter]);\n\t\t\t\t}\n\t\t\t\ttranslate([-fingerLength, -depth/2,height-.1]){\n\t\t\t\t\tcube([fingerLength,depth,.1]);\n\t\t\t\t}\n\t\t\t\ttranslate([0, -depth/2,height]){\n\t\t\t\t\trotate([0,45,0]) {\n\t\t\t\t\t\tcube([hingeOuter/2,depth,.01]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor  (i = [-depth/2 + fingerSize:fingerSize*2:depth/2]) {\n\t\t\t\ttranslate([-fingerLength,i - (fingerSize/2) - (hingeFingerSlop/2),0]) {\n\t\t\t\t\tcube([fingerLength*2,fingerSize + hingeFingerSlop,height*2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate([0, -depth/2, height]) {\n\t\t\trotate([-90,0,0]) {\n\t\t\t\tcylinder(r = hingeInner /2, h = depth);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule top() {\n\tunion() {\n\t\tdifference() {\n\t\t\ttranslate([fingerLength, -depth/2, 0]) {\n\t\t\t\tcube([width,depth,height - .5]);\n\t\t\t}\n\t\t\ttranslate([fingerLength + wallThickness, -depth/2 + wallThickness, wallThickness]) {\n\t\t\t\tcube([width - (wallThickness * 2), depth - (wallThickness * 2), height]);\n\t\t\t}\n\t\t}\n\t\ttranslate([width + fingerLength - wallThickness - 1.5, (-latchWidth/2), 0]) {\n\t\t\tcube([1.5, latchWidth, height - .5 + 4]);\n\t\t}\n\t\ttranslate([width + fingerLength - wallThickness, -latchWidth/2, height - .5 + 3]) {\n\t\t\trotate([-90,0,0]) {\n\t\t\t\tcylinder(r = 1, h = latchWidth);\n\t\t\t}\n\t\t}\n\t\tdifference() {\n\t\t\thull() {\n\t\t\t\ttranslate([0,-depth/2,height]) {\n\t\t\t\t\trotate([-90,0,0]) {\n\t\t\t\t\t\tcylinder(r = hingeOuter/2, h = depth);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttranslate([fingerLength, -depth/2,height - hingeOuter - .5]){\n\t\t\t\t\tcube([.1,depth,hingeOuter - .5]);\n\t\t\t\t}\n\t\t\t\ttranslate([-fingerLength/2, -depth/2,height-.1]){\n\t\t\t\t\tcube([fingerLength,depth,.1]);\n\t\t\t\t}\n\t\t\t\ttranslate([0, -depth/2,height]){\n\t\t\t\t\trotate([0,45,0]) {\n\t\t\t\t\t\tcube([hingeOuter/2,depth,.01]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor  (i = [-depth/2:fingerSize*2:depth/2 + fingerSize]) {\n\t\t\t\ttranslate([-fingerLength,i - (fingerSize/2) - (hingeFingerSlop/2),0]) {\n\t\t\t\t\tcube([fingerLength*2,fingerSize + hingeFingerSlop,height*2]);\n\t\t\t\t}\n\t\t\t\tif (depth/2 - i < (fingerSize * 1.5)) {\n\t\t\t\t\ttranslate([-fingerLength,i - (fingerSize/2) - (hingeFingerSlop/2),0]) {\n\t\t\t\t\t\tcube([fingerLength*2,depth,height*2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([0, -depth/2, height]) {\n\t\t\t\trotate([-90,0,0]) {\n\t\t\t\t\tcylinder(r = hingeInner /2 + hingeInnerSlop, h = depth);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "description": "Okay, I'd like to design a parametric, one-piece hinged box that prints in place. I've been experimenting and have a working version, but I'd like to see if an AI can generate something similar, or potentially better, based on what I've learned and what I'm aiming for.\n\nHere's what I'm looking for:\n\n**Core Requirements:**\n\n*   **One-Piece, Print-in-Place:** The entire box, including the lid and hinge, should print as a single piece without needing assembly. The hinge needs to be functional immediately after printing.\n*   **Parametric:** I need to be able to easily adjust the dimensions of the box and the hinge via parameters in the OpenSCAD file.\n*   **Rectangular Box:** The basic shape of the box should be rectangular.\n*   **Hinged Lid:** The box should have a lid that's attached to the main box body via a hinge.\n*   **Latch:** A simple latch mechanism should be included, and it should be integrated into the print-in-place structure. It doesn't need to be super complex. A simple tab and slot should suffice.\n*   **Functional, non-Fusing Hinge:** The hinge needs to be reliable. I've found that the tolerances are tricky  it needs to be tight enough to function well but loose enough to not fuse during printing. This is a key area to focus on.\n*   **Wall Thickness:** I need to be able to control the thickness of the walls of the box.\n*   **Internal Volume:** It would be good to be able to quickly adjust the internal volume of the box through parameters, as opposed to recalculating internal dimensions using wall thickness.\n\n**Specific Parameters I Need:**\n\n*   `width`: Overall width of the box.\n*   `depth`: Overall depth of the box.\n*   `height`: Overall height of the box (when closed).\n*   `wallThickness`: Thickness of the box walls.\n*   `hingeOuter`: Outer diameter of the hinge barrel.\n*   `hingeInner`: Inner diameter of the hinge barrel (for the pin).\n*   `hingeInnerSlop`: Extra clearance around the hinge pin for free movement.\n*  `hingeFingerSlop`: Clearance around the hinge fingers that mesh between the box and lid.\n*  `fingerLength`: Length of the hinge fingers.\n*   `fingerSize`: Width of each hinge finger.\n*   `latchWidth`: Width of the latch mechanism.\n  \n**Notes on Hinge Design (from my experience):**\n\n*   I've had good results using interleaved fingers on the hinge. The fingers from the box side and the lid side mesh together around a cylindrical hinge pin/rod.\n*   The tolerances are critical, especially `hingeInnerSlop` and `hingeFingerSlop`. I've found that a small change in these values drastically affects whether the hinge fuses or moves freely. Start with something that's more likely to move freely, and then consider tighter fits if needed.\n\n**Libraries:**\n\n*   I haven't used any specific libraries so far, but I'm open to including them if it simplifies things and gives me more control. I'm familiar with the basics of OpenSCAD, but not with most libraries, so if you include them, please explain how they're used. If something like BOSL2 helps with the hinge design that would be great.\n\n**Output:**\n\n*   I'd like a single `.scad` file with all the code. \n\nI'm looking for a clean, well-commented OpenSCAD file that is easy to customize and maintain. I'm comfortable with making minor changes myself after the initial generation if needed. I've also attached my previous code for reference. I'm not suggesting you use this code, but it may be useful.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Paraboloid OpenSCAD Script",
    "scad": "module paraboloid (y=10, f=5, rfa=0, fc=1, detail=44){\n\thi = (y+2*f)/sqrt(2);\n\tx =2*f*sqrt(y/f);\n   translate([0,0,-f*fc])\n\trotate_extrude(convexity = 10,$fn=detail )\n\ttranslate([rfa,0,0])\n\tdifference(){\n\t\tunion(){\n\t\t\tprojection(cut = true)\n\t\t\t\ttranslate([0,0,f*2]) rotate([45,0,0])\n\t\t\t\ttranslate([0,0,-hi/2])cylinder(h= hi, r1=hi, r2=0, center=true, $fn=detail);\n\t\t\ttranslate([-(rfa+x ),0]) square ([rfa+x , y ]);\n\t\t}\n\t\ttranslate([-(2*rfa+x ), -1/2]) square ([rfa+x ,y +1] );\n\t}\n}\nparaboloid (y=50,f=10,rfa= 0,fc=1,detail=120);",
    "description": "Okay, I'm looking to create a parametric elliptic paraboloid in OpenSCAD, similar to the existing `paraboloid` module I've found, but with the ability to control the shape differently. I want to be able to squish or stretch it in the x and y dimensions independently, effectively making an elliptical paraboloid instead of just a circular one.\n\nThe provided `paraboloid` module is a great start, but it's limited to a rotationally symmetric paraboloid, defined by:\n\n*   `y`: height of the paraboloid along the z-axis\n*   `f`: focus distance; the distance of the focus from the top or the focus point.\n*   `rfa`: radius of the focal area\n*   `fc`: a flag to control whether to center the paraboloid at its apex (0) or at the focus point (1).\n*   `detail`: the $fn value for curve subdivisions\n\nI'd like a new module, let's call it `elliptic_paraboloid`, that builds upon this but introduces two radii for controlling the base shape of the paraboloid. Instead of `rfa` being a single radius I'd like to use `rfa_x` and `rfa_y` which are radii at the focal area in x and y axis. Also instead of `x` being calculated directly from `f` and `y`, I'd like it to be controlled by x-axis and y-axis radii at the base of the paraboloid. Let's call these `base_x` and `base_y`, replacing the `x` variable calculation.\n\nSo, the `elliptic_paraboloid` module parameters should be:\n*   `y`: height of the paraboloid along the z-axis\n*   `f`: focus distance\n*   `rfa_x`: radius of the focal area in x-axis\n*  `rfa_y`: radius of the focal area in y-axis\n*   `base_x`: x-radius at base of paraboloid\n*   `base_y`: y-radius at base of paraboloid\n*   `fc`: flag to control center position.\n*   `detail`: the $fn value for curve subdivisions\n\nEssentially, I want to replace the circular cross-section of the existing paraboloid with an elliptical cross-section. I still want to have the same functionality with the focus point and also center on top or in the focus point.\nThe mathematics of a paraboloid will be the same in terms of vertical z-position, I'd just like control the x and y width independently by the radii `base_x` and `base_y`.\n\nCould you provide me with the OpenSCAD code for this `elliptic_paraboloid` module? I am not using any external libraries.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Oh nooo, another customizable thumb wheel / knob / screw / whatever :D",
    "scad": "total_d = 60;\nwing_count = 3;\nwing_thick_d = 8;\nwing_thin_d = 5;\nwing_h = 7;\nnut_d = 14.6;\nhex_nut = 1;\nnut_th = 6.6;\nthread_d = 8;\nnut_shoulder_z = 2;\nnut_shoulder_x= 2.8;\nroundness_ratio = 30;\nroundness= roundness_ratio * min(wing_h, nut_th + nut_shoulder_z) / 100;\n$fs=0.3+0;\ntol= 0.05+0;\nmodule torus(r,rnd)\n{\n\ttranslate([0,0,rnd/2])\n\t\trotate_extrude(convexity= 10)\n\t\t\ttranslate([r-rnd/2, 0, 0])\n\t\t\t\tcircle(r= rnd/2, $fs=0.2);\n}\nmodule rcyl(r,h, zcenter=false, rnd=1)\n{\n\ttranslate([0,0,zcenter ? -h/2 : 0])\n\thull()\n\t{\n\t\ttranslate([0,0,0]) torus(r=r, rnd=rnd);\n\t\ttranslate([0,0,h-rnd]) torus(r=r, rnd=rnd);\n\t}\n}\nmodule one_wing()\n{\n\thull()\n\t{\n\t\ttranslate([total_d/2 - wing_thick_d/2, 0, 0])\n\t\t\trcyl(r= wing_thick_d/2, h= wing_h, rnd= roundness);\n\t\ttranslate([nut_d/2+nut_shoulder_x-roundness, 0, 0])\n\t\t\trcyl(r= wing_thin_d/2, h= nut_shoulder_z+nut_th, rnd= roundness);\n\t}\n}\ndifference()\n{\n\tfor(rot=[0:360/wing_count:359])\n\t{\n\t\trotate([0,0,rot])\n\t\t\tone_wing();\n\t\trcyl(r= nut_d/2+nut_shoulder_x, h= nut_shoulder_z+nut_th, rnd= roundness);\n\t}\n\ttranslate([0,0,nut_shoulder_z - tol])\n\t\tcylinder(r=nut_d/2, h=nut_th+nut_shoulder_z+2*tol, $fn=(hex_nut?6:60));\n\ttranslate([0,0,-tol])\n\t\tcylinder(r=thread_d/2, h=nut_th+nut_shoulder_z+2*tol);\n}",
    "description": "Okay, I'm looking to generate a customizable thumbnut design in OpenSCAD. I want to be able to control various aspects of its shape and dimensions using parameters. Here's what I need:\n\nThe basic shape will be a central nut with a number of \"wings\" radiating outwards.\n\n**Key Parameters:**\n\n*   **`total_d`**: The overall diameter of the thumbnut, encompassing the wings.\n*   **`wing_count`**: The number of wings extending from the central nut. This needs to be a variable I can adjust.\n*   **`wing_thick_d`**: The diameter of the wing at its outer edge.\n*   **`wing_thin_d`**: The diameter of the wing where it meets the central nut.\n*   **`wing_h`**: The height (thickness) of the wing at its outer edge.\n*   **`nut_d`**: The diameter of the nut part from corner to corner.  This can be set to zero to disable the nut shape entirely and just use a cylindrical hole.\n*   **`hex_nut`**: A boolean (1 or 0) to select between a hexagonal nut shape (1) and a simple cylindrical hole (0).\n*   **`nut_th`**: The thickness of the nut itself.\n*   **`thread_d`**: The diameter of the thread hole inside the nut.\n*   **`nut_shoulder_z`**: The thickness of the shoulder below the central nut. This is added to the nut's thickness to calculate how far it protrudes from the main body.\n*   **`nut_shoulder_x`**: The extra width around the central nut, effectively controlling how wide the base of the wing is.\n*    **`roundness_ratio`**: A percentage (1-99) that affects the roundness of the transitions between parts, controlling the curvature of the wing edges and their connection to the nut. This ratio should also affect the radius used for the torus-based \"rcyl\" function.\n\n**Functional Requirements:**\n\n*   **Wings:**  The wings should be created using a `hull` operation, connecting a thicker outer circle to a thinner inner one. The inner circle's diameter and location should be affected by `nut_shoulder_x`. The wing's shape should use `rcyl` (which I think is a custom function using `torus`?) to achieve smooth curves.\n*   **Central Nut:**\n    *   The central nut needs a hole for a bolt. The shape should be a hexagon if `hex_nut` is 1, otherwise, it should be a cylinder. The hole's diameter is specified by `nut_d`.\n    *   The `nut_th` parameter determines the thickness of the nut. `nut_shoulder_z` determines the distance the nut protrudes from the main body of the thumbnut.\n    *   There should be a thread hole passing through everything, with the diameter given by `thread_d`.\n*   **Smooth Transitions:** The shape should be smooth. I want to use torus shapes (`rcyl`, `torus` functions) to ensure round edges where possible, and be able to influence the roundness.\n*   **Tolerance:** I'd like a slight tolerance on the thread and nut holes for printing. This tolerance is represented by the `tol` variable.\n*   **Custom Functions**: A custom function `rcyl` (using `torus`) is used to create smoothly rounded cylinders and should be preserved. The `torus` function is also needed.\n*   **Subtractive Manufacturing**: The script should be designed for 3D printing (i.e. it should remove volumes to create final shape, not use minkowski operations).\n\n**Additional Notes:**\n\n*   The design is meant to be printed, so small details are less important than overall strength and the customizability of the parameters.\n*   The code uses an `$fs` parameter for the `circle` and I assume for `torus`. I'd like to keep this in the code and set to 0.3.\n*   I'd like to have all parameters easily changeable at the top of the script.\n\nCould you generate the OpenSCAD code that implements this design? I don't need any external libraries. I'd like the custom functions `torus` and `rcyl` to be part of the script.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Fraction learning kit (Bruchrechen Lernmaterial)",
    "scad": "use <write/Write.scad>\npart = \"fraction\";\ndiameter = 60;\nthickness = 10;\ntol=1;\nparts=3;\nfine = 50;\nprint_part();\nmodule print_part() {\n\tif (part == \"fraction\") {\n\t\tsectorWithFraction();\n\t} else if (part == \"plate\") {\n\t\tplateWithFraction();\n\t} else {\n\t\techo (\"ERROR: part not found\");\n\t}\n}\nmodule sector(d,t,tol) {\n\tdifference(){\n\t\tcylinder(h=t,r=d/2,center=true,$fn=fine);\n\t\tunion() {\n\t\t\trotate([0,0,180/parts]) translate([(d+2)/2-tol/2,0,0]) cube(size=[d+2,d+2,t+2], center=true);\n\t\t\trotate([0,0,-180/parts]) translate([-(d+2)/2+tol/2,0,0]) cube(size=[d+2,d+2,t+2], center=true);\n\t\t}\n\t}\n}\nmodule sectorStackable() {\n\tintersection() {\n\t\tunion() {\n\t\t\ttranslate([0,0,-thickness*4/5]) sector(diameter-3, thickness, tol+3);\n\t\t\thull() {\n\t\t\t\ttranslate([0,0,thickness*1/5]) sector(diameter-3, thickness, tol+3);\n\t\t\t\ttranslate([0,0,thickness*0.5]) sector(diameter, thickness, tol);\n\t\t\t}\n\t\t}\n\t\tdifference() {\n\t\t\ttranslate([0,0,thickness*0.05]) sector(diameter, thickness*1.1, tol);\n\t\t\ttranslate([0,0,thickness]) sector(diameter-2, thickness, tol+2);\n\t\t}\n\t}\n}\nmodule fraction() {\n\ttranslate([-0.4,-diameter/2.6+8*diameter/60,thickness/2]) write(str(1),t=2*thickness/10,h=diameter*7/60,center=true);\n\ttranslate([0.1,-diameter/2.6+7*diameter/60,thickness/2]) write(\"_\",t=2*thickness/10,h=diameter*7/60,center=true);\n\ttranslate([0.1,-diameter/2.6-2*diameter/60,thickness/2]) write(str(parts),t=2*thickness/10,h=diameter*7/60,center=true);\n}\nmodule sectorWithFraction() {\n\tdifference() {\n\t\tsectorStackable();\n\t\tfraction();\n\t}\n}\ninnerR = (diameter-2)/2;\nouterR = diameter*0.55;\nmodule plate() {\n\tunion() {\n\t\tdifference() {\n\t\t\tcylinder(h=thickness*0.2,r=outerR,center=true,$fn=fine);\n\t\t\ttranslate([0,0,thickness*0.1]) cylinder(h=thickness*0.2,r=innerR,center=true,$fn=fine);\n\t\t}\n\t\tintersection(){\n\t\t\ttranslate([0,diameter/4,0]) cube(size = [1,diameter/2,thickness*0.2], center = true);\n\t\t\trotate([0,0,180]) sector(diameter*2, thickness*0.4, tol);\n\t\t}\n\t\tfor (i = [0:parts-1]) {\n\t\t\trotate([0,0,360*i/parts]) translate([0,outerR-(outerR-innerR)/2+1,thickness*0.1]) cube(size = [2,outerR-innerR+2,thickness*0.4], center = true);\n\t\t}\n\t}\n}\nmodule plateFraction() {\n\ttranslate([0.1,-diameter/2.8+8*diameter/60,thickness*0.05]) write(str(parts),t=2*thickness/10,h=diameter*7/60,center=true);\n\ttranslate([0.1,-diameter/2.8+7*diameter/60,thickness*0.05]) write(\"_\",t=2*thickness/10,h=diameter*7/60,center=true);\n\ttranslate([0.1,-diameter/2.8-2*diameter/60,thickness*0.05]) write(str(parts),t=2*thickness/10,h=diameter*7/60,center=true);\n}\nmodule plateWithFraction() {\n\tdifference() {\n\t\tplate();\n\t\tplateFraction();\n\t}\n}",
    "description": "Okay, I'd like to design some fraction manipulatives for kids to learn about fractions. I want to be able to 3D print them.\n\nThe basic idea is to have two types of parts: fraction sectors and a plate. The fraction sectors are basically pieces of a pie, and the plate has a circle divided into the correct number of parts to match.\n\nHere's a more detailed description of what I'm looking for:\n\n**Fraction Sectors:**\n\n*   Each sector should be a slice of a circle with a specified diameter and thickness.\n*   They should have a small lip/overhang around the outside edge on one side to make them stackable. This would work by making one side of the fraction slightly thinner and with a lip, so that the lip goes inside the piece below. This needs to work for stacking multiple pieces.\n*   I want to be able to specify the number of sectors that make up a whole (e.g., 3 for thirds, 4 for quarters, 6 for sixths).\n*   Each sector should have a fraction printed on it, such as \"1/3\", \"1/4\", etc.\n*   There should be some clearance to allow the pieces to stack nicely.\n\n**Plates:**\n\n*   The plates are basically circles divided into sections corresponding to the number of parts.\n*   The plate should have a central solid disk area and a lip or rim around it.\n*   I would like a line marking the division between different sectors on the plate.\n*   Like the sectors, the plate should have a fraction printed on it to indicate the total number of sectors (e.g., \"3/3\", \"4/4\", etc).\n\n**Parameters:**\n\nI want these to be parametric so I can easily change things:\n\n*   `diameter`: The diameter of the circle that the sectors and plate are based on.\n*   `thickness`: The thickness of the sectors and plate.\n*   `parts`: The number of parts/sectors for the circle. For example, if parts=4 the pieces will represent fourths, and there will be 4 pieces as well as the plate being in 4 sections.\n*   `tol`: A small clearance/tolerance for stacking the sectors.\n*   `fine`:  A value controlling the smoothness of the curves (for example, `$fn`).\n\n**Functionality:**\n\n*   I want two separate modules: `sectorWithFraction()` and `plateWithFraction()`.  I want to be able to choose which one to print by selecting \"fraction\" or \"plate\" for a `part` variable. The `print_part()` will then select the correct module based on the `part` variable.\n*   I need to use the `write` module from the `write/Write.scad` library. I do *not* need you to include the actual library code in the response.\n\n**In summary:**\n\nI need an OpenSCAD file that generates 3D printable fraction manipulatives. I need stackable fraction sectors with a printed fraction, and matching plates also with a fraction printed on them. I want the design to be parametric using `diameter`, `thickness`, `parts`, `tol`, and `fine`, and I need to use the `write/Write.scad` library for text printing. I want a variable called `part` which controls if the sector or the plate is printed.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Wheel Spacer For Custom Rims Customizer",
    "scad": "OD = 72.1;\n    ID = 57.1;\n    Taper_OD = 77;\n    Taper_InnerD = 64;\n    Thickness = 9.5;\n    Taper_Thickness = 3;\nmodule WheelSpacer (OD, ID, Taper_OD, Taper_InnerD, Thickness, Taper_Thickness)\n{\ndifference()\n{\n\tunion()\n\t{\n\t\tcylinder(h = Thickness, r = OD/2, $fn= 128);\n\t\tcylinder(h = Taper_Thickness, r1 = Taper_OD/2, r2= OD/2, $fn = 128);\n\t}\n\ttranslate([0,0,-0.5]) cylinder(h = Thickness+1, r = ID/2, $fn = 128);\n\tcylinder(h = Taper_Thickness, r1 = Taper_InnerD/2, r2 = ID/2, $fn = 128);\n}\n}\nWheelSpacer(OD, ID, Taper_OD, Taper_InnerD, Thickness, Taper_Thickness);",
    "description": "Okay, I need a custom wheel spacer generator, and I'd like it to be parametric in OpenSCAD. I've already got a basic design in mind, but I'd like it improved and made more flexible.\n\nThe spacer needs to be a cylinder with a central hole, and optionally a tapered section on one side.  The main parameters should be:\n\n*   **Outer Diameter (OD):** The overall diameter of the spacer.\n*   **Inner Diameter (ID):** The diameter of the central hole.\n*   **Taper Outer Diameter (Taper_OD):** The outer diameter of the tapered section, if present.\n*   **Taper Inner Diameter (Taper_InnerD):** The inner diameter of the tapered section, if present (should be larger than the ID).\n*   **Overall Thickness (Thickness):** The total thickness of the spacer, including the tapered section.\n*   **Taper Thickness (Taper_Thickness):** The thickness of the tapered section.\n\nThe spacer should be designed such that it's a basic cylinder, then have the tapered section added to one face. Then the inner bore is subtracted from the whole thing, as well as the material removed by the taper.\n\nI need a few improvements over what I've drafted:\n\n1.  **Taper Optionality:**  I'd like the tapered section to be optional. If `Taper_Thickness` is set to 0 or undefined, there should be no taper, just a straight cylindrical spacer. This makes it more versatile.\n2. **Unit Testing**: I'd also like the design to include basic unit tests. If I misconfigure a parameter, I would like an error to be thrown. For instance, OD should be greater than ID and Taper_OD should be greater than Taper_InnerD.\n3.  **Chamfers**: I'd also like to be able to specify chamfers on the inner and outer edges of the cylinder, both on the main portion and the taper. I should be able to specify `Chamfer_Size` and `Chamfer_Segments`. If these are set to 0 or undefined, then there should be no chamfer.\n4.  **Clear Comments**: Please make sure there are clear comments for all parameters and sections of the code.\n\nI would like this done in native OpenSCAD, no external libraries needed.\n"
  },
  {
    "object": "Hey cadmonkey, make me a Customizable Knitting Needles",
    "scad": "$fn = 100;\nBODY_LENGTH = 250;\nBODY_DIAMETER = 5;\nTIP_TAPER_LENGTH = 15;\nTIP_DIAMETER = 1;\nSLEEVE_LENGTH = 3;\nSLEEVE_THICKNESS = 1;\nTOP_DIAMETER = 10;\nTOP_THICKNESS = 1;\nTWO_NEEDLES = true;\ntranslate(v = [BODY_DIAMETER / 2, BODY_DIAMETER / 2, 0])\n{\n\tneedle();\n}\nif(TWO_NEEDLES)\n{\n\ttranslate(v = [-(BODY_DIAMETER / 2), -(BODY_DIAMETER / 2), 0])\n\t{\n\t\tneedle();\n\t}\n}\ncapOffset = (TOP_DIAMETER / 2) + BODY_DIAMETER;\ncapDepth = -((BODY_DIAMETER / 2) - (SLEEVE_LENGTH / 2) - TOP_THICKNESS);\ntranslate(v = [capOffset, capOffset, capDepth])\n{\n\tcap();\n}\nif(TWO_NEEDLES)\n{\n\ttranslate(v = [-capOffset, -capOffset, capDepth])\n\t{\n\t\tcap();\n\t}\n}\nmodule needle()\n{\n\trotate(a = [90, 0, 45])\n\t{\n\t\tunion()\n\t\t{\n\t\t\tcylinder(r = BODY_DIAMETER / 2, h = BODY_LENGTH - TIP_TAPER_LENGTH, center = true);\n\t\t\ttranslate(v=[0, 0, BODY_LENGTH / 2])\n\t\t\t{\n\t\t\t\tcylinder(r1 = BODY_DIAMETER / 2, r2 = TIP_DIAMETER / 2, h = TIP_TAPER_LENGTH, center = true);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule cap()\n{\n\tunion()\n\t{\n\t\tdifference()\n\t\t{\n\t\t\tcylinder(r = (BODY_DIAMETER + SLEEVE_THICKNESS) / 2, h = SLEEVE_LENGTH, center = true);\n\t\t\tcylinder(r = BODY_DIAMETER / 2, h = SLEEVE_LENGTH, center = true);\n\t\t}\n\t\ttranslate(v = [0, 0, -((SLEEVE_LENGTH / 2) + (TOP_THICKNESS / 2))])\n\t\t{\n\t\t\tcylinder(r = TOP_DIAMETER / 2, h = TOP_THICKNESS, center = true);\n\t\t}\n\t}\n}",
    "description": "Okay, so I'm trying to design a set of knitting needles in OpenSCAD, and I've got a basic design working, but I need it to be much more flexible and user friendly. I'm not super familiar with all the OpenSCAD tricks, so I'd really appreciate some help making it parametric and robust.\n\nRight now, my design consists of two main parts: the needle itself, and a cap for the blunt end. The needle is a cylinder that tapers to a point, and the cap fits over the base of the needle. I'd like to be able to easily adjust all the dimensions, and also be able to generate a single needle or a pair, so I need help making this a good parametric design.\n\nHere's what I've got so far, and some more of what I would like to be able to customize:\n\n**Needle Body**\n\n*   **`BODY_LENGTH`**:  This is the total length of the needle, without the tip.\n*   **`BODY_DIAMETER`**: This is the diameter of the main cylindrical part of the needle.\n*   **`TIP_TAPER_LENGTH`**: This is the length of the tapered cone that forms the needle tip.\n*   **`TIP_DIAMETER`**: This is the diameter of the very tip of the needle. It's always smaller than `BODY_DIAMETER`.\n*   **Needle Orientation:** Currently the needle is rotated to lay at a 45 degree angle to make printing easier, it would be nice to be able to control that or remove it, in case a user wanted a straight needle.\n*   **Tip Style:** The tip is currently a cone, but it would be nice to be able to easily make a more rounded or bullet shaped tip if someone wanted it. This could be an additional shape selection or some parameters for the cone shape.\n\n**Cap**\n\n*   **`SLEEVE_LENGTH`**: The length of the cylindrical sleeve part of the cap that fits over the needle base.\n*   **`SLEEVE_THICKNESS`**: The thickness of the sleeve wall.\n*   **`TOP_DIAMETER`**: The diameter of the top (flat circular part) of the cap.\n*   **`TOP_THICKNESS`**: The thickness of the flat top of the cap.\n*   **Cap Placement:** The cap's initial location is a bit complicated because it's calculated based on the needle diameter, sleeve length and top thickness. It would be nice to make it a little more straightforward to position and perhaps not require the calculation, or provide a secondary way to position it.\n\n**General**\n\n*   **`TWO_NEEDLES`**: A boolean flag to generate either one or two needles and caps.\n*   **Parametric Control:** I'd like all the dimensions to be easily adjustable via variables so that a user can quickly create needles with custom sizes.\n*   **Clear Comments:** It would be great if the code could be clearly commented so that I and other users can understand what it's doing.\n*   **Error Handling:** Simple error handling would be useful for cases where the dimensions might not make sense (e.g. TIP_DIAMETER > BODY_DIAMETER).\n*   **Unit System:** Explicitly showing a unit system might be useful for the user, probably in millimeters.\n\n**Libraries**\n*   Please do not use external libraries.\n\nSo, to summarize, Im looking for a clean, parameterized OpenSCAD file that generates one or two knitting needles and their caps, with easily adjustable dimensions, and ideally an option for different tip shapes.  The parameters I listed above should be adjustable, and there should be error handling and good commenting. Can you help me with that?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Parametric Cable Clamp",
    "scad": "use <write/Write.scad>;\ntext = \"TV\";\ntext_thickness = 0.5;\ntext_height = 7;\nclamp_dia = 20;\nclamp_height = 10;\nclamp_wall = 2;\nhandle_angle=25;\nhandle_wall=2;\nhandle_length_factor = 1;\nclamp_rad = clamp_dia/2;\nmodule clamp_ring() {\n  $fn = clamp_dia * 2;\n  difference() {\n     cylinder(h=clamp_height, r=clamp_rad + clamp_wall, center=true);\n     cylinder(h=clamp_height+1, r=clamp_rad, center=true);\n     translate([0,-(clamp_rad+clamp_wall/2),0]) {\n      cube([clamp_wall,clamp_wall+1,clamp_height+1],true);\n     }\n  }\n}\nmodule clamp_handle () {\n  difference() {\n    union() {\n      rotate([0,0,handle_angle/2]) {\n        translate([clamp_rad+clamp_wall-(handle_wall/2),clamp_rad*handle_length_factor,0 ]) {\n          cube([handle_wall,clamp_dia*handle_length_factor,clamp_height], true);\n          rotate([90,0,0]) rotate([0,90,0]) translate([0,0,handle_wall/2+text_thickness/2-0.1]) write(text, t=text_thickness, h=text_height, center=true);\n        }\n      }\n      rotate([0,0,-handle_angle/2]) {\n        translate([-(clamp_rad+clamp_wall-(handle_wall/2)),clamp_rad*handle_length_factor,0 ]) {\n          cube([handle_wall,clamp_dia*handle_length_factor,clamp_height], true);\n          rotate([90,0,180]) rotate([0,90,0]) translate([0,0,handle_wall/2+text_thickness/2-0.1]) write(text, t=text_thickness, h=text_height, center=true);\n        }\n      }\n    }\n    cylinder(h=clamp_height+1, r=clamp_rad, center=true);\n  }\n}\nmodule build() {\n  union() {\n    clamp_ring();\n    clamp_handle();\n  }\n}\nbuild();",
    "description": "Okay, I'm looking to create a parametric cable clamp in OpenSCAD, and I have a pretty good idea of what I want. I need a circular clamp with two handles extending out from it, kind of like a clothes peg but circular. The clamp needs to be able to be customized with parameters for:\n\n*   **clamp_dia**: The inner diameter of the circular part of the clamp. This is the size of the cable or object that it's meant to hold.\n*   **clamp_height**: The height or thickness of the clamp.\n*   **clamp_wall**: The thickness of the circular clamp wall.\n*   **handle_angle**: The angle of the handles, relative to the center of the clamp. So 0 degrees would be straight out and 90 would be more perpendicular.\n*   **handle_wall**: The thickness of the handles.\n*  **handle_length_factor**: A factor that multiplies the clamp diameter to determine the length of the handles.  So, a value of 1 would make the handles roughly the diameter of the clamp\n*   **text**: The text to be displayed on the handles. This needs to be customizable.\n*   **text_thickness**: The depth of the text on the handles (how far it protrudes).\n*   **text_height**: The height of the text.\n\nThe handles should be mirrored and symmetrical, one on each side of the main clamp. And importantly, the text on each handle should be oriented so that it reads correctly when viewed from the outside. The text should also be centered on the face of the handle. \n\nI am using the `write/Write.scad` library for the text functionality, so please make sure that's included.  \n\nCould you please generate the OpenSCAD code for me?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Friction-fit vise soft jaws",
    "scad": "vise_jaw_width = 125;\nvise_jaw_height = 21;\nvise_jaw_depth = 12;\noverlap = 1.26;\nsoft_jaw_face_thickness = 6;\nsoft_jaw_wall_thickness = 3;\ncutout_guide_radius = 3;\ncutout_angles = [45,90];\nfudge_factor = 0.5;\ngOff = vise_jaw_width/len(cutout_angles);\njDepth = max(soft_jaw_face_thickness,\n  (len(cutout_angles) > 0 ?  cutout_guide_radius : 0) +\n  1.5\n);\nrotate([90,0,0])\ntranslate([0,vise_jaw_height/2 + soft_jaw_wall_thickness,0])\ndifference() {\n  translate([\n    soft_jaw_wall_thickness + fudge_factor,\n    -vise_jaw_height/2-soft_jaw_wall_thickness-fudge_factor,\n    0])\n    difference() {\n      cube([\n        vise_jaw_width + fudge_factor*2 + soft_jaw_wall_thickness*2,\n        vise_jaw_height + fudge_factor*2 + soft_jaw_wall_thickness,\n        jDepth + vise_jaw_depth + fudge_factor + soft_jaw_wall_thickness]);\n      translate([soft_jaw_wall_thickness, soft_jaw_wall_thickness, jDepth])\n        cube([vise_jaw_width + fudge_factor*2, vise_jaw_height + fudge_factor*2 + 0.1, vise_jaw_depth + fudge_factor]);\n      translate([soft_jaw_wall_thickness + overlap, soft_jaw_wall_thickness+overlap+fudge_factor, jDepth + vise_jaw_depth + fudge_factor-1])\n        cube([vise_jaw_width + fudge_factor*2 - overlap*2, vise_jaw_height + fudge_factor*2 - overlap, soft_jaw_wall_thickness+2]);\n    }\n    for (i = [len(cutout_angles)-1:0])\n      translate([gOff*(i+0.5),0])\n        rotate([0,90,cutout_angles[i]])\n          cylinder(r=cutout_guide_radius, h=2*vise_jaw_width, center=true, $fn=4);\n}",
    "description": "Okay, I'm looking to design some custom soft jaws for my bench vise, and I'd like to be able to adjust the design using parameters. I've got some measurements from my vise and some ideas about how I want the jaws to function. I'd really appreciate some help creating an OpenSCAD file for this.\n\nHere's what I need:\n\n**Basic Dimensions (These are from my vise):**\n\n*   `vise_jaw_width`: The width of my vise's jaw. Mine is 125mm.\n*   `vise_jaw_height`: The height of my vise's jaw. Mine is 21mm.\n*   `vise_jaw_depth`: The depth of my vise's jaw. Mine is 12mm.\n*   `overlap`: The distance the vise jaw extends past the vise body. Mine is 1.26mm.\n\n**Design Parameters (These are what I'd like to customize):**\n\n*   `soft_jaw_face_thickness`: The desired thickness of the face of the soft jaw. I think around 6mm is good, but I want to be able to adjust it.\n*   `soft_jaw_wall_thickness`: The desired thickness of the walls of the soft jaw. I'm thinking 3mm.\n*   `cutout_guide_radius`: The radius of the circular cutouts on the face of the soft jaw. This is for holding round stock. I'm starting with 3mm, but I may want to go bigger for larger stock.\n*   `cutout_angles`: A list of angles for the orientation of the circular cutouts. This allows for holding at different orientations. For example, `[45, 90]` would cut a groove at 45 and 90 degrees.\n*   `fudge_factor`: A small value to add some slop in the dimensions to account for printer inaccuracies, maybe 0.5mm.\n\n**Design Requirements:**\n\n*   The soft jaws should fit snugly onto my vise jaws, with a lip that grabs onto the back of the jaw and is held in place by the pressure when clamping down on something in the vise.\n*   The thickness of the face of the soft jaw will be the larger of `soft_jaw_face_thickness` and `cutout_guide_radius + 1.5`.\n*   The circular cutouts for holding round stock need to be positioned along the face of the soft jaws, evenly spaced.\n*   I need to be able to control the angle at which the cutouts are oriented by changing the values in `cutout_angles`.\n\n**Additional Notes:**\n\n*   I'd like the code to be well-commented, so I can easily understand what each part is doing and make changes later.\n*   I don't need any libraries at this time, just pure OpenSCAD code.\n*   It would be great if the code included a basic preview, so I can see what the jaws will look like before I print them.\n\nCould you generate the OpenSCAD code for this?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Solar Burner Tube! ",
    "scad": "print_object=1;\nheight=40;\nfocus_area=18;\nresolution= 45;\nwall=1.7;\nlid=3;\nclr=0.2;\nmodule paraboloid (y=50, f=10, rfa=0, fc=1, detail=44){\n\thi = (y+2*f)/sqrt(2);\n\tx =2*f*sqrt(y/f);\n   translate([0,0,-f*fc])\n\trotate_extrude(convexity = 10,$fn=detail )\n\ttranslate([rfa,0,0])\n\tdifference(){\n\t\tunion(){\n\t\t\tprojection(cut = true)\n\t\t\t\ttranslate([0,0,f*2]) rotate([45,0,0])\n\t\t\t\ttranslate([0,0,-hi/2])cylinder(h= hi, r1=hi, r2=0, center=true, $fn=detail);\n\t\t\ttranslate([-(rfa+x ),0]) square ([rfa+x , y ]);\n\t\t}\n\t\ttranslate([-(2*rfa+x ), -1/2]) square ([rfa+x ,y +1] );\n\t}\n}\nmodule reflector(hr=40, xr=20, details=80){\n\tfr= xr/2;\n\tyr=hr+fr;\n\ttranslate([0,0,hr])rotate([180,0,0])\n\tdifference(){\n\t\tif (wall>0) {\n\t\t\tparaboloid (yr ,fr , wall , 1,details );\n\t\t\tif (lid>0) {\n\t\t\t\ttranslate([0,0, hr-lid/2])cylinder(h=lid,r=wall+2*sqrt(yr*yr-yr*hr),center=true,$fn=details);\n\t\t\t\t}\n\t\t\t}\n\t\ttranslate([0,0, -0.01])paraboloid (yr+0.02 ,fr , 0, 1,details );\n\t\ttranslate([0,0,-(fr+1)/2])cube([xr*2+wall*4+1,xr*2+wall*4+1,fr+1],center=true);\n\t}\n}\nmodule  print_lit(hr=40, xr=20, details=80){\n\tfr= xr/2;\n\tyr=hr+fr;\n\tif (wall>0) {\n\t\t\tif (lid>0) {\n\t\t\t\tdifference(){\n\t\t\t\t\ttranslate([0,0,0])cylinder(h=lid+2+wall,r=wall+2*sqrt(yr*yr-yr*hr)+wall+clr,center=true,$fn=details);\n\t\t\t\t\ttranslate([0,0,wall])cylinder(h=lid+2+wall,r=wall+2*sqrt(yr*yr-yr*hr) +clr,center=true,$fn=details);\n\t\t\t\t}\n\t\t\t}\n\t}\n}\nif (print_object==2) print_lit(height,focus_area,resolution);\nif (print_object==1) reflector(height,focus_area,resolution);",
    "description": "Okay, I'm looking to create a solar burner, and I've got a starting point from something I found online, but I need help making it more flexible and easier to customize.\n\nThe basic idea is a paraboloid reflector that focuses sunlight down to a small point.  I want to be able to easily change several key dimensions and also have the option to print either the reflector or a lid that fits over the top.\n\nHere's what I have in mind, and it's based on the existing design:\n\n**Core Requirements:**\n\n*   **Parametric Paraboloid:** The core component is a paraboloid reflector. I need to be able to set the height of the reflector (`height`), and the radius of the focus area at the bottom (`focus_area`). The existing design uses a relationship of `height/focus_area` to be around 2.215, but I'd like to be able to change those independently, with the focus distance being calculated from `focus_area` which I am assuming is a radius of the focus. The calculation in the existing design, `fr= xr/2;` where `xr` is `2*f*sqrt(f/f)`, where f is the focus distance seems incorrect. It seems that `xr` should simply be `2*focus_area`. Also, the focus distance, f, should be `focus_area/2`.\n*   **Resolution Control:** I need to control the number of facets used to approximate the paraboloid. This is represented by a `resolution` parameter in the existing design.\n*   **Wall Thickness:** I need to be able to specify a wall thickness (`wall`) for the reflector, allowing me to create a hollow or solid body.\n*   **Lid Option:**  I want an optional lid. If enabled, it needs a friction ring to hold it onto the reflector. The height of this friction ring should be controlled by a `lid` parameter.  \n*   **Clearance:**  The clearance between the lid's friction ring and the reflector should also be customizable using a `clr` parameter.\n*   **Printable Objects:**  The program should allow me to select whether to print the reflector or the lid via a `print_object` parameter. I need `1` to output just the reflector, and `2` to just output the lid.\n\n**Existing Logic to Clarify:**\n\n*   The existing design centers the paraboloid's focus point at x=0, y=f, but I'm flexible on this.\n*   The paraboloid generation uses a `rotate_extrude` operation of a 2D parabola.\n*   The `paraboloid` module is constructed by cutting a 2D profile from a revolved cone, which is fine.\n*   The existing calculation for the lid ring radius, `r=wall+2*sqrt(yr*yr-yr*hr)`, is not clear to me, and it seems incorrect, it seems to be calculating some radius based on the y values of the paraboloid. This is not needed, since the lid is a cylinder that should be a fixed distance from the edge of the top of the reflector.\n\n**Specific Requests:**\n\n1.  **Parametric OpenSCAD:** Please provide an OpenSCAD file that allows me to control all of the above parameters: `height`, `focus_area`, `resolution`, `wall`, `lid`, `clr`, and `print_object`.\n2.  **Correct Calculations:** Please double-check the calculations within the `paraboloid` and `print_lit` modules, paying special attention to the lid ring radius, as I think there's an error there. The focus distance, f, should simply be `focus_area/2`, and the `xr` value should be `focus_area*2`.\n3.  **Clear Comments:** Please add comments to the code explaining the calculations and the purpose of each section.\n4. **No Libraries**: No external libraries are necessary to accomplish this design.\n\nEssentially, I need a robust and flexible tool for designing and printing solar burner tubes and their lids.\n\nCould you help me with that?\n"
  },
  {
    "object": "Hey cadmonkey, make me a customizable e-cigarette holster",
    "scad": "clip_length = 50;\ninner_length = 90;\ninner_dia = 15;\npart = \"plate\";\nmodule print_part()\n{\nif(part==\"assy\"){\nassembly();\n}else if(part==\"sheath\"){\nsheath();\n}else if(part==\"clip\"){\nclip();\n}else if(part==\"plate\"){\nplate();\n}\n}\nmodule sheath()\n{\ndifference()\n{\nhull()\n{\ntranslate([0,0,-inner_length/2+37.5])\ncylinder(r=inner_dia/2+1.5,h=inner_length+16,center=true);\ntranslate([0,inner_dia/2-3,38])\ncube([inner_dia+3,10,15],center=true);\n}\ntranslate([0,0,-inner_length/2+46.5])\ncylinder(r=inner_dia/2,h=inner_length+31,center=true);\ntranslate([4,inner_dia/2,38])\nrotate([90,0,0])\ncylinder(r=2,h=7,center=true,$fn=16);\ntranslate([4,inner_dia/2-1,38])\nrotate([90,0,0])\ncylinder(r=3.5,h=4,center=true,$fn=6);\ntranslate([-4,inner_dia/2,38])\nrotate([90,0,0])\ncylinder(r=2,h=7,center=true,$fn=16);\ntranslate([-4,inner_dia/2-1,38])\nrotate([90,0,0])\ncylinder(r=3.5,h=4,center=true,$fn=6);\ntranslate([0,0,51])\nrotate([37,0,0])\ncube([inner_dia*2,inner_dia*3,22],center=true);\n}\n}\nmodule clip()\n{\ndifference()\n{\nunion()\n{\ncube([18,15,4],center=false);\ntranslate([0,0,-3])\ncube([18,clip_length,3],center=false);\ntranslate([0,clip_length-2,0])\nrotate([0,90,0])\ncylinder(r=2,h=18,$fn=16);\n}\ntranslate([5,7.5,0])\ncylinder(r=2,h=15,center=true,$fn=16);\ntranslate([13,7.5,0])\ncylinder(r=2,h=15,center=true,$fn=16);\ntranslate([5,7.5,-2.5])\ncylinder(r=3,h=2,center=true,$fn=16);\ntranslate([13,7.5,-2.5])\ncylinder(r=3,h=2,center=true,$fn=16);\n}\n}\nmodule plate()\n{\nsheath();\ntranslate([20,-10,-inner_length+32.5])\nclip();\n}\nmodule assembly()\n{\nsheath();\ntranslate([9,17,45.5])\nrotate([90,180,0])\nclip();\n}\nprint_part();",
    "description": "Okay, I need some help designing a better e-cig holster, and I want it to be parametric so I can easily adjust it for different e-cigs in the future. Right now, I have a simple design, but it could be improved.\n\nHere's what I have in mind:\n\n**Core Functionality:**\n\n*   **Holster/Sheath:** The main part needs to securely hold my e-cig, which is longer than a standard e-go, specifically accommodating an e-go twist battery. It needs to cover the battery length and a bit of the vaporizer, leaving the top accessible.\n*   **Belt Clip:** A clip should attach to the holster for easy belt carrying. It should be robust and not break easily.\n\n**Current Design & Issues:**\n\nI've already made a basic version using OpenSCAD (attached: `ecig_sheath.scad`) but I need to improve on it. The main things I'm concerned about are:\n\n*   **E-cig Retention:** While the e-cig hasn't fallen out, I think the top of the holster needs a better way to hold the e-cig securely. I am considering adding something like Sugru at the opening of the holster to help improve retention. Maybe a design solution integrated into the model instead of a post process material would be preferable.\n*   **Clip Strength:** The clip is quite simple; I wonder if theres a way to strengthen it or make it more flexible using OpenSCAD.\n*   **Assembly:** Currently, I'm using a simple \"plate\" arrangement where the clip and holster are printed together.  I'd like to explore the possibility of having them as separate components so that the clip could rotate or be re-oriented on the holster.\n*   **Overall Parametric Design:** I want to make it easy to modify the internal dimensions (length and diameter), clip length, and other aspects of the design. Currently the design is slightly parametric, but I would like to improve that, adding more parameters to allow for broader adjustment and improve the overall ease of customization.\n\n**Specific Parameters (that should be easy to modify):**\n\n*   `inner_length`: Length of the holster's interior, designed to fit the length of the battery and some of the vape.\n*   `inner_dia`: Inner diameter of the holster, based on the diameter of the battery plus a tolerance for fit.\n*   `clip_length`: The length of the belt clip.\n*   `clip_width`: The width of the belt clip.\n*   `clip_thickness`: The thickness of the belt clip\n*   `holster_wall_thickness`: The thickness of the walls of the holster\n*   `clip_offset_x`: How far the clip should be positioned along the x-axis in relation to the holster\n*   `clip_offset_y`: How far the clip should be positioned along the y-axis in relation to the holster\n*   `clip_offset_z`: How far the clip should be positioned along the z-axis in relation to the holster\n*   `clip_rotation_x`: How much the clip should be rotated about the x-axis\n*   `clip_rotation_y`: How much the clip should be rotated about the y-axis\n*   `clip_rotation_z`: How much the clip should be rotated about the z-axis\n*   `top_lip_height`: The height of a retaining lip at the top of the holster to improve e-cig retention.\n*   `top_lip_width`: The width of a retaining lip at the top of the holster to improve e-cig retention.\n*  `top_lip_angle`: The angle of a retaining lip at the top of the holster to improve e-cig retention.\n\n**OpenSCAD Needs:**\n\nI would like the design to be clean and easy to understand. I'd prefer not to use any external libraries or modules if they can be avoided. I am familiar with basic OpenSCAD operations and functions such as `cube()`, `cylinder()`, `translate()`, `rotate()`, `difference()`, `union()`, and `hull()`.\n\n**Desired Output:**\n\nI'm looking for a robust and parametric OpenSCAD file that:\n\n1.  Creates a hollow cylindrical holster with a customizable internal length and diameter.\n2.  Implements a way to retain the e-cig more securely at the top of the holster (i.e. maybe a small lip).\n3.  Creates a strong and adjustable belt clip.\n4.  Offers the option to print the holster and clip as a single piece, or separately for more customization.\n5. Is well commented, readable, and as simple as possible.\n6. Contains all of the parameters that have been defined above.\n\nCould you help me generate a better OpenSCAD file for this project?\n"
  },
  {
    "object": "Hey cadmonkey, make me a Angular Dice Tower",
    "scad": "root_2 = sqrt(2);\nslope = 40;\nexit_slope = 27;\nwall = 2;\nramp_width = 30;\noverhang=7;\ntotal_width = wall + ramp_width*2;\nlevel_height = (ramp_width-wall)*tan(slope);\ntrim=(wall/sin(slope) - wall)*tan(slope);\nmodule ramp(corner=true, angle=slope, cut_top=true){\n\ttranslate([-wall/2,-wall/2,0])\n\t\tunion(){\n\t\t\tintersection() {\n\t\t\t\ttranslate([0,0,ramp_width*tan(angle) - wall/cos(angle)])\n\t\t\t\t\trotate([0,angle,0])\n\t\t\t\t\t translate([-ramp_width*2,0,0])\n\t\t\t\t\t\tdifference(){\n\t\t\t\t\t\t\tcube([ramp_width*5,ramp_width,ramp_width]);\n\t\t\t\t\t\t\ttranslate([-ramp_width,wall,wall]) cube([ramp_width*6,ramp_width-wall*2, ramp_width]);\n\t\t\t\t\t\t}\n\t\t\t\tif(cut_top==true){\n\t\t\t\t\ttranslate([0,0,-trim]) cube([ramp_width,ramp_width,(ramp_width-wall)*tan(angle)+trim]);\n\t\t\t\t} else {\n\t\t\t\t\ttranslate([0,0,-trim]) cube([ramp_width,ramp_width,ramp_width*tan(exit_slope)+level_height]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (corner== true){\n\t\t\t\ttranslate([0,0,level_height])\n\t\t\t\t difference(){\n\t\t\t\t\tcube([ramp_width,ramp_width,level_height]);\n\t\t\t\t\ttranslate([wall,-wall,-ramp_width])\tcube([ramp_width,ramp_width,ramp_width*2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\nmodule exit_ramp(){\n\tramp(false,exit_slope, false);\n}\nmodule funnel() {\n\tdifference() {\n\t\ttranslate([0,0,overhang*tan(slope)])\n\t\tdifference(){\n\t\t\tpyramid();\n\t\t\ttranslate([0,0,wall*tan(slope)]) pyramid();\n\t\t}\n\t\ttranslate([0,0,-ramp_width]) cube(center=true, [ramp_width*2 - wall,ramp_width*2 -wall,ramp_width*2]);\n\t}\n}\nmodule pyramid(){\n\tassign(total_overhang = ramp_width-wall/2+overhang){\n\tpolyhedron(\n\t\tpoints = [ \t[total_overhang,total_overhang,0],\n\t\t\t\t\t[total_overhang,-total_overhang,0],\n\t\t\t\t\t[-total_overhang,-total_overhang,0],\n\t\t\t\t\t[-total_overhang,total_overhang,0],\n\t\t\t\t\t[0,0,-total_overhang*tan(slope)]],\n\t\ttriangles = [\t[0,1,4],\n\t\t\t\t\t\t[1,2,4],\n\t\t\t\t\t\t[2,3,4],\n\t\t\t\t\t\t[3,0,4],\n\t\t\t\t\t\t[0,3,2],\n\t\t\t\t\t\t[0,2,1]],\n\t\tconvexity=10);\n\t}\n}\nmodule tower(){\n\tunion(){\n\t\tramp();\n\t\ttranslate([ramp_width-wall,wall-ramp_width,(ramp_width-wall)*tan(slope)])\n\t\t\trotate(90)\n\t\t\t\tramp();\n\t\ttranslate([(ramp_width-wall)*2,0,(ramp_width-wall)*tan(slope)*2])\n\t\t\trotate(180)\n\t\t\t\tramp();\n\t\ttranslate([(ramp_width-wall),ramp_width-wall,(ramp_width-wall)*tan(slope)*3])\n\t\t\trotate(270)\n\t\t\t\tramp(false);\n\t}\n}\ntranslate([0,0,wall + (ramp_width-wall)*tan(exit_slope)])\nunion(){\n\ttower();\n\ttranslate([(ramp_width-wall)*2,0,0]) rotate([0,0,180]) tower();\n\ttranslate([ramp_width-wall,0,level_height*4]) funnel();\n}\ntranslate([ramp_width-wall,0,wall]) exit_ramp();\ntranslate([ramp_width-wall,0,wall]) rotate([0,0,180]) exit_ramp();\ntranslate([-wall/2,-ramp_width+wall/2,0]) cube([ramp_width*2 - wall,ramp_width*2 -wall,wall]);",
    "description": "Okay, I've got a basic dice tower design here, but I'd like to make it more customizable and easier to adjust. I've got a basic `.scad` file that uses a series of ramps and a funnel, but I want to make it more configurable. I'm thinking I'd like to be able to tweak things like the number of levels, the size of the dice tray, and maybe even the overall footprint. \n\nHeres what Im envisioning:\n\n**Core Structure:**\n\n*   The tower should be built from repeating ramp modules. Right now, I'm using a fixed number, but I'd love to be able to set the `number_of_levels`. Each ramp module should have a `ramp_width`, `wall_thickness`, and `ramp_slope` parameter.\n*   The final ramp that the dice exit on should have its own independent `exit_ramp_slope` parameter.\n*   The ramps should be connected with corner pieces.\n*   The output ramp angle should be separately customizable from the main ramp slopes using `exit_slope`.\n*   There should be a funnel at the top, parameterized by an `overhang_amount`. This determines the size of the funnel.\n\n**Customization Goals:**\n\n*   **Number of Levels:** I want to be able to specify how many ramp levels are in the tower using an integer `number_of_levels`. Right now, it's fixed at 4.\n*   **Dice Tray:** I need a dice tray at the bottom. Right now I'm adding it with a very simple rectangular base, but I'd like it to also be parametrically generated. I'd like to control the `tray_width`, `tray_depth`, and `tray_wall_height` parameters. The tray should also have some corner rounding controlled with a `tray_corner_radius`. The tray should sit on the base.\n*   **Overall Footprint:**  The core of the tower should have a `total_width` that's based on the `ramp_width` and `wall_thickness`. Id like to control the total width of the tower through these individual values, not directly. The overall height of the tower will be determined by the `number_of_levels` and `level_height`.\n*   **Clearance:**  I want to ensure there's enough space between ramp levels and the side walls of the structure. This might require adding a clearance parameter or automatically calculating clearances based on `wall_thickness` or a combination of `wall_thickness` and `ramp_width`.\n*   **Ramp Trimming:** I'm currently trimming the lower edge of each ramp so it fits into the one below.  This calculation needs to remain a function of `wall_thickness` and `ramp_slope`.\n\n**Specific Requests for the Assistant:**\n\n1.  **Parametric OpenSCAD File:** Please provide a fully parametric `.scad` file that includes the parameters and features described above.\n2.  **Parameter Control:** Use variables for all dimensions such as `ramp_width`, `wall_thickness`, `ramp_slope`, `exit_ramp_slope`, `overhang_amount`, `number_of_levels`, `tray_width`, `tray_depth`, `tray_wall_height`, `tray_corner_radius`, etc., so that they can be easily modified in the customizer.\n3.  **Modular Design:** The code should be modular, separating ramp creation, the funnel, and the dice tray into reusable modules.\n4.  **Clear Code:** The code should be well-commented and easy to read.\n5.  **Library Dependencies:** Please make sure to use a standard library such as BOSL2 to make the code more robust and flexible where appropriate.\n\nMy current `.scad` code is provided above. I'm looking forward to seeing how you can make it much more customizable. Thanks!\n"
  },
  {
    "object": "Hey cadmonkey, make me a Buckle Box, Printable In One Piece",
    "scad": "$fn = 100;\nwidth = 40;\ndepth = 40;\nheight = 15;\nwallThickness = 1.5;\nhingeOuter = 6;\nhingeInner = 3;\nhingeInnerSlop = .4;\nhingeFingerSlop = .4;\nfingerLength = hingeOuter/1.65;\nfingerSize = 6.8;\ntopFingerSize = fingerSize;\nlatchWidth = 15;\nbottom();\ntop();\nbottomLatch();\nmodule bottom() {\n\tunion() {\n\t\tdifference() {\n\t\t\ttranslate([-width - fingerLength, -depth/2, 0]) {\n\t\t\t\tcube([width,depth,height]);\n\t\t\t}\n\t\t\ttranslate([(-width - fingerLength) + wallThickness, -depth/2 + wallThickness, wallThickness]) {\n\t\t\t\tcube([width - (wallThickness * 2), depth - (wallThickness * 2), height]);\n\t\t\t}\n\t\t}\n\t\tdifference() {\n\t\thull() {\n\t\t\t\ttranslate([-(fingerLength*2) - width,-latchWidth,height-2.25]) {\n\t\t\t\t\trotate([-90,0,0]) {\n\t\t\t\t\t\tcylinder(r = hingeOuter/2, h = latchWidth*2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttranslate([-width - fingerLength, -latchWidth, height-hingeOuter-2.25]) {\n\t\t\t\t\tcube([.1, latchWidth * 2, hingeOuter]);\n\t\t\t\t}\n\t\t\t\ttranslate([-(fingerLength*2) -width, -latchWidth,height-2.25]){\n\t\t\t\t\t\tcube([fingerLength,latchWidth * 2,.1]);\n\t\t\t\t\t}\n\t\t\t\t\ttranslate([-(fingerLength*2) -width, -latchWidth,height-2.25]){\n\t\t\t\t\t\trotate([0,-20,0]) {\n\t\t\t\t\t\t\tcube([hingeOuter-wallThickness,latchWidth*2,.01]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([-(fingerLength*3) - width, -(latchWidth/2) - (hingeFingerSlop/2),0]) {\n\t\t\t\t\tcube([fingerLength*3, latchWidth + hingeFingerSlop,height*2]);\n\t\t\t}\n\t\t}\n\t\ttranslate([-(fingerLength*2) -width, -latchWidth/2 - hingeFingerSlop, height-2.25]) {\n\t\t\trotate([-90,0,0]) {\n\t\t\t\tcylinder(r = hingeInner /2, h = latchWidth + (hingeFingerSlop*2));\n\t\t\t}\n\t\t}\n\t\tdifference() {\n\t\t\thull() {\n\t\t\t\ttranslate([0,-depth/2,height]) {\n\t\t\t\t\trotate([-90,0,0]) {\n\t\t\t\t\t\tcylinder(r = hingeOuter/2, h = depth);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttranslate([-fingerLength - .1, -depth/2,height - hingeOuter]){\n\t\t\t\t\tcube([.1,depth,hingeOuter]);\n\t\t\t\t}\n\t\t\t\ttranslate([-fingerLength, -depth/2,height-.1]){\n\t\t\t\t\tcube([fingerLength,depth,.1]);\n\t\t\t\t}\n\t\t\t\ttranslate([0, -depth/2,height]){\n\t\t\t\t\trotate([0,45,0]) {\n\t\t\t\t\t\tcube([hingeOuter/2,depth,.01]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor  (i = [-depth/2 + fingerSize:fingerSize*2:depth/2]) {\n\t\t\t\ttranslate([-fingerLength,i - (fingerSize/2) - (hingeFingerSlop/2),0]) {\n\t\t\t\t\tcube([fingerLength*2,fingerSize + hingeFingerSlop,height*2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate([0, -depth/2, height]) {\n\t\t\trotate([-90,0,0]) {\n\t\t\t\tcylinder(r = hingeInner /2, h = depth);\n\t\t\t}\n\t\t}\n\t}\n}\nmodule top() {\n\tunion() {\n\t\tdifference() {\n\t\t\ttranslate([fingerLength, -depth/2, 0]) {\n\t\t\t\tcube([width,depth,height - .5]);\n\t\t\t}\n\t\t\ttranslate([fingerLength + wallThickness, -depth/2 + wallThickness, wallThickness]) {\n\t\t\t\tcube([width - (wallThickness * 2), depth - (wallThickness * 2), height]);\n\t\t\t}\n\t\t}\n\t\tdifference() {\n\t\t\thull() {\n\t\t\t\t\ttranslate([(fingerLength*2) + width,-latchWidth,height/2]) {\n\t\t\t\t\t\trotate([-90,0,0]) {\n\t\t\t\t\t\t\tcylinder(r = hingeOuter/2, h = latchWidth*2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttranslate([width + fingerLength, -latchWidth, 0]) {\n\t\t\t\t\t\tcube([.1, latchWidth * 2, hingeOuter]);\n\t\t\t\t\t}\n\t\t\t\t\ttranslate([fingerLength + width, -latchWidth,height/2]){\n\t\t\t\t\t\tcube([fingerLength,latchWidth * 2,.1]);\n\t\t\t\t\t}\n\t\t\t\t\ttranslate([fingerLength + width, -latchWidth,(height/2) + (hingeOuter/1.5)]){\n\t\t\t\t\t\trotate([0,45,0]) {\n\t\t\t\t\t\t\tcube([hingeOuter,latchWidth*2,.01]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([fingerLength + width, -(latchWidth/2) - (hingeFingerSlop/2),0]) {\n\t\t\t\t\tcube([fingerLength*2, latchWidth + hingeFingerSlop,height*2]);\n\t\t\t}\n\t\t}\n\t\ttranslate([(fingerLength*2) + width, -latchWidth/2 - hingeFingerSlop, height/2]) {\n\t\t\trotate([-90,0,0]) {\n\t\t\t\tcylinder(r = hingeInner /2, h = latchWidth + (hingeFingerSlop*2));\n\t\t\t}\n\t\t}\n\t\tdifference() {\n\t\t\thull() {\n\t\t\t\ttranslate([0,-depth/2,height]) {\n\t\t\t\t\trotate([-90,0,0]) {\n\t\t\t\t\t\tcylinder(r = hingeOuter/2, h = depth);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttranslate([fingerLength, -depth/2,height - hingeOuter - .5]){\n\t\t\t\t\tcube([.1,depth,hingeOuter - .5]);\n\t\t\t\t}\n\t\t\t\ttranslate([-fingerLength/2, -depth/2,height-.1]){\n\t\t\t\t\tcube([fingerLength,depth,.1]);\n\t\t\t\t}\n\t\t\t\ttranslate([0, -depth/2,height]){\n\t\t\t\t\trotate([0,45,0]) {\n\t\t\t\t\t\tcube([hingeOuter/2,depth,.01]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor  (i = [-depth/2:fingerSize*2:depth/2 + fingerSize]) {\n\t\t\t\ttranslate([-fingerLength,i - (fingerSize/2) - (hingeFingerSlop/2),0]) {\n\t\t\t\t\tcube([fingerLength*2,fingerSize + hingeFingerSlop,height*2]);\n\t\t\t\t}\n\t\t\t\tif (depth/2 - i < (fingerSize * 1.5)) {\n\t\t\t\t\ttranslate([-fingerLength,i - (fingerSize/2) - (hingeFingerSlop/2),0]) {\n\t\t\t\t\t\tcube([fingerLength*2,depth,height*2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([0, -depth/2, height]) {\n\t\t\t\trotate([-90,0,0]) {\n\t\t\t\t\tcylinder(r = hingeInner /2 + hingeInnerSlop, h = depth);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nmodule bottomLatch() {\n\tdifference() {\n\t\tunion() {\n\t\t\thull() {\n\t\t\t\ttranslate([-(fingerLength *2) - width,-latchWidth/2,height-2.25]) {\n\t\t\t\t\trotate([-90,0,0]) {\n\t\t\t\t\t\tcylinder( r = hingeOuter /2, h = latchWidth);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttranslate([-fingerLength*2 - width,-latchWidth/2,height-hingeOuter-2.25]) {\n\t\t\t\t\trotate([0,20,0]) {\n\t\t\t\t\t\tcube([.1,latchWidth,hingeOuter]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttranslate([-fingerLength*2 - width -2.6 + hingeOuter/2 - wallThickness,-latchWidth/2,0]) {\n\t\t\t\tcube([2.5,latchWidth,height-4.5]);\n\t\t\t}\n\t\t\ttranslate([-fingerLength*3 - width - 2.6,-latchWidth/2,0]) {\n\t\t\t\tcube([hingeOuter/2 + fingerLength,latchWidth,wallThickness]);\n\t\t\t}\n\t\t\ttranslate([-fingerLength*3 - width + 1 - 2.6,-latchWidth/2,wallThickness]) {\n\t\t\t\trotate([-90,0,0]) {\n\t\t\t\t\tcylinder(r = 1, h = latchWidth);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttranslate([-(fingerLength *2) - width,-latchWidth/2 - .1,height-2.25]) {\n\t\t\trotate([-90,0,0]) {\n\t\t\t\tcylinder( r = hingeInner /2 + hingeInnerSlop, h = latchWidth + .2);\n\t\t\t}\n\t\t}\n\t}\n}",
    "description": 