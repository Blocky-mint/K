{
  "model_name": "ThomasTheMaker/k-1b",
  "timestamp": "2025-10-29T13:16:50.663559",
  "date": "2025-10-29",
  "time": "13:16:50",
  "total_tests": 282,
  "completed_tests": 282,
  "code_extraction_success": 282,
  "code_extraction_rate": "100.0%",
  "render_success": 239,
  "render_success_rate": "84.8%",
  "visual_similarity_success": 99,
  "visual_similarity_rate": "35.1%",
  "average_tokens_generated": "55",
  "results": [
    {
      "object": "cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 18,
      "code": "module box(width, depth, height) {\n  cube([width, depth, height]);\n}\n\nbox(10, 5, 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "cylinder",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 37,
      "code": "module arch(width, height, depth, radius, angle) {\n  difference() {\n    linear_extrude(height = height) {\n      polygon(points = [\n        [0, 0],\n        [width, 0],\n        [width, depth],\n        [0, depth]\n      ]);\n    }\n    translate([0, -width/2, 0]) {\n      rotate([0, angle, 0]) {\n        linear_extrude(height = height) {\n          polygon(points = [\n            [0, 0],\n            [width, 0],\n            [width, depth],\n            [0, depth]\n          ]);\n        }\n      }\n    }\n  }\n}\n\narch(width = 50, height = 30, depth = 20, radius = 10, angle = 15);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "sphere",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 48,
      "code": "module pentagon(radius) {\n  linear_extrude(height = 1) {\n    polygon(points = [\n      [radius * cos(0), radius * sin(0)],\n      [radius * cos(36), radius * sin(36)],\n      [radius * cos(72), radius * sin(72)],\n      [radius * cos(108), radius * sin(108)],\n      [radius * cos(144), radius * sin(144)]\n    ]);\n  }\n}\n\npentagon(radius = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "cone",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 64,
      "code": "module hemisphere(r) {\n  linear_extrude(height = r) {\n    circle(r);\n  }\n}\n\nhemisphere(r = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "pyramid",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 86,
      "code": "module pentagon(radius, height) {\n  linear_extrude(height = height)\n    polygon(points = [\n      [radius * cos(360 / 5), radius * sin(360 / 5)],\n      [radius * cos(360 / 5), radius * sin(360 / 5 + 360 / 5)],\n      [radius * cos(360 / 5 + 360 / 5), radius * sin(360 / 5 + 360 / 5)],\n      [radius * cos(360 / 5 + 360 / 5 + 360 / 5), radius * sin(360 / 5 + 360 / 5 + 360 / 5)],\n      [radius * cos(360 / 5 + 360 / 5 + 360 / 5 + 360 / 5 + 360 / 5)],\n      [radius * cos(360 / 5 + 360 / 5 + 360 / 5 + 360 / 5 + 360 / 5 + 360 / 5 + 360 / 5]],\n      [0, -radius])\n}\n\npentagon(radius = 10, height = 2);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: Parser error: syntax error in file evaluation/ThomasTheMaker_k-1b_20251029_131650/pyramid.scad, line 9\nCan't parse file 'evaluation/ThomasTheMaker_k-1b_20251029_131650/pyramid.scad'!\n\n",
      "vlm_response": null
    },
    {
      "object": "torus",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 41,
      "code": "module ring(radius, thickness, hole_radius) {\n  difference() {\n    cylinder(h = thickness, r = radius, $fn = 64);\n    cylinder(h = thickness + 0.1, r = hole_radius, $fn = 64);\n  }\n}\n\nring(radius = 10, thickness = 2, hole_radius = 5);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "tetrahedron",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 57,
      "code": "module pyramid(base_width, base_depth, base_height, side_length) {\n  linear_extrude(height = side_length) {\n    polygon(points=[\n      [0, 0],\n      [base_width / 2, base_height * side_length],\n      [base_width, base_height * side_length],\n      [base_width / 2, base_height * side_length],\n      [0, base_height * side_length]\n    ]);\n  }\n}\n\npyramid(base_width = 50, base_depth = 30, base_height = 40, side_length = 100);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "octahedron",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 3,
      "code": "module hexagon(size) {\n  linear_extrude(height = size) {\n    polygon(points=[\n      [size, 0],\n      [size * cos(60), size * sin(60)],\n      [size * cos(120), size * sin(120)],\n      [size * cos(180), size * sin(180)],\n      [size * cos(240), size * sin(240)],\n      [size * cos(300), size * sin(300)]\n    ]);\n  }\n}\n\nhexagon(size = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "heptagon",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 65,
      "code": "module hexagon(size) {\n  linear_extrude(height = size) {\n    polygon(points = [\n      [size, 0],\n      [size * cos(30), size * sin(30)],\n      [size * cos(60), size * sin(60)],\n      [size * cos(90), size * sin(90)],\n      [size * cos(120), size * sin(120)],\n      [size * cos(150), size * sin(150)]\n    ]);\n  }\n}\n\nhexagon(size = 20);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "pentagon",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 20,
      "code": "// Stop sign in OpenSCAD\n\n// Parameters\nradius = 40;\nthickness = 2;\nfont_size = 30;\nfont_height = 40;\n\n// Stop sign body\ndifference() {\n  cylinder(h = thickness, r = radius, $fn = 50);\n  translate([0,0,-0.1])\n    cylinder(h = thickness + 0.2, r = radius - 2, $fn = 50);\n}\n\n// Stop sign letters\ndifference() {\n  linear_extrude(height = thickness, $fn = 30)\n    for (i = [0:1]) {\n      rotate([0,0,i*360/2])\n        translate([radius,0,0])\n          linear_extrude(height = thickness, $fn = 30)\n            text(i,0, font_height);\n    }\n  linear_extrude(height = thickness, $fn = 30)\n    for (i = [0:1]) {\n      rotate([0,0,i*360/2])\n        translate([radius,0,0])\n          linear_extrude(height = thickness, $fn = 30)\n            text(i,0, font_height);\n    }\n}\n\n// Stop sign text\ndifference() {\n  linear_extrude(height = thickness, $fn = 30)\n    for (i = [0:1]) {\n      rotate([0,0,i*360/2])\n        translate([radius,0,0])\n          linear_extrude(height = thickness, $fn = 30)\n            text(i,0, font_height);\n    }\n  linear_extrude(height = thickness, $fn = 30)\n    for (i = [0:1]) {\n      rotate([0,0,i*360/2])\n        translate([radius,0,0])\n          linear_extrude(height = thickness, $fn = 30)\n            text(i,0, font_height);\n    }\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "hexagon",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 74,
      "code": "module hexagon(size) {\n  linear_extrude(height = size) {\n    polygon(points = [\n      [size * cos(60), size * sin(60)],\n      [size * cos(120), size * sin(120)],\n      [size * cos(180), size * sin(180)],\n      [size * cos(240), size * sin(240)],\n      [size * cos(300), size * sin(300)],\n      [size * cos(360), size * sin(360)]\n    ]);\n  }\n\n  difference() {\n    linear_extrude(height = size) {\n      polygon(points = [\n        [size * cos(60), size * sin(60)],\n        [size * cos(120), size * sin(120)],\n        [size * cos(180), size * sin(180)],\n        [size * cos(240), size * sin(240)],\n        [size * cos(300), size * sin(300)],\n        [size * cos(360), size * sin(360)]\n      ]);\n    }\n  }\n}\n\nhexagon(size = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "octagon",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 67,
      "code": "module octagon(radius, height) {\n  difference() {\n    for (i = [0:7]) {\n      angle = i * 360 / 8;\n      rotate([0, 0, angle]) {\n        translate([radius * cos(angle), radius * sin(angle), 0]) {\n          cube([radius * 1.5, radius * 1.5, height], center = true);\n        }\n      }\n    }\n  }\n}\n\noctagon(radius = 10, height = 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "triangular prism",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 30,
      "code": "module pentagon(size) {\n  polygon(points = [\n    [size * cos(0), size * sin(0)],\n    [size * cos(36), size * sin(36)],\n    [size * cos(72), size * sin(72)],\n    [size * cos(108), size * sin(108)],\n    [size * cos(144), size * sin(144)]\n  ]);\n}\n\npentagon(size = 20);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: Geometries in cache: 1\nGeometry cache size in bytes: 160\nCGAL Polyhedrons in cache: 0\nCGAL cache size in bytes: 0\nTotal rendering time: 0:00:00.000\n   Top level object is a 2D object:\n   Contours:    ",
      "vlm_response": null
    },
    {
      "object": "nonagon",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 49,
      "code": "module octagon(radius) {\n  linear_extrude(height = 1)\n    polygon(points = [\n      [radius, 0],\n      [radius * cos(45), radius * sin(45)],\n      [radius * cos(90), radius * sin(90)],\n      [radius * cos(135), radius * sin(135)],\n      [radius * cos(180), radius * sin(180)],\n      [radius * cos(225), radius * sin(225)],\n      [radius * cos(270), radius * sin(270)],\n      [radius * cos(315), radius * sin(315)]\n    ]);\n}\n\noctagon(radius = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "dodecagon",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 76,
      "code": "module hexagon(size) {\n  linear_extrude(height = size)\n  polygon(points = [\n    [size, 0],\n    [size * cos(60), size * sin(60)],\n    [size * cos(120), size * sin(120)],\n    [size * cos(180), size * sin(180)],\n    [size * cos(240), size * sin(240)],\n    [size * cos(300), size * sin(300)]\n  ]);\n}\n\nhexagon(size = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "decagon",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 75,
      "code": "module hexagon(size) {\n  linear_extrude(height = size)\n  polygon(points = [\n    [size * cos(30), size * sin(30)],\n    [size * cos(60), size * sin(60)],\n    [size * cos(90), size * sin(90)],\n    [size * cos(120), size * sin(120)],\n    [size * cos(150), size * sin(150)],\n    [size * cos(180), size * sin(180)],\n    [size * cos(210), size * sin(210)]\n  ]);\n}\n\nhexagon(size = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "pentagonal prism",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 16,
      "code": "module pentagon(size = 10) {\n  linear_extrude(height = 1)\n  polygon(points = [\n    [size * cos(0), size * sin(0)],\n    [size * cos(360), size * sin(360)],\n    [size * cos(720), size * sin(720)],\n    [size * cos(1080), size * sin(1080)],\n    [size * cos(1440), size * sin(1440)]\n  ]);\n}\n\npentagon(size = 20);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: Geometries in cache: 2\nGeometry cache size in bytes: 48\nCGAL Polyhedrons in cache: 0\nCGAL cache size in bytes: 0\nTotal rendering time: 0:00:00.000\nCurrent top level object is empty.\n",
      "vlm_response": null
    },
    {
      "object": "square prism",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 30,
      "code": "module wedge(width, height, depth, angle) {\n  difference() {\n    cube([width, height, depth]);\n    rotate([0,0,angle])\n    translate([0,0,-depth/2])\n    cube([width, height, depth + depth/2]);\n  }\n}\n\nwedge(width = 50, height = 50, depth = 20, angle = 30);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "rectangular prism",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 70,
      "code": "module prism(width, height, depth, angle) {\n  difference() {\n    cube([width, height, depth]);\n    translate([0, 0, -depth * tan(angle)])\n    rotate([0, 0, angle])\n    cube([width, height, depth + depth * tan(angle)]);\n  }\n}\n\nprism(50, 30, 20, 30);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "hexagonal prism",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 10,
      "code": "module hexagon(size) {\n  polygon(points = [\n    [size * cos(30), size * sin(30)],\n    [size * cos(60), size * sin(60)],\n    [size * cos(90), size * sin(90)],\n    [size * cos(120), size * sin(120)],\n    [size * cos(150), size * sin(150)],\n    [size * cos(180), size * sin(180)]\n  ]);\n}\n\nlinear_extrude(height = 1) hexagon(size = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "box",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 42,
      "code": "module box(width, depth, height) {\n  cube([width, depth, height]);\n}\n\nbox(10, 5, 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "tall box",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 53,
      "code": "// Rack Parameters\nrack_width = 1000;  // Rack width in millimeters\nrack_height = 2000; // Rack height in millimeters\nrack_depth = 300;   // Rack depth in millimeters\nmounting_rail_thickness = 25;\npost_width = 30;\npost_height = 300;\npost_spacing = 45;\nhole_diameter = 5;\n\nmodule rack() {\n  difference() {\n    cube([rack_width, rack_height, rack_depth]);\n\n    // Cut out space for mounting\n    translate([0, 0, -0.1]) {\n        cube([rack_width, rack_height, rack_depth + 0.2]);\n    }\n  }\n\n  // Mounting Posts\n  translate([0, rack_height, 0]) {\n    cube([post_width, post_height, post_spacing]);\n  }\n\n  translate([rack_width - post_width, rack_height, 0]) {\n    cube([post_width, post_height, post_spacing]);\n  }\n}\n\nrack();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "wide box",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 45,
      "code": "module panel(width, height, depth, hole_diameter, hole_x, hole_y) {\n  difference() {\n    cube([width, height, depth]);\n    if (hole_diameter > 0) {\n      translate([hole_x, hole_y, -0.1])\n        cylinder(h = depth + 0.2, r = hole_diameter / 2, $fn = 30);\n    }\n  }\n}\n\npanel(width = 100, height = 50, depth = 20, hole_diameter = 5, hole_x = 25, hole_y = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "box with rounded corners",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 33,
      "code": "module rounded_cube(size, radius) {\n  difference() {\n    cube([size[0], size[1], size[2]]);\n    for (i = [-1, 1]) {\n      for (j = [-1, 1]) {\n        translate([i * size[0] / 2, j * size[1] / 2, 0]) {\n          cylinder(r = radius, h = size[2], $fn = 32);\n        }\n      }\n    }\n  }\n}\n\n// Example usage:\n//size = 50;\n//radius = 10;\nrounded_cube(size = size, radius = radius);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "thin box",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 78,
      "code": "module divider(width, height, thickness, holes_radius, holes_count) {\n  difference() {\n    cube([width, height, thickness]);\n    for (i = [0:holes_count - 1]) {\n      translate([width * (i / holes_count) - width / 2, 0, 0]) {\n        cylinder(r = holes_radius, h = thickness, $fn = 32);\n      }\n    }\n  }\n}\n\n// Example usage:\nwidth = 100;\nheight = 50;\nthickness = 5;\nholes_radius = 5;\nholes_count = 10;\n\ndivider(width, height, thickness, holes_radius, holes_count);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "hollow box",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 41,
      "code": "// Vault Parameters\nvault_width = 40;\nvault_depth = 30;\nvault_height = 50;\nwall_thickness = 2;\ndoor_width = 15;\ndoor_height = 20;\ndoor_x_offset = 10;\ndoor_y_offset = 10;\n\nmodule vault_body() {\n  difference() {\n    cube([vault_width, vault_depth, vault_height]);\n    translate([wall_thickness, wall_thickness, 0])\n    cube([vault_width - 2 * wall_thickness, vault_depth - 2 * wall_thickness, vault_height]);\n  }\n}\n\nmodule door() {\n  cube([door_width, vault_depth, door_height]);\n}\n\nmodule door_cutout() {\n  translate([door_x_offset, vault_depth/2 - door_width/2, door_height/2]) {\n    cube([door_width, door_width, door_height]);\n  }\n}\n\ndifference() {\n  vault_body();\n  door_cutout();\n  translate([0,0,-1]) door_cutout();\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "tall cylinder",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 90,
      "code": "module helix(radius, height, turns, segments) {\n  rotate_extrude(convexity = 10, $fn = segments)\n  translate([radius * cos(360 / turns), radius * sin(360 / turns), height * sin(360 / turns)])\n  circle(r = radius);\n}\n\nhelix(radius = 10, height = 20, turns = 10, segments = 60);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: all points for rotate_extrude() must have the same X coordinate sign (range is -0.57 -> 18.09)\nGeometries in cache: 3\nGeometry cache size in bytes: 2080\nCGAL Polyhedrons in cache: 0\nCGAL cache ",
      "vlm_response": null
    },
    {
      "object": "short cylinder",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 67,
      "code": "module pillar(height, width, depth, segments = 36) {\n  difference() {\n    cube([width, depth, height]);\n    translate([width/4, depth/4, height/4])\n    cylinder(h=height/4, r=width/8, $fn=segments);\n  }\n}\n\npillar(height=50, width=10, depth=5, segments=36);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "thick cylinder",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 53,
      "code": "// Pipe parameters\nradius = 10;\nheight = 20;\nsegments = 64;\n\ndifference() {\n  cylinder(h = height, r = radius, $fn = segments);\n  translate([0,0,-0.1]) cylinder(h = height + 0.2, r = radius - 1, $fn = segments);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "box with holes",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 52,
      "code": "module shell_generator(width, height, depth, wall_thickness, hole_diameter, hole_spacing) {\n  difference() {\n    cube([width, height, depth]);\n    for (i = [0:hole_spacing]) {\n      translate([width * i, height * i, depth * i]) {\n        cylinder(h = depth, r = hole_diameter / 2, $fn = 48);\n      }\n    }\n  }\n}\n\nshell_generator(width = 50, height = 30, depth = 10, wall_thickness = 2, hole_diameter = 10, hole_spacing = 15);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "thin cylinder",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 14,
      "code": "module tube(radius, height, segments) {\n  cylinder(r = radius, h = height, $fn = segments);\n}\n\ntube(radius = 10, height = 20, segments = 64);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "star",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 57,
      "code": "module cone(h, r1, r2, $fn=64) {\n  linear_extrude(height = h, convexity = 10) {\n    rotate_extrude(angle = 180, $fn = $fn) {\n      translate([r1, 0, 0]) circle(r = r2);\n    }\n  }\n}\n\ncone(h=10, r1=5, r2=0);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: Geometries in cache: 4\nGeometry cache size in bytes: 48\nCGAL Polyhedrons in cache: 0\nCGAL cache size in bytes: 0\nTotal rendering time: 0:00:00.000\nCurrent top level object is empty.\n",
      "vlm_response": null
    },
    {
      "object": "6-pointed star",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 58,
      "code": "module pentagon(radius, size) {\n  linear_extrude(height = 1)\n  polygon(points = [\n    [radius * cos(360 / size), radius * sin(360 / size)],\n    [radius * cos(360 / size), radius * sin(360 / size)],\n    [radius * cos(360 / size), radius * sin(360 / size)],\n    [radius * cos(360 / size), radius * sin(360 / size)],\n    [radius * cos(360 / size), radius * sin(360 / size)]\n  ]);\n}\n\npentagon(radius = 10, size = 10);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: Geometries in cache: 2\nGeometry cache size in bytes: 48\nCGAL Polyhedrons in cache: 0\nCGAL cache size in bytes: 0\nTotal rendering time: 0:00:00.000\nCurrent top level object is empty.\n",
      "vlm_response": null
    },
    {
      "object": "cone",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 76,
      "code": "module hemisphere(r) {\n  linear_extrude(height = r) {\n    circle(r);\n  }\n}\n\n// Example usage:\nhemisphere(r = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "five-pointed star",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 61,
      "code": "module pentagon(size) {\n  linear_extrude(height = 1)\n  polygon(points = [\n    [size * cos(360 / (5 * 72.25)), size * sin(360 / (5 * 72.25))],\n    [size * cos(360 / (5 * 72.25)), size * sin(360 / (5 * 72.25))],\n    [size * cos(360 / (5 * 72.25)), size * sin(360 / (5 * 72.25))],\n    [size * cos(360 / (5 * 72.25)), size * sin(360 / (5 * 72.25))],\n    [size * cos(360 / (5 * 72.25)), size * sin(360 / (5 * 72.25)) ]\n  ]);\n}\n\npentagon(size = 10);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: Geometries in cache: 2\nGeometry cache size in bytes: 48\nCGAL Polyhedrons in cache: 0\nCGAL cache size in bytes: 0\nTotal rendering time: 0:00:00.000\nCurrent top level object is empty.\n",
      "vlm_response": null
    },
    {
      "object": "8-pointed star",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 99,
      "code": "module pentagon(size) {\n  linear_extrude(height = 1)\n  polygon(points=[\n    [size * cos(0), size * sin(0)],\n    [size * cos(36), size * sin(36)],\n    [size * cos(72), size * sin(72)],\n    [size * cos(108), size * sin(108)],\n    [size * cos(144), size * sin(144)],\n    [size * cos(180), size * sin(180)],\n    [size * cos(216), size * sin(216)]\n  ]);\n}\n\npentagon(size = 20);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "donut",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 96,
      "code": "module torus(r = 1, $fn = 50) {\n  rotate_extrude(f\u73af)\n    circle(r = r);\n}\n\ntorus(r = 1);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: Parser error: syntax error in file evaluation/ThomasTheMaker_k-1b_20251029_131650/donut.scad, line 2\nCan't parse file 'evaluation/ThomasTheMaker_k-1b_20251029_131650/donut.scad'!\n\n",
      "vlm_response": null
    },
    {
      "object": "crescent",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 75,
      "code": "module ring(radius, thickness, inner_radius) {\n  difference() {\n    cylinder(h = thickness, r = radius, $fn = 100);\n    cylinder(h = thickness + 0.1, r = inner_radius, $fn = 100);\n  }\n}\n\nring(radius = 20, thickness = 3, inner_radius = 15);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "cube with spheres",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 52,
      "code": "module hemisphere(r) {\n  rotate_extrude(convexity = 10)\n    circle(r = r);\n}\n\nhemisphere(r = 10);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: all points for rotate_extrude() must have the same X coordinate sign (range is -1.05 -> 10.00)\nGeometries in cache: 2\nGeometry cache size in bytes: 560\nCGAL Polyhedrons in cache: 0\nCGAL cache s",
      "vlm_response": null
    },
    {
      "object": "cube with hole",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 93,
      "code": "module crossbar(width, height, depth, bar_width, bar_height, spacing) {\n  difference() {\n    cube([width, height, depth]);\n\n    // Cut out the space for the bars\n    for (i = [0:3]) {\n      for (j = [0:3]) {\n        translate([width / 2 - (i + j) * (width / 2) - spacing, height / 2 - (j + i) * (height / 2) - spacing, depth / 2 - spacing])\n        cube([bar_width, bar_height, depth]);\n      }\n    }\n  }\n}\n\ncrossbar(width = 50, height = 30, depth = 20, bar_width = 10, bar_height = 5, spacing = 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "sphere with hole",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 51,
      "code": "module hemisphere(r) {\n  linear_extrude(height = r) {\n    circle(r);\n  }\n}\n\nhemisphere(r = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "interlocking cubes",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 8,
      "code": "module box(width, height, depth, corner_radius) {\n  difference() {\n    cube([width, height, depth]);\n    translate([corner_radius, corner_radius, 0])\n      cube([width - 2 * corner_radius, height - 2 * corner_radius, depth]);\n  }\n}\n\nbox(100, 50, 20, 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "sierpinski pyramid",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 47,
      "code": "module spider(width, height, depth, leg_count, leg_length, body_radius, body_height, body_depth, body_radius_offset) {\n  difference() {\n    union() {\n      // Body\n      cylinder(h = body_height, r = body_radius, $fn = 32);\n\n      // Legs\n      for (i = [0:leg_count - 1]) {\n        translate([body_radius + body_radius_offset * i, 0, 0]) {\n          cylinder(h = leg_length, r = body_radius, $fn = 32);\n        }\n      }\n\n      // Eyes\n      translate([body_radius * 0.8, 0, 0]) {\n        sphere(r = body_radius * 0.1);\n      }\n      translate([-body_radius * 0.8, 0, 0]) {\n        sphere(r = body_radius * 0.1);\n      }\n\n      //Antennae (simplified)\n      translate([body_radius * 0.6, body_radius * 0.7, body_height * 0.3]) {\n          cylinder(h = 2, r = 0.3);\n      }\n    }\n  }\n\n  spider(width = 50, height = 30, depth = 20, leg_count = 8, leg_length = 25, body_radius = 15, body_height = 8, body_depth = 10, body_radius_offset = 1, antennae_length = 4, antenna_radius = 0.4);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: Parser error: syntax error in file evaluation/ThomasTheMaker_k-1b_20251029_131650/sierpinski_pyramid.scad, line 31\nCan't parse file 'evaluation/ThomasTheMaker_k-1b_20251029_131650/sierpinski_py",
      "vlm_response": null
    },
    {
      "object": "flower",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 32,
      "code": "// Butterfly parameters\nbody_width = 15;\nbody_height = 20;\nwing_width = 25;\nwing_height = 30;\nwing_depth = 5;\nbody_curve_radius = 5;\nwing_curve_radius = 6;\n\nmodule butterfly() {\n  difference() {\n    union() {\n      // Body\n      translate([0, 0, -body_height/2])\n      sphere(body_width/2);\n\n      // Wings\n      translate([-body_width/2, 0, 0])\n      rotate([0, 0, 45])\n      linear_extrude(height = wing_width)\n      polygon(points=[[0, 0], [wing_width/2, wing_height], [wing_width, 0], [wing_width, wing_height]]);\n      \n      translate([-body_width/2, 0, 0])\n      rotate([0, 0, -45])\n      linear_extrude(height = wing_width)\n      polygon(points=[[0, 0], [wing_width/2, wing_height], [wing_width, 0], [wing_width, wing_height]]);\n    }\n    \n    // Cutout for body\n    translate([0, 0, -body_height])\n    sphere(body_width/2);\n\n    // Cutout for body curve\n    translate([0, 0, -body_height/2 - body_curve_radius])\n    sphere(body_width/2 - body_curve_radius * 2);\n  }\n}\n\nbutterfly();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "flower with petals",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 93,
      "code": "// Butterfly Design in OpenSCAD\n\n// Parameters\nwing_width = 30;\nwing_height = 20;\nbody_width = 25;\nbody_height = 20;\nbody_depth = 10;\nwing_offset = 10;\nbody_color = [1, 0.9, 0]; // Light blue\nbody_curve_radius = 3;\n\nmodule wing(width, height, offset) {\n  linear_extrude(height = height) {\n    difference() {\n      polygon(points=[\n        [0, 0],\n        [width / 2, 0],\n        [width / 2, height],\n        [0, height]\n      ]);\n      translate([offset, 0, 0]) {\n        rotate([90, 0, 0])\n        cube([width, height, 1], center = true);\n      }\n    }\n  }\n}\n\nmodule body() {\n  difference() {\n    cylinder(h = body_height, r = body_width / 2, $fn = 50);\n    translate([0, -1, 0]) {\n      cylinder(h = body_height + 1, r = body_width / 2, $fn = 50);\n    }\n  }\n}\n\nmodule body_curve() {\n  translate([0, 0, body_height / 2]) {\n    rotate([0, 0, 45]) {\n        scale([1, 1, 0.8]) {\n            translate([0,0,0]) {\n                linear_extrude(height = 1, $fn = 50) {\n                    polygon(points=[\n                        [0, body_curve_radius],\n                        [body_width / 2, body_curve_radius],\n                        [body_width / 2, body_curve_radius],\n                        [0, body_curve_radius]\n                    ]);\n                }\n            }\n        }\n    }\n  }\n}\n\n// Main assembly\ndifference() {\n    body();\n    translate([0, 0, body_height/2]) {\n        rotate([90,0,0]) body_curve();\n    }\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "spiral",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 2,
      "code": "module helix(radius, height, turns, segments) {\n  linear_extrude(height = height)\n  for (i = [0:turns-1]) {\n    angle = i * 360 / turns;\n    rotate([0, 0, angle])\n    translate([radius * cos(angle), radius * sin(angle), 0])\n    circle(r = radius);\n  }\n}\n\nhelix(radius = 10, height = 20, turns = 5, segments = 60);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "gear",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 35,
      "code": "// Bearing Parameters\ninner_diameter = 10;\nouter_diameter = 20;\nbearing_width = 15;\nball_diameter = 5;\nnum_balls = 12;\n\n// Calculate ball radii\nball_radius = ball_diameter / 2;\n\n// Bearing Inner Ring\ndifference() {\n  cylinder(h = bearing_width, r = outer_diameter / 2, center = false);\n  cylinder(h = bearing_width, r = inner_diameter / 2, center = false);\n}\n\n// Bearing Outer Ring\ndifference() {\n  cylinder(h = bearing_width, r = outer_diameter / 2, center = false);\n  cylinder(h = bearing_width, r = outer_diameter / 2, center = false);\n}\n\n// Balls\nfor (i = [0:num_balls - 1]) {\n  angle = i * 360 / num_balls;\n  rotate([0, 0, angle]) {\n    translate([outer_diameter / 2 - ball_radius, 0, 0]) {\n      sphere(r = ball_radius);\n    }\n  }\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "helix",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 52,
      "code": "module helix(height, radius, turns, segments) {\n  rotate_extrude(convexity = 10)\n  translate([0, 0, height/segments])\n  circle(r = radius);\n}\n\nhelix(height = 20, radius = 10, turns = 5, segments = 100);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: all points for rotate_extrude() must have the same X coordinate sign (range is -1.05 -> 10.00)\nGeometries in cache: 3\nGeometry cache size in bytes: 1120\nCGAL Polyhedrons in cache: 0\nCGAL cache ",
      "vlm_response": null
    },
    {
      "object": "ripple",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 72,
      "code": "module wave(amplitude, wavelength, height, resolution = 100) {\n  rotate_extrude(angle = 180)\n    translate([0,0,-amplitude/2])\n      circle(r = amplitude/2);\n}\n\nlinear_extrude(height = 10, convexity = 10, slices = 100)\nwave(amplitude = 10, wavelength = 100, height = 10);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: all points for rotate_extrude() must have the same X coordinate sign (range is -1.91 -> 5.00)\nGeometries in cache: 4\nGeometry cache size in bytes: 672\nCGAL Polyhedrons in cache: 0\nCGAL cache si",
      "vlm_response": null
    },
    {
      "object": "wave",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 46,
      "code": "module wave(height, width, thickness, detail) {\n  difference() {\n    hull() {\n      translate([0,0,0]) cube([width, width, height]);\n      translate([width/4, 0, 0]) rotate([0,0,45]) cube([width/4, width/4, height]);\n    }\n    \n    for (i = [0:detail]) {\n      rotate([0,0,i*360/detail])\n        translate([width/4, width/4, height * i / detail])\n          cube([width/4, width/4, height * i / detail]);\n    }\n  }\n}\n\nwave(height = 10, width = 50, thickness = 5, detail = 20);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "bracket",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 31,
      "code": "module beam(length, width, height, fillet_radius) {\n  difference() {\n    cube([length, width, height]);\n    translate([fillet_radius, fillet_radius, fillet_radius])\n      cube([length - 2 * fillet_radius, width - 2 * fillet_radius, height - 2 * fillet_radius]);\n  }\n}\n\nbeam(length = 100, width = 20, height = 10, fillet_radius = 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "clamp",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 14,
      "code": "module clamp(width, height, depth, hole_diameter, hole_distance) {\n  difference() {\n    cube([width, height, depth]);\n    translate([hole_distance, hole_distance, -0.1])\n      cylinder(h=depth + 0.2, r=hole_diameter / 2, $fn=64);\n  }\n}\n\nclamp(width=50, height=20, depth=10, hole_diameter=3, hole_distance=5);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "hinge",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 99,
      "code": "module clip(width, height, thickness, clip_width, clip_height, angle) {\n  difference() {\n    cube([width, height, thickness]);\n    translate([0, 0, -0.1])\n    cube([clip_width, clip_height, thickness + 0.2]);\n  }\n}\n\nclip(width = 50, height = 20, thickness = 2, clip_width = 10, clip_height = 10, angle = 30);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "hook",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 89,
      "code": "// Hook parameters\nhook_length = 50;\nhook_diameter = 10;\nhook_thickness = 2;\nhook_angle = 30;\nwall_thickness = 1;\n\nmodule hook() {\n  difference() {\n    cylinder(h = hook_length, d = hook_diameter, center = false);\n    translate([0, 0, -0.1])\n    rotate([0, 0, hook_angle])\n    cylinder(h = hook_length + 0.2, d = hook_diameter - wall_thickness, center = false);\n  }\n}\n\nhook();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "frustum",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 20,
      "code": "module dome(radius, height, segments = 32) {\n  hull() {\n    for (i = [0:segments]) {\n      angle = i * 360 / segments;\n      rotate([cos(angle), sin(angle), 0]) {\n        translate([radius * cos(angle), radius * sin(angle), 0]) {\n          sphere(r = radius * 0.5, $fn = segments);\n        }\n      }\n    }\n  }\n}\n\ndome(radius = 20, height = 10);",
      "inference_error": null,
      "render_error": "Rendering timeout (>60s)",
      "vlm_response": null
    },
    {
      "object": "ring",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 21,
      "code": "// Washer parameters\nouter_diameter = 50;\ninner_diameter = 20;\nthickness = 5;\n\ndifference() {\n  cylinder(h = thickness, r = outer_diameter / 2, center = false);\n  cylinder(h = thickness, r = inner_diameter / 2, center = false);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "bushing",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 67,
      "code": "// Joint parameters\ninner_diameter = 10;\nouter_diameter = 15;\nheight = 5;\nwall_thickness = 2;\n\n// Calculate radii\ninner_radius = inner_diameter / 2;\nouter_radius = outer_diameter / 2;\n\n// Create the joint\ndifference() {\n  cylinder(h = height, r = outer_radius, center = false);\n  cylinder(h = height, r = inner_radius, center = false);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "spacer",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 36,
      "code": "module separator(width, height, thickness) {\n  difference() {\n    cube([width, height, thickness]);\n    translate([1, 1, 1]) cube([width - 2, height - 2, thickness - 2]);\n  }\n}\n\nseparator(50, 10, 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "washer",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 6,
      "code": "// Screw Parameters\nscrew_diameter = 5;\nscrew_length = 20;\nthread_diameter = 3;\nthread_pitch = 0.8;\nthread_depth = 0.1;\n\n// Screw Body\nmodule screw_body(diameter, length, pitch) {\n  cylinder(h = length, r = diameter / 2, $fn = 32);\n}\n\n// Screw Thread\nmodule screw_thread(diameter, pitch, depth) {\n  linear_extrude(height = depth, convexity = 1)\n  polygon(points=[[0,0], [0, pitch], [0.5, pitch/2], [0.5, -pitch/2]]);\n}\n\n\ndifference() {\n  union() {\n    screw_body(screw_diameter, screw_length, thread_pitch);\n    translate([0, 0, screw_length])\n    cylinder(h = screw_length - 0.1, r = screw_diameter/2, $fn = 32);\n  }\n  translate([0,0,0])\n  rotate([0,0,-45])\n  screw_thread(thread_diameter, thread_pitch, thread_depth);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "letter A",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 84,
      "code": "module arch(width, height, depth, radius, segments = 24) {\n  difference() {\n    cube([width, height, depth]);\n    translate([width/2 - radius, height/2 - radius, depth/2 - radius])\n    rotate([0, 0, 45])\n    cylinder(r=radius, h=height, $fn=segments);\n    translate([0,0,0])\n    rotate([90,0,0])\n    cylinder(r=radius, h=depth, $fn=segments);\n  }\n}\n\narch(width=50, height=30, depth=10, radius=15);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "letter S",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 55,
      "code": "module arch(width, height, depth, radius, segments = 16) {\n  difference() {\n    union() {\n      // Base\n      cube([width, depth, height]);\n\n      // Arch\n      translate([0, depth, height]) {\n        rotate_extrude(angle = 180)\n        translate([width / 2, 0, 0])\n        circle(r = radius);\n      }\n    }\n\n    // Cutout for support (optional)\n    translate([width / 2, -1, -1]) {\n      cube([width / 4, depth + 1, height + 1]);\n    }\n  }\n}\n\narch(width = 50, height = 30, depth = 20, radius = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "letter O",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 52,
      "code": "module arch(width, height, depth, radius, segments) {\n  difference() {\n    hull() {\n      translate([0, 0, 0])\n        rotate_extrude(angle = 360)\n          translate([radius, 0, 0])\n            circle(r = radius);\n      translate([width, 0, 0])\n        rotate_extrude(angle = 360)\n          translate([radius, 0, 0])\n            circle(r = radius);\n    }\n    \n    linear_extrude(height = 1)\n      polygon(points = [\n        [0, 0],\n        [width - radius * 1.5, 0],\n        [width - radius * 1.5, height - radius * 1.5],\n        [0, height - radius * 1.5]\n      ]);\n  }\n}\n\narch(width = 50, height = 30, depth = 10, radius = 15, segments = 20);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "letter T",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 72,
      "code": "// Tent parameters\ntent_width = 100;\ntent_depth = 60;\ntent_height = 50;\nwall_thickness = 5;\nroof_height = 30;\nroof_angle = 30;\n\nmodule tent() {\n  difference() {\n    cube([tent_width, tent_depth, tent_height]);\n    translate([wall_thickness, wall_thickness, 0])\n      cube([tent_width - 2 * wall_thickness, tent_depth - 2 * wall_thickness, tent_height]);\n  }\n}\n\nmodule roof() {\n  linear_extrude(height = roof_height)\n    polygon(points = [\n      [0, 0],\n      [tent_width / 2, tent_depth / 2],\n      [tent_width, 0]\n    ]);\n}\n\n// Combine tent and roof\nunion() {\n  tent();\n  translate([0, 0, tent_height])\n    roof();\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "letter B",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 29,
      "code": "module eagle(size = 50) {\n  difference() {\n    union() {\n      // Body\n      sphere(r = size * 0.4);\n      translate([0, 0, size * 0.3])\n      cylinder(h = size * 0.4, r = size * 0.3);\n\n      // Head\n      translate([0, 0, size * 0.6])\n      sphere(r = size * 0.2);\n\n      // Beak\n      translate([0, 0, size * 0.5])\n      cone(h = size * 0.1, r1 = size * 0.15, r2 = size * 0.1, $fn = 32);\n\n      // Wing (left)\n      translate([-size * 0.5, 0, size * 0.4])\n      rotate([0, 0, -45])\n      cube([size * 0.7, size * 0.3, size * 0.3], center = true);\n\n      // Wing (right)\n      translate([size * 0.5, 0, size * 0.4])\n      rotate([0, 0, 45])\n      cube([size * 0.7, size * 0.3, size * 0.3], center = true);\n\n      // Tail\n      translate([-size * 0.8, 0, size * 0.2])\n      rotate([0, 0, -30])\n      cube([size * 0.3, size * 0.1, size * 0.1], center = true);\n    }\n\n    // Hole for the neck\n    translate([0, 0, -size * 0.2])\n    cylinder(h = size * 0.1, r = size * 0.15);\n  }\n}\n\neagle();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "number 8",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 75,
      "code": "module wedge(width, height, depth, angle) {\n  linear_extrude(height = height) {\n    difference() {\n      circle(r = width / 2);\n      translate([0, 0, -depth * tan(angle)])\n        circle(r = width / 2);\n    }\n  }\n}\n\nwedge(width = 20, height = 10, depth = 5, angle = 30);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: Geometries in cache: 4\nGeometry cache size in bytes: 1168\nCGAL Polyhedrons in cache: 0\nCGAL cache size in bytes: 0\nTotal rendering time: 0:00:00.000\nCurrent top level object is empty.\n",
      "vlm_response": null
    },
    {
      "object": "cube with eyes",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 25,
      "code": "module cookie(radius = 20, thickness = 5, detail = 24) {\n  difference() {\n    union() {\n      // Base\n      cylinder(h = thickness, r = radius, $fn = detail);\n\n      // Sides\n      translate([0, 0, thickness/2]) {\n        cube([radius * 1.2, radius * 1.2, thickness], center = true);\n      }\n\n      translate([0, 0, -thickness/2]) {\n        rotate([0,0,180]) {\n          cube([radius * 1.2, radius * 1.2, thickness], center = true);\n        }\n      }\n\n      translate([radius * 1.2, 0, -thickness/2]) {\n        rotate([0,0,180]) {\n          cube([radius * 1.2, radius * 1.2, thickness], center = true);\n        }\n      }\n    }\n    // Cut out a space for the cookie to open\n    translate([0, 0, -0.1]) {\n        cube([radius * 1.5, radius * 1.5, 0.5], center = true);\n    }\n  }\n\n  color(\"white\") cookie(radius = 20, thickness = 5, detail = 24);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: Parser error: syntax error in file evaluation/ThomasTheMaker_k-1b_20251029_131650/cube_with_eyes.scad, line 32\nCan't parse file 'evaluation/ThomasTheMaker_k-1b_20251029_131650/cube_with_eyes.sc",
      "vlm_response": null
    },
    {
      "object": "number 0",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 58,
      "code": "module pyramid(base_width, base_depth, base_height, vertex_count) {\n  difference() {\n    hull() {\n      translate([0, 0, 0]) cube([base_width, base_depth, base_height]);\n      for (i = [0:vertex_count - 1]) {\n        translate([0, 0, base_height * (i / vertex_count)]) {\n          rotate([0, 0, i * 360 / vertex_count]) {\n            translate([0, 0, 0]) cube([1, 1, 1]);\n          }\n        }\n      }\n    }\n    translate([0, 0, -1]) cube([base_width + 2, base_depth + 2, base_height + 2]);\n  }\n}\n\npyramid(base_width = 50, base_depth = 50, base_height = 25, vertex_count = 5);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "pyramid with face",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 13,
      "code": "module pyramid(base_width, base_depth, base_height, side_length, angle) {\n  linear_extrude(height = side_length) {\n    polygon(points = [\n      [0, 0],\n      [side_length, 0],\n      [side_length, base_height],\n      [0, base_height]\n    ]);\n  }\n  \n  translate([0,0,side_length]) {\n    rotate([0,90,0]) {\n      translate([0,0,-base_height]) {\n        cube([base_width, base_depth, base_height], center = true);\n      }\n    }\n  }\n}\n\npyramid(base_width = 50, base_depth = 50, base_height = 100, side_length = 200, angle = 45);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "number 1",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 96,
      "code": "// Clamp Parameters\nclamp_width = 50;\nclamp_height = 20;\nclamp_depth = 10;\nscrew_diameter = 4;\nscrew_length = 20;\nadjustment_range = 10;\nadjustment_height = 5;\nadjustment_angle = 30;\nscrew_hole_diameter = 2;\nscrew_hole_offset = clamp_width / 2;\n\nmodule clamp() {\n  difference() {\n    union() {\n      // Main Body\n      cube([clamp_width, clamp_height, clamp_depth]);\n\n      // Adjustment Mechanism\n      translate([adjustment_range, clamp_height - adjustment_height, clamp_depth - adjustment_height]) {\n        cube([clamp_width, adjustment_height, adjustment_depth]);\n      }\n\n      // Screw Holes\n      translate([clamp_width/2, clamp_height - adjustment_height, clamp_depth - adjustment_height]) {\n        cylinder(h = screw_length, d = screw_hole_diameter, $fn = 50);\n        translate([screw_hole_offset, clamp_height - adjustment_height, clamp_depth - adjustment_height]) {\n          cylinder(h = screw_length, d = screw_hole_diameter, $fn = 50);\n        }\n      }\n    }\n\n    // Screw Hole Cutouts\n    translate([clamp_width/2, clamp_height - adjustment_height, clamp_depth - adjustment_height]) {\n      cylinder(h = screw_length, d = screw_hole_diameter, $fn = 50);\n      translate([screw_hole_offset, clamp_height - adjustment_height, clamp_depth - adjustment_height]) {\n        cylinder(h = screw_length, d = screw_hole_diameter, $fn = 50);\n      }\n    }\n\n    translate([clamp_width/2, clamp_height - adjustment_height, clamp_depth - adjustment_height]) {\n        cube([clamp_width, adjustment_height, adjustment_depth]);\n    }\n  }\n}\n\nclamp();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "cylinder body",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 81,
      "code": "module hemisphere(r) {\n  linear_extrude(height = r) {\n    circle(r = r);\n  }\n}\n\nhemisphere(r = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "sphere head",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 78,
      "code": "// Parameters for the lid\nlid_width = 50;\nlid_height = 50;\nlid_thickness = 5;\nlid_overhang = 2;\n\nmodule lid() {\n  difference() {\n    cube([lid_width, lid_height, lid_thickness]);\n    translate([0, 0, -lid_overhang])\n    cube([lid_width, lid_height + lid_overhang, lid_thickness]);\n  }\n}\n\nlid();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "bird shape",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 78,
      "code": "module arch(width, height, depth, radius, segments=32) {\n  difference() {\n    cube([width, height, depth]);\n    translate([0, 0, -0.1])\n    rotate([0,0,45])\n    cylinder(r=radius, h=depth, $fn=segments);\n  }\n}\n\narch(width=50, height=30, depth=10, radius=15);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "fish",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 34,
      "code": "// Shark Model in OpenSCAD\n\n$fn = 50;\n\nmodule shark(length = 50, width = 25, height = 15) {\n  difference() {\n    union() {\n      // Body\n      translate([0, 0, 0])\n      cube([length, width, height]);\n\n      // Dorsal Fin\n      translate([length * 0.3, 0, height * 0.3])\n      rotate([0, 0, -30])\n      cube([width * 0.3, height * 0.3, 10]);\n\n      // Pectoral Fin\n      translate([length * 0.2, width * 0.2, height * 0.3])\n      rotate([0, 0, 15])\n      cube([width * 0.2, height * 0.3, 10]);\n\n      // Tail Fin\n      translate([length * 0.4, width * 0.3, height * 0.4])\n      rotate([0, 0, -15])\n      cube([width * 0.3, height * 0.3, 10]);\n    }\n\n    // Hole for mouth (simplified)\n    translate([length * 0.3, 0, height * 0.3])\n    cylinder(h = 2, r = 2);\n  }\n}\n\nshark();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "dome",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 49,
      "code": "module hemisphere(r) {\n  difference() {\n    sphere(r);\n    translate([0,0,-r]) cylinder(r,r,r);\n  }\n}\n\nhemisphere(r = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "arch",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 52,
      "code": "module arch(width, height, depth, radius, segments = 32) {\n  linear_extrude(height = height) {\n    polygon(points = [\n      [0, 0],\n      [width / 2, -radius * cos(360 / segments) * height],\n      [width / 2, height * 1.25],\n      [0, height]\n    ]);\n  }\n\n  translate([0, -radius, 0]) {\n    rotate([90,0,0]) {\n      linear_extrude(height = depth) {\n        polygon(points = [\n          [0, 0],\n          [width / 2, -radius * cos(360 / segments) * height],\n          [width / 2, height * 1.25],\n          [0, height]\n        ]);\n      }\n    }\n  }\n}\n\narch(width = 50, height = 30, depth = 10, radius = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "pyramid tower",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 87,
      "code": "module pyramid(base_width, base_depth, base_height, side_length) {\n  difference() {\n    cube([side_length, side_length, base_height]);\n    translate([0, 0, -0.1]) cube([side_length, side_length, base_height + 0.2]);\n  }\n}\n\npyramid(base_width = 50, base_depth = 50, base_height = 100, side_length = 100);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: Geometries in cache: 3\nGeometry cache size in bytes: 2184\nCGAL Polyhedrons in cache: 1\nCGAL cache size in bytes: 0\nTotal rendering time: 0:00:00.021\nCurrent top level object is empty.\n",
      "vlm_response": null
    },
    {
      "object": "cube tower",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 21,
      "code": "module block(size, center = true) {\n  if (center) {\n    cube_size = size;\n    cube(size);\n  } else {\n    cube_size = size;\n    cube();\n  }\n}\n\nblock([10, 10, 5]);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "corner piece",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 71,
      "code": "module prism(width, height, depth, angle) {\n  difference() {\n    cube([width, height, depth]);\n    translate([0,0,0]) cube([width, height, depth]);\n  }\n}\n\nprism(width = 50, height = 30, depth = 20, angle = 45);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: Geometries in cache: 2\nGeometry cache size in bytes: 1456\nCGAL Polyhedrons in cache: 1\nCGAL cache size in bytes: 0\nTotal rendering time: 0:00:00.020\nCurrent top level object is empty.\n",
      "vlm_response": null
    },
    {
      "object": "wall block",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 81,
      "code": "module block(width, depth, height) {\n  cube([width, depth, height]);\n}\n\nblock(10, 5, 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "brick",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 14,
      "code": "module brick(length, width, height) {\n  cube([length, width, height]);\n}\n\nbrick(20, 10, 5);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "bumpy sphere",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 40,
      "code": "module sphere(r) {\n  sphere(r);\n}\n\nsphere(10);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: Recursion detected calling module 'sphere' in file bumpy_sphere.scad, line 1\nTRACE: called by 'sphere' in file bumpy_sphere.scad, line 2\nTRACE: called by 'sphere' in file bumpy_sphere.scad, lin",
      "vlm_response": null
    },
    {
      "object": "blob",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 82,
      "code": "module egg(radius = 10, height = 20, segments = 64) {\n  hull() {\n    sphere(r = radius);\n    translate([0, 0, -height/2]) sphere(r = radius * 0.75);\n  }\n  difference() {\n    translate([0,0,0])\n    cube([radius * 2, radius * 2, height], center = true);\n  }\n}\n\negg(radius = 10, height = 20, segments = 64);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "random shape",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 9,
      "code": "module hemisphere(r) {\n  difference() {\n    sphere(r);\n    translate([0,0,-r]) cube([2*r*2, 2*r*2, 2*r*2]);\n  }\n  \n  rotate_extrude(convexity = 180)\n  translate([0,0,0])\n  circle(r = r);\n}\n\nhemisphere(r = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "wrinkled cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 42,
      "code": "module brick(width, depth, height) {\n  cube([width, depth, height]);\n}\n\nbrick(20, 10, 5);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "twisted cylinder",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 92,
      "code": "module helix(radius, height, turns, segments) {\n  rotate_extrude(convexity = 10, $fn = segments)\n    translate([radius, 0, 0])\n      circle(r = 1, $fn = segments);\n}\n\nhelix(radius = 10, height = 20, turns = 2, segments = 60);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "organic form",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 63,
      "code": "// Throne Design in OpenSCAD\n\n// Parameters\nthrone_height = 120;\nthrone_width = 80;\nthrone_depth = 100;\narmrest_height = 50;\narmrest_width = 30;\narmrest_depth = 20;\nleg_height = 100;\nleg_width = 15;\nleg_depth = 5;\nbackrest_height = 100;\nbackrest_width = 120;\nbackrest_depth = 30;\nseat_height = 50;\nseat_width = 150;\nseat_depth = 100;\n\n// Main Body\nmodule throne_body() {\n  difference() {\n    cube([throne_width, throne_depth, throne_height]);\n    translate([10,10,10]) cube([throne_width-20, throne_depth-20, throne_height-20]);\n  }\n}\n\n// Armrests\nmodule armrests() {\n  translate([armrest_width, armrest_height, 0]) {\n    cube([armrest_width, armrest_depth, armrest_height]);\n  }\n}\n\n// Legs\nmodule legs() {\n  translate([0, 0, 0]) {\n    cube([leg_width, leg_depth, leg_height]);\n  }\n}\n\n// Backrest\nmodule backrest() {\n  translate([0, 0, throne_height - backrest_height]) {\n    cube([backrest_width, backrest_depth, backrest_height]);\n  }\n}\n\n// Seat\nmodule seat() {\n  translate([0, 0, throne_height - seat_height]) {\n    cube([seat_width, seat_depth, seat_height]);\n  }\n}\n\n//Assembly\ndifference() {\n  union() {\n    throne_body();\n\n    // Legs\n    translate([leg_width, leg_depth, 0]) legs();\n    translate([throne_width - leg_width - leg_width, leg_depth, 0]) legs();\n    translate([leg_width, throne_depth - leg_depth - leg_width, 0]) legs();\n    translate([throne_width - leg_width - leg_width, throne_depth - leg_depth - leg_width, 0]) legs();\n    \n    //Backrest\n    translate([0, 0, 0]) backrest();\n\n    //Armrests\n    translate([armrest_width, armrest_height, 0]) armrests();\n    translate([throne_width - armrest_width - armrest_width, armrest_height, 0]) armrests();\n    translate([leg_width, armrest_height, 0]) armrests();\n    translate([throne_width - armrest_width - armrest_width, armrest_height, 0]) armrests();\n    \n    //Seat\n    translate([0, 0, 0]) seat();\n  }\n}\n\n\n// Render the throne\ntranslate([0, 0, 0]) {\n  difference() {\n    union() {\n      throne_body();\n      translate([0,0,0]) armrests();\n      translate([0,0,0]) legs();\n      translate([0,0,0]) backrest();\n      translate([0,0,0]) seat();\n    }\n  }\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "bolt",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 67,
      "code": "module bolt(head_diameter, head_height, shank_diameter, shank_length, thread_diameter, thread_length) {\n  difference() {\n    // Head\n    cylinder(h = head_height, d = head_diameter, $fn = 50);\n\n    // Shank\n    translate([0, 0, head_height])\n    cylinder(h = shank_length, d = shank_diameter, $fn = 50);\n\n    // Threads\n    for (i = [0:thread_length/thread_diameter]) {\n      translate([0, 0, i * thread_length/thread_diameter])\n      rotate([0, 0, 90])\n      linear_extrude(height = thread_length)\n      polygon(points = [\n          [0, 0],\n          [thread_diameter/2, shank_diameter/2],\n          [0, shank_diameter/2]\n        ]);\n    }\n  }\n}\n\nbolt(head_diameter = 10, head_height = 2, shank_diameter = 20, shank_length = 20, thread_diameter = 2, thread_length = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "screw",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 64,
      "code": "// Screw Parameters\nhead_diameter = 10;\nhead_height = 2;\nshank_diameter = 2;\nshank_length = 30;\nthread_diameter = 1.5;\nthread_length = 20;\nthread_pitch = 0.8;\n\nmodule screw() {\n  difference() {\n    union() {\n      // Head\n      cylinder(h = head_height, r = head_diameter / 2, center = false);\n\n      // Shank\n      cylinder(h = shank_length, r = shank_diameter / 2, center = false);\n    }\n\n    // Threads\n    for (i = [0:thread_length/thread_pitch:thread_length/thread_pitch]) {\n      rotate([0,0,i])\n      translate([0,0,-i/2])\n      linear_extrude(height = 0.1, twist = 0, convexity = 1)\n        circle(r = thread_diameter/2);\n    }\n  }\n}\n\nscrew();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "spring",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 17,
      "code": "module pole(height, radius, segments = 32) {\n  cylinder(h = height, r = radius, $fn = segments);\n}\n\npole(height = 100, radius = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "nut",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 54,
      "code": "// Bearing Parameters\ninner_diameter = 10;\nouter_diameter = 20;\nbearing_width = 5;\nball_diameter = 5;\nnum_balls = 12;\n\n// Calculate bearing radius\ninner_radius = inner_diameter / 2;\nouter_radius = outer_diameter / 2;\n\n// Calculate ball radius\nball_radius = ball_diameter / 2;\n\n// Create the bearing race\ndifference() {\n  cylinder(h = bearing_width, r = outer_radius, center = false);\n  for (i = [0:num_balls - 1]) {\n    angle = i * 360 / num_balls;\n    rotate([0, 0, angle]) {\n      translate([inner_radius, 0, 0]) {\n        sphere(r = ball_radius);\n      }\n    }\n  }\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "axle",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 9,
      "code": "// Axle parameters\ndiameter = 6;\nlength = 50;\n\ndifference() {\n  cylinder(h = length, d = diameter, center = false);\n  cylinder(h = length + 1, d = diameter, center = false);\n}",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: Geometries in cache: 2\nGeometry cache size in bytes: 3184\nCGAL Polyhedrons in cache: 1\nCGAL cache size in bytes: 0\nTotal rendering time: 0:00:00.067\nCurrent top level object is empty.\n",
      "vlm_response": null
    },
    {
      "object": "pulley",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 97,
      "code": "// Wheel parameters\nradius = 50;\nthickness = 10;\nnum_spokes = 8;\nspoke_width = 5;\nspoke_length = 10;\nhole_diameter = 5;\n\ndifference() {\n  cylinder(h = thickness, r = radius, $fn = 50);\n  for (i = [0:num_spokes-1]) {\n    rotate([0, 0, i * 360 / num_spokes]) {\n      translate([radius - spoke_length, 0, 0]) {\n        cube([spoke_length, spoke_width, thickness]);\n      }\n    }\n  }\n  cylinder(h = thickness + 0.1, r = radius - 1, $fn = 50);\n  translate([0,0,-1]) cylinder(h=1, r=hole_diameter/2, $fn=50);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "wheel",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 8,
      "code": "// Wheel parameters\nradius = 50;\nthickness = 15;\nnum_spokes = 8;\nspoke_width = 5;\nspoke_height = 20;\nhole_radius = 5;\n\ndifference() {\n  cylinder(h = thickness, r = radius, $fn = 100);\n\n  for (i = [0:num_spokes - 1]) {\n    rotate([0, 0, i * 360 / num_spokes]) {\n      translate([radius * cos(i * 360 / num_spokes) - radius * sin(i * 360 / num_spokes),\n                   radius * sin(i * 360 / num_spokes) - radius * cos(i * 360 / num_spokes),\n                   0]) {\n        cube([spoke_width, spoke_height, thickness]);\n      }\n    }\n  }\n\n  cylinder(h = thickness + 1, r = hole_radius, $fn = 100);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "shaft",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 51,
      "code": "module column(height, radius, segments) {\n  cylinder(h = height, r = radius, $fn = segments);\n}\n\ncolumn(height = 10, radius = 2, segments = 64);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "pipe",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 52,
      "code": "module tube(radius, height, segments) {\n  cylinder(r = radius, h = height, $fn = segments);\n}\n\ntube(radius = 10, height = 20, segments = 64);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "tube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 64,
      "code": "module rod(diameter, length) {\n  cylinder(h = length, d = diameter);\n}\n\nrod(diameter = 10, length = 50);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "channel",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 91,
      "code": "module slope(length, height, angle) {\n  rotate([0, 0, angle])\n  translate([0, 0, 0])\n  cube([length, height, 0.1]);\n}\n\nslope(50, 10, 30);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "profile",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 71,
      "code": "module prism(width, height, depth, angle) {\n  rotate([0, 0, angle])\n    translate([0, 0, -depth/2])\n      cube([width, height, depth]);\n}\n\nprism(width = 50, height = 30, depth = 20, angle = 45);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "angle iron",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 17,
      "code": "module arch(width, height, depth, radius, segments = 32) {\n  difference() {\n    union() {\n      // Main body\n      cube([width, depth, height]);\n\n      // Arch support\n      translate([0, -depth/2, 0])\n        rotate_extrude(angle = 180)\n          translate([0, 0, 0])\n            square([width, depth]);\n    }\n\n    // Cut out the arch\n    translate([0, -depth/2, 0])\n      rotate_extrude(angle = 180)\n        translate([0, 0, 0])\n          square([width, depth]);\n  }\n}\n\narch(width = 50, height = 20, depth = 10, radius = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "T-beam",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 87,
      "code": "module brace(length, width, height, hole_diameter, hole_offset) {\n  difference() {\n    cube([length, width, height]);\n    translate([hole_offset, hole_offset, 0])\n    cylinder(h=height, r=hole_diameter/2, center=true);\n  }\n}\n\nbrace(length=50, width=10, height=5, hole_diameter=2, hole_offset=2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "I-beam",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 43,
      "code": "module beam(length, width, height, fillet_radius) {\n  difference() {\n    cube([length, width, height]);\n    translate([fillet_radius, fillet_radius, 0])\n      cube([length - 2 * fillet_radius, width - 2 * fillet_radius, height]);\n  }\n}\n\nbeam(length = 100, width = 20, height = 10, fillet_radius = 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "L-profile",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 51,
      "code": "module hexagon(size) {\n  for (i = [0:3]) {\n    angle = i * 360 / 6;\n    rotate([cos(angle), sin(angle), 0])\n    translate([size * cos(angle), size * sin(angle), 0])\n    sphere(r = size / 2);\n  }\n}\n\nlinear_extrude(height = 1) hexagon(size = 20);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: WARNING: Ignoring 3D child object for 2D operation in file L-profile.scad, line 10\nGeometries in cache: 10\nGeometry cache size in bytes: 558648\nCGAL Polyhedrons in cache: 1\nCGAL cache size in bytes: 4",
      "vlm_response": null
    },
    {
      "object": "container with lid",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 63,
      "code": "// Customizable parameters\ncontainer_width = 100;\ncontainer_depth = 50;\ncontainer_height = 25;\nwall_thickness = 2;\nlid_height = 5;\nlid_width = 40;\nlid_depth = 10;\n\n// Base\ndifference() {\n  cube([container_width, container_depth, container_height]);\n  translate([wall_thickness, wall_thickness, 0])\n    cube([container_width - 2 * wall_thickness, container_depth - 2 * wall_thickness, container_height]);\n}\n\n// Lid\ndifference() {\n  cube([lid_width, lid_depth, lid_height]);\n  translate([wall_thickness, wall_thickness, lid_height - 0.5])\n    cube([lid_width - 2 * wall_thickness, lid_depth - 2 * wall_thickness, lid_height - 0.5]);\n}\n\n// Handle\ntranslate([container_width/2 - 10, 0, 0])\n  cube([10, 2, 10]);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "box without lid",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 93,
      "code": "module box(width, depth, height, wall_thickness) {\n  difference() {\n    cube([width, depth, height]);\n    translate([wall_thickness, wall_thickness, wall_thickness])\n    cube([width - 2 * wall_thickness, depth - 2 * wall_thickness, height - 2 * wall_thickness]);\n  }\n\n  box(width = 100, depth = 50, height = 20, wall_thickness = 2);\n}\n\nbox(width = 100, depth = 50, height = 20, wall_thickness = 2);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: Recursion detected calling module 'box' in file box_without_lid.scad, line 1\nTRACE: called by 'box' in file box_without_lid.scad, line 8\nTRACE: called by 'box' in file box_without_lid.scad, lin",
      "vlm_response": null
    },
    {
      "object": "open box",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 65,
      "code": "module panel(width, height, depth, hole_diameter, hole_x, hole_y) {\n  difference() {\n    cube([width, height, depth]);\n    if (hole_diameter > 0) {\n      translate([hole_x, hole_y, depth/2]) {\n        cylinder(h=depth, r=hole_diameter/2, $fn=32);\n      }\n    }\n  }\n}\n\npanel(width=100, height=50, depth=20, hole_diameter=10, hole_x=30, hole_y=10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "cup",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 19,
      "code": "// Cup parameters\nradius = 50;\nheight = 60;\nthickness = 3;\nhandle_width = 10;\nhandle_height = 25;\nhandle_depth = 5;\n\ndifference() {\n  cylinder(h = height, r = radius, $fn = 60);\n  translate([0, 0, height - handle_height])\n    cube([handle_width, handle_height, handle_depth]);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "bowl",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 19,
      "code": "// Parameters\nradius = 10;\nheight = 5;\nwall_thickness = 0.5;\n\n// Cone with tapered tip\ndifference() {\n  union() {\n    cylinder(h = height, r = radius, center = false);\n    translate([0, 0, height - radius])\n    rotate_extrude(angle = 180)\n    translate([0, 0, 0])\n    polygon(points = [[radius * cos(180/360), radius * sin(180/360) * 1.5]]);\n  }\n  translate([0, 0, -wall_thickness])\n  cube([radius * 2 + wall_thickness * 2, radius * 2 + wall_thickness * 2, height + wall_thickness * 2], center = true);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "closed box",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 8,
      "code": "module container(width, depth, height, wall_thickness, corner_radius) {\n  difference() {\n    cube([width, depth, height]);\n    translate([wall_thickness, wall_thickness, 0])\n      cube([width - 2 * wall_thickness, depth - 2 * wall_thickness, height]);\n  }\n\n  // Rounded corners\n  if (corner_radius > 0) {\n    for (i = [0, 1, 2, 3]) {\n      for (j = [0, 1, 2, 3]) {\n        translate([i * (width - 2 * corner_radius), j * (depth - 2 * corner_radius), 0]) {\n          rotate([0, 0, angle(i, j)])\n            cylinder(r = corner_radius, h = height, $fn=50);\n        }\n      }\n    }\n  }\n}\n\ncontainer(width = 100, depth = 50, height = 30, wall_thickness = 2, corner_radius = 5);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "vase",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 17,
      "code": "// Spout Parameters\nspout_diameter = 10;\nspout_height = 20;\nspout_wall_thickness = 2;\nspout_lip_width = 5;\nspout_lip_height = 2;\nspout_angle = 15; // Angle of the spout opening\n\nmodule spout() {\n  difference() {\n    cylinder(h = spout_height, d = spout_diameter, center = false);\n    cylinder(h = spout_height - spout_lip_height, d = spout_diameter - 2 * spout_wall_thickness, center = false);\n  }\n\n  translate([0, 0, spout_height - spout_lip_height]) {\n    rotate([0, 0, spout_angle]) {\n      linear_extrude(height = spout_lip_height) {\n        polygon(points=[[0, 0], [spout_diameter/2, spout_lip_width], [spout_diameter/2 - spout_diameter/2, -spout_lip_height]]);\n      }\n    }\n  }\n}\n\nspout();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "grid",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 92,
      "code": "module panel(width, height, depth, thickness, hole_diameter, hole_x, hole_y) {\n  difference() {\n    cube([width, height, depth]);\n    if (hole_diameter > 0) {\n      translate([hole_x, hole_y, -0.1]) {\n        cylinder(h = depth + 0.2, r = hole_diameter / 2, $fn = 50);\n      }\n    }\n  }\n}\n\n// Example usage:\nwidth = 100;\nheight = 50;\ndepth = 20;\nthickness = 10;\nhole_diameter = 8;\nhole_x = width / 2 - hole_diameter / 2;\nhole_y = height / 2 - hole_diameter / 2;\n\npanel(width, height, depth, thickness, hole_diameter, hole_x, hole_y);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "mesh",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 11,
      "code": "module arch(width, height, depth, radius, segments = 24) {\n  linear_extrude(height = height, convexity = 10, twist = 0)\n    polygon(points = [\n      [0, 0],\n      [width/2, height],\n      [width, 0]\n    ]);\n}\n\narch(width = 100, height = 50, depth = 20, radius = 25, segments = 32);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "lattice",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 12,
      "code": "module pyramid(base_width, base_depth, base_height, side_length) {\n  linear_extrude(height = base_height) {\n    polygon(points = [[0,0], [side_length, 0], [side_length, base_height], [0, base_height]]);\n  }\n}\n\npyramid(base_width = 50, base_depth = 50, base_height = 25, side_length = 80);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "honeycomb",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 86,
      "code": "module hexagon(size) {\n  polygon(points=[\n    [size * cos(30), size * sin(30)],\n    [size * cos(60), size * sin(60)],\n    [size * cos(90), size * sin(90)],\n    [size * cos(120), size * sin(120)],\n    [size * cos(150), size * sin(150)],\n    [size * cos(180), size * sin(180)]\n  ]);\n}\n\nlinear_extrude(height = 0.1) {\n  hexagon(size = 10);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "cross pattern",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 38,
      "code": "module hexagon(size) {\n  linear_extrude(height = 1)\n  polygon(points = [\n    [size * cos(30), size * sin(30)],\n    [size * cos(60), size * sin(60)],\n    [size * cos(90), size * sin(90)],\n    [size * cos(120), size * sin(120)],\n    [size * cos(150), size * sin(150)],\n    [size * cos(180), size * sin(180)]\n  ]);\n}\n\nlinear_extrude(height = 1)\nhexagon(size = 10);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: WARNING: Ignoring 3D child object for 2D operation in file cross_pattern.scad, line 14\nGeometries in cache: 3\nGeometry cache size in bytes: 1768\nCGAL Polyhedrons in cache: 0\nCGAL cache size in bytes: ",
      "vlm_response": null
    },
    {
      "object": "woven pattern",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 27,
      "code": "module rope(length, diameter, segments) {\n  linear_extrude(height = length)\n  polygon(points = [\n    [0, 0],\n    [length / segments, 0],\n    [length / segments * segments, diameter / 2],\n    [length, diameter / 2]\n  ]);\n}\n\n// Example usage:\nrope(length = 100, diameter = 10, segments = 16);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "spiral staircase",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 54,
      "code": "module stair(height, depth, width, rise, run) {\n  difference() {\n    cube([width, depth, height]);\n    translate([0, 0, -0.1]) {\n      cube([width, depth, height + 0.2]);\n    }\n    translate([rise, depth/2, 0]) {\n      cube([width, run, height]);\n    }\n  }\n}\n\nstair(height = 100, depth = 400, width = 300, rise = 20, run = 150);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: Geometries in cache: 5\nGeometry cache size in bytes: 3640\nCGAL Polyhedrons in cache: 1\nCGAL cache size in bytes: 0\nTotal rendering time: 0:00:00.024\nCurrent top level object is empty.\n",
      "vlm_response": null
    },
    {
      "object": "diamond pattern",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 60,
      "code": "module pentagon(size) {\n  linear_extrude(height = size) {\n    polygon(points = [\n      [size * cos(0), size * sin(0)],\n      [size * cos(36), size * sin(36)],\n      [size * cos(72), size * sin(72)],\n      [size * cos(108), size * sin(108)],\n      [size * cos(144), size * sin(144)]\n    ]);\n  }\n}\n\npentagon(size = 20);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "helix curve",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 95,
      "code": "module helix(height, radius, turns, segments) {\n  linear_extrude(height = height, convexity = 10)\n    for (i = [0:turns]) {\n      rotate([0, 0, i * 360 / turns])\n        translate([radius * cos(i * 360 / turns), radius * sin(i * 360 / turns), 0])\n          circle(r = radius);\n    }\n}\n\nhelix(height = 10, radius = 2, turns = 5, segments = 100);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "bezier curve",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 46,
      "code": "module curve(radius, height, segments) {\n  linear_extrude(height = height, convexity = 10)\n    circle(r = radius);\n}\n\ncurve(radius = 10, height = 2, segments = 60);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "wavy surface",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 73,
      "code": "module wave(height, width, thickness, radius) {\n  difference() {\n    cylinder(h = height, r = width / 2, $fn = 60);\n    translate([0,0,-1])\n      cylinder(h = height + 2, r = radius, $fn = 60);\n  }\n}\n\n// Example usage:\nwave(height = 5, width = 20, thickness = 10, radius = 8);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "undulating shape",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 24,
      "code": "module egg(radius = 10, segments = 48) {\n  difference() {\n    sphere(r = radius, $fn = segments);\n    translate([0, 0, radius * 0.2])\n    cube([radius * 2, radius * 2, radius * 2], center = true);\n  }\n}\n\negg(radius = 50);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "two cubes",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 40,
      "code": "module brick(width, height, depth, wall_thickness) {\n  difference() {\n    cube([width, height, depth]);\n    translate([wall_thickness, wall_thickness, wall_thickness]) {\n      cube([width - 2 * wall_thickness, height - 2 * wall_thickness, depth - 2 * wall_thickness]);\n    }\n  }\n\n  brick(20, 10, 5, 1.5);\n}\n\nbrick(25, 15, 10, 2);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: Recursion detected calling module 'brick' in file two_cubes.scad, line 1\nTRACE: called by 'brick' in file two_cubes.scad, line 9\nTRACE: called by 'brick' in file two_cubes.scad, line 9\nTRACE: c",
      "vlm_response": null
    },
    {
      "object": "stack of cylinders",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 80,
      "code": "module cone(h, r1, r2, $fn = 50) {\n  linear_extrude(height = h, convexity = 10) {\n    circle(r = r1, $fn = $fn);\n  }\n}\n\ncone(h = 10, r1 = 5, r2 = 0, $fn = 50);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "cube and sphere",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 30,
      "code": "// Vault Parameters\nvault_width = 50;\nvault_depth = 40;\nvault_height = 30;\nwall_thickness = 2;\ndoor_width = 15;\ndoor_height = 20;\ndoor_clearance = 2;\n\n// Vault Body\nmodule vault_body() {\n    difference() {\n        cube([vault_width, vault_depth, vault_height]);\n        translate([wall_thickness, wall_thickness, wall_thickness])\n        cube([vault_width - 2 * wall_thickness, vault_depth - 2 * wall_thickness, vault_height - wall_thickness]);\n    }\n}\n\n// Door Cutout\nmodule door_cutout() {\n    translate([vault_width/2 - door_width/2, vault_depth/2 - door_clearance, vault_height - door_height])\n    cube([door_width, door_clearance, door_height]);\n}\n\n// Rounded Edges (Optional - for better aesthetic)\nmodule rounded_vault() {\n    difference() {\n        hull() {\n            for (i = [0:1:10]) {\n                for (j = [0:1:10]) {\n                    translate([i * (vault_width/10), j * (vault_depth/10), 0])\n                    sphere(r = 1);\n                }\n            }\n            cube([vault_width, vault_depth, vault_height]);\n        }\n        translate([wall_thickness, wall_thickness, 0])\n        cube([vault_width - 2 * wall_thickness, vault_depth - 2 * wall_thickness, vault_height]);\n    }\n}\n\n// Main Assembly\nunion() {\n    vault_body();\n    door_cutout();\n    // Optionally round the edges:\n    // rounded_vault();\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "pyramid with base",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 81,
      "code": "module pyramid(base_width, base_depth, height) {\n  linear_extrude(height = height)\n    polygon(points=[[0,0], [base_width/2, 0], [base_width, base_depth], [base_width, base_depth], [0, base_depth]]);\n}\n\npyramid(base_width = 50, base_depth = 50, height = 100);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "klein bottle",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 5,
      "code": "module pentagon(radius, size) {\n  linear_extrude(height = 0.5)\n  polygon(points=[\n    [radius * cos(0), radius * sin(0)],\n    [radius * cos(360), radius * sin(360)],\n    [radius * cos(720), radius * sin(720)],\n    [radius * cos(1080), radius * sin(1080)],\n    [radius * cos(1440), radius * sin(1440)]\n  ]);\n}\n\npentagon(radius = 10, size = 20);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: Geometries in cache: 2\nGeometry cache size in bytes: 48\nCGAL Polyhedrons in cache: 0\nCGAL cache size in bytes: 0\nTotal rendering time: 0:00:00.000\nCurrent top level object is empty.\n",
      "vlm_response": null
    },
    {
      "object": "torus knot",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 23,
      "code": "module torus(major_radius, minor_radius, $fn = 100) {\n  rotate_extrude(convexity = 10) {\n    translate([major_radius, 0, 0])\n    circle(r = minor_radius);\n  }\n}\n\ntorus(major_radius = 50, minor_radius = 10, $fn = 100);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "interlocking rings",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 52,
      "code": "// Wheel parameters\nradius = 50;\nthickness = 10;\nnum_spokes = 6;\nspoke_width = 2;\nhole_diameter = 5;\n\n// Wheel body\ndifference() {\n  cylinder(h = thickness, r = radius, $fn = 50);\n  for (i = [0:num_spokes-1]) {\n    rotate([0, 0, i * 360 / num_spokes]) {\n      translate([radius - spoke_width, 0, 0]) {\n        cube([spoke_width, thickness, 1], center = true);\n      }\n    }\n  }\n  cylinder(h = thickness, r = radius - 1, $fn = 50); // Cut out the center for a flat surface\n}\n\n// Hole for axle\ncylinder(h = thickness + 1, r = hole_diameter/2, $fn = 50);\n\n//Optional:  Add a wheel rim for better aesthetics (simple)\n//difference() {\n//  cylinder(h = thickness, r = radius, $fn = 50);\n//  cylinder(h = thickness+1, r = radius-1, $fn = 50);\n//}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "mobius strip",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 15,
      "code": "module washer(outer_diameter, inner_diameter, thickness) {\n  difference() {\n    cylinder(h = thickness, r = outer_diameter / 2, $fn = 100);\n    cylinder(h = thickness, r = inner_diameter / 2, $fn = 100);\n  }\n}\n\nwasher(outer_diameter = 50, inner_diameter = 25, thickness = 3);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "trefoil knot",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 94,
      "code": "module trefoil(radius, height) {\n  linear_extrude(height = height)\n  polygon(points = [\n    [radius * cos(30), radius * sin(30)],\n    [radius * cos(120), radius * sin(120)],\n    [radius * cos(240), radius * sin(240)],\n    [radius * cos(300), radius * sin(300)]\n  ]);\n}\n\n// Adjust parameters as needed\nradius = 10;\nheight = 15;\n\ntrefoil(radius, height);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "figure eight",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 59,
      "code": "module hexagon(size) {\n  polygon(points = [\n    [size, 0],\n    [size * cos(30), size * sin(30)],\n    [size * cos(60), size * sin(60)],\n    [size * cos(90), size * sin(90)],\n    [size * cos(120), size * sin(120)],\n    [size * cos(150), size * sin(150)]\n  ]);\n}\n\nlinear_extrude(height = 1) {\n  hexagon(size = 10);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "lissajous curve",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 80,
      "code": "module Lissajous curve(amplitude, frequency, segments, resolution) {\n  rotate_extrude(convexity = 10, $fn = segments);\n  translate([amplitude, 0, 0])\n  linear_extrude(height = 1, convexity = 10, slices = resolution)\n  {\n    polygon(points = [\n      [0, 0],\n      [0.1, 0.1],\n      [0.2, 0.2],\n      [0.25, 0.25],\n      [0.3, 0.3],\n      [0.25, 0.3],\n      [0.1, 0.3],\n      [0.1, 0.2]\n    ]);\n  }\n}\n\n// Example Usage:\nlissajous_curve(amplitude = 1, frequency = 2, segments = 60, resolution = 50);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: Parser error: syntax error in file evaluation/ThomasTheMaker_k-1b_20251029_131650/lissajous_curve.scad, line 1\nCan't parse file 'evaluation/ThomasTheMaker_k-1b_20251029_131650/lissajous_curve.s",
      "vlm_response": null
    },
    {
      "object": "fractal branch",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 98,
      "code": "module fork(length = 100, width = 5, height = 2, angle = 30) {\n  difference() {\n    union() {\n      // Handle\n      cube([length, width, height]);\n\n      // Fork tine\n      translate([length - width/2, 0, 0])\n      rotate([0,0,angle])\n      cube([width, height, height]);\n    }\n    // Cutout for a slight taper\n    translate([length-width/2, -width/4, -height/4])\n    rotate([0,0,-angle])\n    cube([width, width/2, height/2]);\n  }\n}\n\nfork();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "fractal tree",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 6,
      "code": "module tree(height = 100, branch_angle = 45, branch_height = 20, leaf_width = 15, leaf_height = 5) {\n  // Base\n  cylinder(h = height - leaf_height - branch_height, r = 5, $fn = 50);\n\n  // Branches\n  for (i = [0:2]) {\n    rotate([0, branch_angle * i / 2, 0]) {\n      translate([0, height - branch_height, 0]) {\n        cube([branch_height, branch_width, branch_height]);\n      }\n    }\n  }\n\n  // Leaves\n  translate([-leaf_width / 2, 0, height - leaf_height]) {\n    rotate([0, 0, 30]) {\n      cube([leaf_width, leaf_height, 1]);\n    }\n  }\n\n  translate([leaf_width / 2, 0, height - leaf_height]) {\n    rotate([0, 0, 30]) {\n      cube([leaf_width, leaf_height, 1]);\n    }\n  }\n}\n\ntree(height = 150, branch_angle = 60, branch_height = 30, leaf_width = 20, leaf_height = 8);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "sierpinski triangle",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 33,
      "code": "module sierp(height = 20, width = 30, depth = 20) {\n  difference() {\n    hull() {\n      translate([0, 0, 0]) cube([width, height, depth]);\n      translate([width/2, height/2, depth/2]) cylinder(h = height, r = width/4, $fn = 50);\n      translate([width/2, 0, depth/2]) cylinder(h = height, r = width/4, $fn = 50);\n    }\n    \n    for (i = [0:width/4:width/2]) {\n      translate([i, 0, 0])\n      rotate([0, 0, i * 120])\n      hull() {\n        translate([width/4, height, depth/2]) cube([width/4, height, depth/2]);\n        translate([width/2, height/2, depth/2]) cylinder(h = height, r = width/4, $fn = 50);\n        translate([width/2, 0, depth/2]) cylinder(h = height, r = width/4, $fn = 50);\n      }\n    }\n  }\n}\n\nsierpinski(height = 20, width = 30, depth = 20);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: WARNING: Ignoring unknown module 'sierpinski' in file sierpinski_triangle.scad, line 21\nGeometries in cache: 1\nGeometry cache size in bytes: 0\nCGAL Polyhedrons in cache: 0\nCGAL cache size in bytes: 0\n",
      "vlm_response": null
    },
    {
      "object": "tetrahedron",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 7,
      "code": "// Tetrahedron with rounded corners\nmodule tetrahedron(radius) {\n  difference() {\n    union() {\n      for (i = [0, 1, 2, 3]) {\n        translate([\n          cos(i * 360 / 4),\n          sin(i * 360 / 4),\n          radius * 2\n        ]) {\n          sphere(r = radius);\n        }\n      }\n    }\n    for (i = [0, 1, 2, 3]) {\n      translate([\n        cos(i * 360 / 4),\n        sin(i * 360 / 4),\n        radius * 2\n      ]) {\n        cylinder(h = 1, r = radius);\n      }\n    }\n  }\n}\n\n//set radius for the tetrahedron\nradius = 1;\n\n//translate([0,0,0])\n//tetrahedron(radius);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: Geometries in cache: 1\nGeometry cache size in bytes: 0\nCGAL Polyhedrons in cache: 0\nCGAL cache size in bytes: 0\nTotal rendering time: 0:00:00.000\nCurrent top level object is empty.\n",
      "vlm_response": null
    },
    {
      "object": "julia set",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 33,
      "code": "module wedge(width, height, depth, angle) {\n  linear_extrude(height = depth)\n    polygon(points=[\n      [0, 0],\n      [width, 0],\n      [width, height],\n      [0, height]\n    ]);\n}\n\n// Example usage:\nwedge(width = 10, height = 5, depth = 2, angle = 30);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 54,
      "code": "module prism(width, height, length, angle) {\n  translate([0, 0, 0]) {\n    rotate([0, 0, angle]) {\n      linear_extrude(height = length) {\n        polygon(points=[[0,0], [length, 0], [length, height], [0, height]]);\n      }\n    }\n  }\n}\n\nprism(width = 10, height = 5, length = 20, angle = 30);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "octahedron",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 90,
      "code": "module hexagon(size) {\n  linear_extrude(height = 0.1)\n  polygon(points = [\n    [size * cos(30), size * sin(30)],\n    [size * cos(60), size * sin(60)],\n    [size * cos(90), size * sin(90)],\n    [size * cos(120), size * sin(120)],\n    [size * cos(150), size * sin(150)],\n    [size * cos(180), size * sin(180)]\n  ]);\n}\n\nhexagon(size = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "dodecahedron",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 15,
      "code": "// Parameters\nthickness = 1;\nwidth = 100;\nheight = 100;\ncorner_radius = 10;\n\n// Main Body\ndifference() {\n  cube([width, height, thickness]);\n  translate([corner_radius, corner_radius, -0.1])\n  cube([width - 2 * corner_radius, height - 2 * corner_radius, thickness + 0.2]);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no, the image you provided does not resemble a dodecahedron. a dodecahedron is a polyhedron with 12 faces, typically composed of equilateral triangles as its faces, and is one of the platonic solids. this object appears to be a 3d model of something else entirely, likely not even close to being a solid with 12 faces or regularity in terms of geometric shapes. it looks like a piece of modern art sculpture or some other form of 3d digital creation rather than a traditional polyhedron."
    },
    {
      "object": "icosahedron",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 60,
      "code": "module hexagon(size) {\n  linear_extrude(height = 1) {\n    polygon([\n      cos(random(360.0)),\n      sin(random(360.0)),\n      cos(random(360.0)) * cos(random(360.0)),\n      sin(random(360.0)) * sin(random(360.0))\n    ]);\n  }\n  \n  scale([1,1,1]);\n  \n  scale([size*1.2,size*1.2,1.2]);\n\n  translate([0,0,-size/2])\n    rotate([0,0,45])\n    hexagon(size);\n}\n\nscale([1,1,1]);\nhexagon(size=10);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: WARNING: Ignoring unknown function 'random' in file icosahedron.scad, line 4\nWARNING: cos() parameter could not be converted in file icosahedron.scad, line 4\nWARNING: Ignoring unknown function 'random",
      "vlm_response": null
    },
    {
      "object": "truncated tetrahedron",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 10,
      "code": "// Crane parameters\nheight = 100;\nwidth = 30;\ndepth = 40;\narm_length = 70;\narm_radius = 5;\nneck_radius = 5;\nhead_radius = 20;\nbase_width = 30;\nbase_depth = 30;\nbase_height = 20;\n\nmodule crane() {\n  difference() {\n    union() {\n      // Body\n      cube([width, depth, height]);\n\n      // Neck\n      translate([0, 0, height - neck_radius])\n      cylinder(r=neck_radius, h=neck_radius, center=false);\n\n      // Head\n      translate([width/2 - head_radius, depth/2 - head_radius, height - head_radius])\n      sphere(r=head_radius);\n\n      // Arm (Left)\n      translate([width/2 - arm_radius, depth/2 - arm_radius, height - arm_length])\n      cube([arm_radius, arm_radius, arm_length]);\n\n      // Arm (Right)\n      translate([width/2 - arm_radius, depth/2 - arm_radius, height - arm_length])\n      rotate([0,0,90])\n      cube([arm_radius, arm_radius, arm_length]);\n\n      // Base\n      translate([0, 0, -base_height])\n      cube([base_width, base_depth, base_height]);\n\n      // Base Connector\n      translate([width/2 - base_width/2, depth/2 - base_depth/2, 0])\n      cube([base_width, base_depth, base_height]);\n    }\n\n    // Cut out for feet\n    translate([0, -base_height, -base_height])\n    cube([base_width * 0.5, base_depth * 0.5, base_height * 1.5]);\n\n    // Cut out for legs\n    translate([0, -base_height * 0.8, -base_height * 1.2])\n    cube([width * 0.5, depth * 0.5, 10]);\n\n  }\n}\n\nmodule arm_cylinder() {\n  cylinder(r=arm_radius, h=arm_length);\n}\n\nmodule arm_cube() {\n  cube([arm_radius, arm_radius, arm_length]);\n}\n\nmodule head_sphere() {\n  sphere(r=head_radius);\n}",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: Geometries in cache: 1\nGeometry cache size in bytes: 0\nCGAL Polyhedrons in cache: 0\nCGAL cache size in bytes: 0\nTotal rendering time: 0:00:00.000\nCurrent top level object is empty.\n",
      "vlm_response": null
    },
    {
      "object": "cuboctahedron",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 46,
      "code": "// Vault Parameters\nvault_width = 100;\nvault_depth = 50;\nvault_height = 80;\nwall_thickness = 2;\ndoor_width = 25;\ndoor_height = 40;\ndoor_offset_x = 20;\ndoor_offset_y = 20;\n\nmodule vault() {\n  difference() {\n    cube([vault_width, vault_depth, vault_height]);\n    translate([wall_thickness, wall_thickness, 0])\n    cube([vault_width - 2 * wall_thickness, vault_depth - 2 * wall_thickness, vault_height]);\n  }\n}\n\nvault();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "truncated cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 93,
      "code": "module hexagon(size) {\n  polygon(points = [\n    [size * cos(30), size * sin(30)],\n    [size * cos(60), size * sin(60)],\n    [size * cos(90), size * sin(90)],\n    [size * cos(120), size * sin(120)],\n    [size * cos(150), size * sin(150)],\n    [size * cos(180), size * sin(180)]\n  ]);\n}\n\nlinear_extrude(height = 1)\nhexagon(size = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "truncated octahedron",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 27,
      "code": "module hexagon(size) {\n  linear_extrude(height = 1)\n  polygon(points = [\n    [size * cos(30), size * sin(30)],\n    [size * cos(60), size * sin(60)],\n    [size * cos(90), size * sin(90)],\n    [size * cos(120), size * sin(120)],\n    [size * cos(150), size * sin(150)],\n    [size * cos(180), size * sin(180)]\n  ]);\n}\n\nhexagon(size = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "radial pattern",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 61,
      "code": "module ring(radius, thickness, hole_radius) {\n  difference() {\n    cylinder(h = thickness, r = radius, $fn = 50);\n    cylinder(h = thickness + 0.1, r = hole_radius, center = true, $fn = 50);\n  }\n}\n\nring(radius = 20, thickness = 3, hole_radius = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "symmetrical star",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 42,
      "code": "// Stop Sign\n\n$fn = 50;\n\ndifference() {\n  union() {\n    // Main body\n    translate([0, 0, 0])\n    cube([20, 10, 15]);\n\n    // Stop lines\n    translate([5, 5, 15])\n    cube([12, 12, 8]);\n\n    translate([10, 10, 15])\n    cube([12, 12, 8]);\n\n    translate([5, 10, 15])\n    cube([12, 12, 8]);\n  }\n\n  // Remove the center\n  translate([0, 0, 0])\n  cube([10, 10, 10]);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "mandelbrot shape",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 86,
      "code": "module mandala(size = 10, detail = 16) {\n  for (i = [0:detail-1]) {\n    angle = i * 360 / detail;\n    translate([cos(angle), sin(angle), 0])\n      rotate([0, 0, 0])\n        circle(r = size * size / (1 + 2 * detail));\n  }\n}\n\nmodule mandala(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n}\n\nmodule mandala_smooth(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n}\n\nmodule mandala_complex(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          cylinder(h = 0.1, r1 = size * size / (1 + 2 * detail), r2 = size * size / (1 + 2 * detail), $fn = detail);\n    }\n}\n\n\ndifference() {\n  // Main mandala (simple)\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n\n  // Add some simple rounding for the base (optional)\n  for (i = [0:detail-1]) {\n    angle = i * 360 / detail;\n    translate([cos(angle), sin(angle), 0])\n      rotate([0, 0, 0])\n        circle(r = size * size / (1 + 2 * detail));\n  }\n}\n\n//module mandala(size = 10, detail = 16);\nmodule mandala(size = 10, detail = 16) {\n    linear_extrude(height = 1)\n      for (i = [0:detail-1]) {\n        angle = i * 360 / detail;\n        translate([cos(angle), sin(angle), 0])\n          rotate([0, 0, 0])\n            cylinder(h = 1, r = size * size / (1 + 2 * detail));\n      }\n}\ndifference() {\n    linear_extrude(height = 1)\n      for (i = [0:detail-1]) {\n        angle = i * 360 / detail;\n        translate([cos(angle), sin(angle), 0])\n          rotate([0, 0, 0])\n            cylinder(h = 1, r1 = size * size / (1 + 2 * detail), r2 = size * size / (1 + 2 * detail), $fn = detail);\n      }\n    \n    // Add some simple rounding for the base (optional)\n    for (i = [0:detail-1]) {\n        angle = i * 360 / detail;\n        translate([cos(angle), sin(angle), 0])\n          rotate([0, 0, 0])\n            cylinder(h = 0.2, r1 = size * size / (1 + 2 * detail), r2 = size * size / (1 + 2 * detail), $fn = detail);\n    }\n}\nmodule mandala(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n}\n\nmodule mandala(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n}\n\nmodule mandala_smooth(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n}\n\ndifference() {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n    \n  // Add some simple rounding for the base (optional)\n  for (i = [0:detail-1]) {\n    angle = i * 360 / detail;\n    translate([cos(angle), sin(angle), 0])\n      rotate([0, 0, 0])\n        cylinder(h = 0.2, r1 = size * size / (1 + 2 * detail), r2 = size * size / (1 + 2 * detail), $fn = detail);\n  }\n\n}\n\nmodule mandala(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n}\n\nmodule mandala_complex(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          cylinder(h = 0.1, r1 = size * size / (1 + 2 * detail), r2 = size * size / (1 + 2 * detail), $fn = detail);\n    }\n}\n\ndifference() {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n  \n  // Add some simple rounding for the base (optional)\n  for (i = [0:detail-1]) {\n    angle = i * 360 / detail;\n    translate([cos(angle), sin(angle), 0])\n      rotate([0, 0, 0])\n        cylinder(h = 0.2, r1 = size * size / (1 + 2 * detail), r2 = size * size / (1 + 2 * detail), $fn = detail);\n  }\n}\n\ndifference() {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n\n  // Add some simple rounding for the base (optional)\n  for (i = [0:detail-1]) {\n    angle = i * 360 / detail;\n    translate([cos(angle), sin(angle), 0])\n      rotate([0, 0, 0])\n        cylinder(h = 0.2, r1 = size * size / (1 + 2 * detail), r2 = size * size / (1 + 2 * detail), $fn = detail);\n  }\n}\n\nmodule mandala_smooth(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n}\n\nmodule mandala_complex(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          cylinder(h = 0.1, r1 = size * size / (1 + 2 * detail), r2 = size * size / (1 + 2 * detail), $fn = detail);\n    }\n}\n\nmodule mandala(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n}\n\ndifference() {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n  \n  // Add some simple rounding for the base (optional)\n  for (i = [0:detail-1]) {\n    angle = i * 360 / detail;\n    translate([cos(angle), sin(angle), 0])\n      rotate([0, 0, 0])\n        cylinder(h = 0.2, r1 = size * size / (1 + 2 * detail), r2 = size * size / (1 + 2 * detail), $fn = detail);\n  }\n\n}\n\nmodule mandala_smooth(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n}\n\nmodule mandala_complex(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          cylinder(h = 0.1, r1 = size * size / (1 + 2 * detail), r2 = size * size / (1 + 2 * detail), $fn = detail);\n    }\n}\n\nmodule mandala(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n}\n\nmodule mandala_complex(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          cylinder(h = 0.1, r1 = size * size / (1 + 2 * detail), r2 = size * size / (1 + 2 * detail), $fn = detail);\n    }\n}\n\n\ndifference() {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n  \n  // Add some simple rounding for the base (optional)\n  for (i = [0:detail-1]) {\n    angle = i * 360 / detail;\n    translate([cos(angle), sin(angle), 0])\n      rotate([0, 0, 0])\n        cylinder(h = 0.2, r1 = size * size / (1 + 2 * detail), r2 = size * size / (1 + 2 * detail), $fn = detail);\n  }\n\n}\n\nmodule mandala_smooth(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n}\n\nmodule mandala_complex(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          cylinder(h = 0.1, r1 = size * size / (1 + 2 * detail), r2 = size * size / (1 + 2 * detail), $fn = detail);\n    }\n}\n\nmodule mandala(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n}\n\ndifference() {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin(angle), 0])\n        rotate([0, 0, 0])\n          circle(r = size * size / (1 + 2 * detail));\n    }\n  \n  // Add some simple rounding for the base (optional)\n  for (i = [0:detail-1]) {\n    angle = i * 360 / detail;\n    translate([cos(angle), sin(angle), 0])\n      rotate([0, 0, 0])\n        cylinder(h = 0.2, r1 = size * size / (1 + 2 * detail), r2 = size * size / (1 + 2 * detail), $fn = detail);\n  }\n\n}\n\nmodule mandala_smooth(size = 10, detail = 16) {\n  linear_extrude(height = 1)\n    for (i = [0:detail-1]) {\n      angle = i * 360 / detail;\n      translate([cos(angle), sin",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: Parser error: syntax error in file evaluation/ThomasTheMaker_k-1b_20251029_131650/mandelbrot_shape.scad, line 355\nCan't parse file 'evaluation/ThomasTheMaker_k-1b_20251029_131650/mandelbrot_sha",
      "vlm_response": null
    },
    {
      "object": "radial lines",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 71,
      "code": "module ring(radius, height, thickness) {\n  linear_extrude(height = height)\n    circle(r = radius);\n}\n\nring(radius = 20, height = 10, thickness = 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "concentric rings",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 20,
      "code": "module washer(outer_diameter, inner_diameter, thickness) {\n  difference() {\n    cylinder(h = thickness, r = outer_diameter / 2, $fn = 32);\n    cylinder(h = thickness, r = inner_diameter / 2, $fn = 32);\n  }\n}\n\nwasher(outer_diameter = 50, inner_diameter = 25, thickness = 3);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "symmetric flower",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 43,
      "code": "// Butterfly in OpenSCAD\n\n// Parameters\nwing_width = 30;\nwing_height = 50;\nbody_width = 20;\nbody_height = 30;\nbody_depth = 10;\nbody_curve_radius = 15;\neye_diameter = 4;\neye_offset_x = 12;\neye_offset_y = 10;\n\nmodule wing(width, height, curve_radius) {\n    hull() {\n        translate([0, 0, 0]) cylinder(h=height/2, r1=curve_radius, r2=width/2, center=true);\n        translate([0, 0, height/2]) cylinder(h=height/2, r1=width/2, r2=width/2, center=true);\n    }\n}\n\nmodule body() {\n    cube([body_width, body_height, body_depth]);\n}\n\nmodule eye() {\n    sphere(eye_diameter);\n}\n\ndifference() {\n    body();\n    translate([body_width/2 - eye_offset_x, body_height/2 - eye_offset_y, body_depth/2]) eye();\n    translate([-body_width/2 + eye_offset_x, body_height/2 - eye_offset_y, body_depth/2]) eye();\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "mug",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 10,
      "code": "// Handle parameters\nhandle_length = 50;\nhandle_diameter = 15;\nhandle_wall_thickness = 3;\nhandle_cap_height = 5;\nhandle_cap_radius = 10;\n\ndifference() {\n  cylinder(h = handle_length - handle_cap_height, r = handle_diameter / 2, center = false);\n  translate([0, 0, handle_length - handle_cap_height]) {\n    cylinder(h = handle_cap_height, r = handle_cap_radius, center = false);\n  }\n  \n  // Add a small \"taper\" to the handle for easier printing\n  linear_extrude(height = handle_diameter) {\n    polygon(points=[[0,0],[handle_length - 5, handle_diameter/2], [5, handle_diameter/2]]);\n  }\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "fork",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 38,
      "code": "module fork(length = 100, width = 10, height = 10, bowl_radius = 20, bowl_height = 5) {\n  difference() {\n    union() {\n      // Handle\n      translate([0, 0, 0])\n      cylinder(h = height, r = width / 2, center = false);\n\n      // Bowl\n      translate([length - bowl_radius * 2, 0, 0])\n      cylinder(h = bowl_height, r = bowl_radius, center = false);\n    }\n\n    //Cut out a small hole for the handle\n    translate([length - bowl_radius * 2, 0, 0])\n    cylinder(h = bowl_height + 2, r = width / 2 + 1, center = false);\n  }\n}\n\nfork();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "cup",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 82,
      "code": "// Parameters\nradius = 10;\nheight = 5;\nthickness = 1;\n\n// Shell\ndifference() {\n  cylinder(h = height, r = radius, $fn = 100);\n  cylinder(h = height + 0.1, r = radius - thickness, $fn = 100);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "spoon",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 70,
      "code": "// Spoon Parameters\nhandle_length = 100;\nhandle_radius = 8;\nbowl_depth = 20;\nbowl_width = 50;\nbowl_thickness = 2;\nspoon_taper_angle = 20; // Degrees\n\n// Handle\nmodule spoon_handle() {\n    linear_extrude(height = handle_length - bowl_depth) {\n        circle(r = handle_radius);\n    }\n}\n\n// Bowl\nmodule spoon_bowl() {\n    linear_extrude(height = bowl_thickness) {\n        circle(r = bowl_width / 2);\n    }\n}\n\n// Combine Handle and Bowl\nmodule spoon() {\n    union() {\n        translate([0, 0, 0])\n        spoon_handle();\n        translate([0, 0, handle_length])\n        spoon_bowl();\n    }\n}\n\n// Render the spoon\nspoon();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "knife",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 44,
      "code": "// Knife parameters\nhandle_length = 100;\nhandle_width = 20;\nhandle_thickness = 5;\nblade_length = 60;\nblade_width = 25;\nblade_thickness = 2;\nblade_angle = 20; // Angle of the blade relative to the handle\n\nmodule knife() {\n  difference() {\n    union() {\n      // Handle\n      translate([0, 0, 0])\n      cube([handle_length, handle_width, handle_thickness]);\n\n      // Blade\n      translate([handle_length - blade_length / 2, 0, handle_thickness / 2]) {\n        rotate([0, 0, blade_angle])\n        cube([blade_length, blade_width, blade_thickness]);\n      }\n    }\n    \n    // Cutout for blade\n    translate([handle_length - blade_length / 2 - 10, 0, handle_thickness/2]) {\n        rotate([0, 0, 0])\n        cube([blade_length - 10, blade_width + 2, blade_thickness + 2]);\n    }\n  }\n}\n\nknife();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "bowl",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 71,
      "code": "module hemisphere(r) {\n  linear_extrude(height = r) {\n    circle(r = r);\n  }\n}\n\nhemisphere(r = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "plate",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 97,
      "code": "module shim(thickness, length, width, hole_diameter, hole_height) {\n  difference() {\n    cube([length, width, thickness]);\n    if (hole_diameter > 0) {\n      translate([length - hole_diameter/2, width - hole_diameter/2, thickness/2])\n        cylinder(h=hole_height, r=hole_diameter/2, $fn=50);\n    }\n  }\n}\n\nshim(thickness=2, length=50, width=20, hole_diameter=5, hole_height=5);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "glass",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 26,
      "code": "module cone(h, r1, r2) {\n  linear_extrude(height = h) {\n    circle(r = r1);\n    circle(r = r2);\n  }\n}\n\ncone(h = 10, r1 = 5, r2 = 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "bottle",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 45,
      "code": "module tube(radius, height, segments=64) {\n  cylinder(r=radius, h=height, $fn=segments);\n}\n\ntube(radius=10, height=20);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "wrench",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 85,
      "code": "module wedge(width, height, depth, angle, segments = 24) {\n  rotate([0,0,angle])\n  linear_extrude(height = depth)\n  polygon(points = [[0,0], [width, 0], [width/2, height]]);\n}\n\nwedge(width = 20, height = 10, depth = 5, angle = 45, segments = 24);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "hammer",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 91,
      "code": "// Knife Parameters\nhandle_length = 100;\nhandle_width = 20;\nhandle_thickness = 5;\nblade_length = 80;\nblade_width = 30;\nblade_thickness = 1.5;\nblade_angle = 20; // Angle of the blade from the handle\n\n// Handle\nmodule handle() {\n  cube([handle_length, handle_width, handle_thickness]);\n}\n\n// Blade\nmodule blade() {\n  rotate([0, 0, blade_angle])\n  translate([0, -blade_width/2, 0])\n  cube([blade_length, blade_width, blade_thickness]);\n}\n\ndifference() {\n  union() {\n    handle();\n    translate([0, 0, handle_thickness]) blade();\n  }\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "screwdriver",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 76,
      "code": "module brace(width, height, thickness, hole_diameter, hole_offset) {\n  difference() {\n    cube([width, height, thickness]);\n    translate([hole_offset, hole_offset, -0.1])\n    cylinder(h=thickness+0.2, r=hole_diameter/2, $fn=50);\n    translate([width - hole_offset, height - hole_offset, -0.1])\n    cylinder(h=thickness+0.2, r=hole_diameter/2, $fn=50);\n  }\n}\n\nbrace(width=50, height=20, thickness=5, hole_diameter=3, hole_offset=10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "pliers",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 83,
      "code": "module hook(width, height, depth, hook_angle, thickness) {\n  difference() {\n    union() {\n      // Main body\n      cube([width, height, depth]);\n\n      // Hook\n      translate([0, height, 0])\n        rotate([0, 90, 45])\n          linear_extrude(height = depth)\n            polygon(points=[[0,0], [width/2, height/2], [width/2, -height/2]]);\n    }\n    \n    // Hole for mounting\n    translate([width/4, height/4, -thickness/2])\n      cylinder(h = thickness + 1, r = 2, $fn = 32);\n  }\n}\n\nhook(width = 20, height = 10, depth = 5, hook_angle = 60, thickness = 3);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "ball",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 9,
      "code": "module sphere(r) {\n  sphere(r = r);\n}\n\nsphere(r = 10);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: Recursion detected calling module 'sphere' in file ball.scad, line 1\nTRACE: called by 'sphere' in file ball.scad, line 2\nTRACE: called by 'sphere' in file ball.scad, line 2\nTRACE: called by 'sp",
      "vlm_response": null
    },
    {
      "object": "saw",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 83,
      "code": "module brace(width, height, thickness, hole_diameter, hole_x, hole_y) {\n  difference() {\n    cube([width, height, thickness]);\n    translate([hole_x, hole_y, -0.1])\n      cylinder(h=thickness + 0.2, r=hole_diameter/2, $fn=64);\n  }\n}\n\nbrace(width=50, height=100, thickness=5, hole_diameter=8, hole_x=25, hole_y=20);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "drill",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 48,
      "code": "module shaft(diameter, height, taper_angle = 0) {\n  cylinder(h = height, d = diameter, center = false);\n  if (taper_angle > 0) {\n    linear_extrude(height = height - diameter, convexity = 10)\n    rotate_extrude(convexity = 10)\n    translate([0,0,height - diameter/2])\n    polygon(points = [[0,0], [diameter/2, diameter/2]]);\n  }\n}\n\nshaft(diameter = 10, height = 20);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "level",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 83,
      "code": "module slab(length, width, height) {\n  cube([length, width, height]);\n}\n\nslab(10, 5, 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "dice",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 81,
      "code": "// Dice Parameters\nouter_diameter = 60;\ninner_diameter = 45;\nthickness = 3;\nsegments = 64;\n\n// Calculate radii\nouter_radius = outer_diameter / 2;\ninner_radius = inner_diameter / 2;\n\n// Dice Body\ndifference() {\n  cylinder(h = thickness, r = outer_radius, $fn = segments);\n  cylinder(h = thickness, r = inner_radius, $fn = segments);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "cone target",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 74,
      "code": "module pyramid(base_width, base_depth, base_height, side_length, angle) {\n  polyhedron(\n    points=[\n      [0, 0, 0],\n      [base_width, 0, 0],\n      [base_width, base_height, 0],\n      [0, base_height, 0],\n      [base_width / 2, base_height / 2, side_length]\n    ],\n    faces=[\n      [0, 1, 4],\n      [1, 2, 4],\n      [2, 3, 4],\n      [3, 0, 4],\n      [0, 1, 2, 3]\n    ]\n  );\n}\n\npyramid(base_width = 50, base_depth = 40, base_height = 50, side_length = 60, angle = 45);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "pyramid stack",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 94,
      "code": "module pyramid(base_width, base_depth, base_height, height, angle) {\n  \n  translate([0, 0, 0]) {\n    rotate([0, 0, angle]) {\n      linear_extrude(height = height) {\n        polygon(points = [\n          [0, 0],\n          [base_width, 0],\n          [base_width, base_height],\n          [0, base_height]\n        ]);\n      }\n    }\n  }\n  \n  linear_extrude(height = height) {\n    polygon(points = [\n      [0, 0],\n      [base_width, 0],\n      [base_width, base_height],\n      [0, base_height]\n    ]);\n  }\n}\n\npyramid(base_width = 50, base_depth = 50, base_height = 30, height = 30, angle = 45);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "ring target",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 99,
      "code": "// Parameters\ninner_diameter = 50;\nouter_diameter = 80;\nheight = 10;\nwall_thickness = 2;\n\n// Calculate inner and outer radii\ninner_radius = inner_diameter / 2;\nouter_radius = outer_diameter / 2;\n\n// Create the outer cylinder\ndifference() {\n  cylinder(h = height, r = outer_radius, center = false);\n  cylinder(h = height + 0.1, r = inner_radius, center = false);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "puzzle piece",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 42,
      "code": "module wedge(width, height, depth, angle) {\n  linear_extrude(height = depth) {\n    polygon([\n      [0, 0],\n      [width, 0],\n      [width, height],\n      [0, height]\n    ]);\n  }\n}\n\nwedge(width = 20, height = 10, depth = 5, angle = 30);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "puzzle connector",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 78,
      "code": "module connector(width, height, depth, hole_diameter, hole_height) {\n  difference() {\n    cube([width, height, depth]);\n    translate([width/4, height/4, depth/4])\n    cylinder(h=hole_height, r=hole_diameter/2, $fn=50);\n  }\n}\n\nconnector(width=50, height=30, depth=10, hole_diameter=8, hole_height=5);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "interlocking piece",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 70,
      "code": "module fitting(width, height, depth, hole_diameter, hole_height, wall_thickness) {\n  difference() {\n    cube([width, height, depth]);\n\n    // Hole 1\n    translate([width/4, height/4, depth/2])\n    cylinder(h=hole_height, r=hole_diameter/2);\n\n    // Hole 2\n    translate([width/4, height/4, -depth/2])\n    cylinder(h=hole_height, r=hole_diameter/2);\n  }\n}\n\nfitting(width=50, height=20, depth=10, hole_diameter=5, hole_height=2, wall_thickness=2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "puzzle cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 97,
      "code": "// Vault Parameters\nvault_width = 30;\nvault_height = 20;\nvault_depth = 10;\nwall_thickness = 2;\ndoor_width = 15;\ndoor_height = 10;\ndoor_clearance = 1;\nkeyhole_diameter = 3;\nkeyhole_height = 5;\nkeyhole_offset_x = 2;\nkeyhole_offset_y = 2;\n\n// Vault Body\nmodule vault_body() {\n    cube([vault_width, vault_height, vault_depth]);\n}\n\n// Vault Door\nmodule vault_door() {\n    translate([0,0,0])\n    cube([door_width, door_height, vault_depth]);\n}\n\n// Vault Keyhole\nmodule vault_keyhole() {\n    translate([keyhole_offset_x, keyhole_offset_y, vault_depth - keyhole_height / 2])\n    cylinder(h = keyhole_height, r = keyhole_diameter / 2, $fn=60);\n}\n\n// Walls\nmodule walls() {\n    difference() {\n        vault_body();\n        translate([0, -1, 0]) {\n            cube([vault_width, wall_thickness, vault_depth]);\n        }\n    }\n}\n\n// Keyhole\nvault_keyhole();\n\n// Walls with Keyhole Cutout\ndifference() {\n    vault_body();\n    translate([0, -1, 0]) {\n        cube([vault_width, wall_thickness, vault_depth]);\n    }\n    translate([0, -1, 0]) {\n        cube([door_width, wall_thickness, vault_depth]);\n    }\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "leaf",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 24,
      "code": "module leaf(length = 50, width = 20, thickness = 2, angle = 30) {\n  difference() {\n    hull() {\n      translate([0, 0, 0])\n      cube([length, width, thickness]);\n      translate([length - 1, -width/2, -thickness/2])\n      rotate([0, 0, angle])\n      cube([1, width, thickness]);\n    }\n    \n    if (length < 10) {\n        translate([length - 1, 10, 0])\n        linear_extrude(height = 1)\n        polygon(points=[[0, 0], [10, 0], [10, 10], [0, 10]]);\n    }\n  }\n}\n\nleaf();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "tree",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 47,
      "code": "module pin(height, diameter, wall_thickness, head_diameter) {\n  difference() {\n    cylinder(h = height, d = diameter, center = false);\n    translate([0, 0, height - wall_thickness])\n    cylinder(h = wall_thickness, d = diameter - 2 * wall_thickness, center = false);\n  }\n\n  translate([0, 0, height])\n  cylinder(h = head_diameter, d = 20, center = false);\n}\n\npin(height = 20, diameter = 6, wall_thickness = 1, head_diameter = 8);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "shell",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 41,
      "code": "module hemisphere(r) {\n  rotate_extrude(convexity = 10) {\n    translate([0,0,r])\n    circle(r = r);\n  }\n}\n\nhemisphere(r = 10);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: all points for rotate_extrude() must have the same X coordinate sign (range is -1.05 -> 10.00)\nGeometries in cache: 3\nGeometry cache size in bytes: 1120\nCGAL Polyhedrons in cache: 0\nCGAL cache ",
      "vlm_response": null
    },
    {
      "object": "branch",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 85,
      "code": "module pin(length, diameter, height, thread_height, thread_diameter) {\n  difference() {\n    cylinder(h = height, d = diameter, $fn = 32);\n    translate([0, 0, height - thread_height]) {\n      cylinder(h = thread_height, d = thread_diameter, $fn = 32);\n    }\n  }\n}\n\npin(length = 20, diameter = 3, height = 5, thread_height = 2, thread_diameter = 3.5);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "coral",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 70,
      "code": "module dolphin(length = 50, height = 30, width = 20, fin_height = 20) {\n  difference() {\n    union() {\n      // Body\n      hull() {\n        translate([0, 0, 0])\n        sphere(r = length / 2);\n      }\n\n      // Dorsal Fin\n      translate([length / 2, 0, 0])\n      rotate([0, 0, 30])\n      cube([width / 2, fin_height, height / 2], center = true);\n\n      // Pectoral Fin (left)\n      translate([length / 2 - width / 2, -width / 2, 0])\n      rotate([0, 0, 45])\n      cube([width / 2, height / 2, fin_height], center = true);\n\n      // Pectoral Fin (right)\n      translate([length / 2 - width / 2, width / 2, 0])\n      rotate([0, 0, -45])\n      cube([width / 2, height / 2, fin_height], center = true);\n\n      // Tail\n      translate([length / 2, -width / 2, 0])\n      rotate([0, 0, -30])\n      cube([width, height, fin_height], center = true);\n\n      // Dorsal Fin (back)\n      translate([length / 2, 0, 0])\n      rotate([0, 0, 150])\n      cube([width / 2, fin_height, height / 2], center = true);\n\n      // Eye\n      translate([length / 2, 0, 0])\n      sphere(r = 3);\n    }\n\n    // Smooth out edges (optional)\n    hull() {\n      for (i = [0:1:2]) {\n        for (j = [0:1:2]) {\n          translate([i * length / 2, j * height / 2, 0])\n          cube([1, 1, 1], center = true);\n        }\n      }\n    }\n  }\n}\n\ndolphin();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "wave packet",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 85,
      "code": "module wave(amplitude, frequency, wavelength, height, segments = 64) {\n  linear_extrude(height = height) {\n    rotate_extrude(convexity = 0)\n    translate([amplitude * cos(frequency / (2 * PI)), amplitude * sin(frequency / (2 * PI)), 0])\n    circle(r = height / 2);\n  }\n}\n\nwave(amplitude = 10, frequency = 2, wavelength = 1);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: WARNING: undefined operation (undefined / number) in file wave_packet.scad, line 5\nWARNING: Ignoring 3D child object for 2D operation in file wave_packet.scad, line 3\nGeometries in cache: 4\nGeometry c",
      "vlm_response": null
    },
    {
      "object": "nautilus",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 61,
      "code": "// Butterfly in OpenSCAD\n\nmodule butterfly(size = 100) {\n  difference() {\n    union() {\n      // Body\n      cylinder(h = 20, r = size * 0.4, center = true);\n\n      // Wings (left)\n      translate([size * 0.3, -size * 0.2, 0]) {\n        rotate([0, 0, -45]) {\n          linear_extrude(height = 10)\n          polygon(points = [\n            [size * 0.2, size * 0.1],\n            [size * 0.8, size * 0.4],\n            [size * 0.8, size * 0.8],\n            [size * 0.2, size * 0.1]\n          ]);\n        }\n\n        translate([size * 0.3, -size * 0.2, 0]) {\n          rotate([0, 0, 45]) {\n            linear_extrude(height = 10)\n            polygon(points = [\n              [size * 0.2, size * 0.1],\n              [size * 0.8, size * 0.4],\n              [size * 0.8, size * 0.8],\n              [size * 0.2, size * 0.1]\n            ]);\n          }\n        }\n      }\n\n      // Legs (left)\n      translate([size * 0.1, -size * 0.3, -size * 0.2]) {\n        cube([size * 0.1, size * 0.1, 2]);\n      }\n\n      translate([size * 0.1, -size * 0.3, -size * 0.2]) {\n        cube([size * 0.1, size * 0.1, 2]);\n      }\n      \n      translate([size * 0.2, -size * 0.3, -size * 0.2]) {\n        cube([size * 0.1, size * 0.1, 2]);\n      }\n\n      translate([size * 0.2, -size * 0.3, -size * 0.2]) {\n        cube([size * 0.1, size * 0.1, 2]);\n      }\n      \n      // Tail\n      translate([0, -size * 0.3, -size * 0.3]) {\n        cube([size * 0.3, size * 0.1, 2]);\n      }\n\n    }\n  }\n}\n\nbutterfly(size = 50);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "interference pattern",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 53,
      "code": "module tile(width, depth, height, tile_thickness) {\n  difference() {\n    cube([width, depth, height]);\n    translate([0, 0, 0.1]) cube([width - 2, depth - 2, height - 0.2]);\n  }\n}\n\ntile(50, 50, 5, 1);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "checkerboard",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 9,
      "code": "// Checkerboard parameters\nsquare_size = 10;\nsquare_spacing = 1;\nboard_width = 40;\nboard_height = 20;\nnum_squares = 16;\n\nmodule checkerboard() {\n  for (i = [0:num_squares - 1]) {\n    for (j = [0:num_squares - 1]) {\n      translate([-square_size / 2, -square_size / 2, -square_spacing * i / (num_squares + 1) / 2]) {\n        if (i % 2 == 0 && j % 2 == 0) {\n          cube([square_size, square_size, 1]);\n        } else {\n          cube([square_size, square_size, 1]);\n        }\n      }\n    }\n  }\n}\n\ncheckerboard();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "gradient shape",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 86,
      "code": "module gradient(width, height, depth, gradient_start, gradient_end, gradient_angle) {\n  linear_extrude(height = depth)\n  {\n    circle(r = 1);\n  }\n  linear_extrude(height = depth)\n  {\n    circle(r = 1);\n  }\n  linear_extrude(height = depth)\n  {\n    circle(r = 1);\n  }\n  linear_extrude(height = depth)\n  {\n    circle(r = 1);\n  }\n  linear_extrude(height = depth)\n  {\n    circle(r = 1);\n  }\n  linear_extrude(height = depth)\n  {\n    circle(r = 1);\n  }\n  linear_extrude(height = depth)\n  {\n    circle(r = 1);\n  }\n  linear_extrude(height = depth)\n  {\n    circle(r = 1);\n  }\n  linear_extrude(height = depth)\n  {\n    circle(r = 1);\n  }\n  linear_extrude(height = depth)\n  {\n    circle(r = 1);\n  }\n  linear_extrude(height = depth)\n  {\n    circle(r = 1);\n  }\n  linear_extrude(height = depth)\n  {\n    circle(r = 1);\n  }\n\n  translate([0, 0, -depth/2])\n  {\n    linear_extrude(height = depth)\n    {\n      circle(r = 1);\n    }\n  }\n\n}\n\n// Example usage:\ngradient(width = 100, height = 50, depth = 10, gradient_start = 20, gradient_end = 80, gradient_angle = 30);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "striped pattern",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 13,
      "code": "module octagon(radius, height) {\n  linear_extrude(height = height)\n    polygon(points = [\n      [radius * cos(360 / 2), radius * sin(360 / 2)],\n      [radius * cos(360 / 2 + 360 / 10), radius * sin(360 / 2 + 360 / 10)],\n      [radius * cos(360 / 2 + 360 / 10 + 360 / 20), radius * sin(360 / 2 + 360 / 20)],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 20), radius * sin(360 / 2 + 360 / 2 + 360 / 20)],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 20 + 360 / 20), radius * sin(360 / 2 + 360 / 2 + 360 / 2 + 360 / 20)],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 20 + 360 / 20 + 360 / 20), radius * sin(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 20)],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 20 + 360 / 20 + 360 / 20],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2],\n      [radius * cos(360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 360 / 2 + 36",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: Parser error: syntax error in file evaluation/ThomasTheMaker_k-1b_20251029_131650/striped_pattern.scad, line 10\nCan't parse file 'evaluation/ThomasTheMaker_k-1b_20251029_131650/striped_pattern.",
      "vlm_response": null
    },
    {
      "object": "chamfered cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 71,
      "code": "// Adjustable Parameters\nwall_thickness = 2;\nheight = 50;\nwidth = 100;\ndepth = 80;\nhole_diameter = 20;\nhole_depth = 30;\nhole_offset_x = 15;\nhole_offset_y = 10;\n\n// Main Body\ndifference() {\n  cube([width, depth, height]);\n  translate([width/2, depth/2, 0])\n    cylinder(h=height, r=width/2 + wall_thickness, center=true);\n}\n\n// Hole\ntranslate([width/2, depth/2, 0]) {\n  cylinder(h=hole_depth, r=hole_diameter/2, center=true);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "rounded cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 98,
      "code": "module shell(width, depth, height, thickness, rounds) {\n  difference() {\n    cube([width, depth, height]);\n    for (i = [0:thickness/2]) {\n      translate([0, 0, -i * thickness/2])\n        cylinder(r=rounds, h=thickness, $fn=50);\n    }\n  }\n}\n\nshell(width=50, depth=30, height=20, thickness=3, rounds=2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "beveled cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 24,
      "code": "module brace(width, height, thickness, hole_diameter, hole_offset) {\n  difference() {\n    cube([width, height, thickness]);\n    translate([hole_offset, height/2, 0]) cylinder(h=thickness, r=hole_diameter/2);\n    translate([width - hole_offset, height/2, 0]) cylinder(h=thickness, r=hole_diameter/2);\n  }\n}\n\nbrace(width=50, height=100, thickness=10, hole_diameter=5, hole_offset=10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "crystal",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 75,
      "code": "module dome(radius, height, segments = 32) {\n  hull() {\n    for (i = [0:segments]) {\n      angle = i * 360 / segments;\n      translate([radius * cos(angle), radius * sin(angle), 0]) {\n        sphere(r = radius * 0.5, $fn = segments);\n      }\n    }\n  }\n}\n\n// Example usage:\ndome(radius = 20, height = 15);",
      "inference_error": null,
      "render_error": "Rendering timeout (>60s)",
      "vlm_response": null
    },
    {
      "object": "snowflake",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 17,
      "code": "module snowflake(size = 20, detail = 32) {\n  // Parameters\n  size = size;\n  detail = detail;\n\n  // Function to create a single snowflake line\n  module snowflake_line(x, y, angle) {\n    translate([x, y, 0]) {\n      scale([1, 1, 1.5]) {\n        rotate([0, 0, angle])\n        linear_extrude(height = size)\n        polygon(points = [\n          [0, 0],\n          [size/2, 0],\n          [size/2, size],\n          [size/2, size],\n          [0, size]\n        ]);\n      }\n    }\n  }\n\n  // Main snowflake body\n  difference() {\n    union() {\n      for (i = [0:detail]) {\n        for (j = [0:detail]) {\n          snowflake_line(\n            i * size / detail,\n            j * size / detail,\n            i * 360 / detail\n          );\n        }\n      }\n    }\n    \n    // Hollow out the snowflake\n    translate([0,0,-size/2])\n    cube([size,size,size]);\n  }\n}\n\nsnowflake(size = 50, detail = 48);",
      "inference_error": null,
      "render_error": "Rendering timeout (>60s)",
      "vlm_response": null
    },
    {
      "object": "bilateral symmetry",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 93,
      "code": "// Mirror Parameters\nmirror_width = 100;\nmirror_height = 50;\nmirror_thickness = 2;\n\n// Mirror Body\ndifference() {\n  cube([mirror_width, mirror_height, mirror_thickness]);\n  translate([0, 0, -0.1]) cube([mirror_width + 0.2, mirror_height + 0.2, mirror_thickness + 0.2]);\n}\n\n// Optional:  Add a small hole in the center for mounting.  Comment out if not needed.\n/*\ntranslate([50, 10, 20])\ncube([20, 20, 10]);\n*/",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: Geometries in cache: 3\nGeometry cache size in bytes: 2184\nCGAL Polyhedrons in cache: 1\nCGAL cache size in bytes: 0\nTotal rendering time: 0:00:00.021\nCurrent top level object is empty.\n",
      "vlm_response": null
    },
    {
      "object": "sliced cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 7,
      "code": "module brick(width, height, depth, wall_thickness) {\n  difference() {\n    cube([width, height, depth]);\n    translate([wall_thickness, wall_thickness, wall_thickness])\n    cube([width - 2 * wall_thickness, height - 2 * wall_thickness, depth - 2 * wall_thickness]);\n  }\n}\n\nbrick(50, 30, 20, 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "rotated cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 78,
      "code": "module prism(width, height, depth, angle) {\n  translate([0, 0, 0]) {\n    rotate([0, 0, angle]) {\n      cube([width, height, depth]);\n    }\n  }\n}\n\nprism(20, 10, 5, 30);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "radial symmetry",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 88,
      "code": "// Screw Parameters\nscrew_diameter = 6;\nscrew_length = 10;\nthread_diameter = 3.5;\nthread_length = 20;\npitch = 1.25;\nhole_diameter = 1.5;\n\n// Thread Generation\nthread_height = 0.5;\nthread_angle = 30; // Degrees\n\nmodule screw_thread(diameter, length, pitch, angle) {\n    linear_extrude(height = length) {\n        rotate_extrude(angle = 360 * angle, convexity = 10)\n        translate([diameter/2,0,0])\n            polygon(points=[\n                [0, 0],\n                [length, 0],\n                [0, length],\n                [0, 0]\n            ]);\n    }\n}\n\nmodule screw() {\n    difference() {\n        cylinder(h = screw_length, r = screw_diameter/2, $fn = 50);\n        \n        translate([0,0,-0.1])\n        cylinder(h = screw_length + 0.2, r = thread_diameter/2, $fn = 50);\n        \n        translate([0,0,0])\n        rotate([0,0,0])\n        screw_thread(thread_diameter, thread_length, pitch, thread_angle);\n    }\n}\n\nscrew();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "mirror symmetry",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 23,
      "code": "module mirror(width, height, thickness) {\n  difference() {\n    cube([width, height, thickness]);\n    translate([width/4, height/4, thickness/2])\n    cube([width/2, height/2, thickness]);\n  }\n}\n\nmirror(width = 100, height = 50, thickness = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "tiny cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 29,
      "code": "module prism(width, height, length, angle) {\n  difference() {\n    cube([width, height, length]);\n    translate([0, 0, length]) {\n      rotate([0, 0, angle])\n        cube([width, height, 1]);\n    }\n  }\n}\n\nprism(20, 10, 30, 45);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "rotational symmetry",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 34,
      "code": "// Rack Dimensions\nrack_width = 1000;\nrack_height = 2000;\nrack_depth = 500;\n\n// Panel Dimensions\npanel_width = 1000;\npanel_height = 500;\npanel_depth = 500;\n\n// Screw Hole Dimensions (adjust as needed)\nscrew_hole_diameter = 6;\nscrew_hole_depth = 5;\n\n// Rail Thickness\nrail_thickness = 20;\n\n// Number of Rail Supports (adjust as needed)\nrail_support_width = 10;\n\n// Rail Support Height\nrail_support_height = 100;\n\n// Rail Height\nrail_height = 50;\n\n// Corner radius\ncorner_radius = 10;\n\nmodule rack() {\n  // Base\n  cube([rack_width, rack_height, rack_depth]);\n\n  // Panels\n  translate([0, 0, 0]) {\n    cube([panel_width, panel_height, panel_depth]);\n  }\n\n  translate([0, 0, 0]) {\n    cube([panel_width, panel_height, panel_depth]);\n  }\n\n  translate([0, 0, 0]) {\n    cube([panel_width, panel_height, panel_depth]);\n  }\n\n  translate([0, 0, 0]) {\n    cube([panel_width, panel_height, panel_depth]);\n  }\n\n  // Corner Posts\n  translate([0, 0, 0]) {\n    cube([rail_support_width, rail_height, rail_thickness]);\n    translate([0, 0, 0]) {\n        cube([rail_support_width, rail_height, rail_thickness]);\n        translate([0, 0, 0]) {\n            cube([rail_support_width, rail_height, rail_thickness]);\n            translate([0, 0, 0]) {\n                cube([rail_support_width, rail_height, rail_thickness]);\n            }\n        }\n    }\n  }\n}\n\nmodule screw_hole() {\n  cylinder(h=screw_hole_depth, r=screw_hole_diameter/2, $fn=60);\n}\n\nmodule rail_support() {\n  cube([rail_support_width, rail_height, rail_support_height]);\n}\n\n// Render the rack\nrack();\n\n// Render screws (example - adjust as needed)\n//translate([10, 10, 10])\n//cylinder(h=10, r=1, $fn=60);\n//translate([10, 10, 10])\n//cylinder(h=10, r=1, $fn=60);\n\n// Render rails (example - adjust as needed)\n//translate([10, 10, 0])\n//rail_support();\n//translate([10, 10, 10])\n//rail_support();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "small cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 29,
      "code": "module block(width, depth, height) {\n  cube([width, depth, height]);\n}\n\nblock(10, 5, 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "medium cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 94,
      "code": "// Customizable parameters\nwall_thickness = 2;\nheight = 50;\nwidth = 100;\ndepth = 50;\nhole_diameter = 10;\nhole_height = 20;\n\nmodule mounting_plate(width, depth, height, thickness) {\n  difference() {\n    cube([width, depth, height]);\n    translate([width/4, depth/4, 0])\n    cube([width/2, depth/2, height]);\n  }\n}\n\nmodule mounting_plate_with_hole(width, depth, height, thickness, hole_diameter, hole_height) {\n  difference() {\n    mounting_plate(width, depth, height, thickness);\n    translate([width/4, depth/4, 0])\n    cylinder(h=hole_height, r=hole_diameter/2, $fn=30);\n  }\n}\n\n\n// Main assembly\nmounting_plate_with_hole(width, depth, height, wall_thickness, hole_diameter, hole_height);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "large cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 31,
      "code": "module box(width, depth, height) {\n  cube([width, depth, height]);\n}\n\nbox(10, 5, 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "huge cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 56,
      "code": "module box(width, depth, height) {\n  cube([width, depth, height]);\n}\n\nbox(10, 5, 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "giant cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 62,
      "code": "module box(width, depth, height) {\n  cube([width, depth, height]);\n}\n\nbox(10, 5, 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "thin wall",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 83,
      "code": "module separator(width, height, thickness) {\n  difference() {\n    cube([width, height, thickness]);\n    translate([1, 1, 1]) cube([width - 2, height - 2, thickness - 2]);\n  }\n}\n\nseparator(width = 10, height = 5, thickness = 1);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "thick wall",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 96,
      "code": "module bolt(head_diameter, head_height, shank_diameter, shank_height, thread_diameter, thread_length) {\n  difference() {\n    union() {\n      // Head\n      cylinder(h = head_height, d = head_diameter);\n\n      // Shank\n      translate([0, 0, head_height])\n        cylinder(h = shank_height, d = shank_diameter);\n    }\n\n    // Threads\n    translate([0, 0, -thread_length])\n      rotate_extrude(angle = 360)\n        translate([0, 0, -thread_length])\n          square(0.1);\n  }\n\n  // Optional: Add a small fillet for better aesthetics (uncomment to enable)\n  // fillet(size = 1, height = 1.5);\n}\n\nbolt(head_diameter = 10, head_height = 2, shank_diameter = 2, shank_height = 2, thread_diameter = 1.2, thread_length = 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "medium wall",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 84,
      "code": "module tube(radius, height, segments = 32) {\n  linear_extrude(height = height, convexity = 1)\n    circle(r = radius);\n}\n\ntube(radius = 10, height = 20);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "cube with pyramid",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 9,
      "code": "module pyramid(base_width, base_depth, base_height, side_length) {\n  difference() {\n    cube([side_length, side_length, base_height]);\n    translate([0, 0, -1])\n    cube([side_length, side_length, base_height + 1]);\n  }\n}\n\npyramid(50, 50, 100, 50);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: Geometries in cache: 3\nGeometry cache size in bytes: 2184\nCGAL Polyhedrons in cache: 1\nCGAL cache size in bytes: 0\nTotal rendering time: 0:00:00.020\nCurrent top level object is empty.\n",
      "vlm_response": null
    },
    {
      "object": "solid",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 72,
      "code": "module pin(length, diameter, wall_thickness, head_diameter, head_height) {\n  difference() {\n    cylinder(h = length, d = diameter, center = false);\n    cylinder(h = length - 0.1, d = diameter - wall_thickness, center = false);\n    translate([0, 0, length - head_height]) cylinder(h = head_height, d = head_diameter, center = false);\n  }\n}\n\npin(length = 20, diameter = 3, wall_thickness = 0.5, head_diameter = 6, head_height = 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "shell",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 91,
      "code": "module arch(width, height, depth, radius, segments = 32) {\n  difference() {\n    hull() {\n      for (i = [0:segments-1]) {\n        angle = i * 360 / segments;\n        translate([radius * cos(angle), radius * sin(angle), 0]) {\n          rotate([0, 0, angle]) {\n            cube([width, height, depth], center = true);\n          }\n        }\n      }\n    }\n    translate([0, 0, -0.1]) {\n      cube([width, height, depth + 0.1], center = true);\n    }\n  }\n}\n\narch(width = 50, height = 30, depth = 20, radius = 15);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "sphere with cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 32,
      "code": "module hemisphere(r) {\n  linear_extrude(height = r) {\n    circle(r = r);\n  }\n}\n\nhemisphere(r = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "cylinder with cone",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 53,
      "code": "cylinder(h=10, r=2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "hollow",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 95,
      "code": "// Case parameters\ncase_width = 100;\ncase_depth = 50;\ncase_height = 25;\nwall_thickness = 2;\ninner_clearance = 0.5; // Clearance from inner walls\n\n// Rounded corner radius\ncorner_radius = 10;\n\nmodule case_body() {\n  difference() {\n    cube([case_width, case_depth, case_height]);\n    translate([wall_thickness, wall_thickness, wall_thickness])\n    cube([case_width - 2 * wall_thickness, case_depth - 2 * wall_thickness, case_height - 2 * wall_thickness]);\n  }\n}\n\nmodule case_walls() {\n  difference() {\n    case_body();\n    translate([0,0,case_height - wall_thickness])\n    cube([case_width, case_depth, wall_thickness]);\n    translate([case_width - wall_thickness, 0, case_height - wall_thickness])\n    cube([case_width, case_depth, wall_thickness]);\n  }\n}\n\nmodule rounded_corners() {\n  difference() {\n    case_body();\n    translate([0, 0, -0.1])\n    cylinder(r = corner_radius, h = case_height, $fn = 50);\n    translate([case_width - corner_radius, 0, 0])\n    cylinder(r = corner_radius, h = case_height, $fn = 50);\n    translate([0, case_depth - corner_radius, 0])\n    cylinder(r = corner_radius, h = case_height, $fn = 50);\n    translate([case_width - corner_radius, case_depth - corner_radius, 0])\n    cylinder(r = corner_radius, h = case_height, $fn = 50);\n  }\n}\n\nmodule case() {\n  case_body();\n  case_walls();\n  rounded_corners();\n}\n\n// Render the case\ncase();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "torus with sphere",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 88,
      "code": "module torus(major_radius, minor_radius, $fn = 50) {\n  rotate_extrude(convexity = 10)\n  translate([major_radius, 0, 0])\n  circle(r = minor_radius);\n}\n\ntorus(major_radius = 50, minor_radius = 2, $fn = 50);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "union shape",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 92,
      "code": "module arch(width, height, depth, radius, height_offset) {\n  difference() {\n    cube([width, height, depth]);\n    translate([0, height_offset, 0])\n    cube([width, height, depth]);\n  }\n}\n\narch(width = 50, height = 30, depth = 10, radius = 10, height_offset = 5);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "difference shape",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 8,
      "code": "module pyramid(base_width, base_depth, base_height, side_length) {\n  polyhedron(\n    points = [\n      [0, 0, 0],\n      [base_width, 0, 0],\n      [base_width, base_depth, 0],\n      [0, base_depth, 0],\n      [base_width/2, base_depth/2, side_length]\n    ],\n    faces = [\n      [0, 1, 4],\n      [1, 2, 4],\n      [2, 3, 4],\n      [3, 0, 4],\n      [0, 1, 2, 3]\n    ]\n  );\n}\n\npyramid(base_width = 30, base_depth = 20, base_height = 15, side_length = 50);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "shape with cavity",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 76,
      "code": "module tube(radius, height, segments) {\n  cylinder(r = radius, h = height, $fn = segments);\n}\n\ntube(radius = 10, height = 20, segments = 60);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "shape with indent",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 66,
      "code": "module button(width, height, depth, radius, hole_diameter) {\n  difference() {\n    cube([width, height, depth]);\n    translate([width/4, height/4, -0.5])\n      cylinder(h = depth + 0.5, r = radius, $fn = 50);\n    translate([width/4, height/4, -0.5])\n      cylinder(h = depth + 0.5, r = radius, $fn = 50);\n  }\n  if (hole_diameter > 0) {\n    translate([width/2 - hole_diameter/2, height/2 - hole_diameter/2, depth/2 - hole_diameter/2])\n      cylinder(h = hole_diameter, r = hole_diameter, $fn = 50);\n  }\n}\n\nbutton(width = 40, height = 20, depth = 10, radius = 5, hole_diameter = 3);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes. the image shows an object that appears to have indentation in it, as indicated by the shape and shadow of the bed or mattress within the larger structure."
    },
    {
      "object": "intersection shape",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 79,
      "code": "module crossbar(width, height, bar_width, bar_height, spacing) {\n  difference() {\n    cube([width, height, bar_height]);\n    \n    for (i = [0:width*height/bar_height]) {\n      translate([i, 0, 0]) {\n        cube([bar_width, bar_height, height]);\n      }\n    }\n  }\n}\n\ncrossbar(width = 50, height = 30, bar_width = 10, bar_height = 5, spacing = 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "hollowed out",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 66,
      "code": "module shell(thickness, width, length, height, fillet_radius) {\n  difference() {\n    cube([width, length, height]);\n    translate([thickness, 0, 0]) {\n      cube([width - 2 * thickness, length - 2 * thickness, height]);\n    }\n  }\n\n  for (i = [0:1]) {\n    for (j = [0:1]) {\n      if (i == 0 && j == 0) {\n        translate([0, 0, 0]) {\n          rotate([90, 0, 0]) {\n            translate([width/2, 0, height/2]) {\n              cylinder(r = fillet_radius, $fn=32);\n            }\n          }\n        }\n      } else if (i == 1 && j == 0) {\n        translate([length/2, 0, 0]) {\n          rotate([90, 0, 0]) {\n            translate([width/2, 0, height/2]) {\n              cylinder(r = fillet_radius, $fn=32);\n            }\n          }\n        }\n      } else if (i == 1 && j == 1) {\n        translate([length/2, length/2, 0]) {\n          rotate([90, 0, 0]) {\n            translate([width/2, 0, height/2]) {\n              cylinder(r = fillet_radius, $fn=32);\n            }\n          }\n        }\n      } else if (i == 0 && j == 1) {\n        translate([width/2, length/2, 0]) {\n          rotate([90, 0, 0]) {\n            translate([width/2, 0, height/2]) {\n              cylinder(r = fillet_radius, $fn=32);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n// Example usage:\nshell(thickness = 1, width = 50, length = 80, height = 60, fillet_radius = 5);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "with negative space",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 92,
      "code": "module step(height, width, depth, angle) {\n  difference() {\n    cube([width, depth, height]);\n    translate([width/4, depth/4, 0])\n      rotate([0, angle, 0])\n      cube([width/2, depth/2, height]);\n  }\n}\n\nstep(height = 10, width = 20, depth = 50, angle = 15);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "layered cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 71,
      "code": "module prism(width, height, depth, angle) {\n  difference() {\n    cube([width, height, depth]);\n    translate([0, 0, -depth/2])\n    rotate([0, 0, angle])\n    translate([0, height/2, -depth/2])\n    cube([width, height, depth]);\n  }\n}\n\nprism(width = 50, height = 30, depth = 20, angle = 45);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "nested boxes",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 32,
      "code": "module box(width, depth, height) {\n  cube([width, depth, height]);\n}\n\nbox(10, 5, 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "concentric spheres",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 77,
      "code": "module cone(h, r1, r2) {\n  linear_extrude(height = h)\n    circle(r = r1);\n}\n\ncone(h = 10, r1 = 5, r2 = 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "cut shape",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 40,
      "code": "module wedge(width, height, depth, angle, fillet_radius) {\n  difference() {\n    cube([width, height, depth]);\n    translate([0, -depth/2, 0])\n      rotate([0,0,angle])\n        cube([width, height, depth]);\n  }\n  \n  hull() {\n      translate([0,0,0]) cube([width, height, depth]);\n  }\n  \n  translate([0,0,0])\n      hull()\n      translate([0,0,0])\n        rotate([0,0,angle])\n          hull()\n    \n  \n  \n  \n  translate([width,0,0])\n    hull()\n    translate([0,0,0])\n      rotate([0,0,angle])\n        hull()\n  \n    \n    \n  \n  translate([0,0,0])\n    hull()",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: Parser error: syntax error in file evaluation/ThomasTheMaker_k-1b_20251029_131650/cut_shape.scad, line 33\nCan't parse file 'evaluation/ThomasTheMaker_k-1b_20251029_131650/cut_shape.scad'!\n\n",
      "vlm_response": null
    },
    {
      "object": "layered rings",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 22,
      "code": "module ring(radius, thickness, height) {\n  difference() {\n    cylinder(h = height, r = radius);\n    cylinder(h = height, r = radius - thickness);\n  }\n}\n\nring(radius = 10, thickness = 2, height = 5);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "rotated square",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 95,
      "code": "module wedge(width, height, depth, angle, slices = 16) {\n  linear_extrude(height = height) {\n    polygon(points = [[0,0], [width, 0], [width, depth], [0, depth]]);\n  }\n}\n\n// Example usage:\nwidth = 20;\nheight = 10;\ndepth = 5;\nangle = 30;\nslices = 24;\n\ntranslate([0, 0, 0])\nrotate([0, angle, 0])\nwedge(width, height, depth, angle, slices);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "spiral shape",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 44,
      "code": "module helix(radius, height, turns, segments) {\n  rotate_extrude(convexity = 10)\n    translate([radius, 0, 0])\n      circle(r = 1);\n}\n\nhelix(radius = 10, height = 20, turns = 5, segments = 100);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "helical shape",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 82,
      "code": "module helix(height, radius, turns, segments) {\n  rotate_extrude(angle = 360 * turns / height) {\n    translate([radius, 0, 0])\n    circle(r = radius);\n  }\n}\n\n// Example usage:\nhelix(height = 20, radius = 10, turns = 10, segments = 100);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "rotating pattern",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 70,
      "code": "module wheel(radius, width, spokes_count, spoke_radius, spoke_width, num_spokes) {\n  difference() {\n    cylinder(h=width, r=radius, $fn=64);\n    for (i = [0:num_spokes - 1]) {\n      rotate([0, 0, i * 360 / num_spokes]) {\n        translate([radius, 0, 0]) {\n          cube([spoke_width, width, width/2], center = true);\n        }\n      }\n    }\n  }\n}\n\nwheel(radius = 50, width = 20, spokes_count = 8, spoke_radius = 10, spoke_width = 3, num_spokes = 4);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "scaled sphere",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 44,
      "code": "// Dragonfly in OpenSCAD\n\n// Parameters\nbody_length = 15;\nbody_width = 6;\nbody_height = 2;\nwing_length = 25;\nwing_width = 2;\nwing_height = 1;\neye_radius = 1;\nwing_segments = 24;\n\nmodule body() {\n  difference() {\n    cube([body_length, body_width, body_height]);\n    translate([0,0,-1]) cube([body_length, body_width, body_height + 2]);\n  }\n}\n\nmodule wing() {\n  cube([wing_length, wing_width, wing_height]);\n}\n\nmodule eye() {\n  sphere(eye_radius);\n}\n\n// Main assembly\ndifference() {\n  body();\n  translate([body_length - wing_length - 1, 0, body_height/2]) wing();\n}\n\ntranslate([body_length/2 - wing_length/2, -wing_width/2, body_height/2]) eye();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "scaled cylinder",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 59,
      "code": "module tile(width, height, depth, tile_thickness) {\n  difference() {\n    cube([width, height, depth]);\n    translate([0, 0, -tile_thickness/2])\n    cube([width - 2 * tile_thickness, height - 2 * tile_thickness, depth - 2 * tile_thickness]);\n  }\n}\n\ntile(50, 50, 10, 1.5);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "stretched cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 87,
      "code": "// Connector parameters\nconnector_width = 20;\nconnector_height = 10;\nconnector_depth = 5;\nhole_diameter = 2;\nhole_offset_x = 2;\nhole_offset_y = 2;\n\nmodule connector() {\n  difference() {\n    cube([connector_width, connector_height, connector_depth]);\n    translate([hole_offset_x, hole_offset_y, 0])\n      cylinder(h = connector_depth, r = hole_diameter / 2, $fn=50);\n  }\n}\n\nconnector();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "compressed pyramid",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 83,
      "code": "module pentagon(size) {\n  linear_extrude(height = 1) {\n    polygon(points = [\n      [size * cos(0), size * sin(0)],\n      [size * cos(36), size * sin(36)],\n      [size * cos(72), size * sin(72)],\n      [size * cos(108), size * sin(108)],\n      [size * cos(144), size * sin(144)]\n    ]);\n  }\n}\n\npentagon(size = 20);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "twisted shape",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 29,
      "code": "module snake(radius, height, segments, coil_start) {\n  difference() {\n    for (i = [0:segments - 1]) {\n      rotate([0,0,i * 360 / segments]) {\n        translate([radius, 0, 0]) {\n          cylinder(r = radius * 0.8, h = height, $fn = 60);\n        }\n      }\n    }\n\n    translate([0,0,-height]) {\n      cylinder(r = radius, h = height + 0.1, $fn = 60);\n    }\n  }\n}\n\nsnake(radius = 10, height = 5, segments = 20, coil_start = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "elongated shape",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 90,
      "code": "module pyramid(base_width, base_depth, base_height, side_length) {\n  linear_extrude(height = side_length) {\n    polygon(points = [\n      [0, 0],\n      [base_width, 0],\n      [base_width, base_height],\n      [base_width, base_height],\n      [0, base_height]\n    ]);\n  }\n}\n\npyramid(base_width = 20, base_depth = 20, base_height = 10, side_length = 40);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "distorted cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 53,
      "code": "module wedge(width, height, depth, angle) {\n  linear_extrude(height = depth)\n  polygon(points = [[0, 0], [width, 0], [width, height], [0, height]]);\n}\n\n// Example usage:\nwidth = 20;\nheight = 10;\ndepth = 5;\nangle = 30;\n\ntranslate([0, 0, depth])\ncube([width, height, depth]);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "warped sphere",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 80,
      "code": "module prism(width, height, length, angle) {\n  rotate([0, 0, angle])\n  translate([0, 0, -length/2])\n  cube([width, height, length]);\n}\n\nprism(10, 5, 10, 45);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "bent cylinder",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 34,
      "code": "cylinder(h=10, r=2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "glowing sphere",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 67,
      "code": "module sphere(r) {\n  sphere(r);\n}\n\nsphere(5);",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: ERROR: Recursion detected calling module 'sphere' in file glowing_sphere.scad, line 1\nTRACE: called by 'sphere' in file glowing_sphere.scad, line 2\nTRACE: called by 'sphere' in file glowing_sphere.sca",
      "vlm_response": null
    },
    {
      "object": "stacked spheres",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 77,
      "code": "module pyramid(base_width, base_depth, base_height, side_length, segments=32) {\n  difference() {\n    hull() {\n      for (i = [0:segments-1]) {\n        rotate([0, 0, i * 360 / segments]) {\n          translate([0, 0, -side_length/2]) {\n            sphere(r = side_length / 2);\n          }\n        }\n      }\n    }\n    \n    if (base_height > 0) {\n      hull() {\n        for (i = [0:segments-1]) {\n          rotate([0, 0, i * 360 / segments]) {\n            translate([0, 0, -base_height/2]) {\n              cube([base_width, base_depth, base_height]);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\npyramid(base_width = 50, base_depth = 50, base_height = 50, side_length = 100, segments = 32);",
      "inference_error": null,
      "render_error": "Rendering timeout (>60s)",
      "vlm_response": null
    },
    {
      "object": "twisted torus",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 50,
      "code": "module torus(r_major, r_minor, segments_major, segments_minor) {\n  rotate_extrude(angle = 2 * PI, $fn = segments_major)\n    translate([r_major, 0, 0])\n      circle(r = r_minor);\n}\n\ntorus(r_major = 50, r_minor = 10, segments_major = 64, segments_minor = 64);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "skewed shape",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 71,
      "code": "module wedge(width, height, depth, angle, segments = 36) {\n  linear_extrude(height = depth, convexity = 1) {\n    rotate([0, 0, angle * tan(360 / segments)]) {\n      polygon(points = [\n        [0, 0],\n        [width, 0],\n        [width, height],\n        [0, height]\n      ]);\n    }\n  }\n}\n\nwedge(width = 20, height = 5, depth = 10, angle = 45);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no. the 3d rendered object in the image appears to be a solid cube, which is not skewed. skewing typically refers to an optical illusion where objects appear to be tilted or distorted due to the angle at which they are observed, but the actual object is perfectly straight. however, the cube in this image seems to be perfectly aligned with the axes and is not skewed."
    },
    {
      "object": "light source",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 31,
      "code": "module lightbulb(radius = 10, height = 30, base_radius = 8, base_height = 10, filament_height = 5, filament_radius = 1.5) {\n  difference() {\n    union() {\n      cylinder(h = height - base_height, r = radius, center = false);\n      cylinder(h = base_height, r = radius, center = false);\n    }\n    \n    translate([0, 0, height - filament_height]) {\n      cylinder(h = filament_height, r = radius * 1.2, center = false);\n    }\n    \n    translate([0, 0, -1]) {\n        cylinder(h = 1, r = radius * 1.2, center = false);\n    }\n\n  }\n}\n\nlightbulb();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "reflection",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 27,
      "code": "module mirror(width, height, thickness, angle) {\n  difference() {\n    cube([width, height, thickness]);\n    translate([0, 0, -0.1])\n    rotate([0, angle, 0])\n    translate([width, height, 0])\n    cube([width, height, thickness + 0.2]);\n  }\n}\n\nmirror(width = 100, height = 50, thickness = 5, angle = 45);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "shadow maker",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 5,
      "code": "// Parameters\nthickness = 2;\ninner_diameter = 50;\nouter_diameter = 100;\nheight = 30;\n\n// Shroud\ndifference() {\n  cylinder(h = height, r = outer_diameter / 2, center = false);\n  cylinder(h = height, r = (inner_diameter - thickness) / 2, center = false);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "transparent shape",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 28,
      "code": "module turtle(length=50, width=20, height=10) {\n  difference() {\n    union() {\n      // Body\n      translate([-length/2, -width/2, -height/2]) {\n        cube([length, width, height]);\n      }\n      \n      // Head\n      translate([-length/2, -width/2, -height/2 + height/10]) {\n        cube([length/2, width/2, height/3]);\n      }\n      \n      //Legs\n      translate([-length/4, -width/4, -height/3]) {\n        cube([length/8, width/8, height/4]);\n      }\n      translate([-length/4, width/4, -height/3]) {\n        cube([length/8, width/8, height/4]);\n      }\n      translate([-length/4, -width/4, -height/3]) {\n        rotate([0,0,45]) {\n          cube([length/8, width/8, height/4]);\n        }\n      }\n      translate([-length/4, width/4, -height/3]) {\n        rotate([0,0,45]) {\n          cube([length/8, width/8, height/4]);\n        }\n      }\n    }\n    \n    // Eye\n    translate([-length/6, -width/6, -height/3]) {\n      sphere(r=2);\n    }\n  }\n}\n\nturtle();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "hexagonal tessellation",
      "code_extracted": true,
      "render_success": false,
      "visual_similarity": false,
      "tokens_generated": 31,
      "code": "module hexagon(size) {\n  polygon(points = [\n    [size * cos(0), size * sin(0)],\n    [size * cos(60), size * sin(60)],\n    [size * cos(120), size * sin(120)],\n    [size * cos(180), size * sin(180)],\n    [size * cos(240), size * sin(240)],\n    [size * cos(300), size * sin(300)]\n  ]);\n}\n\nmodule hexagon_filled(size) {\n  linear_extrude(height = 0.1)\n    polygon(points = [\n      [size * cos(0), size * sin(0)],\n      [size * cos(60), size * sin(60)],\n      [size * cos(120), size * sin(120)],\n      [size * cos(180), size * sin(180)],\n      [size * cos(240), size * sin(240)],\n      [size * cos(300), size * sin(300)]\n    ]);\n}\n\n\ndifference() {\n  union() {\n    for (i = [0:7]) {\n      rotate([0, 0, i * 120]) {\n        linear_extrude(height = size) {\n          polygon(points = [\n            [size * cos(i), size * sin(i)],\n            [size * cos(3*i), size * sin(3*i)],\n            [size * cos(6*i), size * sin(6*i)],\n            [size * cos(9*i), size * sin(9*i)],\n            [size * cos(12*i), size * sin(12*i)],\n            [size * cos(15*i), size * sin(15*i)]\n          ]);\n        }\n      }\n    }\n  }\n  difference() {\n    cube([size * 2, size * 2, size * 2]);\n  }\n}",
      "inference_error": null,
      "render_error": "OpenSCAD STL creation failed: WARNING: Ignoring unknown variable 'size' in file hexagonal_tessellation.scad, line 29\nWARNING: Ignoring unknown variable 'size' in file hexagonal_tessellation.scad, line 31\nWARNING: undefined operati",
      "vlm_response": null
    },
    {
      "object": "square tessellation",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 94,
      "code": "module tile(width, depth, height, corner_radius) {\n  difference() {\n    cube([width, depth, height]);\n    translate([corner_radius, corner_radius, 0])\n      cube([width - 2 * corner_radius, depth - 2 * corner_radius, height]);\n  }\n}\n\ntile(50, 50, 10, 5);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "triangular tessellation",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 88,
      "code": "module hexagon(radius, segments, points) {\n  linear_extrude(height = 1) {\n    polygon(points = points);\n  }\n}\n\n// Example usage:\nradius = 10;\nsegments = 6;\npoints = [\n  [radius * cos(30), radius * sin(30)],\n  [radius * cos(45), radius * sin(45)],\n  [radius * cos(60), radius * sin(60)],\n  [radius * cos(75), radius * sin(75)],\n  [radius * cos(90), radius * sin(90)],\n  [radius * cos(105), radius * sin(105)]\n];\n\nhexagon(radius, segments, points);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "complex tessellation",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 89,
      "code": "module tile(width, depth, height, hole_diameter, hole_distance) {\n  difference() {\n    cube([width, depth, height]);\n    translate([hole_distance, hole_distance, 0])\n    cylinder(h=height, r=hole_diameter/2, $fn=60);\n  }\n}\n\ntile(width=50, depth=50, height=10, hole_diameter=5, hole_distance=2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "bordered cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 32,
      "code": "// Connector Parameters\nconnector_width = 20;\nconnector_height = 10;\nconnector_depth = 5;\nhole_diameter = 2.5;\nhole_offset_x = 3;\nhole_offset_y = 3;\n\nmodule connector() {\n  difference() {\n    cube([connector_width, connector_height, connector_depth]);\n    translate([hole_offset_x, hole_offset_y, -0.1])\n    cylinder(h = connector_height + 0.2, r = hole_diameter / 2, $fn = 32);\n    translate([connector_width - hole_offset_x, connector_height - hole_offset_y, -0.1])\n    cylinder(h = connector_height + 0.2, r = hole_diameter / 2, $fn = 32);\n  }\n}\n\nconnector();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "framed shape",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 12,
      "code": "module prism(width, height, length, angle) {\n  rotate([0, 0, angle])\n  translate([0, 0, -length * tan(angle)])\n  cube([width, height, length]);\n}\n\nprism(width = 10, height = 5, length = 10, angle = 30);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "outlined sphere",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 54,
      "code": "// Coil Parameters\nradius = 10;          // Radius of the coil\nwire_radius = 1;       // Radius of the wire\nturns = 10;            // Number of turns\nheight = 2;            // Height of the coil (for mounting)\nspacing = 0.5;          // Spacing between turns (in mm)\n\n// Calculate total height\ntotal_height = height * turns;\n\n// Main Coil Body\ndifference() {\n    cylinder(h = total_height, r = radius, center = false);\n    cylinder(h = total_height, r = radius - wire_radius, center = false);\n}\n\n// Wire\ntranslate([0, 0, total_height / 2]) {\n    cube([radius * 2, radius * 2, total_height], center = true);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "hollow outline",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 77,
      "code": "module shell(width, height, depth, thickness, angle = 0) {\n  difference() {\n    cube([width, height, depth]);\n    translate([0, 0, -thickness/2]) {\n      rotate([0,0,angle])\n      cube([width, height, depth]);\n    }\n  }\n}\n\nshell(width=100, height=100, depth=100, thickness=10, angle=45);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "frame structure",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 78,
      "code": "module plank(length, width, height, fillet_radius) {\n  difference() {\n    cube([length, width, height]);\n    translate([fillet_radius, fillet_radius, 0])\n      cube([length - 2 * fillet_radius, width - 2 * fillet_radius, height]);\n  }\n}\n\nplank(100, 20, 5, 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "connector piece",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 86,
      "code": "module coupler(width, height, depth, hole_diameter, hole_offset_x, hole_offset_y) {\n  difference() {\n    cube([width, height, depth]);\n    translate([width - hole_diameter, height - hole_diameter, depth - hole_diameter])\n      cylinder(h = hole_diameter, r = hole_diameter / 2, $fn = 32);\n  }\n}\n\ncoupler(width = 50, height = 20, depth = 10, hole_diameter = 4, hole_offset_x = 10, hole_offset_y = 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "socket",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 75,
      "code": "// Screw parameters\nscrew_diameter = 1.2;\nthread_diameter = 1.5;\nthread_height = 10;\npitch = 0.8;\nhead_diameter = 20;\nhead_height = 2;\nshank_length = 50;\n\nmodule screw() {\n  difference() {\n    cylinder(h = shank_length, r = screw_diameter/2, center = false);\n    translate([0,0,-0.5])\n    cylinder(h = 2, r = thread_diameter/2, center = false);\n\n    translate([0, 0, -head_height/2])\n    cylinder(h = head_height, r = head_diameter/2, center = false);\n  }\n}\n\nmodule screw_head() {\n  translate([0,0,-head_height/2]) {\n    cylinder(h = head_height, r = head_diameter/2, center = false);\n  }\n}\n\n// Render the screw\nscrew_head();\ntranslate([0,0,0])\nscrew_head();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "joint",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 82,
      "code": "module pin(length, diameter, wall_thickness, fillet_radius) {\n  difference() {\n    cylinder(h = length, d = diameter, center = false);\n    cylinder(h = length + 0.1, d = diameter - 2 * wall_thickness, center = false);\n    for (i = [0:3]) {\n      for (j = [0:3]) {\n        translate([i * (length / 3), j * (length / 3), 0]) {\n          rotate([0, 0, 90])\n            linear_extrude(height = 0.1)\n              polygon(points = [\n                [diameter/2 * cos(360/length), diameter/2 * sin(360/length)],\n                [diameter/2 * cos(360/length), diameter/2 * sin(360/length)],\n                [diameter/2 * cos(360/length), diameter/2 * sin(360/length)],\n                [diameter/2 * cos(360/length), diameter/2 * sin(360/length)]\n              ]);\n        }\n      }\n    }\n    \n    for (i = [0:3]) {\n      for (j = [0:3]) {\n        translate([i * (length / 3), j * (length / 3), -wall_thickness]) {\n            linear_extrude(height = wall_thickness)\n              polygon(points = [\n                [diameter/2 * cos(360/length), diameter/2 * sin(360/length)],\n                [diameter/2 * cos(360/length), diameter/2 * sin(360/length)],\n                [diameter/2 * cos(360/length), diameter/2 * sin(360/length)],\n                [diameter/2 * cos(360/length), diameter/2 * sin(360/length)]\n              ]);\n        }\n      }\n    }\n  }\n}\n\npin(length = 50, diameter = 10, wall_thickness = 2, fillet_radius = 1);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "coupling",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 57,
      "code": "module joint(width, height, depth, hole_diameter, hole_distance) {\n  difference() {\n    cube([width, height, depth]);\n    if (hole_diameter > 0) {\n      translate([hole_distance, hole_distance, -0.1])\n      cylinder(h = depth + 0.2, r = hole_diameter / 2);\n    }\n  }\n}\n\njoint(width = 50, height = 30, depth = 20, hole_diameter = 5, hole_distance = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "plug",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 22,
      "code": "module bushing(inner_diameter, outer_diameter, height, wall_thickness) {\n  difference() {\n    cylinder(h = height, r = outer_diameter / 2, $fn = 100);\n    cylinder(h = height, r = inner_diameter / 2, $fn = 100);\n  }\n  \n  union() {\n    for (i = [0:3]) {\n      translate([i * (outer_diameter / 2) - (outer_diameter / 2) / 2, 0, 0])\n      rotate([0, 0, i * 180])\n      translate([0, 0, -wall_thickness])\n      rotate([90,0,0])\n      linear_extrude(height = inner_diameter, convexity = 1)\n      polygon(points = [\n        [inner_diameter / 2, 0],\n        [outer_diameter / 2, 0]\n      ]);\n    }\n  }\n}\n\n// Example usage:\nbushing(inner_diameter = 10, outer_diameter = 20, height = 10, wall_thickness = 1.5);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "adapter",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 92,
      "code": "module connector(width, height, depth, hole_diameter, hole_offset_x, hole_offset_y) {\n  difference() {\n    cube([width, height, depth]);\n    translate([hole_offset_x, hole_offset_y, -0.1])\n    cylinder(h = depth + 0.2, r = hole_diameter / 2);\n  }\n}\n\nconnector(width = 50, height = 20, depth = 10, hole_diameter = 6, hole_offset_x = 10, hole_offset_y = 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "bracket",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 65,
      "code": "// Connector Parameters\nconnector_width = 20;\nconnector_height = 30;\nconnector_depth = 10;\nhole_diameter = 4;\nhole_height = 5;\n\ndifference() {\n  cube([connector_width, connector_height, connector_depth]);\n\n  translate([hole_diameter/2, hole_diameter/2, -0.1])\n    cylinder(h=connector_height + 0.2, r=hole_diameter/2, $fn=32);\n\n  translate([connector_width - hole_diameter/2, hole_diameter/2, -0.1])\n    cylinder(h=connector_height + 0.2, r=hole_diameter/2, $fn=32);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "mounting base",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 97,
      "code": "module brace(width, height, thickness, hole_diameter, hole_x, hole_y) {\n  difference() {\n    cube([width, height, thickness]);\n    translate([hole_x, hole_y, -1]) cylinder(h = thickness + 2, r = hole_diameter / 2);\n  }\n}\n\nbrace(width = 50, height = 20, thickness = 2, hole_diameter = 3, hole_x = 20, hole_y = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "mounting bracket",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 95,
      "code": "module bracket(width, height, thickness, hole_diameter, hole_offset) {\n  difference() {\n    cube([width, height, thickness]);\n    translate([hole_offset, height/2, -0.1])\n    cylinder(h = thickness + 0.2, r = hole_diameter / 2, $fn = 48);\n  }\n}\n\n// Example usage:\nbracket(width = 50, height = 30, thickness = 5, hole_diameter = 4, hole_offset = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "attachment point",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 92,
      "code": "module connector(width, height, depth, hole_diameter, hole_distance) {\n  difference() {\n    cube([width, height, depth]);\n    translate([width/4, height/4, depth/4])\n    cylinder(h = depth, r = hole_diameter/2, $fn=50);\n  }\n}\n\nconnector(width = 50, height = 30, depth = 20, hole_diameter = 8, hole_distance = 10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "pivot mount",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 8,
      "code": "// Lever Parameters\nlever_length = 50;\nlever_width = 10;\nlever_height = 5;\npivot_radius = 2;\npivot_hole_diameter = 2;\n\nmodule lever() {\n  difference() {\n    cube([lever_length, lever_width, lever_height]);\n    translate([lever_length - pivot_radius, -1, -1])\n    cylinder(r = pivot_radius, h = lever_height + 2, $fn=50);\n    translate([lever_length - pivot_radius, lever_width - pivot_radius, lever_height/2 - pivot_radius])\n    rotate([0,0,45])\n    cylinder(r = pivot_radius, h = lever_width, $fn=50);\n  }\n}\n\nlever();",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "swivel mount",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 96,
      "code": "module flange(width, height, thickness, hole_diameter, hole_x, hole_y) {\n  difference() {\n    cube([width, height, thickness]);\n    translate([hole_x, hole_y, -0.1])\n    cylinder(h=thickness + 0.2, r=hole_diameter/2, $fn=50);\n  }\n}\n\nflange(width=50, height=20, thickness=5, hole_diameter=8, hole_x=25, hole_y=10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "cube array",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 13,
      "code": "module box(width, depth, height) {\n  cube([width, depth, height]);\n}\n\nbox(10, 5, 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "sphere array",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 2,
      "code": "// Hemisphere\n\nradius = 10;\nslices = 64;\nslices_per_sphere = 16;\n\ndifference() {\n    sphere(r = radius, $fn = slices_per_sphere);\n    translate([0, 0, -0.1]) cylinder(h = 0.1, r = radius, $fn = slices_per_sphere);\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no. the image you have provided appears to be of a single sphere rather than an array. an array is typically multiple objects placed in close proximity, which does not seem to apply here."
    },
    {
      "object": "cylinder array",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 99,
      "code": "module hexagon(size) {\n  for (i = [0:7]) {\n    angle = i * 360 / 7;\n    rotate([cos(angle), sin(angle), 0])\n    translate([size * cos(angle), size * sin(angle), 0])\n    cube([size, size, size]);\n  }\n}\n\nhexagon(10);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "mixed array",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 95,
      "code": "module pyramid(base_size, height) {\n  linear_extrude(height = height)\n  polygon(points=[[0,0], [base_size, 0], [base_size/2, base_size], [0, base_size]]);\n}\n\npyramid(base_size = 50, height = 30);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "irregular array",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 53,
      "code": "module pyramid(base_width, base_depth, height) {\n  difference() {\n    cube([base_width, base_depth, height]);\n    translate([base_width/4, base_depth/4, 0]) {\n      cube([base_width/2, base_depth/2, height]);\n    }\n  }\n}\n\npyramid(base_width = 50, base_depth = 50, height = 30);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "transformed cube",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 11,
      "code": "module prism(width, height, length, angle) {\n  rotate([0,0,angle])\n  translate([0,0,0])\n  cube([width, height, length]);\n}\n\nprism(10, 5, 20, 30);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "matrix transformation",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 43,
      "code": "module washer(outer_diameter, inner_diameter, thickness) {\n  difference() {\n    cylinder(h = thickness, r = outer_diameter / 2, center = false);\n    cylinder(h = thickness, r = inner_diameter / 2, center = false);\n  }\n}\n\nwasher(outer_diameter = 50, inner_diameter = 20, thickness = 3);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "module",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 20,
      "code": "module arch(width, height, depth, radius, segments = 24) {\n  difference() {\n    linear_extrude(height = height) {\n      circle(r = radius, $fn = segments);\n    }\n    translate([0, -width/2, 0]) {\n      cube([width, height, depth], center = false);\n    }\n  }\n}\n\narch(width = 100, height = 50, depth = 10, radius = 25);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "unit cell",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 36,
      "code": "module pyramid(base_width, base_depth, base_height, side_length) {\n  difference() {\n    cube([side_length, side_length, base_height]);\n    translate([base_width/2, base_width/2, -0.1])\n    cube([side_length, side_length, base_height + 0.2]);\n  }\n}\n\npyramid(base_width = 50, base_depth = 50, base_height = 30, side_length = 80);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no."
    },
    {
      "object": "hybrid shape",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 28,
      "code": "// Customizable parameters\nbody_width = 50;\nbody_height = 50;\nbody_depth = 20;\ntop_height = 20;\nleg_height = 40;\nleg_width = 5;\nleg_depth = 5;\nwall_thickness = 2;\n\nmodule body() {\n  difference() {\n    cube([body_width, body_height, body_depth]);\n    translate([wall_thickness, wall_thickness, wall_thickness])\n    cube([body_width - 2*wall_thickness, body_height - 2*wall_thickness, body_depth - 2*wall_thickness]);\n  }\n}\n\nmodule leg() {\n  cube([leg_width, leg_height, leg_depth]);\n}\n\n// Main assembly\ndifference() {\n  body();\n\n  // Legs\n  translate([-body_width/2 - leg_width, -body_height/2 - leg_height, -leg_depth/2]) {\n    leg();\n  }\n  translate([-body_width/2 - leg_width, body_height/2 - leg_height, -leg_depth/2]) {\n    leg();\n  }\n  translate([-body_width/2 - leg_width, -body_height/2 - leg_height, body_depth/2 - leg_depth/2]) {\n    leg();\n  }\n  translate([-body_width/2 - leg_width, body_height/2 - leg_height, body_depth/2 - leg_depth/2]) {\n    leg();\n  }\n}\n\n// Render\nunion() {\n  body();\n  translate([0,0,body_depth/2 - leg_height/2]) {\n    leg();\n  }\n}",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "composite shape",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 81,
      "code": "// Squirrel Model in OpenSCAD\n\n$fn = 50;\n\nmodule squirrel(size = 50) {\n  difference() {\n    union() {\n      // Body\n      sphere(r = size * 0.6);\n      translate([0,0,size*0.3])\n      cylinder(h = size * 0.3, r = size * 0.3);\n      translate([0,0,size * 0.6])\n      cylinder(h = size * 0.3, r = size * 0.3);\n\n      // Head\n      translate([0,0,size * 0.5])\n      sphere(r = size * 0.3);\n\n      // Ears\n      translate([size * 0.2, size * 0.1, size * 0.8])\n      rotate([0,0,-30])\n      cylinder(h = size * 0.3, r = size * 0.15);\n      translate([-size * 0.2, size * 0.1, size * 0.8])\n      rotate([0,0,30])\n      cylinder(h = size * 0.3, r = size * 0.15);\n\n      // Legs\n      translate([size * 0.3, -size * 0.2, -size * 0.2])\n      cube([size * 0.3, size * 0.1, size * 0.1]);\n      translate([-size * 0.3, -size * 0.2, -size * 0.2])\n      cube([size * 0.3, size * 0.1, size * 0.1]);\n      translate([-size * 0.3, -size * 0.2, size * 0.1])\n      cube([size * 0.3, size * 0.1, size * 0.1]);\n      translate([size * 0.3, size * 0.2, size * 0.1])\n      cube([size * 0.3, size * 0.1, size * 0.1]);\n\n    }\n    translate([0,0,0])\n    cube([size * 0.6,size * 0.6,size * 0.6]);\n\n  }\n}\n\nsquirrel(size = 50);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "repeating unit",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 93,
      "code": "module spacer(width, height, depth) {\n  cube([width, height, depth]);\n}\n\n// Example usage:\nspacer(10, 5, 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    },
    {
      "object": "constructor piece",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": true,
      "tokens_generated": 54,
      "code": "module box(width, depth, height) {\n  cube([width, depth, height]);\n}\n\nbox(10, 5, 2);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "yes"
    },
    {
      "object": "building block",
      "code_extracted": true,
      "render_success": true,
      "visual_similarity": false,
      "tokens_generated": 8,
      "code": "module brick(length, width, height, wall_thickness) {\n  difference() {\n    cube([length, width, height]);\n    translate([wall_thickness, wall_thickness, wall_thickness])\n    cube([length - 2 * wall_thickness, width - 2 * wall_thickness, height - 2 * wall_thickness]);\n  }\n}\n\nbrick(20, 10, 5, 1.5);",
      "inference_error": null,
      "render_error": null,
      "vlm_response": "no"
    }
  ]
}